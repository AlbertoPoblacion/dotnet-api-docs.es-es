<Type Name="SqlFileStream" FullName="System.Data.SqlTypes.SqlFileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c2bc99b8bb259ca56602c73c9c6c541064fabece" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37671459" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SqlFileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SqlFileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.Data.SqlTypes.SqlFileStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SqlFileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class SqlFileStream sealed : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type SqlFileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Expone los datos de SQL Server que se almacenan con el atributo de columna FILESTREAM como una secuencia de bytes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.SqlTypes.SqlFileStream> clase se utiliza para trabajar con `varbinary(max)` datos almacenados con el atributo FILESTREAM en una base de datos de SQL Server 2008. Debe instalar .NET Framework 3.5 SP1 (o posterior) para usar <xref:System.Data.SqlTypes.SqlFileStream> para trabajar con datos FILESTREAM.  
  
 Especifica la secuencia de archivos de atributo en un `varbinary(max)` columna hace que SQL Server almacenar los datos en el sistema de archivos NTFS local en lugar de en el archivo de base de datos. Instrucciones Transact-SQL proporcionan capacidades de manipulación de datos en el servidor y las interfaces del sistema de archivos de Win32 proporcionan acceso de transmisión por secuencias a los datos.  
  
> [!NOTE]
>  Los archivos individuales almacenados en una columna FILESTREAM no se puede abrir directamente desde el sistema de archivos NTFS. Transmisión de datos FILESTREAM solo funciona en el contexto de una transacción de SQL Server.  
  
 El <xref:System.Data.SqlTypes.SqlFileStream> clase se deriva el <xref:System.IO.Stream> (clase), que representa una abstracción de una secuencia de bytes desde algún origen de datos arbitrarios como un archivo o un bloque de memoria. Puede leer de un FILESTREAM mediante la transferencia de datos de una secuencia en una estructura de datos como una matriz de bytes. Puede escribir en un FILESTREAM mediante la transferencia de los datos de una estructura de datos en una secuencia. También puede buscar dentro de la secuencia, que permite consultar y modificar datos en la posición actual dentro de la secuencia.  
  
 Para obtener documentación conceptual y ejemplos de código, vea [datos FILESTREAM](~/docs/framework/data/adonet/sql/filestream-data.md).  
  
 Para obtener documentación sobre cómo instalar y configurar los datos FILESTREAM en SQL Server, vea [diseñar e implementar el almacenamiento FILESTREAM](http://go.microsoft.com/fwlink/?LinkId=121499) en libros en pantalla de SQL Server 2008.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se enumera los permisos de seguridad (CA) de acceso de código que deben tener todos los llamadores de la pila para usar el `SqlFileStream` constructores.  
  
|Acceso a archivos|Permiso|  
|-----------------|----------------|  
|Leer|<xref:System.Security.Permissions.FileIOPermissionAccess.Read>|  
|Write|<xref:System.Security.Permissions.FileIOPermissionAccess.Write>|  
|Lectura y escritura|<xref:System.Security.Permissions.FileIOPermissionAccess.Read> y <xref:System.Security.Permissions.FileIOPermissionAccess.Write>|  
  
 Para obtener más información acerca de las CA, consulte [Code Access Security and ADO.NET](~/docs/framework/data/adonet/code-access-security.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlFileStream (string path, byte[] transactionContext, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, unsigned int8[] transactionContext, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.#ctor(System.String,System.Byte[],System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, transactionContext As Byte(), access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlFileStream(System::String ^ path, cli::array &lt;System::Byte&gt; ^ transactionContext, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.Data.SqlTypes.SqlFileStream : string * byte[] * System.IO.FileAccess -&gt; System.Data.SqlTypes.SqlFileStream" Usage="new System.Data.SqlTypes.SqlFileStream (path, transactionContext, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactionContext" Type="System.Byte[]" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso lógica al archivo. La ruta de acceso se puede recuperar mediante la función Pathname de Transact-SQL en la columna FILESTREAM subyacente de la tabla.</param>
        <param name="transactionContext">Contexto de transacción del objeto <see langword="SqlFileStream" />. Las aplicaciones deben devolver la matriz de bytes devuelta llamando al método GET_FILESTREAM_TRANSACTION_CONTEXT.</param>
        <param name="access">El modo de acceso que se usará al abrir el archivo. Los valores de enumeración <see cref="T:System.IO.FileAccess" /> admitidos son <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" /> y <see cref="F:System.IO.FileAccess.ReadWrite" />.  Cuando se utiliza <see langword="FileAccess.Read" />, el objeto <see langword="SqlFileStream" /> puede usarse para leer todos los datos existentes.  Cuando se utiliza <see langword="FileAccess.Write" />, <see langword="SqlFileStream" /> apunta a un archivo de cero bytes. Los datos existentes se sobrescribirán cuando se cierre el objeto y la transacción se confirmará.  Cuando se utiliza <see langword="FileAccess.ReadWrite" />, <see langword="SqlFileStream" /> apunta a un archivo que incluye todos los datos existentes. El identificador se coloca al principio del archivo. Puede usar uno de los métodos <see langword="System.IO" /><see langword="Seek" /> para mover la posición del identificador dentro del archivo para escribir o anexar nuevos datos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se produce una excepción, las transacciones abiertas se deberían deshacer. En caso contrario, puede producirse pérdida de datos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es una referencia null o <paramref name="transactionContext" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.  
  
 <paramref name="path" /> comienza por "\\\\.\\", por ejemplo, "\\\\.\PHYSICALDRIVE0".  El identificador devuelto por la llamada a NTCreateFile no es del tipo FILE_TYPE_DISK.  
  
 <paramref name="options" /> contiene un valor que no se admite.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El valor de <paramref name="path" /> especificado no es válido, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el acceso solicitado para la ruta de acceso especificada. Esto ocurre cuando se especifica el acceso de escritura o lectura y escritura, y el archivo o el directorio está establecido para el acceso de solo lectura.</exception>
        <exception cref="T:System.InvalidOperationException">Se produce un error en NtCreateFile con el código de error establecido en ERROR_SHARING_VIOLATION.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SqlFileStream (string path, byte[] transactionContext, System.IO.FileAccess access, System.IO.FileOptions options, long allocationSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, unsigned int8[] transactionContext, valuetype System.IO.FileAccess access, valuetype System.IO.FileOptions options, int64 allocationSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.#ctor(System.String,System.Byte[],System.IO.FileAccess,System.IO.FileOptions,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, transactionContext As Byte(), access As FileAccess, options As FileOptions, allocationSize As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SqlFileStream(System::String ^ path, cli::array &lt;System::Byte&gt; ^ transactionContext, System::IO::FileAccess access, System::IO::FileOptions options, long allocationSize);" />
      <MemberSignature Language="F#" Value="new System.Data.SqlTypes.SqlFileStream : string * byte[] * System.IO.FileAccess * System.IO.FileOptions * int64 -&gt; System.Data.SqlTypes.SqlFileStream" Usage="new System.Data.SqlTypes.SqlFileStream (path, transactionContext, access, options, allocationSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactionContext" Type="System.Byte[]" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="allocationSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso lógica al archivo. La ruta de acceso se puede recuperar mediante la función Pathname de Transact-SQL en la columna FILESTREAM subyacente de la tabla.</param>
        <param name="transactionContext">Contexto de transacción del objeto <see langword="SqlFileStream" />. Cuando se establezca en null, se usará una transacción implícita para el objeto <see langword="SqlFileStream" />. Las aplicaciones deben devolver la matriz de bytes devuelta llamando al método GET_FILESTREAM_TRANSACTION_CONTEXT.</param>
        <param name="access">El modo de acceso que se usará al abrir el archivo. Los valores de enumeración <see cref="T:System.IO.FileAccess" /> admitidos son <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" /> y <see cref="F:System.IO.FileAccess.ReadWrite" />.  Cuando se utiliza <see langword="FileAccess.Read" />, el objeto <see langword="SqlFileStream" /> puede usarse para leer todos los datos existentes.  Cuando se utiliza <see langword="FileAccess.Write" />, <see langword="SqlFileStream" /> apunta a un archivo de cero bytes. Los datos existentes se sobrescribirán cuando se cierre el objeto y la transacción se confirmará.  Cuando se utiliza <see langword="FileAccess.ReadWrite" />, <see langword="SqlFileStream" /> apunta a un archivo que incluye todos los datos existentes. El identificador se coloca al principio del archivo. Puede usar uno de los métodos <see langword="System.IO" /><see langword="Seek" /> para mover la posición del identificador dentro del archivo para escribir o anexar nuevos datos.</param>
        <param name="options">Especifica la opción que se usará al abrir el archivo. Los valores de <see cref="T:System.IO.FileOptions" /> admitidos son <see cref="F:System.IO.FileOptions.Asynchronous" />, <see cref="F:System.IO.FileOptions.WriteThrough" />, <see cref="F:System.IO.FileOptions.SequentialScan" /> y <see cref="F:System.IO.FileOptions.RandomAccess" />.</param>
        <param name="allocationSize">El tamaño de asignación que se usará al crear un archivo. Si se establece en 0, se usará el valor predeterminado.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se produce una excepción, las transacciones abiertas se deberían deshacer. En caso contrario, puede producirse pérdida de datos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es una referencia null o <paramref name="transactionContext" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.  
  
 <paramref name="path" /> comienza por "\\\\.\\", por ejemplo, "\\\\.\PHYSICALDRIVE0".  El identificador devuelto por la llamada a NTCreateFile no es del tipo FILE_TYPE_DISK.  
  
 <paramref name="options" /> contiene un valor que no se admite.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El valor de <paramref name="path" /> especificado no es válido, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el acceso solicitado para la ruta de acceso especificada. Esto ocurre cuando se especifica el acceso de escritura o lectura y escritura, y el archivo o el directorio está establecido para el acceso de solo lectura.</exception>
        <exception cref="T:System.InvalidOperationException">Se produce un error en NtCreateFile con el código de error establecido en ERROR_SHARING_VIOLATION.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="sqlFileStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">El búfer en el que se leen los datos.</param>
        <param name="offset">Desplazamiento de bytes de <c>buffer</c> donde se va a empezar a escribir datos leídos de la secuencia.</param>
        <param name="count">Número máximo de bytes que se pueden leer.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado la lectura.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de lectura asincrónica de otras.</param>
        <summary>Comienza una operación de lectura asincrónica.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que representa la lectura asincrónica, que puede hallarse aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> propiedad para determinar si la instancia actual admite lectura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">En la secuencia no se admite la lectura de datos.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="sqlFileStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer del que se van a escribir datos.</param>
        <param name="offset">Desplazamiento de bytes de <c>buffer</c> desde donde se va a empezar a escribir.</param>
        <param name="count">Número máximo de bytes que se pueden escribir.</param>
        <param name="callback">Devolución de llamada asincrónica opcional, a la que se llamará cuando haya finalizado la escritura.</param>
        <param name="state">Objeto proporcionado por el usuario que distingue esta solicitud de lectura asincrónica de otras.</param>
        <summary>Comienza una operación de escritura asincrónica.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que representa la escritura asincrónica, que puede hallarse aún pendiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Data.SqlTypes.SqlFileStream.CanWrite%2A> propiedad para determinar si la instancia actual admite escritura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">En la secuencia no se admite la escritura de datos.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Data.SqlTypes.SqlFileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la secuencia actual admite lectura.</summary>
        <value>
          <see langword="true" /> si la secuencia actual admite lectura; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Data.SqlTypes.SqlFileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la secuencia actual admite búsquedas.</summary>
        <value>
          <see langword="true" /> si la secuencia actual admite búsqueda; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Data.SqlTypes.SqlFileStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se puede agotar el tiempo de espera de la secuencia actual.</summary>
        <value>
          <see langword="true" /> si se puede agotar el tiempo de espera de la secuencia actual; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Data.SqlTypes.SqlFileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la secuencia actual admite escritura.</summary>
        <value>
          <see langword="true" /> si la secuencia actual admite escritura; si no, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="sqlFileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="sqlFileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Referencia a la solicitud asincrónica pendiente para finalizar.</param>
        <summary>Espera a que se complete la lectura asincrónica que se encuentra pendiente.</summary>
        <returns>El número de bytes leídos de la secuencia, que se encuentra entre cero (0) y el número de bytes solicitado. Las secuencias solo devuelven cero (0) al final de la secuencia; de lo contrario, se deben bloquear hasta que haya al menos un byte disponible.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El objeto <see cref="T:System.IAsyncResult" /> no proviene del método <see langword="BeginRead" /> correspondiente.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="sqlFileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Referencia a la solicitud de E/S asincrónica pendiente.</param>
        <summary>Finaliza una operación de escritura asincrónica.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El objeto <see cref="T:System.IAsyncResult" /> no proviene del método <see langword="BeginWrite" /> correspondiente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SqlFileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SqlFileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="sqlFileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garantiza que se liberen los recursos y se realicen otras operaciones de limpieza cuando el recolector de elementos no utilizados reclama <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="sqlFileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra todos los búferes de esta secuencia y hace que los datos almacenados en búfer se escriban en el dispositivo subyacente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Data.SqlTypes.SqlFileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica la longitud de la secuencia actual en bytes.</summary>
        <value>Valor <see cref="T:System.Int64" /> que indica la longitud de la secuencia actual en bytes.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Data.SqlTypes.SqlFileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso lógica a la secuencia <see cref="T:System.Data.SqlTypes.SqlFileStream" /> que se pasa al constructor.</summary>
        <value>Valor de cadena que indica el nombre de <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Data.SqlTypes.SqlFileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la posición en el flujo actual.</summary>
        <value>Posición actual en la secuencia <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="sqlFileStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de bytes. Cuando este método devuelve un valor, el búfer contiene la matriz de bytes especificada con valores entre desplazamiento y (desplazamiento + recuento - 1) reemplazada con los bytes leídos del origen actual.</param>
        <param name="offset">Desplazamiento en bytes de base cero del búfer donde se comienzan a almacenar los datos leídos de la secuencia actual.</param>
        <param name="count">Número máximo de bytes que se deben leer de la secuencia actual.</param>
        <summary>Lee una secuencia de bytes en el flujo actual y avanza la posición en el flujo según el número de bytes leídos.</summary>
        <returns>Número total de bytes leídos en el búfer. Puede ser menor que el número de bytes solicitado si dicho número no está disponible, o puede ser cero (0) si se alcanza el final de la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> propiedad para determinar si la instancia actual admite escritura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El objeto no admite la lectura de datos.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="sqlFileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee un byte de la secuencia y hace avanzar la posición de la secuencia en un byte, o devuelve -1 si está al final de la secuencia.</summary>
        <returns>Byte sin signo convertido en <see cref="T:System.Int32" />,o bien -1 si está al final de la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> propiedad para determinar si la instancia actual admite lectura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El objeto no admite la lectura de datos.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Data.SqlTypes.SqlFileStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor, en milisegundos, que determina durante cuánto tiempo la secuencia intentará realizar operaciones de lectura antes de que se agote el tiempo de espera.</summary>
        <value>Valor, en milisegundos, que determina durante cuánto tiempo la secuencia intentará realizar operaciones de lectura antes de que se agote el tiempo de espera.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="sqlFileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Desplazamiento de bytes con respecto al parámetro <c>origin</c>.</param>
        <param name="origin">Valor de tipo <see cref="T:System.IO.SeekOrigin" /> que indica el punto de referencia utilizado para obtener la nueva posición.</param>
        <summary>Establece la posición en el flujo actual.</summary>
        <returns>La nueva posición dentro de la secuencia actual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="sqlFileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Longitud deseada de la secuencia actual, en bytes.</param>
        <summary>Establece la longitud del flujo actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Data.SqlTypes.SqlFileStream.CanRead%2A> propiedad para determinar si la instancia actual admite lectura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El objeto no admite la lectura de datos.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionContext">
      <MemberSignature Language="C#" Value="public byte[] TransactionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] TransactionContext" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.TransactionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionContext As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ TransactionContext { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionContext : byte[]" Usage="System.Data.SqlTypes.SqlFileStream.TransactionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el contexto de transacción de este objeto <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</summary>
        <value>Matriz <paramref name="transactionContext" /> que se pasó al constructor de este objeto <see cref="T:System.Data.SqlTypes.SqlFileStream" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="sqlFileStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de bytes. Este método copia <c>count</c> bytes de <c>buffer</c> en la secuencia actual.</param>
        <param name="offset">Desplazamiento de bytes de base cero de <c>buffer</c> en donde se van a empezar a copiar bytes en la secuencia actual.</param>
        <param name="count">Número de bytes que se deben escribir en la secuencia actual.</param>
        <summary>Escribe una secuencia de bytes en la secuencia actual y avanza la posición actual en esta secuencia según el número de bytes escritos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Data.SqlTypes.SqlFileStream.CanWrite%2A> propiedad para determinar si la instancia actual admite escritura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El objeto no admite la escritura de datos.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.SqlTypes.SqlFileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="sqlFileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Byte que se debe escribir en la secuencia.</param>
        <summary>Escribe un byte a la posición actual en la secuencia y avanza la posición de la secuencia en un byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Data.SqlTypes.SqlFileStream.CanWrite%2A> propiedad para determinar si la instancia actual admite escritura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El objeto no admite la escritura de datos.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.SqlTypes.SqlFileStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Data.SqlTypes.SqlFileStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor, en milisegundos, que determina durante cuánto tiempo la secuencia intentará realizar operaciones de escritura antes de que se agote el tiempo de espera.</summary>
        <value>Valor, en milisegundos, que determina durante cuánto tiempo la secuencia intentará realizar operaciones de escritura antes de que se agote el tiempo de espera.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>