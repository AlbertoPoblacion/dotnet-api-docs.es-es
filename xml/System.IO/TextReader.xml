<Type Name="TextReader" FullName="System.IO.TextReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a4b4d32df0f20272abb602e4f3dcdaf62f746f09" /><Meta Name="ms.sourcegitcommit" Value="635a1dbdc9cbcf7f7c258ac9ffa0314ed734da90" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="04/10/2019" /><Meta Name="ms.locfileid" Value="59472162" /></Metadata><TypeSignature Language="C#" Value="public abstract class TextReader : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit TextReader extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.TextReader" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TextReader&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextReader abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type TextReader = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un lector que puede leer una serie secuencial de caracteres.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.TextReader> es la clase base abstracta de <xref:System.IO.StreamReader> y <xref:System.IO.StringReader>, que leen caracteres de secuencias y cadenas, respectivamente. Use estas clases derivadas para abrir un archivo de texto para leer un intervalo de caracteres especificado, o para crear un lector basándose en una secuencia existente.  
  
> [!IMPORTANT]
>  Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar cualquier tipo que se deriva este tipo, debe deshacerse de él directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IO.TextReader.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él, indirectamente, usar una construcción de lenguaje, como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, consulte Dispose y la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
   
  
## Examples  
 La clase <xref:System.IO.TextReader> es abstracta. Por lo tanto, no inicializarla en el código. El <xref:System.IO.StreamReader> clase se deriva de <xref:System.IO.TextReader> y proporciona implementaciones de los miembros para la lectura de una secuencia. El ejemplo siguiente muestra cómo se leen todos los caracteres de un archivo mediante el uso de la <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método. Comprueba si cada carácter es una letra, un dígito o un espacio en blanco antes de agregar el carácter en una instancia de la <xref:System.Text.StringBuilder> clase.  
  
 [!code-csharp[System.IO.StreamReader#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example42.cs#42)]
 [!code-vb[System.IO.StreamReader#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example42.vb#42)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Una clase derivada debe implementar al menos el <see cref="M:System.IO.TextReader.Peek" /> y <see cref="M:System.IO.TextReader.Read" /> métodos para crear una instancia útil de <see cref="T:System.IO.TextReader" />.</para></block>
    <altmember cref="T:System.IO.StringReader" />
    <altmember cref="T:System.IO.StreamReader" />
    <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Cómo: Leer y escribir en un archivo de datos recién creado</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TextReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TextReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para las clases derivadas.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.StringReader" />
        <altmember cref="T:System.IO.StreamReader" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="textReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra el <see cref="T:System.IO.TextReader" /> y libera todos los recursos del sistema asociados a <see langword="TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación de `Close` llamadas la <xref:System.IO.TextReader.Dispose%28System.Boolean%29?displayProperty=nameWithType> método y le pasa un `true` valor.  
  
> [!NOTE]
>  En las clases derivadas, no invalidan el <xref:System.IO.TextReader.Close%2A> método. En su lugar, invalide el <xref:System.IO.TextReader.Dispose%28System.Boolean%29?displayProperty=nameWithType> método para agregar código para liberar recursos.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.StringReader" />
        <altmember cref="T:System.IO.StreamReader" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera todos los recursos utilizados por el objeto <see cref="T:System.IO.TextReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="textReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos utilizados por el objeto <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a <xref:System.IO.TextReader.Dispose%2A> cuando haya terminado de usar <xref:System.IO.TextReader>. El método <xref:System.IO.TextReader.Dispose%2A> deja el <xref:System.IO.TextReader> en un estado no utilizable. Después de llamar a <xref:System.IO.TextReader.Dispose%2A>, debe liberar todas las referencias a la <xref:System.IO.TextReader> por lo que el recolector de elementos no utilizados pueda reclamar la memoria que el <xref:System.IO.TextReader> estaba ocupando.  
  
 Para obtener más información, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Realice siempre una llamada a <xref:System.IO.TextReader.Dispose%2A> antes de liberar la última referencia al objeto <xref:System.IO.TextReader>. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.IO.TextReader> del objeto <xref:System.Object.Finalize%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="textReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> para liberar tanto los recursos administrados como los no administrados; <see langword="false" /> para liberar únicamente los recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.IO.TextReader" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama por el público `Dispose` método y el <xref:System.Object.Finalize%2A> método. De forma predeterminada, este método especifica el `disposing` parámetro como `true`. <xref:System.Object.Finalize%2A> Especifica el `disposing` parámetro como `false`.  
  
 Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.IO.TextReader> hace referencia. Este método invoca al método `Dispose` de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> puede llamarse varias veces por otros objetos. Al reemplazar este método, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />. Para obtener más información sobre cómo implementar este método, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obtener más información acerca de <see cref="M:System.IDisposable.Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.TextReader Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.TextReader Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.TextReader.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As TextReader " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::TextReader ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.TextReader" Usage="System.IO.TextReader.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Proporciona un <see langword="TextReader" /> sin datos del que leer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Leyendo el <xref:System.IO.TextReader.Null> lector de texto es similar a leer desde el final de una secuencia:  
  
-   El <xref:System.IO.TextReader.Read%2A> y <xref:System.IO.TextReader.Peek%2A> métodos devuelven -1.  
  
-   El <xref:System.IO.TextReader.ReadBlock%2A> método devuelve cero.  
  
-   El <xref:System.IO.TextReader.ReadLine%2A> devuelve del método `null`.  
  
-   El <xref:System.IO.TextReader.ReadToEnd%2A> método devuelve una cadena vacía.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.StringReader" />
        <altmember cref="T:System.IO.StreamReader" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public virtual int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Peek () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Peek();" />
      <MemberSignature Language="F#" Value="abstract member Peek : unit -&gt; int&#xA;override this.Peek : unit -&gt; int" Usage="textReader.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el siguiente carácter sin modificar el estado del sistema de lectura o el origen del carácter. Devuelve el siguiente carácter disponible sin leerlo realmente del lector.</summary>
        <returns>Un entero que representa el siguiente carácter que se va a leer, o -1 si no hay más caracteres disponibles o si el lector no admite la operación de búsqueda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.TextReader.Peek%2A> método devuelve un valor entero con el fin de determinar si se ha producido el final del archivo o de otro error. Esto permite que un usuario compruebe primero si el valor devuelto es -1 antes de convertirlo a un <xref:System.Char> tipo.  
  
 La posición actual de la <xref:System.IO.TextReader> esta operación no se modifica. El valor devuelto es -1 si no hay más caracteres disponibles. La implementación predeterminada devuelve -1.  
  
 La clase <xref:System.IO.TextReader> es abstracta. Por lo tanto, no inicializarla en el código. Para obtener un ejemplo del uso de la <xref:System.IO.TextReader.Peek%2A> método, consulte el <xref:System.IO.StreamReader.Peek%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">La clase <see cref="T:System.IO.TextReader" /> está cerrada.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <altmember cref="M:System.IO.StreamReader.Peek" />
        <altmember cref="M:System.IO.StringReader.Peek" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lee datos del lector de texto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read();" />
      <MemberSignature Language="F#" Value="abstract member Read : unit -&gt; int&#xA;override this.Read : unit -&gt; int" Usage="textReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el siguiente carácter en el lector de texto y hace avanzar la posición de los caracteres en un carácter.</summary>
        <returns>Carácter siguiente del lector de texto o -1 si no hay más caracteres disponibles. La implementación predeterminada devuelve -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clase <xref:System.IO.TextReader> es abstracta. Por lo tanto, no inicializarla en el código. Para obtener un ejemplo del uso de la <xref:System.IO.TextReader.Read%2A> método, consulte el <xref:System.IO.StreamReader.Read%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">La clase <see cref="T:System.IO.TextReader" /> está cerrada.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <altmember cref="M:System.IO.StreamReader.Read" />
        <altmember cref="M:System.IO.StringReader.Read" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Read : Span&lt;char&gt; -&gt; int&#xA;override this.Read : Span&lt;char&gt; -&gt; int" Usage="textReader.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member Read : char[] * int * int -&gt; int&#xA;override this.Read : char[] * int * int -&gt; int" Usage="textReader.Read (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Cuando este método devuelve un valor, contiene la matriz de caracteres especificada con valores entre <paramref name="index" /> y (<paramref name="index" /> + <paramref name="count" /> - 1) reemplazada por los caracteres leídos del origen actual.</param>
        <param name="index">Lugar de <paramref name="buffer" /> en el que comenzará la escritura.</param>
        <param name="count">Número máximo de caracteres que se van a leer. Si el final del lector se alcanza antes de escribir el número de caracteres especificado en el búfer, el método vuelve.</param>
        <summary>Lee un número máximo de caracteres especificado en el lector actual y escribe los datos en un búfer, comenzando en el índice especificado.</summary>
        <returns>Número de caracteres que se han leído. Este número será menor o igual que <paramref name="count" />, dependiendo de si los datos están disponibles dentro del lector. Este método devuelve 0 (cero) si se llama cuando no quedan más caracteres para leer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve después `count` caracteres que se leen o se alcanza el final del archivo. <xref:System.IO.TextReader.ReadBlock%2A> es una versión de bloqueo de este método.  
  
 La clase <xref:System.IO.TextReader> es abstracta. Por lo tanto, no inicializarla en el código. Para obtener un ejemplo del uso de la <xref:System.IO.TextReader.Read%2A> método, consulte el <xref:System.IO.StreamReader.Read%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La longitud del búfer menos <paramref name="index" /> es menor que <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">La clase <see cref="T:System.IO.TextReader" /> está cerrada.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <altmember cref="M:System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.IO.StringReader.Read(System.Char[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;&#xA;override this.ReadAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="textReader.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="textReader.ReadAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Cuando este método devuelve un valor, contiene la matriz de caracteres especificada con valores entre <paramref name="index" /> y (<paramref name="index" /> + <paramref name="count" /> - 1) reemplazada por los caracteres leídos del origen actual.</param>
        <param name="index">Lugar de <paramref name="buffer" /> en el que comenzará la escritura.</param>
        <param name="count">Número máximo de caracteres que se van a leer. Si el final del texto se alcanza antes de leer el número de caracteres especificado en el búfer, el método actual vuelve.</param>
        <summary>Lee un número máximo de caracteres especificado en el lector de texto actual de forma asincrónica y escribe los datos en un búfer, comenzando en el índice especificado.</summary>
        <returns>Tarea que representa la operación de lectura asincrónica. El valor del parámetro <paramref name="TResult" /> contiene el número total de bytes leídos en el búfer. El valor del resultado puede ser menor que el número de bytes solicitados si el número de bytes disponibles actualmente es menor que el número solicitado o puede ser 0 (cero) si se ha llegado al final del texto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tarea completa después el número de caracteres especificados por el `count` parámetro se leen o se alcanza el final del archivo.  
  
 La clase <xref:System.IO.TextReader> es abstracta. Por lo tanto, no inicializarla en el código. Para obtener un ejemplo del uso de la <xref:System.IO.TextReader.ReadAsync%2A> método, consulte el <xref:System.IO.StreamReader.ReadAsync%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.ArgumentException">La suma de <paramref name="index" /> y <paramref name="count" /> es mayor que la longitud del búfer.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha desechado el lector de texto.</exception>
        <exception cref="T:System.InvalidOperationException">Una operación de lectura anterior está usando actualmente el lector.</exception>
        <altmember cref="M:System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.IO.StringReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public virtual int ReadBlock (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadBlock(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadBlock(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadBlock (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadBlock(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member ReadBlock : Span&lt;char&gt; -&gt; int&#xA;override this.ReadBlock : Span&lt;char&gt; -&gt; int" Usage="textReader.ReadBlock buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public virtual int ReadBlock (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadBlock([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadBlock (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadBlock(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadBlock : char[] * int * int -&gt; int&#xA;override this.ReadBlock : char[] * int * int -&gt; int" Usage="textReader.ReadBlock (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Cuando este método devuelve un valor, este parámetro contiene la matriz de caracteres especificada con valores entre <paramref name="index" /> y (<paramref name="index" /> + <paramref name="count" /> -1) reemplazada por los caracteres leídos del origen actual.</param>
        <param name="index">Lugar de <paramref name="buffer" /> en el que comenzará la escritura.</param>
        <param name="count">Número máximo de caracteres que se van a leer.</param>
        <summary>Lee un número máximo de caracteres especificado en el lector de texto actual y escribe los datos en un búfer, comenzando en el índice especificado.</summary>
        <returns>Número de caracteres que se han leído. Este número será menor o igual que <paramref name="count" />, dependiendo de si se han leído todos los caracteres de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avanza la posición del lector de texto subyacente por el número de caracteres que se han leído en `buffer`.  
  
 El método se bloquea hasta que `count` se leen caracteres, o se han leído todos los caracteres. Se trata de una versión de bloqueo de <xref:System.IO.TextReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La longitud del búfer menos <paramref name="index" /> es menor que <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">La clase <see cref="T:System.IO.TextReader" /> está cerrada.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <altmember cref="M:System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask&lt;int&gt; ReadBlockAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadBlockAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadBlockAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member ReadBlockAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;&#xA;override this.ReadBlockAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="textReader.ReadBlockAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadBlockAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadBlockAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadBlockAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadBlockAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="textReader.ReadBlockAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Cuando este método devuelve un valor, contiene la matriz de caracteres especificada con valores entre <paramref name="index" /> y (<paramref name="index" /> + <paramref name="count" /> - 1) reemplazada por los caracteres leídos del origen actual.</param>
        <param name="index">Lugar de <paramref name="buffer" /> en el que comenzará la escritura.</param>
        <param name="count">Número máximo de caracteres que se van a leer. Si el final del texto se alcanza antes de leer el número de caracteres especificado en el búfer, el método actual vuelve.</param>
        <summary>Lee un número máximo de caracteres especificado en el lector de texto actual de forma asincrónica y escribe los datos en un búfer, comenzando en el índice especificado.</summary>
        <returns>Tarea que representa la operación de lectura asincrónica. El valor del parámetro <paramref name="TResult" /> contiene el número total de bytes leídos en el búfer. El valor del resultado puede ser menor que el número de bytes solicitados si el número de bytes disponibles actualmente es menor que el número solicitado o puede ser 0 (cero) si se ha llegado al final del texto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tarea no completa hasta que el número de caracteres especificados por el `count` parámetro se leen o se alcanzó el final del texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.ArgumentException">La suma de <paramref name="index" /> y <paramref name="count" /> es mayor que la longitud del búfer.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha desechado el lector de texto.</exception>
        <exception cref="T:System.InvalidOperationException">Una operación de lectura anterior está usando actualmente el lector.</exception>
        <altmember cref="M:System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.IO.StringReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public virtual string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="abstract member ReadLine : unit -&gt; string&#xA;override this.ReadLine : unit -&gt; string" Usage="textReader.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee una línea de caracteres del lector de texto y devuelve los datos como una cadena.</summary>
        <returns>Línea siguiente del lector o <see langword="null" /> si se han leído todos los caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una línea se define como una secuencia de caracteres seguida de un retorno de carro (0x000d), un avance de línea (0x000a), un retorno de carro seguido de un avance de línea <xref:System.Environment.NewLine%2A?displayProperty=nameWithType>, o el marcador de final de la secuencia. La cadena devuelta no contiene la terminación de retorno de carro o avance de línea. El valor devuelto es `null` si se ha alcanzado el final de la secuencia de entrada.  
  
 Si el método produce una <xref:System.OutOfMemoryException> excepción, la posición del lector en subyacente <xref:System.IO.Stream> avanza por el número de caracteres que el método fue capaz de leer, pero los caracteres que ya se han leído en interno <xref:System.IO.TextReader.ReadLine%2A> búfer son se descartan. Dado que no se puede cambiar la posición del lector en la secuencia, los caracteres que ya se han leído son irrecuperables y se puede acceder solo reinicializando la <xref:System.IO.TextReader> objeto. Si la posición inicial dentro de la secuencia es desconocida o la secuencia no admite búsquedas, subyacente <xref:System.IO.Stream> también es necesario reinicializar.  
  
 Para evitar esta situación y generar código robusto, debe usar el <xref:System.IO.TextReader.Read%2A> método y el almacén de los caracteres de lectura en un búfer preasignado.  
  
 La clase <xref:System.IO.TextReader> es abstracta. Por lo tanto, no inicializarla en el código. Para obtener un ejemplo del uso de la <xref:System.IO.TextReader.ReadLine%2A> método, consulte el <xref:System.IO.StreamReader.ReadLine%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay memoria suficiente para asignar un búfer para la cadena devuelta.</exception>
        <exception cref="T:System.ObjectDisposedException">La clase <see cref="T:System.IO.TextReader" /> está cerrada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de caracteres de la siguiente línea es mayor que <see cref="F:System.Int32.MaxValue" /></exception>
        <altmember cref="M:System.IO.StreamReader.ReadLine" />
        <altmember cref="M:System.IO.StringReader.ReadLine" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadLineAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadLineAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadLineAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadLineAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="textReader.ReadLineAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee de forma asincrónica una línea de caracteres y devuelve los datos como una cadena.</summary>
        <returns>Tarea que representa la operación de lectura asincrónica. El valor del parámetro <paramref name="TResult" /> contiene la línea siguiente del lector de texto, o es <see langword="null" /> si se han leído todos los caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clase <xref:System.IO.TextReader> es abstracta. Por lo tanto, no inicializarla en el código. Para obtener un ejemplo del uso de la <xref:System.IO.TextReader.ReadLineAsync%2A> método, consulte el <xref:System.IO.StreamReader.ReadLineAsync%2A?displayProperty=nameWithType> método.  
  
 Si actual <xref:System.IO.TextReader> representa la secuencia de entrada estándar devuelta por la <xref:System.Console.In%2A?displayProperty=nameWithType> propiedad, el <xref:System.IO.TextReader.ReadLineAsync%2A> método se ejecuta sincrónicamente en lugar de forma asincrónica.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de caracteres de la siguiente línea es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha desechado el lector de texto.</exception>
        <exception cref="T:System.InvalidOperationException">Una operación de lectura anterior está usando actualmente el lector.</exception>
        <altmember cref="M:System.IO.StreamReader.ReadLineAsync" />
        <altmember cref="M:System.IO.StringReader.ReadLineAsync" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public virtual string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="abstract member ReadToEnd : unit -&gt; string&#xA;override this.ReadToEnd : unit -&gt; string" Usage="textReader.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee todos los caracteres desde la posición actual hasta el final del lector de texto y los devuelve como una cadena.</summary>
        <returns>Cadena que contiene todos los caracteres desde la posición actual hasta el final del lector.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el método produce una <xref:System.OutOfMemoryException> excepción, la posición del lector en subyacente <xref:System.IO.Stream> avanza por el número de caracteres que el método fue capaz de leer, pero los caracteres que ya se han leído en interno <xref:System.IO.TextReader.ReadToEnd%2A> búfer son se descartan. Dado que no se puede cambiar la posición del lector en la secuencia, los caracteres que ya se han leído son irrecuperables y se puede acceder solo reinicializando la <xref:System.IO.TextReader>. Si la posición inicial dentro de la secuencia es desconocida o la secuencia no admite búsquedas, subyacente <xref:System.IO.Stream> también es necesario reinicializar.  
  
 Para evitar esta situación y generar código robusto, debe usar el <xref:System.IO.TextReader.Read%2A> método y el almacén de los caracteres de lectura en un búfer preasignado.  
  
 La clase <xref:System.IO.TextReader> es abstracta. Por lo tanto, no inicializarla en el código. Para obtener un ejemplo del uso de la <xref:System.IO.TextReader.ReadToEnd%2A> método, consulte el <xref:System.IO.StreamReader.ReadToEnd%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ObjectDisposedException">La clase <see cref="T:System.IO.TextReader" /> está cerrada.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay memoria suficiente para asignar un búfer para la cadena devuelta.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de caracteres de la siguiente línea es mayor que <see cref="F:System.Int32.MaxValue" /></exception>
        <altmember cref="M:System.IO.StreamReader.ReadToEnd" />
        <altmember cref="M:System.IO.StringReader.ReadToEnd" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.ReadToEndAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToEndAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadToEndAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadToEndAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadToEndAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="textReader.ReadToEndAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee de forma asincrónica todos los caracteres desde la posición actual hasta el final del lector de texto y los devuelve como una cadena.</summary>
        <returns>Tarea que representa la operación de lectura asincrónica. El valor del parámetro <paramref name="TResult" /> contiene una cadena con los caracteres desde la posición actual hasta el final del lector de texto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clase <xref:System.IO.TextReader> es abstracta. Por lo tanto, no inicializarla en el código. Para obtener un ejemplo del uso de la <xref:System.IO.TextReader.ReadToEndAsync%2A> método, consulte el <xref:System.IO.StreamReader.ReadToEndAsync%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de caracteres es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha desechado el lector de texto.</exception>
        <exception cref="T:System.InvalidOperationException">Una operación de lectura anterior está usando actualmente el lector.</exception>
        <altmember cref="M:System.IO.StreamReader.ReadToEndAsync" />
        <altmember cref="M:System.IO.StringReader.ReadToEndAsync" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.IO.TextReader Synchronized (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.TextReader Synchronized(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.Synchronized(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (reader As TextReader) As TextReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::TextReader ^ Synchronized(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.IO.TextReader -&gt; System.IO.TextReader" Usage="System.IO.TextReader.Synchronized reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reader"><see langword="TextReader" /> que se va a sincronizar.</param>
        <summary>Crea un contenedor seguro para subprocesos en torno al <see langword="TextReader" /> especificado.</summary>
        <returns><see cref="T:System.IO.TextReader" /> seguro para subprocesos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método actual vuelve una clase que envuelve especificado <xref:System.IO.TextReader> de instancia y restringe el acceso a él mediante varios subprocesos. Todas las lecturas desde el contenedor devuelto será seguro para subprocesos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.TextReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IDisposable.Dispose" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.IO.TextReader> se convierte en una interfaz <xref:System.IDisposable>.

]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>