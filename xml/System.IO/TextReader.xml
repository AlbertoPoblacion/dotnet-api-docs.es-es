<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TextReader.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c6862423f98168f7a3dfd8baa4b6dabc6629b49d.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c6862423f98168f7a3dfd8baa4b6dabc6629b49d</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.TextReader">
          <source>Represents a reader that can read a sequential series of characters.</source>
          <target state="translated">Representa un lector que puede leer una serie secuencial de caracteres.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.TextReader">
          <source><ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> is the abstract base class of <ph id="ph2">&lt;xref:System.IO.StreamReader&gt;</ph> and <ph id="ph3">&lt;xref:System.IO.StringReader&gt;</ph>, which read characters from streams and strings, respectively.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> es la clase base abstracta de <ph id="ph2">&lt;xref:System.IO.StreamReader&gt;</ph> y <ph id="ph3">&lt;xref:System.IO.StringReader&gt;</ph>, que leer caracteres de secuencias y cadenas, respectivamente.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.TextReader">
          <source>Use these derived classes to open a text file for reading a specified range of characters, or to create a reader based on an existing stream.</source>
          <target state="translated">Use estas clases derivadas para abrir un archivo de texto para leer un intervalo especificado de caracteres, o para crear un lector basado en una secuencia existente.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.TextReader">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Este tipo implementa la <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.TextReader">
          <source>When you have finished using any type that derives from this type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">Cuando haya terminado de utilizar cualquier tipo que se deriva este tipo, debe eliminar del mismo directa o indirectamente.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.TextReader">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IO.TextReader.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Para deshacerse del tipo directamente, llame a su <ph id="ph1">&lt;xref:System.IO.TextReader.Dispose%2A&gt;</ph> método en un <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> bloque.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.TextReader">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Para deshacerse de él indirectamente, use una construcción de lenguaje como <ph id="ph1">`using`</ph> (en C#) o <ph id="ph2">`Using`</ph> (en Visual Basic).</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.TextReader">
          <source>For more information, see Dispose and the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Para obtener más información, consulte Dispose y la sección "Uso de un objeto que implementa IDisposable" en el <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> tema de la interfaz.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.TextReader">
          <source>The <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> class is an abstract class.</source>
          <target state="translated">La clase <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> es abstracta.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.TextReader">
          <source>Therefore, you do not instantiate it in your code.</source>
          <target state="translated">Por lo tanto, no inicializarlo en el código.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.TextReader">
          <source>The <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> class derives from <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph> and provides implementations of the members for reading from a stream.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> clase se deriva de <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph> y proporciona implementaciones de los miembros para la lectura de una secuencia.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.TextReader">
          <source>The following example shows how to read all the characters in a file by using the <ph id="ph1">&lt;xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo leer todos los caracteres de un archivo mediante el uso de la <ph id="ph1">&lt;xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.TextReader">
          <source>It checks whether each character is a letter, digit, or white space before adding the character to an instance of the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> class.</source>
          <target state="translated">Comprueba si cada carácter es una letra, un dígito o un espacio en blanco antes de agregar el carácter a una instancia de la <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.TextReader">
          <source>A derived class must minimally implement the <ph id="ph1">&lt;see cref="M:System.IO.TextReader.Peek" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.IO.TextReader.Read" /&gt;</ph> methods to make a useful instance of <ph id="ph3">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>.</source>
          <target state="translated">Una clase derivada debe implementar la <ph id="ph1">&lt;see cref="M:System.IO.TextReader.Peek" /&gt;</ph> y <ph id="ph2">&lt;see cref="M:System.IO.TextReader.Read" /&gt;</ph> métodos para crear una instancia útil de <ph id="ph3">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.#ctor">
          <source>Use this constructor for derived classes.</source>
          <target state="translated">Utilice este constructor para las clases derivadas.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Close">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> and releases any system resources associated with the <ph id="ph2">&lt;see langword="TextReader" /&gt;</ph>.</source>
          <target state="translated">Cierra el <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> y libera todos los recursos del sistema asociados a <ph id="ph2">&lt;see langword="TextReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Close">
          <source>This implementation of <ph id="ph1">`Close`</ph> calls the <ph id="ph2">&lt;xref:System.IO.StringReader.Dispose%28System.Boolean%29?displayProperty=nameWithType&gt;</ph> method and passes it a <ph id="ph3">`true`</ph> value.</source>
          <target state="translated">Esta implementación de <ph id="ph1">`Close`</ph> llamadas el <ph id="ph2">&lt;xref:System.IO.StringReader.Dispose%28System.Boolean%29?displayProperty=nameWithType&gt;</ph> método y le pasa un <ph id="ph3">`true`</ph> valor.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Close">
          <source>Flushing the text reader will not flush its underlying encoder unless you explicitly call <ph id="ph1">`Close`</ph>.</source>
          <target state="translated">El vaciado de lector de texto no hará que vacíe su correspondiente codificador subyacente a menos que se llame explícitamente a <ph id="ph1">`Close`</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Close">
          <source>Setting the <ph id="ph1">&lt;xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType&gt;</ph> property to <ph id="ph2">`true`</ph> means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</source>
          <target state="translated">Establecer el <ph id="ph1">&lt;xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType&gt;</ph> propiedad <ph id="ph2">`true`</ph> significa que los datos se vaciarán del búfer en la secuencia, pero el estado del codificador no se vaciará.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Close">
          <source>This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</source>
          <target state="translated">Esto permite al codificador mantener su estado (caracteres parciales) para que sea posible codificar el siguiente bloque de caracteres correctamente.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Close">
          <source>This scenario affects UTF8 and UTF7 where certain characters can be encoded only after the encoder receives the adjacent character or characters.</source>
          <target state="translated">Este escenario afecta a UTF8 y UTF7 donde ciertos caracteres se pueden codificar solo después de que el codificador reciba el carácter o caracteres adyacentes.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Close">
          <source>In derived classes, do not override the <ph id="ph1">&lt;xref:System.IO.TextReader.Close%2A&gt;</ph> method.</source>
          <target state="translated">En las clases derivadas, no invalide el <ph id="ph1">&lt;xref:System.IO.TextReader.Close%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Close">
          <source>Instead, override the <ph id="ph1">&lt;xref:System.IO.TextReader.Dispose%28System.Boolean%29?displayProperty=nameWithType&gt;</ph> method to add code for releasing resources.</source>
          <target state="translated">En su lugar, reemplace la <ph id="ph1">&lt;xref:System.IO.TextReader.Dispose%28System.Boolean%29?displayProperty=nameWithType&gt;</ph> método para agregar código para liberar recursos.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="T:System.IO.TextReader">
          <source>Releases all resources used by the <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> object.</source>
          <target state="translated">Libera todos los recursos utilizados por el objeto <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Dispose">
          <source>Releases all resources used by the <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> object.</source>
          <target state="translated">Libera todos los recursos utilizados por el objeto <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Dispose">
          <source>Call <ph id="ph1">&lt;xref:System.IO.TextReader.Dispose%2A&gt;</ph> when you are finished using the <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph>.</source>
          <target state="translated">Llame a <ph id="ph1">&lt;xref:System.IO.TextReader.Dispose%2A&gt;</ph> cuando haya terminado de usar <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.IO.TextReader.Dispose%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph> in an unusable state.</source>
          <target state="translated">El método <ph id="ph1">&lt;xref:System.IO.TextReader.Dispose%2A&gt;</ph> deja el <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph> en un estado no utilizable.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Dispose">
          <source>After calling <ph id="ph1">&lt;xref:System.IO.TextReader.Dispose%2A&gt;</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.IO.TextReader&gt;</ph> was occupying.</source>
          <target state="translated">Después de llamar a <ph id="ph1">&lt;xref:System.IO.TextReader.Dispose%2A&gt;</ph>, debe liberar todas las referencias a la <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph> para que el recolector de elementos no utilizados pueda reclamar la memoria que el <ph id="ph3">&lt;xref:System.IO.TextReader&gt;</ph> estaba ocupando.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>limpiar recursos no administrados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> y <bpt id="p2">[</bpt>implementa un método Dispose<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Dispose">
          <source>Always call <ph id="ph1">&lt;xref:System.IO.TextReader.Dispose%2A&gt;</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph>.</source>
          <target state="translated">Realice siempre una llamada a <ph id="ph1">&lt;xref:System.IO.TextReader.Dispose%2A&gt;</ph> antes de liberar la última referencia al objeto <ph id="ph2">&lt;xref:System.IO.TextReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> object's <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> del objeto <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> para liberar tanto recursos administrados como no administrados; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> para liberar únicamente recursos no administrados.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> and optionally releases the managed resources.</source>
          <target state="translated">Libera los recursos no administrados que usa <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> y, de forma opcional, libera los recursos administrados.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">`Dispose`</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Se llama a este método público <ph id="ph1">`Dispose`</ph> método y <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Dispose(System.Boolean)">
          <source>By default, this method specifies the <ph id="ph1">`disposing`</ph> parameter as <ph id="ph2">`true`</ph>.</source>
          <target state="translated">De forma predeterminada, este método especifica la <ph id="ph1">`disposing`</ph> parámetro como <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> specifies the <ph id="ph2">`disposing`</ph> parameter as <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Especifica la <ph id="ph2">`disposing`</ph> parámetro como <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.IO.TextReader&gt;</ph> references.</source>
          <target state="translated">Cuando el parámetro <ph id="ph1">`disposing`</ph> es <ph id="ph2">`true`</ph>, este método libera todos los recursos retenidos por los objetos administrados a los que el control <ph id="ph3">&lt;xref:System.IO.TextReader&gt;</ph> hace referencia.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">`Dispose`</ph> method of each referenced object.</source>
          <target state="translated">Este método invoca al método <ph id="ph1">`Dispose`</ph> de cada uno de los objetos a los que se hace referencia.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> puede recibir varias llamadas de otros objetos.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Dispose(System.Boolean)">
          <source>When overriding this method, be careful not to reference objects that have been previously disposed of in an earlier call to <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph>.</source>
          <target state="translated">Al reemplazar este método, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Dispose(System.Boolean)">
          <source>For more information about how to implement this method, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de cómo implementar este método, consulte <bpt id="p1">[</bpt>implementa un método Dispose<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see cref="M:System.IDisposable.Dispose" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de <ph id="ph1">&lt;see cref="M:System.IDisposable.Dispose" /&gt;</ph> y <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, consulte <bpt id="p1">[</bpt>limpiar recursos no administrados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="F:System.IO.TextReader.Null">
          <source>Provides a <ph id="ph1">&lt;see langword="TextReader" /&gt;</ph> with no data to read from.</source>
          <target state="translated">Proporciona un <ph id="ph1">&lt;see langword="TextReader" /&gt;</ph> sin datos del que leer.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.TextReader.Null">
          <source>Reading from the <ph id="ph1">&lt;xref:System.IO.TextReader.Null&gt;</ph> text reader is similar to reading from the end of a stream:</source>
          <target state="translated">Leer la <ph id="ph1">&lt;xref:System.IO.TextReader.Null&gt;</ph> lector de texto es parecido a leer desde el final de una secuencia:</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.TextReader.Null">
          <source>The <ph id="ph1">&lt;xref:System.IO.TextReader.Read%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.TextReader.Peek%2A&gt;</ph> methods return -1.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.TextReader.Read%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IO.TextReader.Peek%2A&gt;</ph> métodos devuelven -1.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.TextReader.Null">
          <source>The <ph id="ph1">&lt;xref:System.IO.TextReader.ReadBlock%2A&gt;</ph> method returns zero.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.TextReader.ReadBlock%2A&gt;</ph> método devuelva cero.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.TextReader.Null">
          <source>The <ph id="ph1">&lt;xref:System.IO.TextReader.ReadLine%2A&gt;</ph> method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.TextReader.ReadLine%2A&gt;</ph> método <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.TextReader.Null">
          <source>The <ph id="ph1">&lt;xref:System.IO.TextReader.ReadToEnd%2A&gt;</ph> method returns an empty string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.TextReader.ReadToEnd%2A&gt;</ph> método devuelve una cadena vacía.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Peek">
          <source>Reads the next character without changing the state of the reader or the character source.</source>
          <target state="translated">Lee el siguiente carácter sin modificar el estado del sistema de lectura o el origen del carácter.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Peek">
          <source>Returns the next available character without actually reading it from the reader.</source>
          <target state="translated">Devuelve el siguiente carácter disponible sin leerlo realmente del lector.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Peek">
          <source>An integer representing the next character to be read, or -1 if no more characters are available or the reader does not support seeking.</source>
          <target state="translated">Un entero que representa el siguiente carácter que se va a leer, o -1 si no hay más caracteres disponibles o si el lector no admite la operación de búsqueda.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Peek">
          <source>The <ph id="ph1">&lt;xref:System.IO.TextReader.Peek%2A&gt;</ph> method returns an integer value in order to determine whether the end of the file, or another error has occurred.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.TextReader.Peek%2A&gt;</ph> método devuelve un valor entero con el fin de determinar si se ha producido el final del archivo o de otro error.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Peek">
          <source>This allows a user to first check if the returned value is -1 before casting it to a <ph id="ph1">&lt;xref:System.Char&gt;</ph> type.</source>
          <target state="translated">Esto permite que un usuario comprobar primero si el valor devuelto es -1 antes de convertirlo a un <ph id="ph1">&lt;xref:System.Char&gt;</ph> tipo.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Peek">
          <source>The current position of the <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> is not changed by this operation.</source>
          <target state="translated">La posición actual de la <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> no se cambia por esta operación.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Peek">
          <source>The returned value is -1 if no more characters are available.</source>
          <target state="translated">El valor devuelto es -1 si no hay más caracteres disponibles.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Peek">
          <source>The default implementation returns -1.</source>
          <target state="translated">La implementación predeterminada devuelve -1.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Peek">
          <source>The <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> class is an abstract class.</source>
          <target state="translated">La clase <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> es abstracta.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Peek">
          <source>Therefore, you do not instantiate it in your code.</source>
          <target state="translated">Por lo tanto, no inicializarlo en el código.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Peek">
          <source>For an example of using the <ph id="ph1">&lt;xref:System.IO.TextReader.Peek%2A&gt;</ph> method, see the <ph id="ph2">&lt;xref:System.IO.StreamReader.Peek%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para obtener un ejemplo del uso de la <ph id="ph1">&lt;xref:System.IO.TextReader.Peek%2A&gt;</ph> método, consulte el <ph id="ph2">&lt;xref:System.IO.StreamReader.Peek%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Peek">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> is closed.</source>
          <target state="translated">La clase <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> está cerrada.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Peek">
          <source>An I/O error occurs.</source>
          <target state="translated">Error de E/S.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="T:System.IO.TextReader">
          <source>Reads data from the text reader.</source>
          <target state="translated">Lee datos del lector de texto.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read">
          <source>Reads the next character from the text reader and advances the character position by one character.</source>
          <target state="translated">Lee el siguiente carácter en el lector de texto y hace avanzar la posición de los caracteres en un carácter.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read">
          <source>The next character from the text reader, or -1 if no more characters are available.</source>
          <target state="translated">Carácter siguiente del lector de texto o -1 si no hay más caracteres disponibles.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read">
          <source>The default implementation returns -1.</source>
          <target state="translated">La implementación predeterminada devuelve -1.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Read">
          <source>The <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> class is an abstract class.</source>
          <target state="translated">La clase <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> es abstracta.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Read">
          <source>Therefore, you do not instantiate it in your code.</source>
          <target state="translated">Por lo tanto, no inicializarlo en el código.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Read">
          <source>For an example of using the <ph id="ph1">&lt;xref:System.IO.TextReader.Read%2A&gt;</ph> method, see the <ph id="ph2">&lt;xref:System.IO.StreamReader.Read%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para obtener un ejemplo del uso de la <ph id="ph1">&lt;xref:System.IO.TextReader.Read%2A&gt;</ph> método, consulte el <ph id="ph2">&lt;xref:System.IO.StreamReader.Read%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> is closed.</source>
          <target state="translated">La clase <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> está cerrada.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read">
          <source>An I/O error occurs.</source>
          <target state="translated">Error de E/S.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source>When this method returns, contains the specified character array with the values between <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept> and (<bpt id="p2">&lt;c&gt;</bpt>index<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1) replaced by the characters read from the current source.</source>
          <target state="translated">Cuando este método finaliza, contiene la matriz de caracteres especificada con los valores comprendidos entre <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept> e (<bpt id="p2">&lt;c&gt;</bpt>index<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1) reemplazada por los caracteres leídos del origen actual.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source>The position in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin writing.</source>
          <target state="translated">La posición de <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> en la que se va a iniciar la escritura.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source>The maximum number of characters to read.</source>
          <target state="translated">Número máximo de caracteres que se van a leer.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source>If the end of the reader is reached before the specified number of characters is read into the buffer, the method returns.</source>
          <target state="translated">Si el final del lector se alcanza antes de escribir el número de caracteres especificado en el búfer, el método vuelve.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source>Reads a specified maximum number of characters from the current reader and writes the data to a buffer, beginning at the specified index.</source>
          <target state="translated">Lee un número máximo de caracteres especificado en el lector actual y escribe los datos en un búfer, comenzando en el índice especificado.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source>The number of characters that have been read.</source>
          <target state="translated">Número de caracteres que se han leído.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source>The number will be less than or equal to <ph id="ph1">&lt;paramref name="count" /&gt;</ph>, depending on whether the data is available within the reader.</source>
          <target state="translated">Este número será menor o igual que <ph id="ph1">&lt;paramref name="count" /&gt;</ph>, en función de si los datos están disponibles dentro del lector.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source>This method returns 0 (zero) if it is called when no more characters are left to read.</source>
          <target state="translated">Este método devuelve 0 (cero) si se llama cuando no quedan más caracteres para leer.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source>This method returns after either <ph id="ph1">`count`</ph> characters are read or the end of the file is reached.</source>
          <target state="translated">Este método devuelve después <ph id="ph1">`count`</ph> caracteres que se leen o se llega al final del archivo.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.IO.TextReader.ReadBlock%2A&gt;</ph> is a blocking version of this method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.TextReader.ReadBlock%2A&gt;</ph> es una versión de bloqueo de este método.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> class is an abstract class.</source>
          <target state="translated">La clase <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> es abstracta.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source>Therefore, you do not instantiate it in your code.</source>
          <target state="translated">Por lo tanto, no inicializarlo en el código.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source>For an example of using the <ph id="ph1">&lt;xref:System.IO.TextReader.Read%2A&gt;</ph> method, see the <ph id="ph2">&lt;xref:System.IO.StreamReader.Read%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para obtener un ejemplo del uso de la <ph id="ph1">&lt;xref:System.IO.TextReader.Read%2A&gt;</ph> método, consulte el <ph id="ph2">&lt;xref:System.IO.StreamReader.Read%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source>The buffer length minus <ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">La longitud del búfer menos <ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> is closed.</source>
          <target state="translated">La clase <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> está cerrada.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)">
          <source>An I/O error occurs.</source>
          <target state="translated">Error de E/S.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source>When this method returns, contains the specified character array with the values between <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept> and (<bpt id="p2">&lt;c&gt;</bpt>index<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1) replaced by the characters read from the current source.</source>
          <target state="translated">Cuando este método finaliza, contiene la matriz de caracteres especificada con los valores comprendidos entre <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept> e (<bpt id="p2">&lt;c&gt;</bpt>index<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1) reemplazada por los caracteres leídos del origen actual.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source>The position in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin writing.</source>
          <target state="translated">La posición de <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> en la que se va a iniciar la escritura.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source>The maximum number of characters to read.</source>
          <target state="translated">Número máximo de caracteres que se van a leer.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source>If the end of the text is reached before the specified number of characters is read into the buffer, the current method returns.</source>
          <target state="translated">Si el final del texto se alcanza antes de leer el número de caracteres especificado en el búfer, el método actual vuelve.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source>Reads a specified maximum number of characters from the current text reader asynchronously and writes the data to a buffer, beginning at the specified index.</source>
          <target state="translated">Lee un número máximo de caracteres especificado en el lector de texto actual de forma asincrónica y escribe los datos en un búfer, comenzando en el índice especificado.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source>A task that represents the asynchronous read operation.</source>
          <target state="translated">Tarea que representa la operación de lectura asincrónica.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source>The value of the <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> parameter contains the total number of bytes read into the buffer.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> contiene el número total de bytes leídos en el búfer.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source>The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the text has been reached.</source>
          <target state="translated">El valor del resultado puede ser menor que el número de bytes solicitados si el número de bytes disponibles actualmente es menor que el número solicitado o puede ser 0 (cero) si se ha llegado al final del texto.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source>The task completes after either the number of characters specified by the <ph id="ph1">`count`</ph> parameter are read or the end of the file is reached.</source>
          <target state="translated">La tarea complete después el número de caracteres especificado por el <ph id="ph1">`count`</ph> parámetro se leen o se llega al final del archivo.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> class is an abstract class.</source>
          <target state="translated">La clase <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> es abstracta.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source>Therefore, you do not instantiate it in your code.</source>
          <target state="translated">Por lo tanto, no inicializarlo en el código.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source>For an example of using the <ph id="ph1">&lt;xref:System.IO.TextReader.ReadAsync%2A&gt;</ph> method, see the <ph id="ph2">&lt;xref:System.IO.StreamReader.ReadAsync%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para obtener un ejemplo del uso de la <ph id="ph1">&lt;xref:System.IO.TextReader.ReadAsync%2A&gt;</ph> método, consulte el <ph id="ph2">&lt;xref:System.IO.StreamReader.ReadAsync%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source>The sum of <ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated">La suma de <ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es mayor que la longitud del búfer.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source>The text reader has been disposed.</source>
          <target state="translated">Se ha desechado el lector de texto.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)">
          <source>The reader is currently in use by a previous read operation.</source>
          <target state="translated">Una operación de lectura anterior está usando actualmente el lector.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
          <source>When this method returns, this parameter contains the specified character array with the values between <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept> and (<bpt id="p2">&lt;c&gt;</bpt>index<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> -1) replaced by the characters read from the current source.</source>
          <target state="translated">Cuando este método finaliza, este parámetro contiene la matriz de caracteres especificada con los valores comprendidos entre <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept> e (<bpt id="p2">&lt;c&gt;</bpt>index<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> -1) reemplazada por los caracteres leídos del origen actual.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
          <source>The position in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin writing.</source>
          <target state="translated">La posición de <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> en la que se va a iniciar la escritura.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
          <source>The maximum number of characters to read.</source>
          <target state="translated">Número máximo de caracteres que se van a leer.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
          <source>Reads a specified maximum number of characters from the current text reader and writes the data to a buffer, beginning at the specified index.</source>
          <target state="translated">Lee un número máximo de caracteres especificado en el lector de texto actual y escribe los datos en un búfer, comenzando en el índice especificado.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
          <source>The number of characters that have been read.</source>
          <target state="translated">Número de caracteres que se han leído.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
          <source>The number will be less than or equal to <ph id="ph1">&lt;paramref name="count" /&gt;</ph>, depending on whether all input characters have been read.</source>
          <target state="translated">Este número será menor o igual que <ph id="ph1">&lt;paramref name="count" /&gt;</ph>, dependiendo de si se han leído todos los caracteres de entrada.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
          <source>The position of the underlying text reader is advanced by the number of characters that were read into <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">La posición del lector de texto subyacente avanza por el número de caracteres que se leyeron en <ph id="ph1">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
          <source>The method blocks until either <ph id="ph1">`count`</ph> characters are read, or all characters have been read.</source>
          <target state="translated">El método se bloquea hasta que <ph id="ph1">`count`</ph> se leen los caracteres o se han leído todos los caracteres.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
          <source>This is a blocking version of <ph id="ph1">&lt;xref:System.IO.TextReader.Read%2A&gt;</ph>.</source>
          <target state="translated">Se trata de una versión de bloqueo de <ph id="ph1">&lt;xref:System.IO.TextReader.Read%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
          <source>The buffer length minus <ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">La longitud del búfer menos <ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> is closed.</source>
          <target state="translated">La clase <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> está cerrada.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)">
          <source>An I/O error occurs.</source>
          <target state="translated">Error de E/S.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
          <source>When this method returns, contains the specified character array with the values between <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept> and (<bpt id="p2">&lt;c&gt;</bpt>index<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1) replaced by the characters read from the current source.</source>
          <target state="translated">Cuando este método finaliza, contiene la matriz de caracteres especificada con los valores comprendidos entre <bpt id="p1">&lt;c&gt;</bpt>index<ept id="p1">&lt;/c&gt;</ept> e (<bpt id="p2">&lt;c&gt;</bpt>index<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1) reemplazada por los caracteres leídos del origen actual.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
          <source>The position in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin writing.</source>
          <target state="translated">La posición de <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> en la que se va a iniciar la escritura.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
          <source>The maximum number of characters to read.</source>
          <target state="translated">Número máximo de caracteres que se van a leer.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
          <source>If the end of the text is reached before the specified number of characters is read into the buffer, the current method returns.</source>
          <target state="translated">Si el final del texto se alcanza antes de leer el número de caracteres especificado en el búfer, el método actual vuelve.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
          <source>Reads a specified maximum number of characters from the current text reader asynchronously and writes the data to a buffer, beginning at the specified index.</source>
          <target state="translated">Lee un número máximo de caracteres especificado en el lector de texto actual de forma asincrónica y escribe los datos en un búfer, comenzando en el índice especificado.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
          <source>A task that represents the asynchronous read operation.</source>
          <target state="translated">Tarea que representa la operación de lectura asincrónica.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
          <source>The value of the <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> parameter contains the total number of bytes read into the buffer.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> contiene el número total de bytes leídos en el búfer.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
          <source>The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the text has been reached.</source>
          <target state="translated">El valor del resultado puede ser menor que el número de bytes solicitados si el número de bytes disponibles actualmente es menor que el número solicitado o puede ser 0 (cero) si se ha llegado al final del texto.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
          <source>The task does not complete until either the number of characters specified by the <ph id="ph1">`count`</ph> parameter are read, or the end of the text has been reached.</source>
          <target state="translated">La tarea no completa hasta que el número de caracteres especificado por el <ph id="ph1">`count`</ph> parámetro se leen o se ha alcanzado el final del texto.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
          <source>The sum of <ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated">La suma de <ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es mayor que la longitud del búfer.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
          <source>The text reader has been disposed.</source>
          <target state="translated">Se ha desechado el lector de texto.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)">
          <source>The reader is currently in use by a previous read operation.</source>
          <target state="translated">Una operación de lectura anterior está usando actualmente el lector.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadLine">
          <source>Reads a line of characters from the text reader and returns the data as a string.</source>
          <target state="translated">Lee una línea de caracteres del lector de texto y devuelve los datos como una cadena.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadLine">
          <source>The next line from the reader, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if all characters have been read.</source>
          <target state="translated">Línea siguiente del lector o <ph id="ph1">&lt;see langword="null" /&gt;</ph> si se han leído todos los caracteres.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadLine">
          <source>A line is defined as a sequence of characters followed by a carriage return (0x000d), a line feed (0x000a), a carriage return followed by a line feed, <ph id="ph1">&lt;xref:System.Environment.NewLine%2A?displayProperty=nameWithType&gt;</ph>, or the end-of-stream marker.</source>
          <target state="translated">Una línea se define como una secuencia de caracteres seguida de un retorno de carro (0x000d), un avance de línea (0x000a), un retorno de carro seguido de una avance de línea, <ph id="ph1">&lt;xref:System.Environment.NewLine%2A?displayProperty=nameWithType&gt;</ph>, o el marcador de fin de secuencia.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadLine">
          <source>The string that is returned does not contain the terminating carriage return or line feed.</source>
          <target state="translated">La cadena que se devuelve no contiene el retorno de carro o avance de línea de terminación.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadLine">
          <source>The return value is <ph id="ph1">`null`</ph> if the end of the input stream has been reached.</source>
          <target state="translated">El valor devuelto es <ph id="ph1">`null`</ph> si se ha alcanzado el final de la secuencia de entrada.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadLine">
          <source>If the method throws an <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception, the reader's position in the underlying <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> is advanced by the number of characters the method was able to read, but the characters that were already read into the internal <ph id="ph3">&lt;xref:System.IO.TextReader.ReadLine%2A&gt;</ph> buffer are discarded.</source>
          <target state="translated">Si el método produce una <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> excepción, la posición del lector en subyacente <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> avanza por el número de caracteres que el método es capaz de leer, pero los caracteres que ya se han leído en interno <ph id="ph3">&lt;xref:System.IO.TextReader.ReadLine%2A&gt;</ph> búfer se descartan.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadLine">
          <source>Because the position of the reader in the stream cannot be changed, the characters that were already read are unrecoverable and can be accessed only by reinitializing the <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> object.</source>
          <target state="translated">Dado que no se puede cambiar la posición del lector en la secuencia, los caracteres que ya se han leído son irrecuperables y son accesibles solo reinicializando la <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadLine">
          <source>If the initial position within the stream is unknown or the stream does not support seeking, the underlying <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> also needs to be reinitialized.</source>
          <target state="translated">Si se conoce la posición inicial dentro de la secuencia o la secuencia no admite búsquedas, subyacente <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> también es necesario reinicializar.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadLine">
          <source>To avoid such a situation and produce robust code you should use the <ph id="ph1">&lt;xref:System.IO.TextReader.Read%2A&gt;</ph> method and store the read characters in a preallocated buffer.</source>
          <target state="translated">Para evitar esta situación y generar código robusto, debe utilizar el <ph id="ph1">&lt;xref:System.IO.TextReader.Read%2A&gt;</ph> método y el almacén de los caracteres de lectura en un búfer preasignado.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadLine">
          <source>The <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> class is an abstract class.</source>
          <target state="translated">La clase <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> es abstracta.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadLine">
          <source>Therefore, you do not instantiate it in your code.</source>
          <target state="translated">Por lo tanto, no inicializarlo en el código.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadLine">
          <source>For an example of using the <ph id="ph1">&lt;xref:System.IO.TextReader.ReadLine%2A&gt;</ph> method, see the <ph id="ph2">&lt;xref:System.IO.StreamReader.ReadLine%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para obtener un ejemplo del uso de la <ph id="ph1">&lt;xref:System.IO.TextReader.ReadLine%2A&gt;</ph> método, consulte el <ph id="ph2">&lt;xref:System.IO.StreamReader.ReadLine%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadLine">
          <source>An I/O error occurs.</source>
          <target state="translated">Error de E/S.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadLine">
          <source>There is insufficient memory to allocate a buffer for the returned string.</source>
          <target state="translated">No hay memoria suficiente para asignar un búfer para la cadena devuelta.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadLine">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> is closed.</source>
          <target state="translated">La clase <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> está cerrada.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadLine">
          <source>The number of characters in the next line is larger than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph></source>
          <target state="translated">El número de caracteres de la siguiente línea es mayor que <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadLineAsync">
          <source>Reads a line of characters asynchronously and returns the data as a string.</source>
          <target state="translated">Lee de forma asincrónica una línea de caracteres y devuelve los datos como una cadena.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadLineAsync">
          <source>A task that represents the asynchronous read operation.</source>
          <target state="translated">Tarea que representa la operación de lectura asincrónica.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadLineAsync">
          <source>The value of the <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> parameter contains the next line from the text reader, or is <ph id="ph2">&lt;see langword="null" /&gt;</ph> if all of the characters have been read.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> contiene la línea siguiente del lector de texto, o es <ph id="ph2">&lt;see langword="null" /&gt;</ph> si se han leído todos los caracteres.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadLineAsync">
          <source>The <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> class is an abstract class.</source>
          <target state="translated">La clase <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> es abstracta.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadLineAsync">
          <source>Therefore, you do not instantiate it in your code.</source>
          <target state="translated">Por lo tanto, no inicializarlo en el código.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadLineAsync">
          <source>For an example of using the <ph id="ph1">&lt;xref:System.IO.TextReader.ReadLineAsync%2A&gt;</ph> method, see the <ph id="ph2">&lt;xref:System.IO.StreamReader.ReadLineAsync%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para obtener un ejemplo del uso de la <ph id="ph1">&lt;xref:System.IO.TextReader.ReadLineAsync%2A&gt;</ph> método, consulte el <ph id="ph2">&lt;xref:System.IO.StreamReader.ReadLineAsync%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadLineAsync">
          <source>If the current <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> represents the standard input stream returned by the <ph id="ph2">&lt;xref:System.Console.In%2A?displayProperty=nameWithType&gt;</ph> property, the <ph id="ph3">&lt;xref:System.IO.TextReader.ReadLineAsync%2A&gt;</ph> method executes synchronously rather than asynchronously.</source>
          <target state="translated">Si la actual <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> representa el flujo de entrada estándar devuelto por la <ph id="ph2">&lt;xref:System.Console.In%2A?displayProperty=nameWithType&gt;</ph> propiedad, el <ph id="ph3">&lt;xref:System.IO.TextReader.ReadLineAsync%2A&gt;</ph> el método se ejecuta sincrónicamente en lugar de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadLineAsync">
          <source>The number of characters in the next line is larger than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">El número de caracteres de la siguiente línea es mayor que <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadLineAsync">
          <source>The text reader has been disposed.</source>
          <target state="translated">Se ha desechado el lector de texto.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadLineAsync">
          <source>The reader is currently in use by a previous read operation.</source>
          <target state="translated">Una operación de lectura anterior está usando actualmente el lector.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadToEnd">
          <source>Reads all characters from the current position to the end of the text reader and returns them as one string.</source>
          <target state="translated">Lee todos los caracteres desde la posición actual hasta el final del lector de texto y los devuelve como una cadena.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadToEnd">
          <source>A string that contains all characters from the current position to the end of the text reader.</source>
          <target state="translated">Cadena que contiene todos los caracteres desde la posición actual hasta el final del lector.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadToEnd">
          <source>If the method throws an <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception, the reader's position in the underlying <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> is advanced by the number of characters the method was able to read, but the characters that were already read into the internal <ph id="ph3">&lt;xref:System.IO.TextReader.ReadToEnd%2A&gt;</ph> buffer are discarded.</source>
          <target state="translated">Si el método produce una <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> excepción, la posición del lector en subyacente <ph id="ph2">&lt;xref:System.IO.Stream&gt;</ph> avanza por el número de caracteres que el método es capaz de leer, pero los caracteres que ya se han leído en interno <ph id="ph3">&lt;xref:System.IO.TextReader.ReadToEnd%2A&gt;</ph> búfer se descartan.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadToEnd">
          <source>Because the position of the reader in the stream cannot be changed, the characters that were already read are unrecoverable and can be accessed only by reinitializing the <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph>.</source>
          <target state="translated">Dado que no se puede cambiar la posición del lector en la secuencia, los caracteres que ya se han leído son irrecuperables y son accesibles solo reinicializando la <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadToEnd">
          <source>If the initial position within the stream is unknown or the stream does not support seeking, the underlying <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> also needs to be reinitialized.</source>
          <target state="translated">Si se conoce la posición inicial dentro de la secuencia o la secuencia no admite búsquedas, subyacente <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> también es necesario reinicializar.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadToEnd">
          <source>To avoid such a situation and produce robust code you should use the <ph id="ph1">&lt;xref:System.IO.TextReader.Read%2A&gt;</ph> method and store the read characters in a preallocated buffer.</source>
          <target state="translated">Para evitar esta situación y generar código robusto, debe utilizar el <ph id="ph1">&lt;xref:System.IO.TextReader.Read%2A&gt;</ph> método y el almacén de los caracteres de lectura en un búfer preasignado.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadToEnd">
          <source>The <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> class is an abstract class.</source>
          <target state="translated">La clase <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> es abstracta.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadToEnd">
          <source>Therefore, you do not instantiate it in your code.</source>
          <target state="translated">Por lo tanto, no inicializarlo en el código.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadToEnd">
          <source>For an example of using the <ph id="ph1">&lt;xref:System.IO.TextReader.ReadToEnd%2A&gt;</ph> method, see the <ph id="ph2">&lt;xref:System.IO.StreamReader.ReadToEnd%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para obtener un ejemplo del uso de la <ph id="ph1">&lt;xref:System.IO.TextReader.ReadToEnd%2A&gt;</ph> método, consulte el <ph id="ph2">&lt;xref:System.IO.StreamReader.ReadToEnd%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadToEnd">
          <source>An I/O error occurs.</source>
          <target state="translated">Error de E/S.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadToEnd">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> is closed.</source>
          <target state="translated">La clase <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> está cerrada.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadToEnd">
          <source>There is insufficient memory to allocate a buffer for the returned string.</source>
          <target state="translated">No hay memoria suficiente para asignar un búfer para la cadena devuelta.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadToEnd">
          <source>The number of characters in the next line is larger than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph></source>
          <target state="translated">El número de caracteres de la siguiente línea es mayor que <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadToEndAsync">
          <source>Reads all characters from the current position to the end of the text reader asynchronously and returns them as one string.</source>
          <target state="translated">Lee de forma asincrónica todos los caracteres desde la posición actual hasta el final del lector de texto y los devuelve como una cadena.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadToEndAsync">
          <source>A task that represents the asynchronous read operation.</source>
          <target state="translated">Tarea que representa la operación de lectura asincrónica.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadToEndAsync">
          <source>The value of the <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> parameter contains a string with the characters from the current position to the end of the text reader.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> contiene una cadena con los caracteres desde la posición actual hasta el final del lector de texto.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadToEndAsync">
          <source>The <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> class is an abstract class.</source>
          <target state="translated">La clase <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> es abstracta.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadToEndAsync">
          <source>Therefore, you do not instantiate it in your code.</source>
          <target state="translated">Por lo tanto, no inicializarlo en el código.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.ReadToEndAsync">
          <source>For an example of using the <ph id="ph1">&lt;xref:System.IO.TextReader.ReadToEndAsync%2A&gt;</ph> method, see the <ph id="ph2">&lt;xref:System.IO.StreamReader.ReadToEndAsync%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para obtener un ejemplo del uso de la <ph id="ph1">&lt;xref:System.IO.TextReader.ReadToEndAsync%2A&gt;</ph> método, consulte el <ph id="ph2">&lt;xref:System.IO.StreamReader.ReadToEndAsync%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadToEndAsync">
          <source>The number of characters is larger than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">El número de caracteres es mayor que <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadToEndAsync">
          <source>The text reader has been disposed.</source>
          <target state="translated">Se ha desechado el lector de texto.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.ReadToEndAsync">
          <source>The reader is currently in use by a previous read operation.</source>
          <target state="translated">Una operación de lectura anterior está usando actualmente el lector.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Synchronized(System.IO.TextReader)">
          <source>The <ph id="ph1">&lt;see langword="TextReader" /&gt;</ph> to synchronize.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="TextReader" /&gt;</ph> que se va a sincronizar.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Synchronized(System.IO.TextReader)">
          <source>Creates a thread-safe wrapper around the specified <ph id="ph1">&lt;see langword="TextReader" /&gt;</ph>.</source>
          <target state="translated">Crea un contenedor seguro para subprocesos en torno al <ph id="ph1">&lt;see langword="TextReader" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Synchronized(System.IO.TextReader)">
          <source>A thread-safe <ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.TextReader" /&gt;</ph> seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Synchronized(System.IO.TextReader)">
          <source>The current method returns a class that wraps around the specified <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> instance and restricts access to it by multiple threads.</source>
          <target state="translated">El método actual devuelve una clase que se ajusta alrededor especificado <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> instancia y restringe el acceso a él mediante varios subprocesos.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.TextReader.Synchronized(System.IO.TextReader)">
          <source>All reads from the returned wrapper will be thread safe.</source>
          <target state="translated">Todas las lecturas realizadas desde el contenedor devuelto será es seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.IO.TextReader.Synchronized(System.IO.TextReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>