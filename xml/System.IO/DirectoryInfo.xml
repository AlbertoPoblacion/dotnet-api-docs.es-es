<Type Name="DirectoryInfo" FullName="System.IO.DirectoryInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="28fcb435354d1b5e6e1bb1b14c5818378e90f11b" /><Meta Name="ms.sourcegitcommit" Value="2982b8c4cce02c2542285fcaf172f7544d6b80bc" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="04/09/2019" /><Meta Name="ms.locfileid" Value="59349461" /></Metadata><TypeSignature Language="C#" Value="public sealed class DirectoryInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit DirectoryInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.DirectoryInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DirectoryInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DirectoryInfo sealed : System::IO::FileSystemInfo" />
  <TypeSignature Language="F#" Value="type DirectoryInfo = class&#xA;    inherit FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Expone métodos de instancia para crear, mover y enumerar archivos en directorios y subdirectorios. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.DirectoryInfo> clase para las operaciones habituales, como copiar, mover, cambiar el nombre, crear y eliminar directorios.  
  
 Si va a utilizar un objeto varias veces, considere la posibilidad de usar el método de instancia de <xref:System.IO.DirectoryInfo> en lugar de los correspondientes métodos estáticos de la <xref:System.IO.Directory> clase ya no siempre será necesario realizar una comprobación de seguridad.  
  
> [!NOTE]
>  En los miembros que aceptan una ruta de acceso como una cadena de entrada, esa ruta de acceso debe tener un formato correcto o se produce una excepción. Por ejemplo, si una ruta de acceso es un nombre completo, pero comienza con un espacio, la ruta de acceso no se recorta en los métodos de la clase. Por lo tanto, la ruta de acceso es incorrecto y se produce una excepción. De forma similar, una ruta de acceso o una combinación de rutas de acceso no puede ser completo dos veces. Por ejemplo, "c:\temp c:\windows" también genera una excepción en la mayoría de los casos. Asegúrese de que las rutas de acceso correctos al usar métodos que aceptan una cadena de ruta de acceso.  
  
 En los miembros que aceptan una ruta de acceso, la ruta de acceso puede hacer referencia a un archivo o simplemente un directorio. La ruta de acceso especificada también puede hacer referencia a una ruta de acceso relativa o una ruta de acceso de convención de nomenclatura Universal (UNC) para un nombre de servidor y recurso compartido. Por ejemplo, todo lo siguiente es las rutas de acceso aceptables:  
  
-   "c:\\\MyDir\\\MyFile.txt" en C#, o "c:\MyDir\MyFile.txt" en Visual Basic.  
  
-   "c:\\\MyDir" en C#, o "c:\MyDir" en Visual Basic.  
  
-   "MyDir\\\MySubdir" en C#, o "Midir\misubdir" en Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" en C#, o "\\\MyServer\MyShare" en Visual Basic.  
  
 De forma predeterminada, se concede acceso de lectura/escritura completo a los nuevos directorios a todos los usuarios.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra algunos de los miembros principales de la `DirectoryInfo` clase.  
  
 [!code-cpp[DirInfo Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Class Example/CPP/dirinfo class example.cpp#1)]
 [!code-csharp[DirInfo Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Class Example/CS/dirinfo class example.cs#1)]
 [!code-vb[DirInfo Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Class Example/VB/dirinfo class example.vb#1)]  
  
 El ejemplo siguiente muestra cómo copiar un directorio y su contenido.  
  
 [!code-csharp[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/cs/copydir.cs#1)]
 [!code-vb[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/vb/CopyDir.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="P:System.IO.FileSystemInfo.Attributes" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.Directory" />
    <altmember cref="T:System.IO.Path" />
    <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Cómo: Leer y escribir en un archivo de datos recién creado</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DirectoryInfo (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DirectoryInfo(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.DirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="new System.IO.DirectoryInfo path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Cadena que especifica la ruta de acceso en la que se va a crear <see langword="DirectoryInfo" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.DirectoryInfo" /> en la ruta de acceso especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor no comprueba si existe un directorio. Este constructor es un marcador de posición para una cadena que se usa para obtener acceso al disco en operaciones posteriores.  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura Universal (UNC).  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza este constructor para crear el directorio especificado y el subdirectorio y se muestra que no se puede eliminar un directorio que contiene subdirectorios.  
  
 [!code-cpp[DirInfo Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Ctor/CPP/dirinfo ctor.cpp#1)]
 [!code-csharp[DirInfo Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Ctor/CS/dirinfo ctor.cs#1)]
 [!code-vb[DirInfo Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Ctor/VB/dirinfo ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contiene caracteres no válidos como ", &lt;, &gt; o |.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer archivos y directorios. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un directorio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Sub Create ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create();" />
      <MemberSignature Language="F#" Value="member this.Create : unit -&gt; unit" Usage="directoryInfo.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el directorio ya existe, este método no hace nada.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente se comprueba si existe un directorio especificado, se crea el directorio si no existe y elimina el directorio.  
  
 [!code-cpp[DirInfo Create#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Create/CPP/dirinfo create.cpp#1)]
 [!code-csharp[DirInfo Create#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Create/CS/dirinfo create.cs#1)]
 [!code-vb[DirInfo Create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Create/VB/dirinfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">No se puede crear el directorio.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en archivos. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.Create : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.Create directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">Control de acceso que se aplica al directorio.</param>
        <summary>Crea un directorio mediante un objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga del método para crear un directorio con el control de acceso, por lo que no hay ninguna posibilidad de que directorio puede obtenerse acceso antes de que se aplica la seguridad.  
  
 Si el directorio ya existe, este método no hace nada.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El directorio especificado por <paramref name="path" /> es de solo lectura o no está vacío.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.NotSupportedException">Se intentó crear un directorio con solo el carácter de dos puntos (:).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso Crear un directorio. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubdirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea uno o varios subdirectorios en la ruta de acceso especificada. La ruta de acceso especificada puede ser relativa a esta instancia de la clase <see cref="T:System.IO.DirectoryInfo" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubdirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso especificada. No puede ser un volumen de disco diferente ni un nombre de convención de nomenclatura universal (Universal Naming Convention, UNC).</param>
        <summary>Crea uno o varios subdirectorios en la ruta de acceso especificada. La ruta de acceso especificada puede ser relativa a esta instancia de la clase <see cref="T:System.IO.DirectoryInfo" />.</summary>
        <returns>Último directorio especificado en <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los directorios especificados en `path` se crean, a menos que alguna parte de `path` no es válido. El `path` parámetro especifica una ruta de acceso de directorio, no una ruta de acceso de archivo. Si el subdirectorio ya existe, este método no hace nada.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente se muestra cómo crear un subdirectorio. En este ejemplo, se quitan los directorios una vez creado. Por lo tanto, para probar este ejemplo, comente las líneas de eliminación en el código.  
  
 [!code-cpp[directoryinfocreatesub#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfocreatesub/CPP/directoryinfocreatesub.cpp#1)]
 [!code-csharp[directoryinfocreatesub#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfocreatesub/CS/directoryinfocreatesub.cs#1)]
 [!code-vb[directoryinfocreatesub#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfocreatesub/VB/directoryinfocreatesub.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> no especifica una ruta de acceso de archivo válida o contiene caracteres <see langword="DirectoryInfo" /> no válidos.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">No se puede crear el directorio.  
  
O bien 
Un archivo o directorio ya tiene el nombre especificado por <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no tiene permiso de acceso a código para crear el directorio.  
  
O bien 
El llamador no tiene permiso de acceso a código para leer el directorio descrito por el objeto <see cref="T:System.IO.DirectoryInfo" /> devuelto.  Esto puede ocurrir cuando el parámetro <paramref name="path" /> describe un directorio existente.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> contiene un carácter de dos puntos (:) que no forma parte de una etiqueta de unidad ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso especificada. No puede ser un volumen de disco diferente ni un nombre de convención de nomenclatura universal (Universal Naming Convention, UNC).</param>
        <param name="directorySecurity">Seguridad que se va a aplicar.</param>
        <summary>Crea uno o varios subdirectorios en la ruta de acceso especificada con la seguridad especificada. La ruta de acceso especificada puede ser relativa a esta instancia de la clase <see cref="T:System.IO.DirectoryInfo" />.</summary>
        <returns>Último directorio especificado en <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los directorios especificados en `path` se crean, a menos que alguna parte de `path` no es válido. El `path` parámetro especifica una ruta de acceso de directorio, no una ruta de acceso de archivo. Si el subdirectorio ya existe, este método no hace nada.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> no especifica una ruta de acceso de archivo válida o contiene caracteres <see langword="DirectoryInfo" /> no válidos.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">No se puede crear el directorio.  
  
O bien 
Un archivo o directorio ya tiene el nombre especificado por <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no tiene permiso de acceso a código para crear el directorio.  
  
O bien 
El llamador no tiene permiso de acceso a código para leer el directorio descrito por el objeto <see cref="T:System.IO.DirectoryInfo" /> devuelto.  Esto puede ocurrir cuando el parámetro <paramref name="path" /> describe un directorio existente.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> contiene un carácter de dos puntos (:) que no forma parte de una etiqueta de unidad ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Elimina un <see cref="T:System.IO.DirectoryInfo" /> y su contenido de una ruta de acceso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberSignature Language="F#" Value="override this.Delete : unit -&gt; unit" Usage="directoryInfo.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina este <see cref="T:System.IO.DirectoryInfo" /> si está vacío.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente produce una excepción si se intenta eliminar un directorio que no está vacío.  
  
 [!code-cpp[DirInfo Delete1#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Delete1/CPP/dirinfo delete1.cpp#1)]
 [!code-csharp[DirInfo Delete1#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Delete1/CS/dirinfo delete1.cs#1)]
 [!code-vb[DirInfo Delete1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Delete1/VB/dirinfo delete1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El directorio contiene un archivo de solo lectura.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio que describe este objeto <see cref="T:System.IO.DirectoryInfo" /> no existe o no se ha encontrado.</exception>
        <exception cref="T:System.IO.IOException">El directorio no está vacío.  
  
O bien 
El directorio es el directorio de trabajo actual de la aplicación.  
  
O bien 
Hay un identificador abierto en el directorio, y el sistema operativo es Windows XP o anterior. Este identificador puede obtenerse al enumerar directorios. Para obtener más información, vea [Cómo: Enumerar directorios y archivos](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en archivos. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete (recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete(bool recursive);" />
      <MemberSignature Language="F#" Value="override this.Delete : bool -&gt; unit" Usage="directoryInfo.Delete recursive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="recursive"><see langword="true" /> para eliminar este directorio, sus subdirectorios y todos los archivos; de lo contrario, es <see langword="false" />.</param>
        <summary>Elimina esta instancia de <see cref="T:System.IO.DirectoryInfo" />, especificando si se van a eliminar los subdirectorios y los archivos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `DirectoryInfo` no tiene archivos o subdirectorios, este método elimina el `DirectoryInfo` aunque `recursive` es `false`. Si intenta eliminar un `DirectoryInfo` que no está vacío cuando `recursive` es `false` produce una <xref:System.IO.IOException>.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente se muestra cómo eliminar un directorio. Dado que se quita el directorio, primero en comentario la `Delete` línea para probar que el directorio existe. A continuación, elimine la línea misma de código para comprobar que el directorio se quitó correctamente.  
  
 [!code-cpp[directoryinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfodelete/CPP/directoryinfodelete.cpp#1)]
 [!code-csharp[directoryinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfodelete/CS/directoryinfodelete.cs#1)]
 [!code-vb[directoryinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfodelete/VB/directoryinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El directorio contiene un archivo de solo lectura.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio descrito por este objeto <see cref="T:System.IO.DirectoryInfo" /> no existe o no se ha encontrado.</exception>
        <exception cref="T:System.IO.IOException">El directorio es de solo lectura.  
  
O bien 
El directorio contiene uno o varios archivos o subdirectorios y <paramref name="recursive" /> es <see langword="false" />.  
  
O bien 
El directorio es el directorio de trabajo actual de la aplicación.  
  
O bien 
Hay un identificador abierto en el directorio o en uno de sus archivos, y el sistema operativo es Windows XP o anterior. Este identificador abierto puede obtenerse al enumerar directorios y archivos. Para obtener más información, vea [Cómo: Enumerar directorios y archivos](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Indicador de escritura requerido para el permiso de escritura para el <see langword="DirectoryInfo" /> y subdirectorios que va a eliminar.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una colección enumerable de información de directorios del directorio actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories () As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories();" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : unit -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una colección enumerable de información de directorios del directorio actual.</summary>
        <returns>Colección enumerable de directorios del directorio actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> y <xref:System.IO.DirectoryInfo.GetDirectories%2A> métodos difieren como sigue:  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, puede empezar a enumerar la colección de <xref:System.IO.DirectoryInfo> objetos antes de que se devuelve toda la colección.  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.GetDirectories%2A>, debe esperar a que la matriz entera de <xref:System.IO.DirectoryInfo> objetos que se devolverán antes de que puede tener acceso a la matriz.  
  
 Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> puede ser más eficaz.  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.DirectoryInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> método en la colección iniciará una nueva enumeración.  
  
   
  
## Examples  
 El ejemplo siguiente se enumeran los subdirectorios bajo el directorio C:\Program Files y usa una consulta LINQ para devolver los nombres de todos los directorios que se crearon antes del 2009 comprobando el valor de la <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A> propiedad.  
  
 Si solo necesita los nombres de los subdirectorios, utilice estático <xref:System.IO.Directory> clase para mejorar el rendimiento. Para obtener un ejemplo, vea el <xref:System.IO.Directory.EnumerateDirectories%28System.String%29> método.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/cs/program.cs)]
 [!code-vb[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/vb/module1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso encapsulada en el objeto <see cref="T:System.IO.DirectoryInfo" /> no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories (searchPattern As String) As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Devuelve una colección enumerable de información de directorios que coincide con un modelo de búsqueda especificado.</summary>
        <returns>Colección enumerable de directorios que coincide con <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, la cadena "* t" busca todos los nombres terminan con la letra "t". ". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 El <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> y <xref:System.IO.DirectoryInfo.GetDirectories%2A> métodos difieren como sigue:  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, puede empezar a enumerar la colección de <xref:System.IO.DirectoryInfo> objetos antes de que se devuelve toda la colección.  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.GetDirectories%2A>, debe esperar a que la matriz entera de <xref:System.IO.DirectoryInfo> objetos que se devolverán antes de que puede tener acceso a la matriz.  
  
 Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> puede ser más eficaz.  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.DirectoryInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> método en la colección iniciará una nueva enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso encapsulada en el objeto <see cref="T:System.IO.DirectoryInfo" /> no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.SearchOption -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir solo el directorio actual o todos los subdirectorios. El valor predeterminado es <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Devuelve una colección enumerable de información de directorios que coincide con un modelo de búsqueda y una opción de búsqueda en subdirectorios especificados.</summary>
        <returns>Colección enumerable de directorios que coincide con <paramref name="searchPattern" /> y <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, la cadena "* t" busca todos los nombres terminan con la letra "t". ". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 El <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> y <xref:System.IO.DirectoryInfo.GetDirectories%2A> métodos difieren como sigue:  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>, puede empezar a enumerar la colección de <xref:System.IO.DirectoryInfo> objetos antes de que se devuelve toda la colección.  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.GetDirectories%2A>, debe esperar a que la matriz entera de <xref:System.IO.DirectoryInfo> objetos que se devolverán antes de que puede tener acceso a la matriz.  
  
 Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> puede ser más eficaz.  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.DirectoryInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> método en la colección iniciará una nueva enumeración.  
  
   
  
## Examples  
 El ejemplo siguiente, a partir de un directorio especificado, utiliza este método y el <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> método para enumerar los archivos y directorios dentro del directorio de inicio y mostrar los detalles de los archivos de más de 10 MB de tamaño.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> no es un valor de <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso encapsulada en el objeto <see cref="T:System.IO.DirectoryInfo" /> no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una colección enumerable de información de archivos del directorio actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles () As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : unit -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una colección enumerable de información de archivos del directorio actual.</summary>
        <returns>Colección enumerable de los archivos del directorio actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> y <xref:System.IO.DirectoryInfo.GetFiles%2A> métodos difieren como sigue:  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, puede empezar a enumerar la colección de <xref:System.IO.FileInfo> objetos antes de que se devuelve toda la colección.  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.GetFiles%2A>, debe esperar a que la matriz entera de <xref:System.IO.FileInfo> objetos que se devolverán antes de que puede tener acceso a la matriz.  
  
 Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> puede ser más eficaz.  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.FileInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> método en la colección iniciará una nueva enumeración.  
  
   
  
## Examples  
 El ejemplo siguiente se enumera los archivos en un directorio especificado y usa una consulta LINQ para devolver los nombres de todos los archivos que se crearon antes del 2009 comprobando el valor de la <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A> propiedad.  
  
 Si solo necesita los nombres de los archivos, use estático <xref:System.IO.Directory> clase para mejorar el rendimiento. Para obtener un ejemplo, vea el <xref:System.IO.Directory.EnumerateFiles%28System.String%29?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module1.vb#1)]  
  
 El ejemplo siguiente muestra cómo enumerar los archivos en un directorio mediante el uso de las opciones de búsqueda diferentes. En el ejemplo se da por supuesto un directorio que contenga los archivos denominados log1.txt, log2.txt, test1.txt, test2.txt, test3.txt y un subdirectorio que tiene un archivo denominado SubFile.txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso encapsulada en el objeto <see cref="T:System.IO.DirectoryInfo" /> no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles (searchPattern As String) As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los archivos.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Devuelve una colección enumerable de información de archivos que coincide con un modelo de búsqueda.</summary>
        <returns>Colección enumerable de archivos que coincide con <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, la cadena "* t" busca todos los nombres terminan con la letra "t". ". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 El <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> y <xref:System.IO.DirectoryInfo.GetFiles%2A> métodos difieren como sigue:  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, puede empezar a enumerar la colección de <xref:System.IO.FileInfo> objetos antes de que se devuelve toda la colección.  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.GetFiles%2A>, debe esperar a que la matriz entera de <xref:System.IO.FileInfo> objetos que se devolverán antes de que puede tener acceso a la matriz.  
  
 Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> puede ser más eficaz.  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.FileInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> método en la colección iniciará una nueva enumeración.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo enumerar los archivos en un directorio mediante el uso de las opciones de búsqueda diferentes. En el ejemplo se da por supuesto un directorio que contenga los archivos denominados log1.txt, log2.txt, test1.txt, test2.txt, test3.txt y un subdirectorio que tiene un archivo denominado SubFile.txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso encapsulada en el objeto <see cref="T:System.IO.DirectoryInfo" /> no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los archivos.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir solo el directorio actual o todos los subdirectorios. El valor predeterminado es <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Devuelve una colección enumerable de información de archivos que coincide con un modelo de búsqueda y una opción de búsqueda en subdirectorios especificados.</summary>
        <returns>Colección enumerable de archivos que coincide con <paramref name="searchPattern" /> y <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, la cadena "* t" busca todos los nombres terminan con la letra "t". ". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 El <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> y <xref:System.IO.DirectoryInfo.GetFiles%2A> métodos difieren como sigue:  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, puede empezar a enumerar la colección de <xref:System.IO.FileInfo> objetos antes de que se devuelve toda la colección.  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.GetFiles%2A>, debe esperar a que la matriz entera de <xref:System.IO.FileInfo> objetos que se devolverán antes de que puede tener acceso a la matriz.  
  
 Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> puede ser más eficaz.  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.FileInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> método en la colección iniciará una nueva enumeración.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo enumerar los archivos en un directorio mediante el uso de las opciones de búsqueda diferentes. En el ejemplo se da por supuesto un directorio que contenga los archivos denominados log1.txt, log2.txt, test1.txt, test2.txt, test3.txt y un subdirectorio que tiene un archivo denominado SubFile.txt.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> no es un valor de <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso encapsulada en el objeto <see cref="T:System.IO.DirectoryInfo" /> no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una colección enumerable de información del sistema de archivos del directorio actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos () As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : unit -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una colección enumerable de información del sistema de archivos del directorio actual.</summary>
        <returns>Colección enumerable de información del sistema de archivos del directorio actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> y <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> métodos difieren como sigue:  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, puede empezar a enumerar la colección de <xref:System.IO.FileSystemInfo> objetos antes de que se devuelve toda la colección.  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, debe esperar a que la matriz entera de <xref:System.IO.FileSystemInfo> objetos que se devolverán antes de que puede tener acceso a la matriz.  
  
 Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> puede ser más eficaz.  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.FileSystemInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> método en la colección iniciará una nueva enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso encapsulada en el objeto <see cref="T:System.IO.DirectoryInfo" /> no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos (searchPattern As String) As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Devuelve una colección enumerable de información del sistema de archivos que coincide con un modelo de búsqueda especificado.</summary>
        <returns>Colección enumerable de objetos de información del sistema de archivos que coincide con <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, la cadena "* t" busca todos los nombres terminan con la letra "t". ". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 El <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> y <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> métodos difieren como sigue:  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, puede empezar a enumerar la colección de <xref:System.IO.FileSystemInfo> objetos antes de que se devuelve toda la colección.  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, debe esperar a que la matriz entera de <xref:System.IO.FileSystemInfo> objetos que se devolverán antes de que puede tener acceso a la matriz.  
  
 Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> puede ser más eficaz.  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.FileSystemInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> método en la colección iniciará una nueva enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso encapsulada en el objeto <see cref="T:System.IO.DirectoryInfo" /> no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir solo el directorio actual o todos los subdirectorios. El valor predeterminado es <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Devuelve una colección enumerable de información del sistema de archivos que coincide con un modelo de búsqueda y una opción de búsqueda en subdirectorios especificados.</summary>
        <returns>Colección enumerable de objetos de información del sistema de archivos que coincide con <paramref name="searchPattern" /> y <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, la cadena "* t" busca todos los nombres terminan con la letra "t". ". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 El <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> y <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> métodos difieren como sigue:  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>, puede empezar a enumerar la colección de <xref:System.IO.FileSystemInfo> objetos antes de que se devuelve toda la colección.  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>, debe esperar a que la matriz entera de <xref:System.IO.FileSystemInfo> objetos que se devolverán antes de que puede tener acceso a la matriz.  
  
 Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> puede ser más eficaz.  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.FileSystemInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> método en la colección iniciará una nueva enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> no es un valor de <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso encapsulada en el objeto <see cref="T:System.IO.DirectoryInfo" /> no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Exists : bool" Usage="System.IO.DirectoryInfo.Exists" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si existe el directorio.</summary>
        <value><see langword="true" /> si el directorio existe; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.DirectoryInfo.Exists%2A> propiedad devuelve `false` si se produce un error al intentar determinar si existe el archivo especificado. Esto puede ocurrir en situaciones en las que generan excepciones, como pasar un nombre de archivo con caracteres no válidos o hay demasiados caracteres, un disco con errores o que faltan, o si el llamador no tiene permiso para leer el archivo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un uso de la `Exists` propiedad en el contexto de la copia de un directorio de origen en un directorio de destino.  
  
 [!code-cpp[DirectoryInfo Usage Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirectoryInfo Usage Example/CPP/copydirectory.cpp#1)]
 [!code-csharp[DirectoryInfo Usage Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirectoryInfo Usage Example/CS/copydirectory.cs#1)]
 [!code-vb[DirectoryInfo Usage Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirectoryInfo Usage Example/VB/copydirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.IO.DirectoryInfo.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso completa del directorio.</summary>
        <value>Cadena que contiene la ruta de acceso completa.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>    
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene las entradas de la lista de control de acceso (ACL) para el directorio actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.IO.DirectoryInfo.GetAccessControl%2A> métodos para recuperar el acceso a controlan las entradas de lista (ACL) para el archivo actual.  
  
 Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que encapsula las entradas de la lista de control de acceso (ACL) del directorio descrito por el objeto <see cref="T:System.IO.DirectoryInfo" /> actual.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que encapsula las reglas de control de acceso para el directorio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a esta sobrecarga del método es equivalente a llamar a la <xref:System.IO.Directory.GetAccessControl%2A> sobrecarga del método y especificando el acceso de control de secciones <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> (<xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>`Or`<xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>`Or`<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> en Visual Basic).  
  
 Use el <xref:System.IO.DirectoryInfo.GetAccessControl%2A> método para recuperar las entradas de lista (ACL) del control de acceso para el archivo actual.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo o directorio determinado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.DirectoryInfo.GetAccessControl%2A> y <xref:System.IO.DirectoryInfo.SetAccessControl%2A> métodos para agregar y, a continuación, quitar un acceso de control entrada de lista (ACL) de un directorio.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">No se ha podido encontrar o modificar el directorio.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El directorio es de solo lectura.  
  
O bien 
Esta operación no es compatible con la plataforma actual.  
  
O bien 
El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S al abrir el directorio.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Microsoft Windows 2000 o posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso enumerar una lista de control de acceso (ACL) para un directorio. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="includeSections">Uno de los valores <see cref="T:System.Security.AccessControl.AccessControlSections" /> que especifica el tipo de información de la lista de control de acceso (ACL) que se recibe.</param>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que encapsula el tipo especificado de entradas de la lista de control de acceso (ACL) del directorio descrito por el objeto <see cref="T:System.IO.DirectoryInfo" /> actual.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que encapsula las reglas de control de acceso correspondientes al archivo descrito por el parámetro <paramref name="path" />.  
  
Excepciones 
 <list type="table"><listheader><term> Tipo de excepción 
 </term><description> Condición 
 </description></listheader><item><term><see cref="T:System.SystemException" /></term><description> No se ha podido encontrar o modificar el directorio.  
  
 </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> El proceso actual no tiene acceso para abrir el directorio.  
  
 </description></item><item><term><see cref="T:System.IO.IOException" /></term><description> Se ha producido un error de E/S al abrir el directorio.  
  
 </description></item><item><term><see cref="T:System.PlatformNotSupportedException" /></term><description> El sistema operativo actual no es Microsoft Windows 2000 o posterior.  
  
 </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> El directorio es de solo lectura.  
  
O bien 
Esta operación no es compatible con la plataforma actual.  
  
O bien 
El llamador no dispone del permiso requerido.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.IO.DirectoryInfo.GetAccessControl%2A> método para recuperar las entradas de lista (ACL) del control de acceso para el archivo actual.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo o directorio determinado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso enumerar una lista de control de acceso (ACL) para un directorio. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve los subdirectorios del directorio actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories () As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories();" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : unit -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve los subdirectorios del directorio actual.</summary>
        <returns>Matriz de objetos <see cref="T:System.IO.DirectoryInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay ningún subdirectorio, este método devuelve una matriz vacía. Este método no es recursiva.  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.DirectoryInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 El ejemplo siguiente recupera todos los directorios en el directorio raíz y muestra los nombres de directorio.  
  
 [!code-cpp[directoryinfogetdirectories#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfogetdirectories/CPP/directoryinfogetdirectories.cpp#1)]
 [!code-csharp[directoryinfogetdirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetdirectories/CS/directoryinfogetdirectories.cs#1)]
 [!code-vb[directoryinfogetdirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetdirectories/VB/directoryinfogetdirectories.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso encapsulada en el objeto <see cref="T:System.IO.DirectoryInfo" /> no es válida como, por ejemplo, una ruta de una unidad no asignada.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer los directorios. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (searchPattern As String) As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Devuelve una matriz de directorios en el <see cref="T:System.IO.DirectoryInfo" /> actual que coinciden con los criterios de búsqueda especificados.</summary>
        <returns>Matriz de tipo <see langword="DirectoryInfo" /> que coincide con <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, la cadena "* t" busca todos los nombres terminan con la letra "t". ". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.DirectoryInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 El ejemplo siguiente cuenta los directorios en una ruta de acceso que contienen la carta especificados.  
  
 [!code-cpp[DirInfo GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo GetDirs2/CPP/dirinfo getdirs2.cpp#1)]
 [!code-csharp[DirInfo GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetDirs2/CS/dirinfo getdirs2.cs#1)]
 [!code-vb[DirInfo GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetDirs2/VB/dirinfo getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> contiene uno o varios caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso encapsulada en el objeto <see langword="DirectoryInfo" /> no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer desde archivos y directorios y para tener acceso a la ruta de acceso. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.EnumerationOptions -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.SearchOption -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir solo el directorio actual o todos los subdirectorios.</param>
        <summary>Devuelve una matriz de directorios en el <see cref="T:System.IO.DirectoryInfo" /> actual aplicando los criterios de búsqueda dados y utilizando un valor para determinar si se busca en los subdirectorios.</summary>
        <returns>Matriz de tipo <see langword="DirectoryInfo" /> que coincide con <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, la cadena "* t" busca todos los nombres terminan con la letra "t". ". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 Si no hay ningún subdirectorio en o coincide con ningún subdirectorio en el `searchPattern` parámetro, este método devuelve una matriz vacía.  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.DirectoryInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 El siguiente ejemplo enumera todos los directorios y archivos que comienzan por la letra "c" en "c:\\".  
  
 [!code-cpp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cpp/searchoption.cpp#00)]
 [!code-csharp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cs/searchoption.cs#00)]
 [!code-vb[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/vb/searchoption.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> contiene uno o varios caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> no es un valor de <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso encapsulada en el objeto <see langword="DirectoryInfo" /> no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer desde archivos y directorios y para tener acceso a la ruta de acceso. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una lista de archivos del directorio actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles () As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="member this.GetFiles : unit -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una lista de archivos del directorio actual.</summary>
        <returns>Matriz de tipo <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> y <xref:System.IO.DirectoryInfo.GetFiles%2A> métodos difieren como sigue:  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, puede empezar a enumerar la colección de <xref:System.IO.FileInfo> objetos antes de que se devuelve toda la colección.  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.GetFiles%2A>, debe esperar a que la matriz entera de <xref:System.IO.FileInfo> objetos que se devolverán antes de que puede tener acceso a la matriz.  
  
 Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> puede ser más eficaz.  
  
 Si no hay ningún archivo en el <xref:System.IO.DirectoryInfo>, este método devuelve una matriz vacía.  
  
 No se garantiza el orden de los nombres de archivo devueltos; Utilice el <xref:System.Array.Sort%2A> método si se requiere un orden específico.  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.FileInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo obtener una lista de archivos desde un directorio mediante el uso de las opciones de búsqueda diferentes. En el ejemplo se da por supuesto un directorio que contenga los archivos denominados log1.txt, log2.txt, test1.txt, test2.txt, test3.txt y un subdirectorio que tiene un archivo denominado SubFile.txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso no es válida, por ejemplo porque está en una unidad no asignada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer los directorios. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (searchPattern As String) As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los archivos.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Devuelve una lista de archivos del directorio actual que coinciden con el modelo de búsqueda.</summary>
        <returns>Matriz de tipo <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, la cadena "* t" busca todos los nombres terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 El <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> y <xref:System.IO.DirectoryInfo.GetFiles%2A> métodos difieren como sigue:  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, puede empezar a enumerar la colección de <xref:System.IO.FileInfo> objetos antes de que se devuelve toda la colección.  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.GetFiles%2A>, debe esperar a que la matriz entera de <xref:System.IO.FileInfo> objetos que se devolverán antes de que puede tener acceso a la matriz.  
  
 Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> puede ser más eficaz.  
  
 Si no hay ningún archivo en el <xref:System.IO.DirectoryInfo>, este método devuelve una matriz vacía.  
  
 Se permiten los siguientes especificadores comodín en el `searchPattern` parámetro.  
  
|carácter comodín|Descripción|  
|------------------------|-----------------|  
|*|Cero o más caracteres.|  
|?|Exactamente cero o un carácter.|  
  
 No se garantiza el orden de los nombres de archivo devueltos; Utilice el <xref:System.Array.Sort%2A> método si se requiere un orden específico.  
  
 Se permiten caracteres comodín. Por ejemplo, el `searchPattern` cadena "*.txt" búsquedas para todos los archivos con nombres que tenga una extensión de "txt". El `searchPattern` cadena "s\*" busca todos los archivos con nombres que empiecen por la letra "s". Si no hay ningún archivo o no archivos que coinciden con el `searchPattern` de cadena en el <xref:System.IO.DirectoryInfo>, este método devuelve una matriz vacía.  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` (por ejemplo, "*.txt"), el comportamiento de la coincidencia varía según la longitud de la extensión de archivo especificado. Un `searchPattern` con un archivo de extensión de exactamente tres caracteres devuelve archivos con una extensión de tres o más caracteres, donde los tres primeros caracteres coinciden con la extensión de archivo especificada en el `searchPattern`. Un `searchPattern` con un archivo de extensión de uno, dos o más de tres caracteres devuelve sólo los archivos con extensiones de esa longitud exacta que coinciden con la extensión de archivo especificada en el `searchPattern`. Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos en un directorio, "file1.txt" y "file1.txtother", un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
> [!NOTE]
>  Dado que este método comprueba los nombres de archivo con el formato de nombre de 8.3 archivo y el formato de nombre de archivo largos, un modelo de búsqueda similar a "* 1\*.txt" puede devolver los nombres de archivo inesperado. Por ejemplo, mediante un patrón de búsqueda de "\*1\*.txt" devolverá "nombrelargoarchivo.txt" porque el formato de nombre de 8.3 archivo equivalente sería "longf~1.txt".  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.FileInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo obtener una lista de archivos desde un directorio mediante el uso de las opciones de búsqueda diferentes. En el ejemplo se da por supuesto un directorio que contenga los archivos denominados log1.txt, log2.txt, test1.txt, test2.txt, test3.txt y un subdirectorio que tiene un archivo denominado SubFile.txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> contiene uno o varios caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la ruta de acceso y para la lectura de archivos y directorios. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.EnumerationOptions -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.SearchOption -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los archivos.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir solo el directorio actual o todos los subdirectorios.</param>
        <summary>Devuelve una lista de archivos del directorio actual que coinciden con el modelo de búsqueda dado y utiliza un valor para determinar si se va a buscar en los subdirectorios.</summary>
        <returns>Matriz de tipo <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> y <xref:System.IO.DirectoryInfo.GetFiles%2A> métodos difieren como sigue:  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>, puede empezar a enumerar la colección de <xref:System.IO.FileInfo> objetos antes de que se devuelve toda la colección.  
  
-   Cuando usas <xref:System.IO.DirectoryInfo.GetFiles%2A>, debe esperar a que la matriz entera de <xref:System.IO.FileInfo> objetos que se devolverán antes de que puede tener acceso a la matriz.  
  
 Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> puede ser más eficaz.  
  
 Si no hay ningún archivo en el <xref:System.IO.DirectoryInfo>, este método devuelve una matriz vacía.  
  
 Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|carácter comodín|Descripción|  
|------------------------|-----------------|  
|* (asterisco)|Cero o más caracteres.|  
|? (signo de interrogación)|Exactamente cero o un carácter.|  
  
 No se garantiza el orden de los nombres de archivo devueltos; Utilice el <xref:System.Array.Sort%2A> método si se requiere un orden específico.  
  
 Se permiten caracteres comodín. Por ejemplo, el `searchPattern` cadena "*.txt" búsquedas para todos los archivos con nombres que tenga una extensión de "txt". El `searchPattern` cadena "s\*" busca todos los archivos con nombres que empiecen por la letra "s". Si no hay ningún archivo o no archivos que coinciden con el `searchPattern` de cadena en el <xref:System.IO.DirectoryInfo>, este método devuelve una matriz vacía.  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` (por ejemplo, "*.txt"), el comportamiento de la coincidencia varía según la longitud de la extensión de archivo especificado. Un `searchPattern` con un archivo de extensión de exactamente tres caracteres devuelve archivos con una extensión de tres o más caracteres, donde los tres primeros caracteres coinciden con la extensión de archivo especificada en el `searchPattern`. Un `searchPattern` con un archivo de extensión de uno, dos o más de tres caracteres devuelve sólo los archivos con extensiones de esa longitud exacta que coinciden con la extensión de archivo especificada en el `searchPattern`. Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos en un directorio, "file1.txt" y "file1.txtother", un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
 En la lista siguiente se muestra el comportamiento de longitudes diferentes para el `searchPattern` parámetro:  
  
-   "*. abc" devuelve los archivos con una extensión of.abc,.abcd,.abcde,.abcdef, y así sucesivamente.  
  
-   "*.abcd" devuelve sólo los archivos que tienen una extensión de abcd.  
  
-   "*.abcde" devuelve sólo los archivos que tienen una extensión de abcde.  
  
-   "*.abcdef" devuelve sólo los archivos que tienen una extensión de abcdef.  
  
> [!NOTE]
>  Dado que este método comprueba los nombres de archivo con el formato de nombre de 8.3 archivo y el formato de nombre de archivo largos, un modelo de búsqueda similar a "* 1\*.txt" puede devolver los nombres de archivo inesperado. Por ejemplo, mediante un patrón de búsqueda de "\*1\*.txt" devolverá "nombrelargoarchivo.txt" porque el formato de nombre de 8.3 archivo equivalente sería "longf~1.txt".  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.FileInfo> propiedades:  
  
1.  <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
2.  <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
3.  <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
4.  <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
5.  <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
6.  <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
7.  <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
8.  <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo obtener una lista de archivos desde un directorio mediante el uso de las opciones de búsqueda diferentes. En el ejemplo se da por supuesto un directorio que contenga los archivos denominados log1.txt, log2.txt, test1.txt, test2.txt, test3.txt y un subdirectorio que tiene un archivo denominado SubFile.txt.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> contiene uno o varios caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> no es un valor de <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la ruta de acceso y para la lectura de archivos y directorios. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera una matriz de objetos <see cref="T:System.IO.FileSystemInfo" /> fuertemente tipados que representan los archivos y subdirectorios del directorio actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos () As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : unit -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz de entradas <see cref="T:System.IO.FileSystemInfo" /> fuertemente tipadas que representan todos los archivos y subdirectorios de un directorio.</summary>
        <returns>Matriz de entradas de <see cref="T:System.IO.FileSystemInfo" /> fuertemente tipadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no existen archivos o directorios en el <xref:System.IO.DirectoryInfo>, este método devuelve una matriz vacía. Este método no es recursiva.  
  
 Para los subdirectorios, el <xref:System.IO.FileSystemInfo> los objetos devueltos por este método se pueden convertir a la clase derivada <xref:System.IO.DirectoryInfo>. Use la <xref:System.IO.FileAttributes> valor devuelto por la <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> propiedad para determinar si el <xref:System.IO.FileSystemInfo> representa un archivo o un directorio.  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.FileSystemInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 En el ejemplo siguiente se cuentan los archivos y directorios en el directorio especificado.  
  
 [!code-csharp[FSizeSort#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSizeSort/CS/fsizesort.cs#1)]
 [!code-vb[FSizeSort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSizeSort/VB/fsizesort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos (searchPattern As String) As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios y archivos.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Recupera una matriz de objetos <see cref="T:System.IO.FileSystemInfo" /> fuertemente tipados que representan los archivos y subdirectorios que coinciden con los criterios de búsqueda especificados.</summary>
        <returns>Matriz de objetos <see langword="FileSystemInfo" /> fuertemente tipados que coinciden con los criterios de búsqueda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, la cadena "* t" busca todos los nombres terminan con la letra "t". ". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 Este método no es recursiva.  
  
 Para los subdirectorios, el <xref:System.IO.FileSystemInfo> los objetos devueltos por este método se pueden convertir a la clase derivada <xref:System.IO.DirectoryInfo>. Use la <xref:System.IO.FileAttributes> valor devuelto por la <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> propiedad para determinar si el <xref:System.IO.FileSystemInfo> representa un archivo o un directorio.  
  
 Se permiten caracteres comodín. Por ejemplo, el `searchPattern` cadena "* t" busca todos los nombres de directorio en `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de directorio en `path` empiecen por la letra "s".  
  
 La cadena ".." solo puede usarse en `searchPattern` si se especifica como parte de un nombre de directorio válido, como en el nombre del directorio "un.. "b". No se puede usar para mover hacia arriba de la jerarquía de directorios. Si no hay ningún archivo o directorios, o no hay archivos o directorios que coinciden con el `searchPattern` de cadena en el <xref:System.IO.DirectoryInfo>, este método devuelve una matriz vacía.  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.FileSystemInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 En el ejemplo siguiente se cuentan los archivos y directorios que coinciden con el patrón de búsqueda especificado.  
  
 [!code-csharp[DirInfo GetFileSysInfos2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetFileSysInfos2/CS/dirinfo getfilesysinfos2.cs#1)]
 [!code-vb[DirInfo GetFileSysInfos2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetFileSysInfos2/VB/dirinfo getfilesysinfos2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> contiene uno o varios caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer desde archivos y directorios y para tener acceso a la ruta de acceso. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.EnumerationOptions -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.SearchOption -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios y archivos.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir solo el directorio actual o todos los subdirectorios. El valor predeterminado es <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Recupera una matriz de objetos <see cref="T:System.IO.FileSystemInfo" /> que representan los archivos y subdirectorios que coinciden con los criterios de búsqueda especificados.</summary>
        <returns>Matriz de entradas del sistema de archivos que coinciden con los criterios de búsqueda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, la cadena "* t" busca todos los nombres terminan con la letra "t". ". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 Para los subdirectorios, el <xref:System.IO.FileSystemInfo> los objetos devueltos por este método se pueden convertir a la clase derivada <xref:System.IO.DirectoryInfo>. Use la <xref:System.IO.FileAttributes> valor devuelto por la <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType> propiedad para determinar si el <xref:System.IO.FileSystemInfo> representa un archivo o un directorio.  
  
 Este método rellena previamente los valores de las siguientes acciones <xref:System.IO.FileSystemInfo> propiedades:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> contiene uno o varios caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> no es un valor de <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : string -&gt; unit" Usage="directoryInfo.MoveTo destDirName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destDirName">Nombre y ruta de acceso a la que se va a mover este directorio. El destino no puede ser otro volumen de disco ni un directorio con el mismo nombre. Puede ser un directorio existente al que desee agregar este directorio como subdirectorio.</param>
        <summary>Mueve una instancia de <see cref="T:System.IO.DirectoryInfo" /> y su contenido a una nueva ruta de acceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método produce una <xref:System.IO.IOException> si, por ejemplo, intenta mover c:\mydir a c:\public, y c:\public ya existe. Debe especificar "c:\\\public\\\mydir" como el `destDirName` parámetro, o especificar un nuevo nombre de directorio, como "c:\\\newdir".  
  
 Este método permite mover un directorio a un directorio de sólo lectura. El atributo de lectura/escritura de los directorios no se ve afectado.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente se muestra cómo mover un directorio.  
  
 [!code-cpp[directoryinfomoveto#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfomoveto/CPP/directoryinfomoveto.cpp#1)]
 [!code-csharp[directoryinfomoveto#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfomoveto/CS/directoryinfomoveto.cs#1)]
 [!code-vb[directoryinfomoveto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfomoveto/VB/directoryinfomoveto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destDirName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="destDirName" /> es una cadena vacía ("").</exception>
        <exception cref="T:System.IO.IOException">Se ha intentado mover un directorio a otro volumen.  
  
O bien 
 <paramref name="destDirName" /> ya existe.  
  
O bien 
No tiene autorización para esta ruta de acceso.  
  
O bien 
El directorio que se está moviendo y el directorio de destino tienen el mismo nombre.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">No se puede encontrar el directorio de destino.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir archivos y directorios y para el acceso al directorio de destino. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.DirectoryInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de esta instancia de <see cref="T:System.IO.DirectoryInfo" />.</summary>
        <value>El nombre del directorio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esto <xref:System.IO.DirectoryInfo.Name%2A> propiedad devuelve solo el nombre del directorio, por ejemplo, "Bin". Para obtener la ruta de acceso completa, por ejemplo, "c:\public\Bin", use el <xref:System.IO.FileSystemInfo.FullName%2A> propiedad.  
  
 El <xref:System.IO.DirectoryInfo.Name%2A> propiedad de un <xref:System.IO.DirectoryInfo> no requiere ningún permiso (más allá del permiso de lectura en el directorio necesario construir el <xref:System.IO.DirectoryInfo.Exists%2A>) pero puede proporcionar el nombre del directorio. Out si es necesario para entregar un <xref:System.IO.DirectoryInfo> en un directorio protegido con un nombre seguro criptográficamente, cree un directorio ficticio para el uso del código de confianza.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra el nombre del elemento actual `DirectoryInfo` solo la instancia.  
  
 [!code-cpp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CS/source.cs#1)]
 [!code-vb[Classic DirectoryInfo.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemInfo.FullName" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Parent" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Parent { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el directorio principal de un subdirectorio especificado.</summary>
        <value>El directorio principal, o <see langword="null" /> si la ruta de acceso es null o si la ruta de acceso del archivo indica un directorio raíz (por ejemplo, "\\", "C:", o * "\\\server\share").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra que hace referencia al directorio principal de un directorio especificado.  
  
 [!code-cpp[directoryinfoparent#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfoparent/CPP/directoryinfoparent.cpp#1)]
 [!code-csharp[directoryinfoparent#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfoparent/CS/directoryinfoparent.cs#1)]
 [!code-vb[directoryinfoparent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfoparent/VB/directoryinfoparent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer desde archivos y directorios y para tener acceso a la ruta de acceso. Enumeraciones asociadas: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />, <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Root">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Root { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Root" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Root" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Root As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Root { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Root : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Root" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la parte de la raíz del directorio.</summary>
        <value>Un objeto que representa la raíz del directorio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra las ubicaciones de raíz para los directorios especificados.  
  
 [!code-csharp[directoryinforoot#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinforoot/CS/directoryinforoot2.cs#2)]
 [!code-vb[directoryinforoot#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinforoot/VB/directoryinforoot2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer desde archivos y directorios y para tener acceso a la ruta de acceso. Enumeraciones asociadas: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />, <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.SetAccessControl directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">Objeto que describe una entrada ACL que se aplica al directorio descrito por el parámetro <paramref name="path" />.</param>
        <summary>Aplica las entradas de la lista de control de acceso (ACL) descritas por un objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> al directorio descrito por el objeto <see cref="T:System.IO.DirectoryInfo" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una lista de control de acceso (ACL) describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo o directorio determinado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 El <xref:System.IO.DirectoryInfo.SetAccessControl%2A> método aplica las entradas ACL a un archivo que representa la lista ACL no heredada.  
  
> [!CAUTION]
>  Especifica la ACL para `directorySecurity` reemplaza la ACL existente para el directorio. Para agregar permisos para un usuario nuevo, use el <xref:System.IO.DirectoryInfo.GetAccessControl%2A> método para obtener la ACL existente y modificarlo.  
  
 El <xref:System.IO.DirectoryInfo.SetAccessControl%2A> método conserva solo <xref:System.Security.AccessControl.DirectorySecurity> objetos que se han modificado después de la creación de objetos.  Si un <xref:System.Security.AccessControl.DirectorySecurity> objeto no se ha modificado, no se conservarán en un archivo.  Por lo tanto, no es posible recuperar un <xref:System.Security.AccessControl.DirectorySecurity> desde un archivo de objeto y vuelva a aplicar el mismo objeto a otro archivo.  
  
 Para copiar información de la ACL de un archivo a otro:  
  
1.  Use la <xref:System.IO.DirectoryInfo.GetAccessControl%2A> método para recuperar el <xref:System.Security.AccessControl.DirectorySecurity> objeto desde el archivo de origen.  
  
2.  Cree un nuevo <xref:System.Security.AccessControl.DirectorySecurity> objeto para el archivo de destino.  
  
3.  Use la <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> o <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> método del origen de <xref:System.Security.AccessControl.DirectorySecurity> objeto para recuperar la información de la ACL.  
  
4.  Use la <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> o <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> método para copiar la información recuperada en el paso 3 en el destino <xref:System.Security.AccessControl.DirectorySecurity> objeto.  
  
5.  Establecer como destino <xref:System.Security.AccessControl.DirectorySecurity> objeto en el archivo de destino usando la <xref:System.IO.DirectoryInfo.SetAccessControl%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.DirectoryInfo.GetAccessControl%2A> y <xref:System.IO.DirectoryInfo.SetAccessControl%2A> métodos para agregar y, a continuación, quitar un acceso de control entrada de lista (ACL) de un directorio.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="directorySecurity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">No se pudo encontrar o modificar el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El proceso actual no tiene acceso para abrir el archivo.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Microsoft Windows 2000 o posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso enumerar la lista de control de acceso (ACL) para un directorio. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="directoryInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la ruta de acceso original que pasó el usuario.</summary>
        <returns>Ruta de acceso original pasada por el usuario.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
  </Members>
</Type>