<Type Name="File" FullName="System.IO.File">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="33ff20675af33b874a1f85321d5e07899d6d1ef4" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/13/2018" />
    <Meta Name="ms.locfileid" Value="35417282" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class File" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit File extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.File" />
  <TypeSignature Language="VB.NET" Value="Public Class File" />
  <TypeSignature Language="C++ CLI" Value="public ref class File abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona métodos estáticos para crear, copiar, eliminar, mover y abrir un solo archivo, y contribuye a la creación de objetos <see cref="T:System.IO.FileStream" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.File> clase para las operaciones típicas, como copiar, mover, cambiar el nombre, crear, abrir, eliminar y anexar a un único archivo a la vez. También puede usar el <xref:System.IO.File> clase para obtener y establecer atributos de archivo o <xref:System.DateTime> información relacionada con la creación, acceso y la escritura de un archivo. Si desea realizar operaciones en varios archivos, consulte <xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType> o <xref:System.IO.DirectoryInfo.GetFiles%2A?displayProperty=nameWithType>.  
  
 Muchas de las <xref:System.IO.File> métodos devuelven otros tipos de E/S al crear o abrir archivos. Puede utilizar estos otros tipos para manipular todavía más un archivo. Para obtener más información, vea específico <xref:System.IO.File> miembros como <xref:System.IO.File.OpenText%2A>, <xref:System.IO.File.CreateText%2A>, o <xref:System.IO.File.Create%2A>.  
  
 Dado que todos los <xref:System.IO.File> métodos son estáticos, puede que sea más eficaz usar un <xref:System.IO.File> método en lugar de su correspondiente <xref:System.IO.FileInfo> método de instancia, si desea realizar sólo una operación. Todos los <xref:System.IO.File> métodos requieren la ruta de acceso al archivo que está manipulando.  
  
 Los métodos estáticos de la <xref:System.IO.File> clase realizar comprobaciones de seguridad en todos los métodos. Si va a utilizar un objeto varias veces, considere la posibilidad de usar el método de instancia correspondiente de <xref:System.IO.FileInfo> en su lugar, dado que la comprobación de seguridad no siempre que sea necesario.  
  
 De forma predeterminada, se concede acceso completo de lectura/escritura a los nuevos archivos a todos los usuarios.  
  
 La tabla siguiente describen las enumeraciones que se utilizan para personalizar el comportamiento de diversos <xref:System.IO.File> métodos.  
  
|Enumeración|Descripción|  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|Especifica el acceso de lectura y escritura en un archivo.|  
|<xref:System.IO.FileShare>|Especifica el nivel de acceso permitido para un archivo que ya está en uso.|  
|<xref:System.IO.FileMode>|Especifica si se conserva o se sobrescribe el contenido de un archivo existente, y si las solicitudes para crear un archivo existente producirá una excepción.|  
  
> [!NOTE]
>  En los miembros que aceptan una ruta de acceso como una cadena de entrada, esa ruta de acceso debe ser correcto o se produce una excepción. Por ejemplo, si una ruta de acceso está completa pero comienza con un espacio, la ruta de acceso no se recorta en los métodos de la clase. Por lo tanto, la ruta de acceso es incorrecto y se produce una excepción. De forma similar, una ruta de acceso o una combinación de rutas de acceso no puede ser completo dos veces. Por ejemplo, "c:\temp c:\windows" también genera una excepción en la mayoría de los casos. Asegúrese de que las rutas de acceso sean correctos cuando se utilizan los métodos que aceptan una cadena de ruta de acceso.  
  
 En los miembros que aceptan una ruta de acceso, la ruta de acceso puede hacer referencia a un archivo o simplemente un directorio. La ruta de acceso especificada puede hacer referencia a una ruta de acceso relativa o una ruta de acceso de convención de nomenclatura universal (UNC, Universal Naming Convention) para un nombre de servidor y recurso compartido. Por ejemplo, todos los requisitos siguientes son las rutas de acceso aceptables:  
  
-   "c:\\\MyDir\\\MyFile.txt" en C# o "c:\MyDir\MyFile.txt" en Visual Basic.  
  
-   "c:\\\MyDir" en C# o "c:\MyDir" en Visual Basic.  
  
-   "MyDir\\\MySubdir" en C# o "Midir\misubdir" en Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" en C#, o "\\\MyServer\MyShare" en Visual Basic.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar la <xref:System.IO.File> clase para comprobar si existe un archivo, y según el resultado, cree un nuevo archivo y escribir en él, o abra el archivo existente y leer de él. Antes de ejecutar el código, cree un `c:\temp` carpeta.  
  
 [!code-cpp[File Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Class Example/CPP/file class example.cpp#1)]
 [!code-csharp[File Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Class Example/CS/file class example.cs#1)]
 [!code-vb[File Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Class Example/VB/file class example.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AppendAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anexa líneas a un archivo y, a continuación, cierra el archivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">El archivo al que se van a anexar líneas. Si el archivo no existe, se creará.</param>
        <param name="contents">Las líneas que se van a anexar al archivo.</param>
        <summary>Anexa líneas a un archivo y, a continuación, cierra el archivo. Si el archivo especificado no existe, este método crea un archivo, escribe las líneas especificadas en él y, a continuación, lo cierra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método crea el archivo si no existe, pero no crea nuevos directorios. Por lo tanto, el valor de la `path` parámetro debe contener directorios existentes.  
  
   
  
## Examples  
 En el ejemplo siguiente se escribe las líneas seleccionadas de un archivo de datos de ejemplo en un archivo y, a continuación, se anexa más líneas. El directorio denominado `temp` en la unidad C debe existir para que el ejemplo que se complete correctamente.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> o <paramref name="contents" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> no es válido (por ejemplo, el directorio no existe o está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo especificado por <paramref name="path" />.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no tiene permiso para escribir en el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> es un directorio.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">El archivo al que se van a anexar líneas. Si el archivo no existe, se creará.</param>
        <param name="contents">Las líneas que se van a anexar al archivo.</param>
        <param name="encoding">Codificación de caracteres que se utilizará.</param>
        <summary>Anexa líneas a un archivo usando la codificación especificada y, a continuación, lo cierra. Si el archivo especificado no existe, este método crea un archivo, escribe las líneas especificadas en él y, a continuación, lo cierra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método crea el archivo si no existe, pero no crea nuevos directorios. Por lo tanto, el valor de la `path` parámetro debe contener directorios existentes.  
  
 Puede usar este método para crear un archivo que contiene lo siguiente:  
  
-   Los resultados de un [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) consultar en las líneas de un archivo, que se obtienen mediante el uso de la <xref:System.IO.File.ReadLines%2A> método.  
  
-   El contenido de una colección que implementa un <xref:System.Collections.Generic.IEnumerable%601> de cadenas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />, <paramref name="contents" /> o <paramref name="encoding" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> no es válido (por ejemplo, el directorio no existe o está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo especificado por <paramref name="path" />.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> es un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anexa la cadena especificada al archivo y crea el archivo si aún no existe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo al que se va a anexar la cadena especificada.</param>
        <param name="contents">Cadena que se va a anexar al archivo.</param>
        <summary>Abre un archivo, le anexa la cadena especificada y, a continuación, cierra el archivo. Si el archivo no existe, este método crea un archivo, escribe la cadena especificada en él y, a continuación, lo cierra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dada una cadena y una ruta de acceso de archivo, este método abre el archivo especificado, anexa la cadena al final del archivo y, a continuación, cierra el archivo. El identificador de archivo se garantiza que se cierra por este método, incluso si se producen excepciones.  
  
 El método crea el archivo si no existe, pero no crea nuevos directorios. Por lo tanto, el valor de la `path` parámetro debe contener directorios existentes.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.File.AppendAllText%2A> método para agregar texto adicional al final de un archivo. En este ejemplo, se crea un archivo si aún no existe, y se le agrega texto. Sin embargo, en el directorio se denomina `temp` en la unidad C debe existir para que el ejemplo que se complete correctamente.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, el directorio no existe o está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso escribir en un archivo o directorio. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Archivo al que se va a anexar la cadena especificada.</param>
        <param name="contents">Cadena que se va a anexar al archivo.</param>
        <param name="encoding">Codificación de caracteres que se utilizará.</param>
        <summary>Anexa la cadena especificada al archivo y crea el archivo si aún no existe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dada una cadena y una ruta de acceso de archivo, este método abre el archivo especificado, anexa la cadena al final del archivo con la codificación especificada y, a continuación, cierra el archivo. El identificador de archivo se garantiza que se cierra por este método, incluso si se producen excepciones.  
  
 El método crea el archivo si no existe, pero no crea nuevos directorios. Por lo tanto, el valor de la `path` parámetro debe contener directorios existentes.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.File.AppendAllText%2A> método para agregar texto adicional al final de un archivo. En este ejemplo, se crea un archivo si aún no existe, y se le agrega texto. Sin embargo, en el directorio se denomina `temp` en la unidad C debe existir para que el ejemplo que se complete correctamente.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, el directorio no existe o está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso escribir en un archivo o directorio. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter AppendText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter AppendText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AppendText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ AppendText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso del archivo al que se va a anexar.</param>
        <summary>Crea un <see cref="T:System.IO.StreamWriter" /> que anexa texto codificado UTF-8 a un archivo existente o a un nuevo archivo si el archivo especificado no existe.</summary>
        <returns>Un escritor de secuencias que anexa el texto con codificación UTF-8 al archivo especificado o a un nuevo archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es equivalente a la <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> sobrecarga del constructor. Si el archivo especificado por `path` no existe, se crea. Si el archivo existe, las operaciones de escritura del <xref:System.IO.StreamWriter> anexar texto al archivo. Subprocesos adicionales tienen permiso para leer el archivo mientras está abierto.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se anexa texto a un archivo. El método crea un nuevo archivo si el archivo no existe. Sin embargo, en el directorio se denomina `temp` en la unidad C debe existir para que el ejemplo que se complete correctamente.  
  
 [!code-cpp[File_AppendText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File_AppendText/CPP/file_appendtext.cpp#1)]
 [!code-csharp[File_AppendText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File_AppendText/CS/file_appendtext.cs#1)]
 [!code-vb[File_AppendText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File_AppendText/VB/file_appendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, el directorio no existe o está en una unidad no asignada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para anexar al archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia un archivo existente en un archivo nuevo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Archivo que se va a copiar.</param>
        <param name="destFileName">Nombre del archivo de destino. No puede ser un directorio o un archivo existente.</param>
        <summary>Copia un archivo existente en un archivo nuevo. No se permite sobrescribir un archivo del mismo nombre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es equivalente a la <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29> sobrecarga del método con el `overwrite` parámetro establecido en `false`.  
  
 El `sourceFileName` y `destFileName` parámetros pueden especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea el <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType> método. Este método no admite caracteres comodín en los parámetros.  
  
 Los atributos del archivo original se conservan en el archivo copiado.  
  
   
  
## Examples  
 El siguiente ejemplo copia archivos en la carpeta de copia de seguridad de C:\archives\2008. Usa las dos sobrecargas de la <xref:System.IO.File.Copy%2A> método tal como se indica a continuación:  
  
-   En primer lugar utiliza la <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> sobrecarga del método para copiar archivos de texto (.txt). El código muestra que esta sobrecarga no permitir la sobrescritura de archivos que ya se han copiado.  
  
-   A continuación, utiliza el <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga del método para copiar imágenes (archivos .jpg). El código muestra que esta sobrecarga permite sobrescribir archivos que ya se han copiado.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> o <paramref name="destFileName" /> es una cadena de longitud cero, contiene sólo espacios en blanco, o contiene uno o varios caracteres no válidos, tal y como se definen en <see cref="F:System.IO.Path.InvalidPathChars" />.  -o bien- <paramref name="sourceFileName" /> o <paramref name="destFileName" /> especifica un directorio.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="sourceFileName" /> o <paramref name="destFileName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada en <paramref name="sourceFileName" /> o <paramref name="destFileName" /> no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="sourceFileName" />.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="destFileName" /> existe.  -o bien- Se ha producido un error de E/S.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> o <paramref name="destFileName" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer de <paramref name="sourceFileName" /> y escribir en <paramref name="destFileName" />. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName, bool overwrite);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Archivo que se va a copiar.</param>
        <param name="destFileName">Nombre del archivo de destino. No puede ser un directorio.</param>
        <param name="overwrite">Es <see langword="true" /> si se puede sobrescribir el archivo de destino; en caso contrario, es <see langword="false" />.</param>
        <summary>Copia un archivo existente en un archivo nuevo. Se permite sobrescribir un archivo del mismo nombre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `sourceFileName` y `destFileName` parámetros pueden especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Este método no admite caracteres comodín en los parámetros.  
  
 Los atributos del archivo original se conservan en el archivo copiado.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El siguiente ejemplo copia archivos en la carpeta de copia de seguridad de C:\archives\2008. Usa las dos sobrecargas de la <xref:System.IO.File.Copy%2A> método tal como se indica a continuación:  
  
-   En primer lugar utiliza la <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> sobrecarga del método para copiar archivos de texto (.txt). El código muestra que esta sobrecarga no permitir la sobrescritura de archivos que ya se han copiado.  
  
 A continuación, utiliza el <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga del método para copiar imágenes (archivos .jpg). El código muestra que esta sobrecarga permite sobrescribir archivos que ya se han copiado.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.  -o bien- <paramref name="destFileName" /> es de solo lectura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> o <paramref name="destFileName" /> es una cadena de longitud cero, contiene sólo espacios en blanco, o contiene uno o varios caracteres no válidos, tal y como se definen en <see cref="F:System.IO.Path.InvalidPathChars" />.  -o bien- <paramref name="sourceFileName" /> o <paramref name="destFileName" /> especifica un directorio.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="sourceFileName" /> o <paramref name="destFileName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada en <paramref name="sourceFileName" /> o <paramref name="destFileName" /> no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="sourceFileName" />.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="destFileName" /> existe y <paramref name="overwrite" /> es <see langword="false" />.  -o bien- Se ha producido un error de E/S.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> o <paramref name="destFileName" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer de <paramref name="sourceFileName" /> y escribir en <paramref name="destFileName" />. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un archivo en la ruta de acceso especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso y nombre del archivo que se va a crear.</param>
        <summary>Crea o sobrescribe un archivo en la ruta de acceso especificada.</summary>
        <returns>
          <see cref="T:System.IO.FileStream" /> que proporciona acceso de lectura y escritura al archivo especificado en <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileStream> objeto creado por este método tiene una restricción default <xref:System.IO.FileShare> valo <xref:System.IO.FileShare.None>; ningún otro proceso o código tener acceso al archivo creado hasta que se cierra el identificador de archivo original.  
  
 Este método es equivalente a la <xref:System.IO.File.Create%28System.String%2CSystem.Int32%29> sobrecarga del método con el tamaño de búfer predeterminado.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Si el archivo especificado no existe, se crea; Si existe y no es de solo lectura, se sobrescribe el contenido.  
  
 De forma predeterminada, se concede acceso completo de lectura/escritura a los nuevos archivos a todos los usuarios. El archivo se abrió con acceso de lectura/escritura y debe cerrarse para que pueda abrir otra aplicación.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un archivo en la ruta de acceso especificada, escribe información en el archivo y lee del archivo.  
  
 [!code-cpp[File Create1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create1/CPP/file create1.cpp#1)]
 [!code-csharp[File Create1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create1/CS/file create1.cs#1)]
 [!code-vb[File Create1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create1/VB/file create1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.  -o bien- <paramref name="path" /> ha especificado un archivo que es de solo lectura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al crear el archivo</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso para leer y escribir en el archivo descrito por el <paramref name="path" /> parámetro. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /> . Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Nombre del archivo.</param>
        <param name="bufferSize">Número de bytes almacenados en el búfer para leer y escribir en el archivo.</param>
        <summary>Crea o sobrescribe el archivo especificado.</summary>
        <returns>
          <see cref="T:System.IO.FileStream" /> con el tamaño de búfer especificado que proporciona acceso de lectura y escritura al archivo especificado en <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileStream> objeto creado por este método tiene una restricción default <xref:System.IO.FileShare> valo <xref:System.IO.FileShare.None>; ningún otro proceso o código tener acceso al archivo creado hasta que se cierra el identificador de archivo original.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Este método es equivalente a la <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> sobrecarga del constructor. Si el archivo especificado no existe, se crea; Si existe y no es de solo lectura, se sobrescribe el contenido.  
  
 De forma predeterminada, se concede acceso completo de lectura/escritura a los nuevos archivos a todos los usuarios. El archivo se abrió con acceso de lectura/escritura y debe cerrarse para que pueda abrir otra aplicación.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un archivo con el tamaño de búfer especificado.  
  
 [!code-cpp[File Create2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create2/CPP/file create2.cpp#1)]
 [!code-csharp[File Create2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create2/CS/file create2.cs#1)]
 [!code-vb[File Create2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create2/VB/file create2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.  -o bien- <paramref name="path" /> ha especificado un archivo que es de solo lectura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al crear el archivo</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso para leer y escribir en el archivo descrito por el <paramref name="path" /> parámetro. Acción de seguridad: petición. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer, options As FileOptions) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Nombre del archivo.</param>
        <param name="bufferSize">Número de bytes almacenados en el búfer para leer y escribir en el archivo.</param>
        <param name="options">Uno de los valores de <see cref="T:System.IO.FileOptions" /> que describe cómo crear o sobrescribir el archivo.</param>
        <summary>Crea o sobrescribe el archivo especificado, especificando un tamaño de búfer y un valor de <see cref="T:System.IO.FileOptions" /> que describe cómo crear o sobrescribir el archivo.</summary>
        <returns>Un archivo nuevo con el tamaño de búfer especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Este método es equivalente a la <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> sobrecarga del constructor. Si el archivo especificado no existe, se crea; Si existe y no es de solo lectura, se sobrescribe el contenido.  
  
 De forma predeterminada, se concede acceso completo de lectura/escritura a los nuevos archivos a todos los usuarios. El archivo se abrió con acceso de lectura/escritura y debe cerrarse para que pueda abrir otra aplicación.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.  -o bien- <paramref name="path" /> ha especificado un archivo que es de solo lectura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al crear el archivo</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso para leer y escribir en el archivo descrito por el <paramref name="path" /> parámetro. Acción de seguridad: petición. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Nombre del archivo.</param>
        <param name="bufferSize">Número de bytes almacenados en el búfer para leer y escribir en el archivo.</param>
        <param name="options">Uno de los valores de <see cref="T:System.IO.FileOptions" /> que describe cómo crear o sobrescribir el archivo.</param>
        <param name="fileSecurity">Uno de los valores de <see cref="T:System.Security.AccessControl.FileSecurity" /> que determina el control de acceso y la seguridad de auditoría del archivo.</param>
        <summary>Crea o sobrescribe el archivo especificado con el tamaño de búfer, las opciones de archivo y la seguridad de archivo especificados.</summary>
        <returns>Un archivo nuevo con el tamaño de búfer, las opciones de archivo y la seguridad de archivo especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Este método es equivalente a la <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> sobrecarga del constructor. Si el archivo especificado no existe, se crea; Si existe y no es de solo lectura, se sobrescribe el contenido.  
  
 De forma predeterminada, se concede acceso completo de lectura/escritura a los nuevos archivos a todos los usuarios. El archivo se abrió con acceso de lectura/escritura y debe cerrarse para que pueda abrir otra aplicación.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.  -o bien- <paramref name="path" /> ha especificado un archivo que es de solo lectura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al crear el archivo</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso para leer y escribir en el archivo descrito por el <paramref name="path" /> parámetro. Acción de seguridad: petición. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter CreateText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter CreateText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.CreateText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ CreateText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo que se va a abrir para escritura.</param>
        <summary>Crea o abre un archivo para escribir texto con codificación UTF-8. Si el archivo ya existe, se sobrescribe su contenido.</summary>
        <returns>
          <see cref="T:System.IO.StreamWriter" /> que escribe en el archivo especificado con codificación UTF-8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es equivalente a la <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> sobrecarga del constructor con la `append` parámetro establecido en `false`. Si el archivo especificado por `path` no existe, se crea. Si el archivo existe, se sobrescribe su contenido. Subprocesos adicionales tienen permiso para leer el archivo mientras está abierto.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un archivo para escribir y leer texto.  
  
 [!code-cpp[File CreateText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File CreateText/CPP/file createtext.cpp#1)]
 [!code-csharp[File CreateText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File CreateText/CS/file createtext.cs#1)]
 [!code-vb[File CreateText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File CreateText/VB/file createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public static void Decrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Decrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Decrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Decrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Decrypt(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso que describe el archivo que se va a descifrar.</param>
        <summary>Descifra un archivo cifrado por la cuenta actual mediante el método <see cref="M:System.IO.File.Encrypt(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.File.Decrypt%2A> método le permite descifrar un archivo cifrado mediante el <xref:System.IO.File.Encrypt%2A> método.  El <xref:System.IO.File.Decrypt%2A> método pueda descifrar sólo los archivos que se cifraron con la cuenta de usuario actual.  
  
 El <xref:System.IO.File.Decrypt%2A> método requiere acceso exclusivo al archivo que se va a descifrar y producirá una excepción si otro proceso está usando el archivo. Si el archivo no está cifrado, <xref:System.IO.File.Decrypt%2A> devolverá un valor distinto de cero, que indica una ejecución correcta.  
  
 Tanto el <xref:System.IO.File.Encrypt%2A> método y el <xref:System.IO.File.Decrypt%2A> método utiliza el proveedor de servicios criptográficos (CSP) instalado en el equipo y las claves de cifrado de archivo del proceso de llamada al método.  
  
 Debe ser el actual sistema de archivos con formato NTFS y el sistema operativo actual deben ser Windows NT o una versión posterior.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.IO.File.Encrypt%2A> método y <xref:System.IO.File.Decrypt%2A> método para cifrar y descifrar un archivo. El archivo debe existir para que funcione el ejemplo.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Se especificó una unidad no válida.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo descrito por el parámetro <paramref name="path" />.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo. Por ejemplo, el archivo cifrado ya está abierto.  -o bien- Esta operación no es compatible con la plataforma actual.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o una versión posterior.</exception>
        <exception cref="T:System.NotSupportedException">El sistema de archivos no es NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El parámetro <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- El parámetro <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso para leer y escribir en el archivo descrito por el <paramref name="path" /> parámetro. Acción de seguridad: petición. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nombre del archivo que se va a eliminar. No se admiten los caracteres comodín.</param>
        <summary>Elimina el archivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especifique un nombre de archivo con información de ruta de acceso relativa o absoluta para el `path` parámetro. Caracteres comodín no se pueden incluidos. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Si el archivo que se va a eliminar no existe, se inicia ninguna excepción.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se copia grupos de archivos en la carpeta de copia de seguridad de C:\archives\2008 y, a continuación, los elimina de la carpeta de origen.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">El archivo especificado está en uso.  -o bien- Hay un identificador abierto en el archivo y el sistema operativo es Windows XP o una versión anterior. Este identificador abierto puede obtenerse al enumerar directorios y archivos. Para obtener más información, vea [Cómo: Enumerar directorios y archivos](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.  -o bien- El archivo es un archivo ejecutable que está en uso.  -o bien- <paramref name="path" /> es un directorio.  -o bien- <paramref name="path" /> ha especificado un archivo de solo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para eliminar el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public static void Encrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Encrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Encrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Encrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Encrypt(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso que describe el archivo que se va a cifrar.</param>
        <summary>Cifra un archivo de forma que solo la cuenta utilizada para cifrarlo pueda descifrarlo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.File.Encrypt%2A> método le permite cifrar un archivo de forma que sólo la cuenta utilizada para llamar a este método puede descifrarlo. Use la <xref:System.IO.File.Decrypt%2A> método para descifrar un archivo cifrado por la <xref:System.IO.File.Encrypt%2A> método.  
  
 El <xref:System.IO.File.Encrypt%2A> método requiere acceso exclusivo al archivo que se cifra y se producirá un error si otro proceso está usando el archivo.  
  
 Tanto el <xref:System.IO.File.Encrypt%2A> método y el <xref:System.IO.File.Decrypt%2A> método utiliza el proveedor de servicios criptográficos (CSP) instalado en el equipo y las claves de cifrado de archivo del proceso de llamada al método.  
  
 Este método no está disponible en todas las versiones de Windows. Por ejemplo, no está disponible en ediciones para el hogar.  
  
 El sistema de archivos actual debe tener el formato NTFS.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.IO.File.Encrypt%2A> método y <xref:System.IO.File.Decrypt%2A> método para cifrar y descifrar un archivo. El archivo debe existir para que funcione el ejemplo.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Se especificó una unidad no válida.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo descrito por el parámetro <paramref name="path" />.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.  -o bien- Esta operación no es compatible con la plataforma actual.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o una versión posterior.</exception>
        <exception cref="T:System.NotSupportedException">El sistema de archivos no es NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El parámetro <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- El parámetro <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso para leer y escribir en el archivo descrito por el <paramref name="path" /> parámetro. Acción de seguridad: petición. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo que se va a comprobar.</param>
        <summary>Determina si existe el archivo especificado.</summary>
        <returns>
          <see langword="true" /> si el llamador tiene los permisos necesarios y <paramref name="path" /> contiene el nombre de un archivo existente; de lo contrario, <see langword="false" />. Este método también devuelve <see langword="false" /> si <paramref name="path" /> es <see langword="null" />, una ruta de acceso no válida o una cadena de longitud cero. Si el llamador no tiene permisos suficientes para leer el archivo especificado, no se produce ninguna excepción y el método devuelve <see langword="false" />, independientemente de la existencia de <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.File.Exists%2A> no se debe utilizar el método para la validación de ruta de acceso, simplemente, este método comprueba si el archivo especificado en `path` existe. Pasar una ruta de acceso no válida a <xref:System.IO.File.Exists%2A> devuelve `false`. Para comprobar si la ruta de acceso contiene caracteres no válidos, se puede llamar a la <xref:System.IO.Path.GetInvalidPathChars%2A> método para recuperar los caracteres que no son válidos para el sistema de archivos. También puede crear una expresión regular para comprobar si la ruta de acceso es válida para su entorno. Para obtener ejemplos de rutas de acceso aceptables, vea <xref:System.IO.File>.  
  
 Para comprobar si existe un directorio, consulte <xref:System.IO.Directory.Exists%2A?displayProperty=nameWithType>.  
  
 Tenga en cuenta que otro proceso pueda hacer algo con el archivo entre el momento en que se llama a la <xref:System.IO.File.Exists%2A> método y realizar otra operación en el archivo, como <xref:System.IO.File.Delete%2A>.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Si `path` describe un directorio, este método devuelve `false`. Los espacios finales se quitan de la `path` parámetro antes de determinar si el archivo existe.  
  
 El <xref:System.IO.File.Exists%2A> método `false` si se produce un error al intentar determinar si existe el archivo especificado. Esto puede ocurrir en las situaciones que provocan excepciones, como pasar un nombre de archivo con caracteres no válidos o hay demasiados caracteres, un disco con errores o que faltan, o si el llamador no tiene permiso para leer el archivo.  
  
   
  
## Examples  
 En el ejemplo siguiente se determina si existe un archivo.  
  
 [!code-csharp[File Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Exists/CS/program.cs#1)]
 [!code-vb[File Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Exists/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer desde el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="M:System.IO.Directory.Exists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula las entradas de la lista de control de acceso (ACL) para un archivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.FileInfo.GetAccessControl%2A> métodos para recuperar el acceso controlan las entradas de lista (ACL) para un archivo especificado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso a un archivo que contiene un objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que describe la información de la lista de control de acceso (ACL) del archivo.</param>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula las entradas de la lista de control de acceso (ACL) para un archivo especificado.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula las reglas de control de acceso correspondientes al archivo descrito por el parámetro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.File.GetAccessControl%2A> método para recuperar las entradas de lista (ACL) del control de acceso para un archivo.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo especificado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 En entornos de NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> se conceden al usuario si el usuario tiene <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> derechos en la carpeta principal. Para denegar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, denegar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> en el directorio principal.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.IO.File.GetAccessControl%2A> y <xref:System.IO.File.SetAccessControl%2A> métodos para agregar y, a continuación, quitar una acceso controlan la entrada de la lista (ACL) de un archivo.  Para ejecutar este ejemplo, debe proporcionar una cuenta de usuario o grupo válida.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">No se encuentra el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El parámetro <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- El parámetro <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso Leer la lista de control de acceso. Acción de seguridad: petición. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso a un archivo que contiene un objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que describe la información de la lista de control de acceso (ACL) del archivo.</param>
        <param name="includeSections">Uno de los valores <see cref="T:System.Security.AccessControl.AccessControlSections" /> que especifica el tipo de información de la lista de control de acceso (ACL) que se recibe.</param>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula el tipo especificado de las entradas de la lista de control de acceso (ACL) para un archivo determinado.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula las reglas de control de acceso correspondientes al archivo descrito por el parámetro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.File.GetAccessControl%2A> método para recuperar las entradas de lista (ACL) del control de acceso para un archivo.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo especificado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 En entornos de NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> se conceden al usuario si el usuario tiene <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> derechos en la carpeta principal. Para denegar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, denegar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> en el directorio principal.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">No se encuentra el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El parámetro <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- El parámetro <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso Leer la lista de control de acceso. Acción de seguridad: petición. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.IO.FileAttributes GetAttributes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.IO.FileAttributes GetAttributes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAttributes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (path As String) As FileAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileAttributes GetAttributes(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAttributes</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso al archivo.</param>
        <summary>Obtiene el <see cref="T:System.IO.FileAttributes" /> del archivo en la ruta de acceso.</summary>
        <returns>
          <see cref="T:System.IO.FileAttributes" /> del archivo en la ruta de acceso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la `GetAttributes` y `SetAttributes` métodos aplicando la `Archive` y `Hidden` atributos a un archivo.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> está vacío, solo contiene espacios en blanco o incluye caracteres no válidos.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> representa un archivo y no es válida, por ejemplo, es una ruta a una unidad no asignada, o no se encuentra el archivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> representa un directorio y no es válida, por ejemplo, es una ruta a una unidad no asignada, o no se encuentra el directorio.</exception>
        <exception cref="T:System.IO.IOException">Otro proceso está usando este archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer archivos. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo o directorio para el que se va a obtener información de fecha y hora de creación.</param>
        <summary>Devuelve la fecha y hora de creación del archivo o el directorio especificados.</summary>
        <returns>Estructura <see cref="T:System.DateTime" /> que se establece en la fecha y hora de creación para el archivo o directorio especificado. Este valor se expresa en hora local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no se pueden actualizar continuamente el sistema operativo.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Si el archivo se describe en el `path` parámetro no existe, este método devuelve 12:00 de la medianoche del 1 de enero de 1601 D.C. (E.C.) Hora Universal coordinada (UTC), se ajusta a la hora local.  
  
 Las unidades con formato NTFS pueden almacenar en caché información sobre un archivo, como el tiempo de creación de archivos, durante un breve período de tiempo. Como resultado, puede ser necesario establecer explícitamente la hora de creación de un archivo si va a sobrescribir o reemplazar un archivo existente.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra `GetCreationTime`.  
  
 [!code-vb[System.IO.File.GetCreationTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer desde el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo o directorio para el que se va a obtener información de fecha y hora de creación.</param>
        <summary>Devuelve la fecha y la hora de creación, en formato de hora universal coordinada (UTC), del archivo o directorio especificado.</summary>
        <returns>Estructura <see cref="T:System.DateTime" /> que se establece en la fecha y hora de creación para el archivo o directorio especificado. Este valor se expresa en hora UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no se pueden actualizar continuamente el sistema operativo.  
  
 Si el archivo se describe en el `path` parámetro no existe, este método devuelve 12:00 de la medianoche del 1 de enero de 1601 D.C. (E.C.) Hora de Universal coordinada (UTC).  
  
 Las unidades con formato NTFS pueden almacenar en caché información sobre un archivo, como el tiempo de creación de archivos, durante un breve período de tiempo. Como resultado, puede ser necesario establecer explícitamente la hora de creación de un archivo si va a sobrescribir o reemplazar un archivo existente.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.IO.File.GetCreationTimeUtc%2A> método.  
  
 [!code-vb[System.IO.File.GetCreationTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer desde el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo o directorio para el que se va a obtener información de fecha y hora de acceso.</param>
        <summary>Devuelve la fecha y hora a la que se produjo el último acceso al archivo o directorio especificado.</summary>
        <returns>Estructura <see cref="T:System.DateTime" /> que se establece en la fecha y hora a la que se produjo el último acceso al archivo o directorio especificado. Este valor se expresa en hora local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no se pueden actualizar continuamente el sistema operativo.  
  
 Si el archivo se describe en el `path` parámetro no existe, este método devuelve 12:00 de la medianoche del 1 de enero de 1601 D.C. (E.C.) Hora Universal coordinada (UTC), se ajusta a la hora local.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra `GetLastAccessTime`.  
  
 [!code-cpp[File GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastAccess/CPP/file getlastaccess.cpp#1)]
 [!code-csharp[File GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastAccess/CS/file getlastaccess.cs#1)]
 [!code-vb[File GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastAccess/VB/file getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer desde el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo o directorio para el que se va a obtener información de fecha y hora de acceso.</param>
        <summary>Devuelve la fecha y la hora, en formato de hora universal coordinada (UTC), a la que se produjo el último acceso al archivo o directorio especificado.</summary>
        <returns>Estructura <see cref="T:System.DateTime" /> que se establece en la fecha y hora a la que se produjo el último acceso al archivo o directorio especificado. Este valor se expresa en hora UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no se pueden actualizar continuamente el sistema operativo.  
  
 Si el archivo se describe en el `path` parámetro no existe, este método devuelve 12:00 de la medianoche del 1 de enero de 1601 D.C. (E.C.) Hora de Universal coordinada (UTC).  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer desde el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo o directorio para el que se va a obtener información de fecha y hora de escritura.</param>
        <summary>Devuelve la fecha y hora a la que se escribió por última vez en el archivo o directorio especificado.</summary>
        <returns>Estructura <see cref="T:System.DateTime" /> que se establece en la fecha y hora a la que se escribió por última vez en el archivo o directorio especificado. Este valor se expresa en hora local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no se pueden actualizar continuamente el sistema operativo. Cada sistema operativo administra la última hora de escritura según sus propias reglas. Para mejorar el rendimiento, un sistema operativo no se puede establecer el último valor de tiempo de escritura a la hora exacta de la última operación de escritura, pero puede establecerlo para una aproximación cercana a en su lugar.  
  
 Si el archivo se describe en el `path` parámetro no existe, este método devuelve 12:00 de la medianoche del 1 de enero de 1601 D.C. (E.C.) Hora Universal coordinada (UTC), se ajusta a la hora local.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra `GetLastWriteTime`.  
  
 [!code-cpp[File GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastWrite/CPP/file getlastwrite.cpp#1)]
 [!code-csharp[File GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastWrite/CS/file getlastwrite.cs#1)]
 [!code-vb[File GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastWrite/VB/file getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer desde el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo o directorio para el que se va a obtener información de fecha y hora de escritura.</param>
        <summary>Devuelve la fecha y la hora, en formato de hora universal coordinada (UTC), a la que se escribió por última vez en el archivo o directorio especificado.</summary>
        <returns>Estructura <see cref="T:System.DateTime" /> que se establece en la fecha y hora a la que se escribió por última vez en el archivo o directorio especificado. Este valor se expresa en hora UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no se pueden actualizar continuamente el sistema operativo. Cada sistema operativo administra la última hora de escritura según sus propias reglas. Para mejorar el rendimiento, un sistema operativo no se puede establecer el último valor de tiempo de escritura a la hora exacta de la última operación de escritura, pero puede establecerlo para una aproximación cercana a en su lugar.  
  
 Si el archivo se describe en el `path` parámetro no existe, este método devuelve 12:00 de la medianoche del 1 de enero de 1601 D.C. (E.C.) Hora de Universal coordinada (UTC).  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer desde el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nombre del archivo que se va a mover. Puede incluir una ruta de acceso relativa o absoluta.</param>
        <param name="destFileName">Nueva ruta de acceso y nombre del archivo.</param>
        <summary>Mueve un archivo especificado a una nueva ubicación, proporcionando la opción para indicar un nuevo nombre de archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método funciona en volúmenes de disco y no produce una excepción si el origen y destino son iguales. Tenga en cuenta que si se intenta reemplazar un archivo moviendo un archivo del mismo nombre en el directorio, obtendrá un <xref:System.IO.IOException>. No se puede usar el método Move para sobrescribir un archivo existente.  
  
 El `sourceFileName` y `destFileName` argumentos pueden incluir información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Si intenta mover un archivo a través de volúmenes de disco y que el archivo esté en uso, el archivo se copia al destino, pero no se elimina desde el origen.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se mueve un archivo.  
  
 [!code-cpp[File Move#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Move/CPP/file move.cpp#1)]
 [!code-csharp[File Move#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Move/CS/file move.cs#1)]
 [!code-vb[File Move#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Move/VB/file move.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El archivo de destino ya existe.  -o bien- No se encontró <paramref name="sourceFileName" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="sourceFileName" /> o <paramref name="destFileName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> o <paramref name="destFileName" /> es una cadena de longitud cero, contiene sólo espacios en blanco o contiene caracteres no válidos, tal y como se definen en <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada en <paramref name="sourceFileName" /> o <paramref name="destFileName" /> no es válida (por ejemplo, se encuentra en una unidad de red no asignada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> o <paramref name="destFileName" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer de <paramref name="sourceFileName" /> y escribir en <paramref name="destFileName" />. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre un <see cref="T:System.IO.FileStream" /> en la ruta de acceso especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Archivo que se va a abrir.</param>
        <param name="mode">Valor <see cref="T:System.IO.FileMode" /> que especifica si se crea un archivo si no existe uno y determina si el contenido de los archivos existentes se conserva o se sobrescribe.</param>
        <summary>Abre un elemento <see cref="T:System.IO.FileStream" /> en la ruta de acceso especificada con acceso de lectura y escritura y sin posibilidad de compartir.</summary>
        <returns>
          <see cref="T:System.IO.FileStream" /> abierto en el modo y ruta de acceso especificados, con acceso de lectura y escritura y de uso no compartido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un archivo temporal y se escribe texto en ella. En el ejemplo, a continuación, abre el archivo, con T:System.IO.FileMode.Open; es decir, si el archivo ya no existe, no se crearán.  
  
 [!code-cpp[File Open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open1/CPP/file open1.cpp#1)]
 [!code-csharp[File Open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open1/CS/file open1.cs#1)]
 [!code-vb[File Open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open1/VB/file open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.  -o bien- <paramref name="mode" /> es <see cref="F:System.IO.FileMode.Create" /> y el archivo especificado es un archivo oculto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> especifica un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado en <paramref name="path" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir en el archivo especificado. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Archivo que se va a abrir.</param>
        <param name="mode">Valor <see cref="T:System.IO.FileMode" /> que especifica si se crea un archivo si no existe uno y determina si el contenido de los archivos existentes se conserva o se sobrescribe.</param>
        <param name="access">Valor <see cref="T:System.IO.FileAccess" /> que especifica las operaciones que se pueden realizar en el archivo.</param>
        <summary>Abre un elemento <see cref="T:System.IO.FileStream" /> en la ruta de acceso especificada, con el modo y acceso especificados y sin posibilidad de compartir.</summary>
        <returns>
          <see cref="T:System.IO.FileStream" /> de uso no compartido que proporciona acceso al archivo especificado, con el modo y el acceso especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se abre un archivo con acceso de solo lectura.  
  
 [!code-cpp[file open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open2/CPP/file open2.cpp#1)]
 [!code-csharp[file open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open2/CS/file open2.cs#1)]
 [!code-vb[file open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open2/VB/file open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.  -o bien- <paramref name="access" /> ha especificado <see langword="Read" /> y <paramref name="mode" /> ha especificado <see langword="Create" />, <see langword="CreateNew" />, <see langword="Truncate" /> o <see langword="Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica un archivo de solo lectura y <paramref name="access" /> no es <see langword="Read" />.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.  -o bien- <paramref name="mode" /> es <see cref="F:System.IO.FileMode.Create" /> y el archivo especificado es un archivo oculto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> o <paramref name="access" /> especifica un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado en <paramref name="path" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir en el archivo especificado. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess, share As FileShare) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Archivo que se va a abrir.</param>
        <param name="mode">Valor <see cref="T:System.IO.FileMode" /> que especifica si se crea un archivo si no existe uno y determina si el contenido de los archivos existentes se conserva o se sobrescribe.</param>
        <param name="access">Valor <see cref="T:System.IO.FileAccess" /> que especifica las operaciones que se pueden realizar en el archivo.</param>
        <param name="share">Valor <see cref="T:System.IO.FileShare" /> que especifica el tipo de acceso que otros subprocesos tienen en este archivo.</param>
        <summary>Abre un <see cref="T:System.IO.FileStream" /> en la ruta de acceso especificada con el modo especificado, con acceso de lectura, escritura o ambos, y la opción de uso compartido especificada.</summary>
        <returns>
          <see cref="T:System.IO.FileStream" /> en la ruta de acceso especificada con el modo especificado, con acceso de lectura, escritura o ambos, y la opción de uso compartido especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se abre un archivo con acceso de solo lectura y no permiten el uso compartido de archivos.  
  
 [!code-cpp[file open3#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open3/CPP/file open3.cpp#1)]
 [!code-csharp[file open3#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open3/CS/file open3.cs#1)]
 [!code-vb[file open3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open3/VB/file open3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.  -o bien- <paramref name="access" /> ha especificado <see langword="Read" /> y <paramref name="mode" /> ha especificado <see langword="Create" />, <see langword="CreateNew" />, <see langword="Truncate" /> o <see langword="Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica un archivo de solo lectura y <paramref name="access" /> no es <see langword="Read" />.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.  -o bien- <paramref name="mode" /> es <see cref="F:System.IO.FileMode.Create" /> y el archivo especificado es un archivo oculto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> especifica un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado en <paramref name="path" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir en el archivo especificado. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenRead (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenRead(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenRead(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRead (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenRead(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo que se va a abrir para la lectura.</param>
        <summary>Abre un archivo existente para lectura.</summary>
        <returns>
          <see cref="T:System.IO.FileStream" /> de solo lectura en la ruta de acceso especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es equivalente a la <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> sobrecarga de constructor con un <xref:System.IO.FileMode> valo <xref:System.IO.FileMode.Open>, un <xref:System.IO.FileAccess> valo <xref:System.IO.FileAccess.Read> y un <xref:System.IO.FileShare> valor de <xref:System.IO.FileShare.Read>.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se abre un archivo para leerlo.  
  
 [!code-cpp[file openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenRead/CPP/file openread.cpp#1)]
 [!code-csharp[file openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenRead/CS/file openread.cs#1)]
 [!code-vb[file openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenRead/VB/file openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado en <paramref name="path" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer desde el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamReader OpenText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenText (path As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo que se va a abrir para la lectura.</param>
        <summary>Abre un archivo de texto existente con codificación UTF-8 para lectura.</summary>
        <returns>
          <see cref="T:System.IO.StreamReader" /> en la ruta de acceso especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es equivalente a la <xref:System.IO.StreamReader.%23ctor%28System.String%29> sobrecarga del constructor.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se abre un archivo de texto para su lectura.  
  
 [!code-cpp[file opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[file opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenText/CS/file opentext.cs#1)]
 [!code-vb[file opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado en <paramref name="path" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer desde el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenWrite (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenWrite(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenWrite(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenWrite (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenWrite(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo que se va a abrir para escritura.</param>
        <summary>Abre un archivo existente o crea un nuevo archivo para escribir en él.</summary>
        <returns>Objeto <see cref="T:System.IO.FileStream" /> no compartido en la ruta de acceso especificada con acceso <see cref="F:System.IO.FileAccess.Write" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es equivalente a la <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> sobrecarga de constructor con modo de archivo establecido en <xref:System.IO.FileMode.OpenOrCreate>, el acceso establecido en <xref:System.IO.FileAccess.Write>y el modo de uso compartido establecido en <xref:System.IO.FileShare.None>.  
  
 El <xref:System.IO.File.OpenWrite%2A> método abre un archivo si ya existe uno para la ruta de acceso de archivo, o crea un nuevo archivo si no existe. Para un archivo existente, no anexa el texto nuevo para el texto existente. En su lugar, sobrescriben los caracteres existentes con los nuevos caracteres. Si sobrescribe una cadena más larga (como "Esto es una prueba del método OpenWrite") con una cadena más corta (por ejemplo, "segunda ejecución"), el archivo contendrá una combinación de las cadenas ("segundo runtest del método OpenWrite").  
  
 El `path` parámetro puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, use el <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 El valor devuelto <xref:System.IO.FileStream> no admite la lectura. Para abrir un archivo para lectura y escritura, utilice <xref:System.IO.File.Open%2A>.

 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se abre un archivo para lectura y escritura.  
  
 [!code-cpp[file openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[file openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[file openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.  -o bien- <paramref name="path" /> ha especificado un archivo o un directorio de solo lectura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadAllBytes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (path As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo que se abre para la lectura.</param>
        <summary>Abre un archivo binario, lee su contenido, lo introduce en una matriz de bytes y, a continuación, cierra el archivo.</summary>
        <returns>Una matriz de bytes con el contenido del archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dada una ruta de acceso de archivo, este método abre el archivo, lee el contenido del archivo en una matriz de bytes y, a continuación, cierra el archivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado en <paramref name="path" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso leer de un archivo o directorio. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;byte[]&gt; ReadAllBytesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;unsigned int8[]&gt; ReadAllBytesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Byte[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre un archivo de texto, lee todas sus líneas, las introduce en una matriz de cadenas y, a continuación, cierra el archivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllLines (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo que se abre para la lectura.</param>
        <summary>Abre un archivo de texto, lee todas sus líneas y, a continuación, cierra el archivo.</summary>
        <returns>Una matriz de cadenas que contiene todas las líneas del archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método abre un archivo, lee todas sus líneas del archivo y, a continuación, agrega cada línea como un elemento de una matriz de cadenas. A continuación, cierra el archivo. Fuente de una línea se define como una secuencia de caracteres seguida de un retorno de carro ('\r'), un salto de línea ('\n') o un retorno de carro seguido inmediatamente por una línea. La cadena resultante no contiene el retorno de carro o avance de línea de terminación.  
  
 Este método intenta detectar automáticamente la codificación de un archivo basado en la presencia de marcas de orden de bytes. Formatos de codificación UTF-8 y UTF-32 (big-endian y little-endian) se pueden detectar.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.File.ReadAllLines%2A> método para mostrar el contenido de un archivo. En este ejemplo se crea un archivo, si aún no existe, y se le agrega texto.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado en <paramref name="path" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso leer de un archivo o directorio. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Archivo que se abre para la lectura.</param>
        <param name="encoding">Codificación aplicada al contenido del archivo.</param>
        <summary>Abre un archivo, lee todas sus líneas con la codificación especificada y, a continuación, cierra el archivo.</summary>
        <returns>Una matriz de cadenas que contiene todas las líneas del archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método abre un archivo, lee todas sus líneas del archivo y, a continuación, agrega cada línea como un elemento de una matriz de cadenas. A continuación, cierra el archivo. Fuente de una línea se define como una secuencia de caracteres seguida de un retorno de carro ('\r'), un salto de línea ('\n') o un retorno de carro seguido inmediatamente por una línea. La cadena resultante no contiene el retorno de carro o avance de línea de terminación.  
  
 Este método intenta detectar automáticamente la codificación de un archivo basado en la presencia de marcas de orden de bytes. Formatos de codificación UTF-8 y UTF-32 (big-endian y little-endian) se pueden detectar.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.File.ReadAllLines%2A> método para mostrar el contenido de un archivo. En este ejemplo se crea un archivo, si aún no existe, y se le agrega texto.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado en <paramref name="path" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso leer de un archivo o directorio. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre un archivo de texto, lee todas sus líneas, las introduce en una cadena y, a continuación, cierra el archivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo que se abre para la lectura.</param>
        <summary>Abre un archivo de texto, lee todas sus líneas y, a continuación, cierra el archivo.</summary>
        <returns>Cadena que contiene todas las líneas del archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método abre un archivo, lee todas sus líneas del archivo y, a continuación, agrega cada línea como un elemento de una cadena. A continuación, cierra el archivo. Fuente de una línea se define como una secuencia de caracteres seguida de un retorno de carro ('\r'), un salto de línea ('\n') o un retorno de carro seguido inmediatamente por una línea. La cadena resultante no contiene el retorno de carro o avance de línea de terminación.  
  
 Este método intenta detectar automáticamente la codificación de un archivo basado en la presencia de marcas de orden de bytes. Formatos de codificación UTF-8 y UTF-32 (big-endian y little-endian) se pueden detectar.  
  
 Use la <xref:System.IO.File.ReadAllText%28System.String%2CSystem.Text.Encoding%29> sobrecarga del método al leer archivos que pueden contener texto importado, porque no se reconoce caracteres no puede leer correctamente.  
  
 El identificador de archivo se garantiza que se cierra por este método, incluso si se producen excepciones.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.File.ReadAllText%2A> método para mostrar el contenido de un archivo. En este ejemplo se crea un archivo, si aún no existe, y se le agrega texto.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado en <paramref name="path" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso leer de un archivo o directorio. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Archivo que se abre para la lectura.</param>
        <param name="encoding">Codificación aplicada al contenido del archivo.</param>
        <summary>Abre un archivo, lee todas sus líneas con la codificación especificada y, a continuación, cierra el archivo.</summary>
        <returns>Cadena que contiene todas las líneas del archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método abre un archivo, lee todas sus líneas del archivo y, a continuación, agrega cada línea como un elemento de una cadena. A continuación, cierra el archivo. Fuente de una línea se define como una secuencia de caracteres seguida de un retorno de carro ('\r'), un salto de línea ('\n') o un retorno de carro seguido inmediatamente por una línea. La cadena resultante no contiene el retorno de carro o avance de línea de terminación.  
  
 Este método intenta detectar automáticamente la codificación de un archivo basado en la presencia de marcas de orden de bytes. Formatos de codificación UTF-8 y UTF-32 (big-endian y little-endian) se pueden detectar.  
  
 El identificador de archivo se garantiza que se cierra por este método, incluso si se producen excepciones.  
  
 Para usar la configuración de codificación como está configurado para su sistema operativo, especifique la <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> propiedad para el `encoding` parámetro.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.File.ReadAllText%2A> método para mostrar el contenido de un archivo. En este ejemplo se crea un archivo, si aún no existe, y se le agrega texto.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado en <paramref name="path" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso leer de un archivo o directorio. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lee las líneas de un archivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLines (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo que se va a leer.</param>
        <summary>Lee las líneas de un archivo.</summary>
        <returns>Todas las líneas del archivo o las líneas que son el resultado de una consulta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.File.ReadLines%2A> y <xref:System.IO.File.ReadAllLines%2A> métodos difieren como sigue: al usar <xref:System.IO.File.ReadLines%2A>, puede empezar a enumerar la colección de cadenas antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.File.ReadAllLines%2A>, debe esperar a que se devuelva la matriz entera de cadenas antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con archivos muy grandes, <xref:System.IO.File.ReadLines%2A> puede ser más eficaz.  
  
 Puede usar el <xref:System.IO.File.ReadLines%2A> método para hacer lo siguiente:  
  
-   Realizar [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) consultas en un archivo para obtener un conjunto filtrado de sus líneas.  
  
-   Escribir la colección devuelta de líneas en un archivo con el <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> método, o anexarlas a un archivo existente con el <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> método.  
  
-   Cree una instancia rellenada inmediatamente de una colección que toma una <xref:System.Collections.Generic.IEnumerable%601> colección de cadenas para su constructor, como un <xref:System.Collections.Generic.IList%601> o <xref:System.Collections.Generic.Queue%601>.  
  
 Este método usa <xref:System.Text.Encoding.UTF8%2A> para el valor de codificación.  
  
   
  
## Examples  
 En el ejemplo siguiente se lee las líneas de un archivo para buscar las líneas que contengan cadenas especificadas.  
  
 [!code-csharp[System.IO.File.ReadLines#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.readlines/cs/program.cs#1)]
 [!code-vb[System.IO.File.ReadLines#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.readlines/vb/program.vb#1)]  
  
 En el ejemplo siguiente se usa el <xref:System.IO.File.ReadLines%2A> método en una consulta LINQ que enumera todos los directorios para los archivos que tienen una extensión .txt, lee cada línea del archivo y muestra la línea si contiene la cadena "Microsoft".  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El valor de <paramref name="path" /> no es válido (por ejemplo, se encuentra en una unidad no asignada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo especificado por <paramref name="path" />.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> es un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Archivo que se va a leer.</param>
        <param name="encoding">Codificación aplicada al contenido del archivo.</param>
        <summary>Lee las líneas de un archivo que tiene una codificación especificada.</summary>
        <returns>Todas las líneas del archivo o las líneas que son el resultado de una consulta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para especificar una codificación para leer el archivo.  
  
 El <xref:System.IO.File.ReadLines%2A> y <xref:System.IO.File.ReadAllLines%2A> métodos difieren como sigue: al usar <xref:System.IO.File.ReadLines%2A>, puede empezar a enumerar la colección de cadenas antes de que se devuelve toda la colección. Cuando usas <xref:System.IO.File.ReadAllLines%2A>, debe esperar a que se devuelva la matriz entera de cadenas antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con archivos muy grandes, <xref:System.IO.File.ReadLines%2A> puede ser más eficaz.  
  
 Puede usar el <xref:System.IO.File.ReadLines%2A> método para hacer lo siguiente:  
  
-   Realizar [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) consultas en un archivo para obtener un conjunto filtrado de sus líneas.  
  
-   Escribir la colección devuelta de líneas en un archivo con el <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> método, o anexarlas a un archivo existente con el <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> método.  
  
-   Cree una instancia rellenada inmediatamente de una colección que toma una <xref:System.Collections.Generic.IEnumerable%601> colección de cadenas para su constructor, como un <xref:System.Collections.Generic.IList%601> o <xref:System.Collections.Generic.Queue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero, contiene solo espacios en blanco o contiene uno o varios de los caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El valor de <paramref name="path" /> no es válido (por ejemplo, se encuentra en una unidad no asignada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo especificado por <paramref name="path" />.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> es un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reemplaza el contenido de un archivo especificado con el contenido de otro archivo, elimina el archivo original y crea una copia de seguridad del archivo reemplazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.File.Replace%2A> métodos reemplazan el contenido de un archivo especificado con el contenido de otro archivo.  También crean una copia de seguridad del archivo que se reemplazó.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nombre de un archivo que reemplaza al especificado por <c>destinationFileName</c>.</param>
        <param name="destinationFileName">Nombre del archivo que se reemplaza.</param>
        <param name="destinationBackupFileName">Nombre del archivo de copia de seguridad.</param>
        <summary>Reemplaza el contenido de un archivo especificado con el contenido de otro archivo, elimina el archivo original y crea una copia de seguridad del archivo reemplazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.File.Replace%2A> método reemplaza el contenido de un archivo especificado con el contenido de otro archivo.  También crea una copia de seguridad del archivo que se reemplazó.  
  
 Si el `sourceFileName` y `destinationFileName` están en volúmenes diferentes, este método producirá una excepción. Si la `destinationBackupFileName` es en un volumen diferente del archivo de origen, se eliminará el archivo de copia de seguridad.  
  
 Pasar `null` a la `destinationBackupFileName` parámetro si no desea crear una copia de seguridad del archivo que se va a reemplazar.  

 Si el `destinationBackupFileName` ya existe se sobrescribirá con el contenido de la `destinationFileName` archivo.
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.IO.File.Replace%2A> método para reemplazar un archivo con otro y crear una copia de seguridad del archivo reemplazado.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso descrita por el parámetro <paramref name="destinationFileName" /> no tiene un formato válido.  -o bien- La ruta de acceso que describe el parámetro <paramref name="destinationBackupFileName" /> no tenía un formato válido.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="destinationFileName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Se especificó una unidad no válida.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo descrito por el objeto <see cref="T:System.IO.FileInfo" /> actual.  -o bien- No se encontró el archivo descrito por el parámetro <paramref name="destinationBackupFileName" />.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.  \- o bien - Los parámetros <paramref name="sourceFileName" /> y <paramref name="destinationFileName" /> especifican el mismo archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo es Windows 98 Second Edition o una versión anterior y el sistema de archivos no es NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El parámetro <paramref name="sourceFileName" /> o <paramref name="destinationFileName" /> especifica un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- Los parámetros de origen o destino especifican un directorio en lugar de un archivo.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso para escribir en el archivo descrito por el <paramref name="destinationBackupFileName" /> parámetro si se especifica uno. Acción de seguridad: petición. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String, ignoreMetadataErrors As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nombre de un archivo que reemplaza al especificado por <c>destinationFileName</c>.</param>
        <param name="destinationFileName">Nombre del archivo que se reemplaza.</param>
        <param name="destinationBackupFileName">Nombre del archivo de copia de seguridad.</param>
        <param name="ignoreMetadataErrors">Es <see langword="true" /> para omitir los errores de combinación (como atributos y listas de control de acceso (ACL)) del archivo reemplazado en el archivo de reemplazo; de lo contrario, es <see langword="false" />.</param>
        <summary>Reemplaza el contenido de un archivo especificado con el contenido de otro archivo, elimina el archivo original, crea una copia de seguridad del archivo reemplazado y, de forma opcional, omite los errores de fusión mediante combinación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.File.Replace%2A> método reemplaza el contenido de un archivo especificado con el contenido de otro archivo.  También crea una copia de seguridad del archivo que se reemplazó.  
  
 Si el `sourceFileName` y `destinationFileName` están en volúmenes diferentes, este método producirá una excepción. Si la `destinationBackupFileName` es en un volumen diferente del archivo de origen, se eliminará el archivo de copia de seguridad.  
  
 Pasar `null` a la `destinationBackupFileName` parámetro si no desea crear una copia de seguridad del archivo que se va a reemplazar.  

 Si el `destinationBackupFileName` ya existe se sobrescribirá con el contenido de la `destinationFileName` archivo.
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.IO.File.Replace%2A> método para reemplazar un archivo con otro y crear una copia de seguridad del archivo reemplazado.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso descrita por el parámetro <paramref name="destinationFileName" /> no tiene un formato válido.  -o bien- La ruta de acceso que describe el parámetro <paramref name="destinationBackupFileName" /> no tenía un formato válido.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="destinationFileName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Se especificó una unidad no válida.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo descrito por el objeto <see cref="T:System.IO.FileInfo" /> actual.  -o bien- No se encontró el archivo descrito por el parámetro <paramref name="destinationBackupFileName" />.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.  \- o bien - Los parámetros <paramref name="sourceFileName" /> y <paramref name="destinationFileName" /> especifican el mismo archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo es Windows 98 Second Edition o una versión anterior y el sistema de archivos no es NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El parámetro <paramref name="sourceFileName" /> o <paramref name="destinationFileName" /> especifica un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- Los parámetros de origen o destino especifican un directorio en lugar de un archivo.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso para escribir en el archivo descrito por el <paramref name="destinationBackupFileName" /> parámetro si se especifica uno. Acción de seguridad: petición. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAccessControl(System.String,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Archivo al que se van a agregar o del que se van a quitar entradas de la lista de control de acceso (ACL).</param>
        <param name="fileSecurity">Objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que describe una entrada de la ACL que se va a aplicar al archivo descrito por el parámetro <c>path</c>.</param>
        <summary>Aplica al archivo especificado las entradas de la lista de control de acceso (ACL) descritas por un objeto <see cref="T:System.Security.AccessControl.FileSecurity" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.File.SetAccessControl%2A> método aplica las entradas de lista (ACL) de control de acceso a un archivo que representa la lista ACL no heredada.  
  
> [!CAUTION]
>  La ACL especificada para el `fileSecurity` parámetro reemplaza la ACL existente para el archivo. Para agregar permisos para un usuario nuevo, use la <xref:System.IO.File.GetAccessControl%2A> método para obtener la lista ACL existente, modificarlo y, a continuación, usar <xref:System.IO.File.SetAccessControl%2A> para aplicarlo al archivo.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo especificado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 El <xref:System.IO.File.SetAccessControl%2A> método conserva solo <xref:System.Security.AccessControl.FileSecurity> objetos que se han modificado después de la creación de objetos.  Si un <xref:System.Security.AccessControl.FileSecurity> objeto no se ha modificado, no se conservarán en un archivo.  Por lo tanto, no es posible recuperar un <xref:System.Security.AccessControl.FileSecurity> de objetos de un archivo y vuelva a aplicar el mismo objeto a otro archivo.  
  
 Para copiar la información de la ACL de un archivo a otro:  
  
1.  Use la <xref:System.IO.File.GetAccessControl%2A> método para recuperar la <xref:System.Security.AccessControl.FileSecurity> objeto desde el archivo de origen.  
  
2.  Crear un nuevo <xref:System.Security.AccessControl.FileSecurity> objeto para el archivo de destino.  
  
3.  Use la <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> o <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> método del origen de <xref:System.Security.AccessControl.FileSecurity> objeto que se va a recuperar la información de la ACL.  
  
4.  Use la <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> o <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> método para copiar la información recuperada en el paso 3 en el destino <xref:System.Security.AccessControl.FileSecurity> objeto.  
  
5.  Establecer el destino <xref:System.Security.AccessControl.FileSecurity> objeto en el archivo de destino usando la <xref:System.IO.File.SetAccessControl%2A> método.  
  
 En entornos de NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> se conceden al usuario si el usuario tiene <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> derechos en la carpeta principal. Para denegar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, denegar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> en el directorio principal.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.IO.File.GetAccessControl%2A> y <xref:System.IO.File.SetAccessControl%2A> métodos para agregar y, a continuación, quitar una acceso controlan la entrada de la lista (ACL) de un archivo.  Para ejecutar este ejemplo, debe proporcionar una cuenta de usuario o grupo válida.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">No se encuentra el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El parámetro <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- El parámetro <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="fileSecurity" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso tener acceso al archivo. Acción de seguridad: petición. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.Change" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetAttributes">
      <MemberSignature Language="C#" Value="public static void SetAttributes (string path, System.IO.FileAttributes fileAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAttributes(string path, valuetype System.IO.FileAttributes fileAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAttributes(System.String,System.IO.FileAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttributes(System::String ^ path, System::IO::FileAttributes fileAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileAttributes" Type="System.IO.FileAttributes" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso al archivo.</param>
        <param name="fileAttributes">Combinación bit a bit de los valores de la enumeración.</param>
        <summary>Establece el <see cref="T:System.IO.FileAttributes" /> especificado del archivo en la ruta de acceso especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Ciertos atributos de archivo como <xref:System.IO.FileAttributes.Hidden> y <xref:System.IO.FileAttributes.ReadOnly>, se pueden combinar. Otros atributos, como <xref:System.IO.FileAttributes.Normal>, debe utilizarse solo.  
  
 No es posible cambiar el estado de compresión de un <xref:System.IO.File> objeto mediante el <xref:System.IO.File.SetAttributes%2A> método.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la `GetAttributes` y `SetAttributes` métodos aplicando la `Archive` y `Hidden` atributos a un archivo.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> está vacío, contiene solamente espacios en blanco, contiene caracteres no válidos o el atributo de archivo no es válido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para leer y escribir en archivos. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Archivo para el que se va a establecer información de fecha y hora de creación.</param>
        <param name="creationTime">
          <see cref="T:System.DateTime" /> que contiene el valor que se va a establecer para la fecha y la hora de creación de <c>path</c>. Este valor se expresa en hora local.</param>
        <summary>Establece la fecha y la hora a la que se creó el archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Las unidades con formato NTFS pueden almacenar en caché metainformación de archivos, como el tiempo de creación de archivos, durante un breve período de tiempo. Como resultado, puede ser necesario establecer explícitamente la hora de creación de un archivo si va a sobrescribir o reemplazar un archivo existente.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S al realizar la operación.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> especifica un valor fuera del intervalo de fechas, horas o ambas permitido para esta operación.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Archivo para el que se va a establecer información de fecha y hora de creación.</param>
        <param name="creationTimeUtc">
          <see cref="T:System.DateTime" /> que contiene el valor que se va a establecer para la fecha y la hora de creación de <c>path</c>. Este valor se expresa en hora UTC.</param>
        <summary>Establece la fecha y la hora, en formato de hora universal coordinada (UTC), a la que se creó el archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Las unidades con formato NTFS pueden almacenar en caché metainformación de archivos, como el tiempo de creación de archivos, durante un breve período de tiempo. Como resultado, puede ser necesario establecer explícitamente la hora de creación de un archivo si va a sobrescribir o reemplazar un archivo existente.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S al realizar la operación.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> especifica un valor fuera del intervalo de fechas, horas o ambas permitido para esta operación.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Archivo para el que se va a establecer información de fecha y hora de acceso.</param>
        <param name="lastAccessTime">
          <see cref="T:System.DateTime" /> que contiene el valor que se va a establecer para la fecha y la hora de último acceso de <c>path</c>. Este valor se expresa en hora local.</param>
        <summary>Establece la fecha y la hora en que se obtuvo acceso por última vez al archivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se comprueba el sistema de archivos para el archivo especificado, si es necesario, crear y, a continuación, se establece y obtiene la hora del último acceso.  
  
 [!code-cpp[file setlastaccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastAccess/CPP/file setlastaccess.cpp#1)]
 [!code-csharp[file setlastaccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastAccess/CS/file setlastaccess.cs#1)]
 [!code-vb[file setlastaccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastAccess/VB/file setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTime" /> especifica un valor fuera del intervalo de fechas u horas permitido para esta operación.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Archivo para el que se va a establecer información de fecha y hora de acceso.</param>
        <param name="lastAccessTimeUtc">
          <see cref="T:System.DateTime" /> que contiene el valor que se va a establecer para la fecha y la hora de último acceso de <c>path</c>. Este valor se expresa en hora UTC.</param>
        <summary>Establece la fecha y la hora, en formato de hora universal coordinada (UTC), a la que se produjo el último acceso al archivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTimeUtc" /> especifica un valor fuera del intervalo de fechas u horas permitido para esta operación.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Archivo para el que se va a establecer información de fecha y hora.</param>
        <param name="lastWriteTime">
          <see cref="T:System.DateTime" /> que contiene el valor que se va a establecer para la fecha y la hora de última escritura de <c>path</c>. Este valor se expresa en hora local.</param>
        <summary>Establece la fecha y la hora en que escribió por última vez en el archivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se comprueba el sistema de archivos para el archivo especificado y crea el archivo si es necesario y, a continuación, se establece y obtiene la última hora de escritura del archivo.  
  
 [!code-cpp[file setlastwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastWrite/CPP/file setlastwrite.cpp#1)]
 [!code-csharp[file setlastwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastWrite/CS/file setlastwrite.cs#1)]
 [!code-vb[file setlastwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastWrite/VB/file setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTime" /> especifica un valor fuera del intervalo de fechas u horas permitido para esta operación.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Archivo para el que se va a establecer información de fecha y hora.</param>
        <param name="lastWriteTimeUtc">
          <see cref="T:System.DateTime" /> que contiene el valor que se va a establecer para la fecha y la hora de última escritura de <c>path</c>. Este valor se expresa en hora UTC.</param>
        <summary>Establece la fecha y la hora, en formato de hora universal coordinada (UTC), a la que se escribió por última vez en el archivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTimeUtc" /> especifica un valor fuera del intervalo de fechas u horas permitido para esta operación.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string path, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllBytes(string path, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytes(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (path As String, bytes As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ path, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="path">Archivo en el que se va a escribir.</param>
        <param name="bytes">Bytes que se van a escribir en el archivo.</param>
        <summary>Crea un archivo nuevo, escribe en él la matriz de bytes especificada y, a continuación, lo cierra. Si el archivo de destino ya existe, se sobrescribe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dada una matriz de bytes y una ruta de acceso de archivo, este método abre el archivo especificado, escribe el contenido de la matriz de bytes en el archivo y, a continuación, cierra el archivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" /> o la matriz de bytes está vacía.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso escribir en un archivo o directorio. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllBytesAsync (string path, byte[] bytes, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllBytesAsync(string path, unsigned int8[] bytes, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytesAsync(System.String,System.Byte[],System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un archivo nuevo, escribe una o varias cadenas en él y lo cierra.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">Archivo en el que se va a escribir.</param>
        <param name="contents">Líneas que se van a escribir en el archivo.</param>
        <summary>Crea un archivo nuevo, escribe una colección de cadenas en él y lo cierra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento predeterminado de la <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método consiste en escribir datos utilizando la codificación UTF-8 sin una marca de orden de bytes (BOM). Si es necesario incluir un identificador de UTF-8, como una marca de orden de byte al comienzo de un archivo, utilice la <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29> sobrecarga del método con <xref:System.Text.Encoding.UTF8%2A> codificación.  
  
 Si el archivo de destino ya existe, se sobrescribe.  
  
 Puede utilizar este método para crear el contenido de una clase de colección que toma una <xref:System.Collections.Generic.IEnumerable%601> en su constructor, como un <xref:System.Collections.Generic.List%601.%23ctor%2A>, <xref:System.Collections.Generic.HashSet%601.%23ctor%2A>, o un <xref:System.Collections.Generic.SortedSet%601.%23ctor%2A> clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se escribe las líneas seleccionadas de un archivo de datos de ejemplo en un archivo.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> o <paramref name="contents" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El valor de <paramref name="path" /> no es válido (por ejemplo, se encuentra en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> es un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="path">Archivo en el que se va a escribir.</param>
        <param name="contents">Matriz de cadenas que se va a escribir en el archivo.</param>
        <summary>Crea un archivo nuevo, escribe en él la matriz de cadenas especificada y, a continuación, lo cierra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el archivo de destino ya existe, se sobrescribe.  
  
 El comportamiento predeterminado de la <xref:System.IO.File.WriteAllLines%2A> método consiste en escribir datos con codificación UTF-8 sin una marca de orden de bytes (BOM). Si es necesario incluir un identificador de UTF-8, como una marca de orden de byte al comienzo de un archivo, utilice la <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.String%5B%5D%2CSystem.Text.Encoding%29> sobrecarga del método con <xref:System.Text.Encoding.UTF8%2A> codificación.  
  
 Dada una matriz de cadenas y una ruta de acceso de archivo, este método abre el archivo especificado, escribe la matriz de cadenas en el archivo y, a continuación, cierra el archivo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.File.WriteAllLines%2A> método para escribir texto en un archivo. En este ejemplo se crea un archivo, si aún no existe, y se le agrega texto.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> o <paramref name="contents" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso escribir en un archivo o directorio. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Archivo en el que se va a escribir.</param>
        <param name="contents">Líneas que se van a escribir en el archivo.</param>
        <param name="encoding">Codificación de caracteres que se utilizará.</param>
        <summary>Crea un archivo nuevo usando la codificación especificada, escribe en él la colección de cadenas especificada y, a continuación, lo cierra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el archivo de destino ya existe, se sobrescribe.  
  
 Puede usar este método para crear un archivo que contiene lo siguiente:  
  
-   Los resultados de un [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) consultar en las líneas de un archivo, que se obtienen mediante el uso de la <xref:System.IO.File.ReadLines%2A> método.  
  
-   El contenido de una colección que implementa un <xref:System.Collections.Generic.IEnumerable%601> de cadenas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />, <paramref name="contents" /> o <paramref name="encoding" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El valor de <paramref name="path" /> no es válido (por ejemplo, se encuentra en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> es un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[],System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Archivo en el que se va a escribir.</param>
        <param name="contents">Matriz de cadenas que se va a escribir en el archivo.</param>
        <param name="encoding">Objeto <see cref="T:System.Text.Encoding" /> que representa la codificación de caracteres aplicada a la matriz de cadenas.</param>
        <summary>Crea un archivo nuevo, escribe en él la matriz de cadenas especificada usando la codificación especificada y, a continuación, lo cierra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el archivo de destino ya existe, se sobrescribe.  
  
 Dada una matriz de cadenas y una ruta de acceso de archivo, este método abre el archivo especificado, escribe la matriz de cadenas en el archivo con la codificación especificada y, a continuación, cierra el archivo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.File.WriteAllLines%2A> método para escribir texto en un archivo. En este ejemplo se crea un archivo, si aún no existe, y se le agrega texto.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> o <paramref name="contents" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso escribir en un archivo o directorio. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un archivo nuevo, escribe el contenido en el archivo y, a continuación, lo cierra. Si el archivo de destino ya existe, se sobrescribe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo en el que se va a escribir.</param>
        <param name="contents">Cadena que se va a escribir en el archivo.</param>
        <summary>Crea un archivo nuevo, escribe la cadena especificada en él y, a continuación, lo cierra. Si el archivo de destino ya existe, se sobrescribe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa UTF-8 codificación sin una marca de orden de bytes (BOM), por lo que usar el <xref:System.Text.Encoding.GetPreamble%2A> método devolverá una matriz de bytes vacía. Si es necesario incluir un identificador de UTF-8, como una marca de orden de byte al comienzo de un archivo, utilice la <xref:System.IO.File.WriteAllText%28System.String%2CSystem.String%2CSystem.Text.Encoding%29> sobrecarga del método con <xref:System.Text.Encoding.UTF8%2A> codificación.  
  
 Dada una cadena y una ruta de acceso de archivo, este método abre el archivo especificado, escribe la cadena en el archivo y, a continuación, cierra el archivo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.File.WriteAllText%2A> método para escribir texto en un archivo. En este ejemplo se crea un archivo, si aún no existe, y se le agrega texto.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" /> o <paramref name="contents" /> está vacío.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso escribir en un archivo o directorio. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Archivo en el que se va a escribir.</param>
        <param name="contents">Cadena que se va a escribir en el archivo.</param>
        <param name="encoding">La codificación que se aplica a la cadena.</param>
        <summary>Crea un archivo nuevo, escribe en él la cadena especificada con la codificación especificada y, a continuación, lo cierra. Si el archivo de destino ya existe, se sobrescribe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dada una cadena y una ruta de acceso de archivo, este método abre el archivo especificado, escribe la cadena en el archivo mediante la codificación especificada y, a continuación, cierra el archivo. El identificador de archivo se garantiza que se cierra por este método, incluso si se producen excepciones.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.IO.File.WriteAllText%2A> método para escribir texto en un archivo. En este ejemplo se crea un archivo, si aún no existe, y se le agrega texto.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos definidos por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" /> o <paramref name="contents" /> está vacío.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificó un archivo que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- <paramref name="path" /> ha especificado un directorio.  -o bien- El autor de llamada no dispone del permiso requerido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso escribir en un archivo o directorio. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>