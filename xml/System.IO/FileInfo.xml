<Type Name="FileInfo" FullName="System.IO.FileInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="02b15f53b39b1bf9a9c371680550a7121690bdf9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36484072" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit FileInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FileInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileInfo sealed : System::IO::FileSystemInfo" />
  <TypeSignature Language="F#" Value="type FileInfo = class&#xA;    inherit FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona propiedades y métodos de instancia para crear, copiar, eliminar, mover y abrir archivos y contribuye a la creación de objetos <see cref="T:System.IO.FileStream" />. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.FileInfo> clase para las operaciones típicas, como copiar, mover, cambiar el nombre, crear, abrir, eliminar y anexar texto a archivos.  
  
 Si va a realizar varias operaciones en el mismo archivo, puede ser más eficaz utilizar <xref:System.IO.FileInfo> instancia métodos en lugar de los correspondientes métodos estáticos de la <xref:System.IO.File> de la clase, ya no siempre será necesario realizar una comprobación de seguridad.  
  
 Muchas de las <xref:System.IO.FileInfo> métodos devuelven otros tipos de E/S al crear o abrir archivos. Puede utilizar estos otros tipos para manipular todavía más un archivo. Para obtener más información, vea específico <xref:System.IO.FileInfo> miembros como <xref:System.IO.FileInfo.Open%2A>, <xref:System.IO.FileInfo.OpenRead%2A>, <xref:System.IO.FileInfo.OpenText%2A>, <xref:System.IO.FileInfo.CreateText%2A>, o <xref:System.IO.FileInfo.Create%2A>.  
  
 De forma predeterminada, se concede acceso completo de lectura/escritura a los nuevos archivos a todos los usuarios.  
  
 La tabla siguiente describen las enumeraciones que se utilizan para personalizar el comportamiento de diversos <xref:System.IO.FileInfo> métodos.  
  
|Enumeración|Descripción|  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|Especifica el acceso de lectura y escritura en un archivo.|  
|<xref:System.IO.FileShare>|Especifica el nivel de acceso permitido para un archivo que ya está en uso.|  
|<xref:System.IO.FileMode>|Especifica si se conserva o se sobrescribe el contenido de un archivo existente, y si las solicitudes para crear un archivo existente producirá una excepción.|  
  
> [!NOTE]
>  En los miembros que aceptan una ruta de acceso como una cadena de entrada, esa ruta de acceso debe ser correcto o se produce una excepción. Por ejemplo, si una ruta de acceso está completa pero comienza con un espacio, la ruta de acceso no se recorta en los métodos de la clase. Por lo tanto, la ruta de acceso es incorrecto y se produce una excepción. De forma similar, una ruta de acceso o una combinación de rutas de acceso no puede ser completo dos veces. Por ejemplo, "c:\temp c:\windows" también genera una excepción en la mayoría de los casos. Asegúrese de que las rutas de acceso sean correctos cuando se utilizan los métodos que aceptan una cadena de ruta de acceso.  
  
 En los miembros que aceptan una ruta de acceso, la ruta de acceso puede hacer referencia a un archivo o simplemente un directorio. La ruta de acceso especificada puede hacer referencia a una ruta de acceso relativa o una ruta de acceso de convención de nomenclatura universal (UNC, Universal Naming Convention) para un nombre de servidor y recurso compartido. Por ejemplo, todos los requisitos siguientes son las rutas de acceso aceptables:  
  
-   "c:\\\MyDir\\\MyFile.txt" en C# o "c:\MyDir\MyFile.txt" en Visual Basic.  
  
-   "c:\\\MyDir" en C# o "c:\MyDir" en Visual Basic.  
  
-   "MyDir\\\MySubdir" en C# o "Midir\misubdir" en Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" en C#, o "\\\MyServer\MyShare" en Visual Basic.  
  
 La <xref:System.IO.FileInfo> clase proporciona las siguientes propiedades que permiten recuperar información sobre un archivo. Para obtener un ejemplo de cómo usar cada propiedad, vea las páginas de propiedades.  
  
-   El <xref:System.IO.FileInfo.Directory%2A> propiedad recupera un objeto que representa el directorio principal de un archivo.  
  
-   El <xref:System.IO.FileInfo.DirectoryName%2A> propiedad recupera la ruta de acceso completa del directorio principal de un archivo.  
  
-   El <xref:System.IO.FileInfo.Exists%2A> propiedad comprueba la presencia de un archivo de poder trabajar con él.  
  
-   El <xref:System.IO.FileInfo.IsReadOnly%2A> propiedad recupera o establece un valor que especifica si se puede modificar un archivo.  
  
-   El <xref:System.IO.FileInfo.Length%2A> recupera el tamaño de un archivo.  
  
-   El <xref:System.IO.FileInfo.Name%2A> recupera el nombre de un archivo.  
  
   
  
## Examples  
 El ejemplo siguiente muestra algunos de los miembros principales de la `FileInfo` clase.  
  
 Cuando primero se recuperen las propiedades, <xref:System.IO.FileInfo> llamadas el <xref:System.IO.FileSystemInfo.Refresh%2A> método y las memorias caché la información sobre el archivo. En las llamadas posteriores, debe llamar a <xref:System.IO.FileSystemInfo.Refresh%2A> para obtener la última copia de la información.  
  
 [!code-cpp[FInfo Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Class/CPP/finfo class.cpp#1)]
 [!code-csharp[FInfo Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Class/CS/finfo class.cs#1)]
 [!code-vb[FInfo Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Class/VB/finfo class.vb#1)]  
  
 Este ejemplo produce un resultado similar al siguiente.  
  
```  
Hello  
And  
Welcome  
C:\Users\userName\AppData\Local\Temp\tmp70AB.tmp was copied to C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp.  
C:\Users\userName\AppData\Local\Temp\tmp70CB.tmp was successfully deleted.  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.DriveInfo" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileInfo (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileInfo(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.IO.FileInfo : string -&gt; System.IO.FileInfo" Usage="new System.IO.FileInfo fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">El nombre completo del nuevo archivo o el nombre de archivo relativo. No finalice la ruta de acceso con el carácter separador de directorios.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileInfo" />, que actúa como contenedor de una ruta de archivos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede especificar el nombre completo o el nombre de archivo relativa, pero la comprobación de seguridad Obtiene el nombre completo.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza este constructor para crear dos archivos, que se escriben, leer, copiar y eliminar, a continuación.  
  
 [!code-cpp[finfo ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Ctor/CPP/finfo ctor.cpp#1)]
 [!code-csharp[finfo ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Ctor/CS/finfo ctor.cs#1)]
 [!code-vb[finfo ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Ctor/VB/finfo ctor.vb#1)]  
  
 En el ejemplo siguiente se abre un archivo existente o se crea un archivo, se anexa texto al archivo y muestra los resultados.  
  
 [!code-cpp[fileinfomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfomain/CPP/fileinfomain.cpp#1)]
 [!code-csharp[fileinfomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfomain/CS/fileinfomain.cs#1)]
 [!code-vb[fileinfomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfomain/VB/fileinfomain.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">El nombre de archivo está vacío, solo contiene espacios en blanco o incluye caracteres no válidos.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Acceso a <paramref name="fileName" /> denegado.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="fileName" /> contiene un carácter de dos puntos (:) dentro de la cadena.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer archivos. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter AppendText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamWriter AppendText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.AppendText" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendText () As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ AppendText();" />
      <MemberSignature Language="F#" Value="member this.AppendText : unit -&gt; System.IO.StreamWriter" Usage="fileInfo.AppendText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un <see cref="T:System.IO.StreamWriter" /> que agrega texto al archivo representado por esta instancia de <see cref="T:System.IO.FileInfo" />.</summary>
        <returns>Un nuevo objeto <see langword="StreamWriter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se anexa texto a un archivo y lee del archivo.  
  
 [!code-cpp[finfo appendtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo AppendText/CPP/finfo appendtext.cpp#1)]
 [!code-csharp[finfo appendtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo AppendText/CS/finfo appendtext.cs#1)]
 [!code-vb[finfo appendtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo AppendText/VB/finfo appendtext.vb#1)]  
  
 En el ejemplo siguiente se muestra cómo anexar texto al final de un archivo y también muestra el resultado de la operación de anexado en la consola. La primera vez que se llama a esta rutina, se crea el archivo si no existe. Después de eso, se anexa el texto especificado en el archivo.  
  
 [!code-cpp[fileinfoappendtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoappendtext/CPP/fileinfoappendtext.cpp#1)]
 [!code-csharp[fileinfoappendtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoappendtext/CS/fileinfoappendtext.cs#1)]
 [!code-vb[fileinfoappendtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoappendtext/VB/fileinfoappendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y anexar texto a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia un archivo existente en un archivo nuevo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo CopyTo (string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo CopyTo(string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CopyTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destFileName As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ CopyTo(System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : string -&gt; System.IO.FileInfo" Usage="fileInfo.CopyTo destFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destFileName">El nombre del nuevo archivo destino de la copia.</param>
        <summary>Copia un archivo existente en un archivo nuevo, impidiendo que se sobrescriba el archivo existente.</summary>
        <returns>Nuevo archivo con una ruta de acceso completa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.FileInfo.CopyTo%2A> método para permitir que se sobrescriba un archivo existente.  
  
> [!CAUTION]
>  Siempre que sea posible, evite usar nombres cortos de archivo (por ejemplo, XXXXXX~1.XXX) con este método. Si dispone de dos archivos cortos equivalentes nombres de archivo, a continuación, este método puede producirá un error y generar una excepción o dar lugar a un comportamiento no deseado  
  
   
  
## Examples  
 El ejemplo siguiente muestra ambas sobrecargas de la `CopyTo` método.  
  
 [!code-cpp[finfo copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CopyTo2/CPP/finfo copyto2.cpp#1)]
 [!code-csharp[finfo copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CopyTo2/CS/program.cs#1)]
 [!code-vb[finfo copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CopyTo2/VB/program.vb#1)]  
  
 En el ejemplo siguiente se muestra cómo copiar un archivo a otro archivo, producir una excepción si el archivo de destino ya existe.  
  
 [!code-cpp[FileInfoCopyTo1#1](~/samples/snippets/cpp/VS_Snippets_CLR/FileInfoCopyTo1/CPP/fileinfocopyto1.cpp#1)]
 [!code-csharp[FileInfoCopyTo1#1](~/samples/snippets/csharp/VS_Snippets_CLR/FileInfoCopyTo1/CS/fileinfocopyto1.cs#1)]
 [!code-vb[FileInfoCopyTo1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FileInfoCopyTo1/VB/fileinfocopyto1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> está vacío, solo contiene espacios en blanco o incluye caracteres no válidos.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error o el archivo de destino ya existe.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Se pasa una ruta de acceso a directorio o se mueve el archivo a una unidad diferente.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio especificado en <paramref name="destFileName" /> no existe.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="destFileName" /> contiene dos puntos (:) dentro de la cadena pero no especifica el volumen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir en archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo CopyTo (string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo CopyTo(string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CopyTo(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destFileName As String, overwrite As Boolean) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ CopyTo(System::String ^ destFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : string * bool -&gt; System.IO.FileInfo" Usage="fileInfo.CopyTo (destFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destFileName">El nombre del nuevo archivo destino de la copia.</param>
        <param name="overwrite">
          <see langword="true" /> si se permite que se sobrescriba el archivo existente; en caso contrario, <see langword="false" />.</param>
        <summary>Copia un archivo existente en un archivo nuevo, permitiendo que se sobrescriba el archivo existente.</summary>
        <returns>Un nuevo archivo, o una copia sobrescrita de un archivo existente si <paramref name="overwrite" /> es <see langword="true" />. Si existe el archivo y <paramref name="overwrite" /> es <see langword="false" />, se produce una excepción <see cref="T:System.IO.IOException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para permitir o impedir que se sobrescriba un archivo existente. Use la <xref:System.IO.FileInfo.CopyTo%2A> método para impedir que se sobrescriba un archivo existente de forma predeterminada.  
  
> [!CAUTION]
>  Siempre que sea posible, evite usar nombres cortos de archivo (por ejemplo, XXXXXX~1.XXX) con este método. Si dispone de dos archivos cortos equivalentes nombres de archivo, a continuación, este método puede producirá un error y generar una excepción o dar lugar a un comportamiento no deseado  
  
   
  
## Examples  
 El ejemplo siguiente muestra ambas sobrecargas de la `CopyTo` método.  
  
 [!code-cpp[finfo copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CopyTo2/CPP/finfo copyto2.cpp#1)]
 [!code-csharp[finfo copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CopyTo2/CS/program.cs#1)]
 [!code-vb[finfo copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CopyTo2/VB/program.vb#1)]  
  
 En el ejemplo siguiente se muestra cómo copiar un archivo a otro archivo, especifica si se va a sobrescribir un archivo que ya existe.  
  
 [!code-cpp[fileinfocopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfocopyto/CPP/fileinfocopyto.cpp#1)]
 [!code-csharp[fileinfocopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfocopyto/CS/fileinfocopyto.cs#1)]
 [!code-vb[fileinfocopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfocopyto/VB/fileinfocopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> está vacío, solo contiene espacios en blanco o incluye caracteres no válidos.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error o el archivo de destino ya existe y <paramref name="overwrite" /> es <see langword="false" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio especificado en <paramref name="destFileName" /> no existe.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Se pasa una ruta de acceso a directorio o se mueve el archivo a una unidad diferente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="destFileName" /> contiene un carácter de dos puntos (:) dentro de la cadena.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir en archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Function Create () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Create();" />
      <MemberSignature Language="F#" Value="member this.Create : unit -&gt; System.IO.FileStream" Usage="fileInfo.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un archivo.</summary>
        <returns>Un nuevo archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, se concede acceso completo de lectura/escritura a los nuevos archivos a todos los usuarios.  
  
 Este método es un contenedor para la funcionalidad proporcionada por <xref:System.IO.File.Create%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una referencia a un archivo y, a continuación, crea el archivo en disco mediante `FileInfo.Create()`.  
  
 [!code-cpp[fileinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodelete/CPP/fileinfodelete.cpp#1)]
 [!code-csharp[fileinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodelete/CS/fileinfodelete.cs#1)]
 [!code-vb[fileinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodelete/VB/fileinfodelete.vb#1)]  
  
 En el ejemplo siguiente se crea un archivo, agrega texto y lee del archivo.  
  
 [!code-cpp[finfo create#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Create/CPP/finfo create.cpp#1)]
 [!code-csharp[finfo create#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Create/CS/finfo create.cs#1)]
 [!code-vb[finfo create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Create/VB/finfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir en archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter CreateText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamWriter CreateText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.CreateText" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateText () As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ CreateText();" />
      <MemberSignature Language="F#" Value="member this.CreateText : unit -&gt; System.IO.StreamWriter" Usage="fileInfo.CreateText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un <see cref="T:System.IO.StreamWriter" /> que escribe un nuevo archivo de texto.</summary>
        <returns>Un nuevo objeto <see langword="StreamWriter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, se concede acceso completo de lectura/escritura a los nuevos archivos a todos los usuarios.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el `CreateText` método.  
  
 [!code-cpp[finfo createtext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo CreateText/CPP/finfo createtext.cpp#1)]
 [!code-csharp[finfo createtext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo CreateText/CS/finfo createtext.cs#1)]
 [!code-vb[finfo createtext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo CreateText/VB/finfo createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El nombre de archivo es un directorio.</exception>
        <exception cref="T:System.IO.IOException">El disco es de solo lectura.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir en archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public void Decrypt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Decrypt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Decrypt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Decrypt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Decrypt();" />
      <MemberSignature Language="F#" Value="member this.Decrypt : unit -&gt; unit" Usage="fileInfo.Decrypt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Descifra un archivo cifrado por la cuenta actual mediante el método <see cref="M:System.IO.FileInfo.Encrypt" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileInfo.Decrypt%2A> método le permite descifrar un archivo cifrado mediante el <xref:System.IO.FileInfo.Encrypt%2A> método.  El <xref:System.IO.FileInfo.Decrypt%2A> método pueda descifrar sólo los archivos que se cifraron con la cuenta de usuario actual.  
  
 Tanto el <xref:System.IO.FileInfo.Encrypt%2A> método y el <xref:System.IO.FileInfo.Decrypt%2A> método utiliza el proveedor de servicios criptográficos (CSP) instalado en el equipo y las claves de cifrado de archivo del proceso de llamada al método.  
  
 Debe ser el actual sistema de archivos con formato NTFS y el sistema operativo actual deben ser Microsoft Windows NT o una versión posterior.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.IO.FileInfo.Encrypt%2A> método y <xref:System.IO.FileInfo.Decrypt%2A> método para cifrar y descifrar un archivo.  
  
 [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DriveNotFoundException">Se especificó una unidad no válida.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo descrito por el objeto <see cref="T:System.IO.FileInfo" /> actual.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.NotSupportedException">El sistema de archivos no es NTFS.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Microsoft Windows NT o posterior.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El archivo descrito por el actual objeto <see cref="T:System.IO.FileInfo" /> es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- El autor de la llamada no dispone del permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" /> acción de seguridad: petición.  Para obtener permiso para leer y escribir en el archivo descrito por el actual <see cref="T:System.IO.FileInfo" /> objeto.</permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberSignature Language="F#" Value="override this.Delete : unit -&gt; unit" Usage="fileInfo.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina de forma permanente un archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el archivo no existe, este método no hace nada.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el `Delete` método.  
  
 [!code-cpp[finfo delete#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Delete/CPP/finfo delete.cpp#1)]
 [!code-csharp[finfo delete#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Delete/CS/finfo delete.cs#1)]
 [!code-vb[finfo delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Delete/VB/finfo delete.vb#1)]  
  
 En el siguiente ejemplo se crea, se cierra y se elimina un archivo.  
  
 [!code-cpp[fileinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodelete/CPP/fileinfodelete.cpp#1)]
 [!code-csharp[fileinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodelete/CS/fileinfodelete.cs#1)]
 [!code-vb[fileinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodelete/VB/fileinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El archivo de destino está abierto o asignado a la memoria en un equipo que ejecuta Microsoft Windows NT.  -o bien- Hay un identificador abierto en el archivo y el sistema operativo es Windows XP o una versión anterior. Este identificador abierto puede obtenerse al enumerar directorios y archivos. Para obtener más información, vea [Cómo: Enumerar directorios y archivos](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">La ruta de acceso es un directorio.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir en archivos. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Directory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Directory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Directory" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Directory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Directory As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Directory { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Directory : System.IO.DirectoryInfo" Usage="System.IO.FileInfo.Directory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una instancia del directorio principal.</summary>
        <value>Objeto <see cref="T:System.IO.DirectoryInfo" /> que representa el directorio principal de este archivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener el directorio principal como una cadena, use la <xref:System.IO.FileInfo.DirectoryName%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo siguiente se abre o crea un archivo, determina la ruta completa y determina y muestra el contenido completo del directorio.  
  
 [!code-cpp[fileinfodirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfodirectory/CPP/fileinfodirectory.cpp#1)]
 [!code-csharp[fileinfodirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfodirectory/CS/fileinfodirectory.cs#1)]
 [!code-vb[fileinfodirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfodirectory/VB/fileinfodirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer archivos. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DirectoryName">
      <MemberSignature Language="C#" Value="public string DirectoryName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DirectoryName" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.DirectoryName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DirectoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DirectoryName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectoryName : string" Usage="System.IO.FileInfo.DirectoryName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una cadena que representa la ruta de acceso completa del directorio.</summary>
        <value>Cadena que representa la ruta de acceso completa del directorio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener el directorio principal como un <xref:System.IO.DirectoryInfo> objeto, utilice el <xref:System.IO.FileInfo.Directory%2A> propiedad.  
  
 Cuando se llama por primera vez, <xref:System.IO.FileInfo> llamadas <xref:System.IO.FileSystemInfo.Refresh%2A> y almacena en caché información acerca del archivo. En las llamadas posteriores, debe llamar a <xref:System.IO.FileSystemInfo.Refresh%2A> para obtener la última copia de la información.  
  
   
  
## Examples  
 En el ejemplo siguiente se recupera la ruta de acceso completa del archivo especificado.  
  
 [!code-cpp[System.IO.FileInfo members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileInfo members/CPP/fileinfomembers.cpp#3)]
 [!code-csharp[System.IO.FileInfo members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileInfo members/CS/fileinfomembers.cs#3)]
 [!code-vb[System.IO.FileInfo members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileInfo members/VB/fileinfomembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see langword="null" /> se pasó para el nombre del directorio.</exception>
        <exception cref="T:System.IO.PathTooLongException">El nombre de la ruta de acceso absoluta supera la longitud máxima definida pro el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer archivos. Enumeración asociada: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public void Encrypt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Encrypt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Encrypt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Encrypt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Encrypt();" />
      <MemberSignature Language="F#" Value="member this.Encrypt : unit -&gt; unit" Usage="fileInfo.Encrypt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cifra un archivo de forma que solo la cuenta utilizada para cifrarlo pueda descifrarlo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileInfo.Encrypt%2A> método le permite cifrar un archivo de forma que sólo la cuenta utilizada para llamar a este método puede descifrarlo.  Use la <xref:System.IO.FileInfo.Decrypt%2A> método para descifrar un archivo cifrado por la <xref:System.IO.FileInfo.Encrypt%2A> método.  
  
 Tanto el <xref:System.IO.FileInfo.Encrypt%2A> método y el <xref:System.IO.FileInfo.Decrypt%2A> método utiliza el proveedor de servicios criptográficos (CSP) instalado en el equipo y las claves de cifrado de archivo del proceso de llamada al método.  
  
 Debe ser el actual sistema de archivos con formato NTFS y el sistema operativo actual deben ser Microsoft Windows NT o una versión posterior.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.IO.FileInfo.Encrypt%2A> método y <xref:System.IO.FileInfo.Decrypt%2A> método para cifrar un archivo y, a continuación, descifrarlo.  
  
 [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DriveNotFoundException">Se especificó una unidad no válida.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo descrito por el objeto <see cref="T:System.IO.FileInfo" /> actual.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.NotSupportedException">El sistema de archivos no es NTFS.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Microsoft Windows NT o posterior.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El archivo descrito por el actual objeto <see cref="T:System.IO.FileInfo" /> es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- El autor de la llamada no dispone del permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" /> acción de seguridad: petición.  Para obtener permiso para leer y escribir en el archivo descrito por el actual <see cref="T:System.IO.FileInfo" /> objeto.</permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Exists : bool" Usage="System.IO.FileInfo.Exists" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si existe un archivo.</summary>
        <value>
          <see langword="true" /> si existe el archivo; <see langword="false" /> si no existe el archivo o es un directorio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama por primera vez, <xref:System.IO.FileInfo> llamadas <xref:System.IO.FileSystemInfo.Refresh%2A> y almacena en caché información acerca del archivo. En las llamadas posteriores, debe llamar a <xref:System.IO.FileSystemInfo.Refresh%2A> para obtener la última copia de la información.  
  
 El <xref:System.IO.FileInfo.Exists%2A> propiedad devuelve `false` si se produce un error al intentar determinar si existe el archivo especificado. Esto puede ocurrir en las situaciones que provocan excepciones, como pasar un nombre de archivo con caracteres no válidos o hay demasiados caracteres, un disco con errores o que faltan, o si el llamador no tiene permiso para leer el archivo.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.IO.FileInfo.Exists%2A> propiedad garantizar que existe un archivo antes de abrirlo.  Puede utilizar esta técnica para producir una excepción personalizada cuando no se encuentra el archivo.  
  
 [!code-cpp[IO.FileInfo.Exists#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Exists/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Exists/cs/sample.cs#1)]
 [!code-vb[IO.FileInfo.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Exists/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula las entradas de lista de control de acceso (ACL) del archivo descrito por el objeto <see cref="T:System.IO.FileInfo" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.FileInfo.GetAccessControl%2A> entradas de lista (ACL) para el archivo actual de control de métodos para recuperar el acceso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileInfo.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula las entradas de lista de control de acceso (ACL) del archivo descrito por el objeto <see cref="T:System.IO.FileInfo" /> actual.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula las reglas de control de acceso para el archivo actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.FileInfo.GetAccessControl%2A> método para recuperar las entradas de lista (ACL) del control de acceso para el archivo actual.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo especificado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.IO.FileInfo.GetAccessControl%2A> método y <xref:System.IO.FileInfo.SetAccessControl%2A> método para agregar y, a continuación, quitar una entrada de lista (ACL) del control de acceso de un archivo.  Para ejecutar este ejemplo, debe proporcionar una cuenta de usuario o grupo válida.  
  
 [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Microsoft Windows 2000 o posterior.</exception>
        <exception cref="T:System.Security.AccessControl.PrivilegeNotHeldException">La cuenta del sistema actual no tiene privilegios administrativos.</exception>
        <exception cref="T:System.SystemException">No se encuentra el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Esta operación no es compatible con la plataforma actual.  -o bien- El autor de la llamada no dispone del permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /> acción de seguridad: petición.  Para obtener permiso Leer la lista de control de acceso.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.FileSecurity" Usage="fileInfo.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">Uno de los valores de <see cref="T:System.Security.AccessControl.AccessControlSections" /> que especifica qué grupo de entradas de control de acceso se van a recuperar.</param>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula el tipo especificado de entradas de la lista de control de acceso (ACL) para el archivo descrito por el objeto <see cref="T:System.IO.FileInfo" /> actual.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula las reglas de control de acceso para el archivo actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.FileInfo.GetAccessControl%2A> método para recuperar las entradas de lista (ACL) del control de acceso para el archivo actual.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo especificado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Microsoft Windows 2000 o posterior.</exception>
        <exception cref="T:System.Security.AccessControl.PrivilegeNotHeldException">La cuenta del sistema actual no tiene privilegios administrativos.</exception>
        <exception cref="T:System.SystemException">No se encuentra el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Esta operación no es compatible con la plataforma actual.  -o bien- El autor de la llamada no dispone del permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /> acción de seguridad: petición.  Para obtener permiso Leer la lista de control de acceso.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool with get, set" Usage="System.IO.FileInfo.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que determina si el archivo actual es de solo lectura.</summary>
        <value>Es <see langword="true" /> si el archivo actual es de solo lectura; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.FileInfo.IsReadOnly%2A> propiedad para determinar rápidamente o cambiar si el archivo actual es de solo lectura.  
  
 Cuando se llama por primera vez, <xref:System.IO.FileInfo> llamadas <xref:System.IO.FileSystemInfo.Refresh%2A> y almacena en caché información acerca del archivo. En las llamadas posteriores, debe llamar a <xref:System.IO.FileSystemInfo.Refresh%2A> para obtener la última copia de la información.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.FileInfo.IsReadOnly%2A> propiedad para marcar un archivo como de solo lectura y, a continuación, marcarla como de lectura y escritura.  
  
 [!code-cpp[IO.FileInfo.IsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.isReadOnly/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.IsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.isReadOnly/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.IsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.isReadOnly/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo descrito por el objeto <see cref="T:System.IO.FileInfo" /> actual.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Esta operación no es compatible con la plataforma actual.  -o bien- El autor de la llamada no dispone del permiso necesario.</exception>
        <exception cref="T:System.ArgumentException">El usuario no tiene permiso de escritura, pero ha intentado establecer esta propiedad en <see langword="false" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.AccessControl.FileSystemRights.Write" /> acción de seguridad: petición.  Para obtener permiso para leer y escribir en el archivo descrito por el actual <see cref="T:System.IO.FileInfo" /> objeto.</permission>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileInfo.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño, en bytes, del archivo actual.</summary>
        <value>Tamaño del archivo actual en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de la <xref:System.IO.FileInfo.Length%2A> propiedad es previamente almacenado en caché si la instancia actual de la <xref:System.IO.FileInfo> objeto devolvió desde cualquiera de las siguientes acciones <xref:System.IO.DirectoryInfo> métodos:  
  
-   <xref:System.IO.DirectoryInfo.GetDirectories%2A>  
  
-   <xref:System.IO.DirectoryInfo.GetFiles%2A>  
  
-   <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>  
  
-   <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>  
  
 Para obtener el valor más reciente, llame a la <xref:System.IO.FileSystemInfo.Refresh%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el tamaño de los archivos especificados.  
  
 [!code-cpp[FileLength#1](~/samples/snippets/cpp/VS_Snippets_CLR/FileLength/CPP/filelength.cpp#1)]
 [!code-csharp[FileLength#1](~/samples/snippets/csharp/VS_Snippets_CLR/FileLength/CS/filelength.cs#1)]
 [!code-vb[FileLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FileLength/VB/filelength.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <see cref="M:System.IO.FileSystemInfo.Refresh" /> no puede actualizar el estado del archivo o directorio.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.  -o bien- La <see langword="Length" /> propiedad se llama para un directorio.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destFileName);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : string -&gt; unit" Usage="fileInfo.MoveTo destFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destFileName">La ruta de acceso a la que se mueve el archivo, que puede especificar un nombre de archivo distinto.</param>
        <summary>Mueve un archivo especificado a una nueva ubicación, proporcionando la opción para indicar un nuevo nombre de archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método funciona en volúmenes de disco. Por ejemplo, el archivo c:\MyFile.txt se pueden mover a d:\público y cambiar NewFile.txt.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo mover un archivo a una ubicación diferente y cambiar el nombre del archivo.  
  
 [!code-csharp[IO.FileInfo.MoveTo#1](~/samples/snippets/csharp/VS_Snippets_Misc/IO.FileInfo.MoveTo/CS/Program.cs#1)]
 [!code-vb[IO.FileInfo.MoveTo#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/IO.FileInfo.MoveTo/VB/Program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S, por ejemplo, el archivo de destino ya existe o el dispositivo de destino no está listo.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destFileName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="destFileName" /> está vacío, solo contiene espacios en blanco o incluye caracteres no válidos.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="destFileName" /> es de solo lectura o es un directorio.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="destFileName" /> contiene un carácter de dos puntos (:) dentro de la cadena.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir en archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre del archivo.</summary>
        <value>Nombre del archivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama por primera vez, <xref:System.IO.FileInfo> llamadas <xref:System.IO.FileSystemInfo.Refresh%2A> y almacena en caché información acerca del archivo. En las llamadas posteriores, debe llamar a <xref:System.IO.FileSystemInfo.Refresh%2A> para obtener la última copia de la información.  
  
 El nombre del archivo incluye la extensión de archivo.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `Name` propiedad para mostrar los nombres de archivos en el directorio actual.  
  
 [!code-cpp[fileinfoname#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoname/CPP/fileinfoname.cpp#1)]
 [!code-csharp[fileinfoname#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoname/CS/fileinfoname.cs#1)]
 [!code-vb[fileinfoname#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoname/VB/fileinfoname.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre un archivo con varios privilegios de lectura y escritura y de uso compartido.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="member this.Open : System.IO.FileMode -&gt; System.IO.FileStream" Usage="fileInfo.Open mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="mode">Constante <see cref="T:System.IO.FileMode" /> que especifica el modo (por ejemplo, <see langword="Open" /> o <see langword="Append" />) en que se abre el archivo.</param>
        <summary>Abre un archivo en el modo especificado.</summary>
        <returns>Archivo abierto en el modo especificado, con acceso de lectura y escritura y de uso no compartido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se abre un archivo, agrega información al archivo y lee el archivo.  
  
 [!code-cpp[finfo open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Open1/CPP/finfo open1.cpp#1)]
 [!code-csharp[finfo open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Open1/CS/finfo open1.cs#1)]
 [!code-vb[finfo open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Open1/VB/finfo open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El archivo es de solo lectura o es un directorio.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">El archivo ya está abierto.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir y leer de archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode, access As FileAccess) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.Open : System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="fileInfo.Open (mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="mode">Constante <see cref="T:System.IO.FileMode" /> que especifica el modo (por ejemplo, <see langword="Open" /> o <see langword="Append" />) en que se abre el archivo.</param>
        <param name="access">Constante <see cref="T:System.IO.FileAccess" /> que especifica si el archivo se abre con el acceso de archivo <see langword="Read" />, <see langword="Write" /> o <see langword="ReadWrite" />.</param>
        <summary>Abre un archivo en el modo especificado, con acceso de lectura o escritura (o ambos).</summary>
        <returns>Objeto <see cref="T:System.IO.FileStream" /> abierto en el modo y con el acceso especificados y de uso no compartido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se abre un archivo como de solo lectura y se lee desde el archivo.  
  
 [!code-cpp[finfo open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo Open2/CPP/finfo open2.cpp#1)]
 [!code-csharp[finfo open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo Open2/CS/finfo open2.cs#1)]
 [!code-vb[finfo open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo Open2/VB/finfo open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> es de solo lectura o es un directorio.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">El archivo ya está abierto.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir y leer de archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream Open(valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (mode As FileMode, access As FileAccess, share As FileShare) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ Open(System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="member this.Open : System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="fileInfo.Open (mode, access, share)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="mode">Constante <see cref="T:System.IO.FileMode" /> que especifica el modo (por ejemplo, <see langword="Open" /> o <see langword="Append" />) en que se abre el archivo.</param>
        <param name="access">Constante <see cref="T:System.IO.FileAccess" /> que especifica si el archivo se abre con el acceso de archivo <see langword="Read" />, <see langword="Write" /> o <see langword="ReadWrite" />.</param>
        <param name="share">Constante <see cref="T:System.IO.FileShare" /> que especifica el tipo de acceso que otros objetos <see langword="FileStream" /> tienen en este archivo.</param>
        <summary>Abre un archivo en el modo especificado, con acceso de lectura o escritura (o ambos) y la opción de uso compartido especificada.</summary>
        <returns>Objeto <see cref="T:System.IO.FileStream" /> abierto en el modo y con el acceso especificados y con opciones de uso compartido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo abrir un archivo para lectura y escritura, pero denegar el acceso a otros usuarios o procesos.  
  
 [!code-cpp[fileinfoopen#1](~/samples/snippets/cpp/VS_Snippets_CLR/fileinfoopen/CPP/fileinfoopen.cpp#1)]
 [!code-csharp[fileinfoopen#1](~/samples/snippets/csharp/VS_Snippets_CLR/fileinfoopen/CS/fileinfoopen.cs#1)]
 [!code-vb[fileinfoopen#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/fileinfoopen/VB/fileinfoopen.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> es de solo lectura o es un directorio.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">El archivo ya está abierto.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir y leer de archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public System.IO.FileStream OpenRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream OpenRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenRead" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenRead () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ OpenRead();" />
      <MemberSignature Language="F#" Value="member this.OpenRead : unit -&gt; System.IO.FileStream" Usage="fileInfo.OpenRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un objeto <see cref="T:System.IO.FileStream" /> de solo lectura.</summary>
        <returns>Nuevo objeto <see cref="T:System.IO.FileStream" /> de solo lectura.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve sólo lectura <xref:System.IO.FileStream> objeto con el <xref:System.IO.FileShare> modo establecido en <xref:System.IO.FileShare.Read>.  
  
   
  
## Examples  
 En el ejemplo siguiente se abre un archivo como de solo lectura y se lee en ella.  
  
 [!code-cpp[finfo openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenRead/CPP/finfo openread.cpp#1)]
 [!code-csharp[finfo openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenRead/CS/finfo openread.cs#1)]
 [!code-vb[finfo openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenRead/VB/finfo openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> es de solo lectura o es un directorio.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">El archivo ya está abierto.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer archivos. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.StreamReader OpenText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenText" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenText () As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenText();" />
      <MemberSignature Language="F#" Value="member this.OpenText : unit -&gt; System.IO.StreamReader" Usage="fileInfo.OpenText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un <see cref="T:System.IO.StreamReader" /> con la codificación UTF8 que lee de un archivo de texto existente.</summary>
        <returns>Nuevo <see langword="StreamReader" /> con la codificación UTF8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se lee texto de un archivo.  
  
 [!code-cpp[finfo opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[finfo opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenText/CS/file opentext.cs#1)]
 [!code-vb[finfo opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> es de solo lectura o es un directorio.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, por ejemplo, está en una unidad no asignada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir en archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="T:System.IO.StreamReader" />
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public System.IO.FileStream OpenWrite ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileStream OpenWrite() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.OpenWrite" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenWrite () As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileStream ^ OpenWrite();" />
      <MemberSignature Language="F#" Value="member this.OpenWrite : unit -&gt; System.IO.FileStream" Usage="fileInfo.OpenWrite " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un <see cref="T:System.IO.FileStream" /> de solo escritura.</summary>
        <returns>Objeto no compartido de solo escritura <see cref="T:System.IO.FileStream" /> para un archivo nuevo o existente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileInfo.OpenWrite%2A> método abre un archivo si ya existe uno para la ruta de acceso de archivo, o crea un nuevo archivo si no existe. Para un archivo existente, no anexa el texto nuevo para el texto existente. En su lugar, sobrescriben los caracteres existentes con los nuevos caracteres. Si sobrescribe una cadena más larga (como "Esto es una prueba del método OpenWrite") con una cadena más corta (por ejemplo, "segunda ejecución"), el archivo contendrá una combinación de las cadenas ("segundo runtest del método OpenWrite").  
  
   
  
## Examples  
 En el ejemplo siguiente se abre un archivo para escribir en él y, a continuación, se lee desde el archivo.  
  
 [!code-cpp[finfo openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FInfo OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[finfo openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FInfo OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[finfo openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FInfo OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">La ruta de acceso especificada al crear una instancia del objeto <see cref="T:System.IO.FileInfo" /> es de solo lectura o es un directorio.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada al crear una instancia del objeto <see cref="T:System.IO.FileInfo" /> no es válida, como si estuviera en una unidad no asignada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir en archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reemplaza el contenido de un archivo especificado con el archivo descrito por el objeto <see cref="T:System.IO.FileInfo" /> actual, eliminando el archivo original y creando una copia de seguridad del archivo reemplazado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.FileInfo.Replace%2A> métodos cuando es necesario reemplazar rápidamente un archivo con el contenido del archivo descrito por el actual <xref:System.IO.FileInfo> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (destinationFileName As String, destinationBackupFileName As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ Replace(System::String ^ destinationFileName, System::String ^ destinationBackupFileName);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.IO.FileInfo" Usage="fileInfo.Replace (destinationFileName, destinationBackupFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destinationFileName">Nombre de un archivo que va a reemplazarse con el archivo actual.</param>
        <param name="destinationBackupFileName">Nombre de un archivo con el que se va a crear una copia de seguridad del archivo descrito por el parámetro <c>destFileName</c>.</param>
        <summary>Reemplaza el contenido de un archivo especificado con el archivo descrito por el objeto <see cref="T:System.IO.FileInfo" /> actual, eliminando el archivo original y creando una copia de seguridad del archivo reemplazado.</summary>
        <returns>Objeto <see cref="T:System.IO.FileInfo" /> que encapsula información sobre el archivo descrito por el parámetro <paramref name="destFileName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileInfo.Replace%2A> método reemplaza el contenido de un archivo especificado con el contenido del archivo descrito por el actual <xref:System.IO.FileInfo> objeto.  También crea una copia de seguridad del archivo que se reemplazó.  Por último, devuelve un nuevo <xref:System.IO.FileInfo> objeto que describe el archivo sobrescrito.  
  
> [!CAUTION]
>  Este método se realizará correctamente en entornos de Windows 2000 si la `destFileName` es de solo lectura y no se producirá una excepción. Use la <xref:System.IO.FileInfo.IsReadOnly%2A> propiedad para comprobar si el archivo de destino es de solo lectura antes de intentar reemplazarlo.  
  
 Pasar `null` a la `destBackupFileName` parámetro si no desea crear una copia de seguridad del archivo que se va a reemplazar.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.File.Replace%2A> método para reemplazar un archivo con otro y crear una copia de seguridad del archivo reemplazado.  
  
 [!code-cpp[IO.FileInfo.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Replace/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso descrita por el parámetro <paramref name="destFileName" /> no tiene un formato válido.  -o bien- La ruta de acceso que describe el parámetro <paramref name="destBackupFileName" /> no tenía un formato válido.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="destFileName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo descrito por el objeto <see cref="T:System.IO.FileInfo" /> actual.  -o bien- No se encontró el archivo descrito por el parámetro <paramref name="destinationFileName" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Microsoft Windows NT o posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> acción de seguridad: petición.  Para obtener permiso para escribir en el archivo descrito por el <paramref name="destBackupFileName" /> parámetro si se especifica uno.</permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.Replace(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (destinationFileName As String, destinationBackupFileName As String, ignoreMetadataErrors As Boolean) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ Replace(System::String ^ destinationFileName, System::String ^ destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool -&gt; System.IO.FileInfo" Usage="fileInfo.Replace (destinationFileName, destinationBackupFileName, ignoreMetadataErrors)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destinationFileName">Nombre de un archivo que va a reemplazarse con el archivo actual.</param>
        <param name="destinationBackupFileName">Nombre de un archivo con el que se va a crear una copia de seguridad del archivo descrito por el parámetro <c>destFileName</c>.</param>
        <param name="ignoreMetadataErrors">Es <see langword="true" /> para omitir los errores de combinación (como de atributos y ACL) del archivo reemplazado en el archivo de reemplazo; de lo contrario, es <see langword="false" />.</param>
        <summary>Reemplaza el contenido de un archivo especificado con el archivo descrito por el objeto <see cref="T:System.IO.FileInfo" /> actual, eliminando el archivo original y creando una copia de seguridad del archivo reemplazado.  También especifica si se van a omitir los errores de fusión mediante combinación.</summary>
        <returns>Objeto <see cref="T:System.IO.FileInfo" /> que encapsula información sobre el archivo descrito por el parámetro <paramref name="destFileName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileInfo.Replace%2A> método reemplaza el contenido de un archivo especificado con el contenido del archivo descrito por el actual <xref:System.IO.FileInfo> objeto.  También crea una copia de seguridad del archivo que se reemplazó.  Por último, devuelve un nuevo <xref:System.IO.FileInfo> objeto que describe el archivo sobrescrito.  
  
> [!CAUTION]
>  Este método se realizará correctamente en entornos de Windows 2000 si la `destFileName` es de solo lectura y no se producirá una excepción. Use la <xref:System.IO.FileInfo.IsReadOnly%2A> propiedad para comprobar si el archivo de destino es de solo lectura antes de intentar reemplazarlo.  
  
 Pasar `null` a la `destBackupFileName` parámetro si no desea crear una copia de seguridad del archivo que se va a reemplazar.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.File.Replace%2A> método para reemplazar un archivo con otro y crear una copia de seguridad del archivo reemplazado.  
  
 [!code-cpp[IO.FileInfo.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.Replace/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso descrita por el parámetro <paramref name="destFileName" /> no tiene un formato válido.  -o bien- La ruta de acceso que describe el parámetro <paramref name="destBackupFileName" /> no tenía un formato válido.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="destFileName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo descrito por el objeto <see cref="T:System.IO.FileInfo" /> actual.  -o bien- No se encontró el archivo descrito por el parámetro <paramref name="destinationFileName" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Microsoft Windows NT o posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> acción de seguridad: petición.  Para obtener permiso para escribir en el archivo descrito por el <paramref name="destBackupFileName" /> parámetro si se especifica uno.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileInfo.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">Objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que describe una entrada de la lista de control de acceso (ACL) que se va a aplicar al archivo actual.</param>
        <summary>Aplica las entradas de la lista de control de acceso (ACL) descritas por un objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> al archivo descrito por el objeto <see cref="T:System.IO.FileInfo" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileInfo.SetAccessControl%2A> método aplica las entradas de lista (ACL) de control de acceso al archivo actual que representa la lista ACL no heredada.  
  
 Use la <xref:System.IO.FileInfo.SetAccessControl%2A> método siempre que tenga que agregar o quitar entradas de la ACL de un archivo.  
  
> [!CAUTION]
>  La ACL especificada para el `fileSecurity` parámetro reemplaza la ACL existente para el archivo. Para agregar permisos para un usuario nuevo, use la <xref:System.IO.Directory.GetAccessControl%2A> método para obtener la lista ACL existente, modificarlo y, a continuación, usar <xref:System.IO.FileInfo.SetAccessControl%2A> para aplicarlo al archivo.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo especificado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 El <xref:System.IO.FileInfo.SetAccessControl%2A> método conserva solo <xref:System.Security.AccessControl.FileSecurity> objetos que se han modificado después de la creación de objetos.  Si un <xref:System.Security.AccessControl.FileSecurity> objeto no se ha modificado, no se conservarán en un archivo.  Por lo tanto, no es posible recuperar un <xref:System.Security.AccessControl.FileSecurity> de objetos de un archivo y vuelva a aplicar el mismo objeto a otro archivo.  
  
 Para copiar la información de la ACL de un archivo a otro:  
  
1.  Use la <xref:System.IO.FileInfo.GetAccessControl%2A> método para recuperar la <xref:System.Security.AccessControl.FileSecurity> objeto desde el archivo de origen.  
  
2.  Crear un nuevo <xref:System.Security.AccessControl.FileSecurity> objeto para el archivo de destino.  
  
3.  Use la <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> o <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> método del origen de <xref:System.Security.AccessControl.FileSecurity> objeto que se va a recuperar la información de la ACL.  
  
4.  Use la <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> o <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> método para copiar la información recuperada en el paso 3 en el destino <xref:System.Security.AccessControl.FileSecurity> objeto.  
  
5.  Establecer el destino <xref:System.Security.AccessControl.FileSecurity> objeto en el archivo de destino usando la <xref:System.IO.FileInfo.SetAccessControl%2A> método.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.IO.FileInfo.GetAccessControl%2A> método y <xref:System.IO.FileInfo.SetAccessControl%2A> método para agregar y, a continuación, quitar una entrada ACL de un archivo.  Para ejecutar este ejemplo, debe proporcionar una cuenta de usuario o grupo válida.  
  
 [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="fileSecurity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">No se pudo encontrar o modificar el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El proceso actual no tiene acceso para abrir el archivo.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Microsoft Windows 2000 o posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.Change" /> acción de seguridad: petición de permiso para tener acceso al archivo.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="fileInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la ruta de acceso como una cadena.</summary>
        <returns>Cadena que representa la ruta de acceso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La cadena devuelta por la <xref:System.IO.FileInfo.ToString%2A> método representa la ruta de acceso que se pasó al constructor.  Cuando se crea un <xref:System.IO.FileInfo> utilizando los constructores del objeto el <xref:System.IO.FileInfo.ToString%2A> método devuelve la ruta de acceso completa.  Sin embargo, hay casos donde la cadena devuelta por la <xref:System.IO.FileInfo.ToString%2A> método no representa la ruta de acceso completa.  Por ejemplo, cuando se crea un <xref:System.IO.FileInfo> objeto mediante la <xref:System.IO.DirectoryInfo.GetFiles%2A> método, el <xref:System.IO.FileInfo.ToString%2A> método no representa la ruta de acceso completa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>