<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FileStream.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86ca1270f501ef9faaea438d5520f0e0455a33f21ad.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a1270f501ef9faaea438d5520f0e0455a33f21ad</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.FileStream">
          <source>Provides a <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> for a file, supporting both synchronous and asynchronous read and write operations.</source>
          <target state="translated">Proporciona un <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> para un archivo, lo que permite operaciones de lectura y escritura sincrónica y asincrónica.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> clase para leer, escribir, abrir y cerrar archivos en un sistema de archivos y para manipular otros identificadores del sistema operativo relacionados con el archivo, como canalizaciones, entrada estándar y salida estándar.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>You can use the <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Stream.CopyTo%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> methods to perform synchronous operations, or the <ph id="ph5">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph8">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph> methods to perform asynchronous operations.</source>
          <target state="translated">Puede usar el <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Stream.CopyTo%2A&gt;</ph>, y <ph id="ph4">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> métodos para realizar las operaciones sincrónicas, o la <ph id="ph5">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, y <ph id="ph8">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph> métodos para realizar operaciones asincrónicas.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread.</source>
          <target state="translated">Use los métodos asincrónicos para realizar operaciones de archivos de gran cantidad de recursos sin bloquear el subproceso principal.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>This performance consideration is particularly important in a <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> app or <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</source>
          <target state="translated">Esta consideración de rendimiento es especialmente importante en una aplicación de la <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> o una aplicación de <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> en que una operación de streaming prolongada puede bloquear el subproceso de interfaz de usuario y hacer que parezca que una aplicación ha dejado de responder.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> buffers input and output for better performance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> búferes de entrada y salida para mejorar el rendimiento.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Este tipo implementa la <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">Cuando haya terminado de utilizar el tipo, debe eliminar del mismo directa o indirectamente.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Para deshacerse del tipo directamente, llame a su <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> método en un <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> bloque.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Para deshacerse de él indirectamente, use una construcción de lenguaje como <ph id="ph1">`using`</ph> (en C#) o <ph id="ph2">`Using`</ph> (en Visual Basic).</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> tema de la interfaz.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property detects whether the file handle was opened asynchronously.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> propiedad detecta si se abrió el identificador de archivo de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>You specify this value when you create an instance of the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class using a constructor that has an <ph id="ph2">`isAsync`</ph>, <ph id="ph3">`useAsync`</ph>, or <ph id="ph4">`options`</ph> parameter.</source>
          <target state="translated">Especifique este valor cuando se crea una instancia de la <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> clase utilizando un constructor que tiene un <ph id="ph2">`isAsync`</ph>, <ph id="ph3">`useAsync`</ph>, o <ph id="ph4">`options`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>When the property is <ph id="ph1">`true`</ph>, the stream utilizes overlapped I/O to perform file operations asynchronously.</source>
          <target state="translated">Cuando la propiedad es <ph id="ph1">`true`</ph>, la secuencia utiliza E/S superpuesta para realizar operaciones de archivo de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>However, the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property does not have to be <ph id="ph2">`true`</ph> to call the <ph id="ph3">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> method.</source>
          <target state="translated">Sin embargo, el <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> propiedad no tiene que ser <ph id="ph2">`true`</ph> para llamar a la <ph id="ph3">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, o <ph id="ph5">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>When the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property is <ph id="ph2">`false`</ph> and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</source>
          <target state="translated">Cuando el <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> propiedad es <ph id="ph2">`false`</ph> y llama a la lectura asincrónica y las operaciones de escritura, no sigue se bloquea el subproceso de interfaz de usuario, pero la operación de E/S real se realiza de forma sincrónica.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> method supports random access to files.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> método admite el acceso aleatorio a los archivos.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> allows the read/write position to be moved to any position within the file.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> permite la posición de lectura/escritura se muevan a cualquier posición dentro del archivo.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>This is done with byte offset reference point parameters.</source>
          <target state="translated">Esto se realiza con parámetros de punto de referencia de desplazamiento de bytes.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <ph id="ph1">&lt;xref:System.IO.SeekOrigin&gt;</ph> enumeration.</source>
          <target state="translated">El desplazamiento de byte es relativo al punto de referencia de búsqueda, que puede ser el comienzo, la posición actual o el final del archivo subyacente, tal como está representado por los tres miembros de la <ph id="ph1">&lt;xref:System.IO.SeekOrigin&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>Disk files always support random access.</source>
          <target state="translated">Archivos de disco siempre admiten el acceso aleatorio.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>At the time of construction, the <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property value is set to <ph id="ph2">`true`</ph> or <ph id="ph3">`false`</ph> depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <ph id="ph4">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property value is <ph id="ph5">`true`</ph>.</source>
          <target state="translated">En el momento de construcción, el <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> valor de la propiedad se establece en <ph id="ph2">`true`</ph> o <ph id="ph3">`false`</ph> según el tipo de archivo subyacente. Si el tipo de archivo subyacente es FILE_TYPE_DISK, tal como se define en winbase.h, el <ph id="ph4">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> es el valor de la propiedad <ph id="ph5">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>Otherwise, the <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property value is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">En caso contrario, el <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> es el valor de la propiedad <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.</source>
          <target state="translated">Si un proceso termina con parte de un archivo bloqueado o cierra un archivo que tiene bloqueos pendientes, el comportamiento es indefinido.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>For directory operations and other file operations, see the <ph id="ph1">&lt;xref:System.IO.File&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Directory&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.Path&gt;</ph> classes.</source>
          <target state="translated">Para las operaciones de directorio y otras operaciones de archivo, consulte la <ph id="ph1">&lt;xref:System.IO.File&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Directory&gt;</ph>, y <ph id="ph3">&lt;xref:System.IO.Path&gt;</ph> clases.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.File&gt;</ph> class is a utility class that has static methods primarily for the creation of <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> objects based on file paths.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.File&gt;</ph> es una clase de utilidad que tiene métodos estáticos principalmente para la creación de <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> objetos basados en las rutas de acceso de archivo.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class creates a stream from a byte array and is similar to the <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> class.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> clase crea una secuencia a partir de una matriz de bytes y es similar a la <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>Detection of Stream Position Changes</source>
          <target state="translated">Detección de cambios de la posición de secuencia</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>When a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle.</source>
          <target state="translated">Cuando un <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objeto no tiene control exclusivo sobre su identificador, otro subproceso podría tener acceso al identificador de archivo al mismo tiempo y cambiar la posición del puntero de archivo del sistema operativo que está asociado con el identificador de archivo.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>In this case, the cached position in the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object and the cached data in the buffer could be compromised.</source>
          <target state="translated">En este caso, la posición almacenada en caché en el <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objeto y los datos en caché en el búfer pudieron verse comprometidos.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objeto habitualmente realiza comprobaciones en los métodos que tener acceso al búfer almacenado en caché para asegurarse de que la posición del identificador del sistema operativo es igual que la posición almacenada en caché utilizada por el <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>If an unexpected change in the handle position is detected in a call to the <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again.</source>
          <target state="translated">Si se detecta un cambio inesperado en la posición del identificador en una llamada a la <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> (método), .NET Framework descarta el contenido del búfer y vuelve a leer la secuencia del archivo.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.</source>
          <target state="translated">Esto puede afectar al rendimiento, dependiendo del tamaño del archivo y ningún otro proceso que podría afectar a la posición de la secuencia de archivos.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>If an unexpected change in the handle position is detected in a call to the <ph id="ph1">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph> method, the contents of the buffer are discarded and an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> exception is thrown.</source>
          <target state="translated">Si se detecta un cambio inesperado en la posición del identificador en una llamada a la <ph id="ph1">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph> método, el contenido del búfer se descartan y <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> se produce la excepción.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>A <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object will not have an exclusive hold on its handle when either the <ph id="ph2">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> property is accessed to expose the handle or the <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> object is given the <ph id="ph4">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> property in its constructor.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objeto no tendrán una suspensión exclusivo sobre su identificador cuando ya sea el <ph id="ph2">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> acceso a la propiedad para exponer el identificador o el <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> se proporciona al objeto el <ph id="ph4">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> propiedad en su constructor.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The following example demonstrates some of the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> constructors.</source>
          <target state="translated">El ejemplo siguiente muestra algunas de las <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> constructores.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The following example shows how to write to a file asynchronously.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo escribir en un archivo de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click.</source>
          <target state="translated">Este código se ejecuta en una aplicación WPF que tiene un TextBlock denominado /userinput y un botón enlazarse a un controlador de eventos Click denominado Button_Click.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.FileStream">
          <source>The file path needs to be changed to a file than exits on the computer.</source>
          <target state="translated">La ruta de acceso de archivo debe cambiarse a un archivo que exista en el equipo.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="T:System.IO.FileStream">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>A file handle for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Identificador de archivo para el archivo que el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> actual va a encapsular.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Constante que establece las propiedades <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> y <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> del objeto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> para el identificador de archivo especificado, con el permiso de lectura y escritura especificado.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>When <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> is called, the handle is also closed and the file's handle count is decremented.</source>
          <target state="translated">Cuando <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> es llama, se cierra también el identificador y el recuento de identificadores del archivo va disminuyendo.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> se da por supuesto que tiene control exclusivo sobre el identificador.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">Lectura, escritura o búsqueda mientras un <ph id="ph1">`FileStream`</ph> también contiene un identificador podría provocar daños en los datos.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">Por motivos de seguridad de datos, llame a <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> antes de utilizar el identificador y evite llamar a cualquier método distinto de <ph id="ph2">`Close`</ph> cuando haya terminado con el identificador.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> es el valor predeterminado para los <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructores sin un <ph id="ph3">`FileShare`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="access" /&gt;</ph> is not a field of <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="access" /&gt;</ph> no es un campo de <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">Se produjo un error de E/S, como un error de disco.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>The stream has been closed.</source>
          <target state="translated">Se ha cerrado la secuencia.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">El sistema operativo no permite el <ph id="ph1">&lt;paramref name="access" /&gt;</ph> solicitado para el identificador de archivo especificado, como sucede, por ejemplo, cuando <ph id="ph2">&lt;paramref name="access" /&gt;</ph> es <ph id="ph3">&lt;see langword="Write" /&gt;</ph> o <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> y el identificador de archivo está establecido para el acceso de sólo lectura.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">para leer, escribir y anexar texto a archivos.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, y <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>A file handle for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Identificador de archivo para el archivo que el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> actual va a encapsular.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Constante que establece las propiedades <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> y <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> del objeto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> para el identificador de archivo especificado, con el permiso de lectura y escritura especificado.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>When <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> is called, the handle is also closed and the file's handle count is decremented.</source>
          <target state="translated">Cuando <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> es llama, se cierra también el identificador y el recuento de identificadores del archivo va disminuyendo.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> se da por supuesto que tiene control exclusivo sobre el identificador.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">Lectura, escritura o búsqueda mientras un <ph id="ph1">`FileStream`</ph> también contiene un identificador podría provocar daños en los datos.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">Por motivos de seguridad de datos, llame a <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> antes de utilizar el identificador y evite llamar a cualquier método distinto de <ph id="ph2">`Close`</ph> cuando haya terminado con el identificador.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> es el valor predeterminado para los <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructores sin un <ph id="ph3">`FileShare`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="access" /&gt;</ph> is not a field of <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="access" /&gt;</ph> no es un campo de <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">Se produjo un error de E/S, como un error de disco.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>The stream has been closed.</source>
          <target state="translated">Se ha cerrado la secuencia.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">El sistema operativo no permite el <ph id="ph1">&lt;paramref name="access" /&gt;</ph> solicitado para el identificador de archivo especificado, como sucede, por ejemplo, cuando <ph id="ph2">&lt;paramref name="access" /&gt;</ph> es <ph id="ph3">&lt;see langword="Write" /&gt;</ph> o <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> y el identificador de archivo está establecido para el acceso de sólo lectura.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">para leer, escribir y anexar texto a archivos.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, y <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Constante que determina cómo abrir o crear el archivo.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path and creation mode.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con el modo de creación y la ruta de acceso especificados.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">El <ph id="ph1">`path`</ph> parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the <ph id="ph1">`FileStream`</ph> object has been closed, but read attempts will succeed).</source>
          <target state="translated">El constructor se concede acceso de lectura/escritura al archivo y se abre compartiendo el acceso de lectura (es decir, las solicitudes para abrir el archivo para escritura por esta u otro proceso producirá errores hasta que el <ph id="ph1">`FileStream`</ph> se ha cerrado el objeto, pero los intentos de lectura se realice correctamente).</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a <ph id="ph1">`FileAccess`</ph> parameter with the value set to <ph id="ph2">`FileAccess.Read`</ph>.</source>
          <target state="translated">No se puede utilizar este constructor para abrir archivos de solo lectura; en su lugar, debe usar un constructor que acepta un <ph id="ph1">`FileAccess`</ph> parámetro con el valor establecido en <ph id="ph2">`FileAccess.Read`</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The buffer size is set to the default size of 4096 bytes (4 KB).</source>
          <target state="translated">El tamaño del búfer se establece en el tamaño predeterminado de 4096 bytes (4 KB).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> es <ph id="ph2">`true`</ph> para todos los <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objetos que encapsulan archivos.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`path`</ph> indica un dispositivo que no admite búsquedas, el <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> propiedad resultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> es <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información adicional, vea <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> es el valor predeterminado para los <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructores sin un <ph id="ph3">`FileShare`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>For constructors without a <ph id="ph1">&lt;xref:System.IO.FileAccess&gt;</ph> parameter, if the <ph id="ph2">`mode`</ph> parameter is set to <ph id="ph3">&lt;xref:System.IO.FileMode.Append&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileAccess.Write&gt;</ph> is the default access.</source>
          <target state="translated">Para los constructores sin un <ph id="ph1">&lt;xref:System.IO.FileAccess&gt;</ph> parámetro, si la <ph id="ph2">`mode`</ph> parámetro está establecido en <ph id="ph3">&lt;xref:System.IO.FileMode.Append&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileAccess.Write&gt;</ph> es el acceso predeterminado.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>Otherwise, the access is set to <ph id="ph1">&lt;xref:System.IO.FileAccess.ReadWrite&gt;</ph>.</source>
          <target state="translated">En caso contrario, el acceso está establecido en <ph id="ph1">&lt;xref:System.IO.FileAccess.ReadWrite&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo escribir datos en un archivo, byte a byte y, a continuación, compruebe que los datos se han escrito correctamente.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">No se encuentra el archivo, como cuando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> es <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, y no existe el archivo especificado por <ph id="ph4">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">El archivo ya debe existir en estos modos.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Se produce un error de E/S, como cuando se especifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> y ya existe el archivo especificado por <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The stream has been closed.</source>
          <target state="translated">Se ha cerrado la secuencia.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">La ruta de acceso especificada no es válida, por ejemplo, está en una unidad no asignada.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contiene un valor no válido.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">para leer, escribir y anexar texto a archivos.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, y <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>A file handle for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Identificador de archivo para el archivo que el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> actual va a encapsular.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> constant that sets the <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph3">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph4">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Constante <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> que establece las propiedades <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> y <ph id="ph3">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> del objeto <ph id="ph4">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valor <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> positivo mayor que 0 que indica el tamaño del búfer.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">El tamaño de búfer predeterminado es 4096.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission, and buffer size.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> para el identificador de archivo especificado, con el tamaño de búfer y el permiso de lectura y escritura especificados.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> se da por supuesto que tiene control exclusivo sobre el identificador.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">Lectura, escritura o búsqueda mientras un <ph id="ph1">`FileStream`</ph> también contiene un identificador podría provocar daños en los datos.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">Por motivos de seguridad de datos, llame a <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> antes de utilizar el identificador y evite llamar a cualquier método distinto de <ph id="ph2">`Close`</ph> cuando haya terminado con el identificador.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
          <target state="translated">Como alternativa, leer y escribir en el controlador antes de llamar a este <ph id="ph1">`FileStream`</ph> constructor.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> es el valor predeterminado para los <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructores sin un <ph id="ph3">`FileShare`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> parameter is an invalid handle.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> no es un identificador válido.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> parameter is a synchronous handle and it was used asynchronously.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> es un identificador sincrónico y se utilizó de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> parameter is negative.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">Se produjo un error de E/S, como un error de disco.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The stream has been closed.</source>
          <target state="translated">Se ha cerrado la secuencia.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">El sistema operativo no permite el <ph id="ph1">&lt;paramref name="access" /&gt;</ph> solicitado para el identificador de archivo especificado, como sucede, por ejemplo, cuando <ph id="ph2">&lt;paramref name="access" /&gt;</ph> es <ph id="ph3">&lt;see langword="Write" /&gt;</ph> o <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> y el identificador de archivo está establecido para el acceso de sólo lectura.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">para leer, escribir y anexar texto a archivos.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, y <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">Para obtener permiso llamar a código no administrado.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>A file handle for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Identificador de archivo para el archivo que el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> actual va a encapsular.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Constante que establece las propiedades <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> y <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> del objeto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the file handle will be owned by this <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si esta instancia de <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> va a ser la propietaria del identificador de archivo; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission and <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance ownership.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> para el identificador de archivo especificado, con el permiso de lectura y escritura establecido y la propiedad de la instancia de <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified access to the file.</source>
          <target state="translated">El <ph id="ph1">`FileStream`</ph> se proporciona el acceso especificado al objeto en el archivo.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The ownership of the handle will be as specified.</source>
          <target state="translated">La propiedad del identificador será según se haya especificado.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>If this process owns the handle, a call to the <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> method will also close the handle and the file's handle count is decremented.</source>
          <target state="translated">Si este proceso posee el identificador, una llamada a la <ph id="ph1">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> método también cerrará el identificador y el recuento de identificadores del archivo va disminuyendo.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the default buffer size of 4096 bytes.</source>
          <target state="translated">La <ph id="ph1">`FileStream`</ph> objeto recibe el tamaño de búfer predeterminado de 4096 bytes.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> se da por supuesto que tiene control exclusivo sobre el identificador.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">Lectura, escritura o búsqueda mientras un <ph id="ph1">`FileStream`</ph> también contiene un identificador podría provocar daños en los datos.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">Por motivos de seguridad de datos, llame a <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> antes de utilizar el identificador y evite llamar a métodos distintos de <ph id="ph2">`Close`</ph> cuando haya terminado con el identificador.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> es el valor predeterminado para los <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructores sin un <ph id="ph3">`FileShare`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="access" /&gt;</ph> is not a field of <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="access" /&gt;</ph> no es un campo de <ph id="ph2">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">Se produjo un error de E/S, como un error de disco.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The stream has been closed.</source>
          <target state="translated">Se ha cerrado la secuencia.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">El sistema operativo no permite el <ph id="ph1">&lt;paramref name="access" /&gt;</ph> solicitado para el identificador de archivo especificado, como sucede, por ejemplo, cuando <ph id="ph2">&lt;paramref name="access" /&gt;</ph> es <ph id="ph3">&lt;see langword="Write" /&gt;</ph> o <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> y el identificador de archivo está establecido para el acceso de sólo lectura.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">para leer, escribir y anexar texto a archivos.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, y <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Constante que determina cómo abrir o crear el archivo.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Constante que determina cómo puede obtener acceso al archivo el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>This also determines the values returned by the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Esto también determina los valores que devuelven las propiedades <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> y <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> del objeto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> specifies a disk file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> si <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> especifica un archivo de disco.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, and read/write permission.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con el permiso de lectura y escritura, el modo de creación y la ruta de acceso especificados.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">El <ph id="ph1">`path`</ph> parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the <ph id="ph1">`FileStream`</ph> object has been closed, but read attempts will succeed).</source>
          <target state="translated">El constructor se concede acceso de lectura/escritura al archivo y se abre compartiendo el acceso de lectura (es decir, las solicitudes para abrir el archivo para escritura por esta u otro proceso producirá errores hasta que el <ph id="ph1">`FileStream`</ph> se ha cerrado el objeto, pero los intentos de lectura se realice correctamente).</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The buffer size is set to the default size of 4096 bytes (4 KB).</source>
          <target state="translated">El tamaño del búfer se establece en el tamaño predeterminado de 4096 bytes (4 KB).</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> es <ph id="ph2">`true`</ph> para todos los <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objetos que encapsulan archivos.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`path`</ph> indica un dispositivo que no admite búsquedas, el <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> propiedad resultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> es <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información adicional, vea <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> es el valor predeterminado para los <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructores sin un <ph id="ph3">`FileShare`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">No se encuentra el archivo, como cuando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> es <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, y no existe el archivo especificado por <ph id="ph4">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">El archivo ya debe existir en estos modos.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Se produce un error de E/S, como cuando se especifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> y ya existe el archivo especificado por <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The stream has been closed.</source>
          <target state="translated">Se ha cerrado la secuencia.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">El sistema operativo no permite el <ph id="ph1">&lt;paramref name="access" /&gt;</ph> solicitado para el <ph id="ph2">&lt;paramref name="path" /&gt;</ph> especificado, como sucede, por ejemplo, cuando <ph id="ph3">&lt;paramref name="access" /&gt;</ph> es <ph id="ph4">&lt;see langword="Write" /&gt;</ph> o <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> y el archivo o el directorio está establecido para el acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contiene un valor no válido.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">para leer, escribir y anexar texto a archivos.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, y <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>A file handle for the file that this <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Identificador de archivo para el archivo que este objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> va a encapsular.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Constante que establece las propiedades <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> y <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> del objeto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valor <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> positivo mayor que 0 que indica el tamaño del búfer.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">El tamaño de búfer predeterminado es 4096.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se abrió el identificador de forma asincrónica (es decir, en modo de E/S superpuesta); de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission, buffer size, and synchronous or asynchronous state.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> para el identificador de archivo especificado, y con el permiso de lectura y escritura, el tamaño de búfer y el estado sincrónico o asincrónico especificados.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>You set the <ph id="ph1">`isAsync`</ph> parameter to <ph id="ph2">`true`</ph> to open the file handle asynchronously.</source>
          <target state="translated">Establece el <ph id="ph1">`isAsync`</ph> parámetro <ph id="ph2">`true`</ph> para abrir el identificador de archivo de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>When the parameter is <ph id="ph1">`true`</ph>, the stream utilizes overlapped I/O to perform file operations asynchronously.</source>
          <target state="translated">Cuando el parámetro es <ph id="ph1">`true`</ph>, la secuencia utiliza E/S superpuesta para realizar operaciones de archivo de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>However, the parameter does not have to be <ph id="ph1">`true`</ph> to call the <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> method.</source>
          <target state="translated">Sin embargo, el parámetro no tiene que ser <ph id="ph1">`true`</ph> para llamar a la <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, o <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>When the <ph id="ph1">`isAsync`</ph> parameter is <ph id="ph2">`false`</ph> and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</source>
          <target state="translated">Cuando el <ph id="ph1">`isAsync`</ph> parámetro es <ph id="ph2">`false`</ph> y llama a la lectura asincrónica y las operaciones de escritura, no sigue se bloquea el subproceso de interfaz de usuario, pero la operación de E/S real se realiza de forma sincrónica.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> se da por supuesto que tiene control exclusivo sobre el identificador.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">Lectura, escritura o búsqueda mientras un <ph id="ph1">`FileStream`</ph> también contiene un identificador podría provocar daños en los datos.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">Por motivos de seguridad de datos, llame a <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> antes de utilizar el identificador y evite llamar a cualquier método distinto de <ph id="ph2">`Close`</ph> cuando haya terminado con el identificador.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
          <target state="translated">Como alternativa, leer y escribir en el controlador antes de llamar a este <ph id="ph1">`FileStream`</ph> constructor.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> es el valor predeterminado para los <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructores sin un <ph id="ph3">`FileShare`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> parameter is an invalid handle.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> no es un identificador válido.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> parameter is a synchronous handle and it was used asynchronously.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="handle" /&gt;</ph> es un identificador sincrónico y se utilizó de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> parameter is negative.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">Se produjo un error de E/S, como un error de disco.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The stream has been closed.</source>
          <target state="translated">Se ha cerrado la secuencia.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">El sistema operativo no permite el <ph id="ph1">&lt;paramref name="access" /&gt;</ph> solicitado para el identificador de archivo especificado, como sucede, por ejemplo, cuando <ph id="ph2">&lt;paramref name="access" /&gt;</ph> es <ph id="ph3">&lt;see langword="Write" /&gt;</ph> o <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> y el identificador de archivo está establecido para el acceso de sólo lectura.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">para leer, escribir y anexar texto a archivos.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, y <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">Para obtener permiso llamar a código no administrado.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>A file handle for the file that this <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Identificador de archivo para el archivo que este objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> va a encapsular.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Constante que establece las propiedades <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> y <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> del objeto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the file handle will be owned by this <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si esta instancia de <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> va a ser la propietaria del identificador de archivo; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valor <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> positivo mayor que 0 que indica el tamaño del búfer.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">El tamaño de búfer predeterminado es 4096.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission, <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance ownership, and buffer size.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> para el identificador de archivo especificado, con el tamaño de búfer, la propiedad de la instancia de <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> y el permiso de lectura y escritura especificados.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified access to the file.</source>
          <target state="translated">El <ph id="ph1">`FileStream`</ph> se proporciona el acceso especificado al objeto en el archivo.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The ownership of the handle will be as specified.</source>
          <target state="translated">La propiedad del identificador será según se haya especificado.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>If this <ph id="ph1">`FileStream`</ph> owns the handle, a call to the <ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> method will also close the handle.</source>
          <target state="translated">Si este <ph id="ph1">`FileStream`</ph> posee el identificador, una llamada a la <ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> método también cerrará el identificador.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>In particular, the file's handle count is decremented.</source>
          <target state="translated">En concreto, el recuento de identificadores del archivo es reducido.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified buffer size.</source>
          <target state="translated">El <ph id="ph1">`FileStream`</ph> se proporciona el tamaño de búfer especificado al objeto.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> se da por supuesto que tiene control exclusivo sobre el identificador.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">Lectura, escritura o búsqueda mientras un <ph id="ph1">`FileStream`</ph> también contiene un identificador podría provocar daños en los datos.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">Por motivos de seguridad de datos, llame a <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> antes de utilizar el identificador y evite llamar a cualquier método distinto de <ph id="ph2">`Close`</ph> cuando haya terminado con el identificador.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
          <target state="translated">Como alternativa, leer y escribir en el controlador antes de llamar a este <ph id="ph1">`FileStream`</ph> constructor.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> es el valor predeterminado para los <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructores sin un <ph id="ph3">`FileShare`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">Se produjo un error de E/S, como un error de disco.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The stream has been closed.</source>
          <target state="translated">Se ha cerrado la secuencia.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">El sistema operativo no permite el <ph id="ph1">&lt;paramref name="access" /&gt;</ph> solicitado para el identificador de archivo especificado, como sucede, por ejemplo, cuando <ph id="ph2">&lt;paramref name="access" /&gt;</ph> es <ph id="ph3">&lt;see langword="Write" /&gt;</ph> o <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> y el identificador de archivo está establecido para el acceso de sólo lectura.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">para leer, escribir y anexar texto a archivos.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, y <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Constante que determina cómo abrir o crear el archivo.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Constante que determina cómo puede obtener acceso al archivo el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>This also determines the values returned by the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Esto también determina los valores que devuelven las propiedades <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> y <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> del objeto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> specifies a disk file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> si <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> especifica un archivo de disco.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">Constante que determina cómo compartirán el archivo los procesos.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, read/write permission, and sharing permission.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con el permiso de uso compartido, el permiso de lectura y escritura, el modo de creación y la ruta de acceso especificados.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">El <ph id="ph1">`path`</ph> parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the <ph id="ph1">`FileStream`</ph> object has been closed, but read attempts will succeed).</source>
          <target state="translated">El constructor se concede acceso de lectura/escritura al archivo y se abre compartiendo el acceso de lectura (es decir, las solicitudes para abrir el archivo para escritura por esta u otro proceso producirá errores hasta que el <ph id="ph1">`FileStream`</ph> se ha cerrado el objeto, pero los intentos de lectura se realice correctamente).</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The buffer size is set to the default size of 4096 bytes (4 KB).</source>
          <target state="translated">El tamaño del búfer se establece en el tamaño predeterminado de 4096 bytes (4 KB).</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> es <ph id="ph2">`true`</ph> para todos los <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objetos que encapsulan archivos.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`path`</ph> indica un dispositivo que no admite búsquedas, el <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> propiedad resultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> es <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información adicional, vea <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph> method.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">No se encuentra el archivo, como cuando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> es <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, y no existe el archivo especificado por <ph id="ph4">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">El archivo ya debe existir en estos modos.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Se produce un error de E/S, como cuando se especifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> y ya existe el archivo especificado por <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The system is running Windows 98 or Windows 98 Second Edition and <ph id="ph1">&lt;paramref name="share" /&gt;</ph> is set to <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>.</source>
          <target state="translated">El sistema está ejecutando Windows 98 o Windows 98 Segunda edición y se ha establecido <ph id="ph1">&lt;paramref name="share" /&gt;</ph> en <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The stream has been closed.</source>
          <target state="translated">Se ha cerrado la secuencia.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">El sistema operativo no permite el <ph id="ph1">&lt;paramref name="access" /&gt;</ph> solicitado para el <ph id="ph2">&lt;paramref name="path" /&gt;</ph> especificado, como sucede, por ejemplo, cuando <ph id="ph3">&lt;paramref name="access" /&gt;</ph> es <ph id="ph4">&lt;see langword="Write" /&gt;</ph> o <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> y el archivo o el directorio está establecido para el acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contains an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> contiene un valor no válido.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">para leer, escribir y anexar texto a archivos.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, y <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>A file handle for the file that this <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Identificador de archivo para el archivo que este objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> va a encapsular.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>A constant that sets the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Constante que establece las propiedades <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> y <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> del objeto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the file handle will be owned by this <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si esta instancia de <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> va a ser la propietaria del identificador de archivo; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valor <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> positivo mayor que 0 que indica el tamaño del búfer.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">El tamaño de búfer predeterminado es 4096.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se abrió el identificador de forma asincrónica (es decir, en modo de E/S superpuesta); de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class for the specified file handle, with the specified read/write permission, <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> instance ownership, buffer size, and synchronous or asynchronous state.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> para el identificador de archivo especificado, con el estado sincrónico o asincrónico, el tamaño de búfer, la propiedad de la instancia de <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> y el permiso de lectura y escritura especificados.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified access to the file.</source>
          <target state="translated">El <ph id="ph1">`FileStream`</ph> se proporciona el acceso especificado al objeto en el archivo.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The ownership of the handle will be as specified.</source>
          <target state="translated">La propiedad del identificador será según se haya especificado.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>If this <ph id="ph1">`FileStream`</ph> owns the handle, a call to the <ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> method will also close the handle.</source>
          <target state="translated">Si este <ph id="ph1">`FileStream`</ph> posee el identificador, una llamada a la <ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph> método también cerrará el identificador.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>In particular, the file's handle count is decremented.</source>
          <target state="translated">En concreto, el recuento de identificadores del archivo es reducido.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`FileStream`</ph> object is given the specified buffer size.</source>
          <target state="translated">El <ph id="ph1">`FileStream`</ph> se proporciona el tamaño de búfer especificado al objeto.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source><ph id="ph1">`FileStream`</ph> assumes that it has exclusive control over the handle.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> se da por supuesto que tiene control exclusivo sobre el identificador.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>Reading, writing, or seeking while a <ph id="ph1">`FileStream`</ph> is also holding a handle could result in data corruption.</source>
          <target state="translated">Lectura, escritura o búsqueda mientras un <ph id="ph1">`FileStream`</ph> también contiene un identificador podría provocar daños en los datos.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>For data safety, call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> before using the handle, and avoid calling any methods other than <ph id="ph2">`Close`</ph> after you are done using the handle.</source>
          <target state="translated">Por motivos de seguridad de datos, llame a <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> antes de utilizar el identificador y evite llamar a cualquier método distinto de <ph id="ph2">`Close`</ph> cuando haya terminado con el identificador.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>Alternately, read and write to the handle before calling this <ph id="ph1">`FileStream`</ph> constructor.</source>
          <target state="translated">Como alternativa, leer y escribir en el controlador antes de llamar a este <ph id="ph1">`FileStream`</ph> constructor.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source><ph id="ph1">`FileShare.Read`</ph> is the default for those <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructors without a <ph id="ph3">`FileShare`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`FileShare.Read`</ph> es el valor predeterminado para los <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> constructores sin un <ph id="ph3">`FileShare`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="access" /&gt;</ph> is less than <ph id="ph2">&lt;see langword="FileAccess.Read" /&gt;</ph> or greater than <ph id="ph3">&lt;see langword="FileAccess.ReadWrite" /&gt;</ph> or <ph id="ph4">&lt;paramref name="bufferSize" /&gt;</ph> is less than or equal to 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="access" /&gt;</ph> es menor que <ph id="ph2">&lt;see langword="FileAccess.Read" /&gt;</ph> o mayor que <ph id="ph3">&lt;see langword="FileAccess.ReadWrite" /&gt;</ph> o <ph id="ph4">&lt;paramref name="bufferSize" /&gt;</ph> es menor que o igual a 0.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The handle is invalid.</source>
          <target state="translated">El identificador no es válido.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>An I/O error, such as a disk error, occurred.</source>
          <target state="translated">Se produjo un error de E/S, como un error de disco.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The stream has been closed.</source>
          <target state="translated">Se ha cerrado la secuencia.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified file handle, such as when <ph id="ph2">&lt;paramref name="access" /&gt;</ph> is <ph id="ph3">&lt;see langword="Write" /&gt;</ph> or <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> and the file handle is set for read-only access.</source>
          <target state="translated">El sistema operativo no permite el <ph id="ph1">&lt;paramref name="access" /&gt;</ph> solicitado para el identificador de archivo especificado, como sucede, por ejemplo, cuando <ph id="ph2">&lt;paramref name="access" /&gt;</ph> es <ph id="ph3">&lt;see langword="Write" /&gt;</ph> o <ph id="ph4">&lt;see langword="ReadWrite" /&gt;</ph> y el identificador de archivo está establecido para el acceso de sólo lectura.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>for access to unmanaged code.</source>
          <target state="translated">Para obtener acceso a código no administrado.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Constante que determina cómo abrir o crear el archivo.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Constante que determina cómo puede obtener acceso al archivo el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>This also determines the values returned by the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Esto también determina los valores que devuelven las propiedades <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> y <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> del objeto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> specifies a disk file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> si <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> especifica un archivo de disco.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">Constante que determina cómo compartirán el archivo los procesos.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valor <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> positivo mayor que 0 que indica el tamaño del búfer.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">El tamaño de búfer predeterminado es 4096.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, read/write and sharing permission, and buffer size.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con el tamaño de búfer, el permiso de lectura y escritura y de uso compartido, el modo de creación y la ruta de acceso especificados.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">El <ph id="ph1">`path`</ph> parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> es <ph id="ph2">`true`</ph> para todos los <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objetos que encapsulan archivos.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`path`</ph> indica un dispositivo que no admite búsquedas, el <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> propiedad resultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> es <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información adicional, vea <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> es un valor negativo o es cero.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contain an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph> o <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contienen un valor no válido.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">No se encuentra el archivo, como cuando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> es <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, y no existe el archivo especificado por <ph id="ph4">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">El archivo ya debe existir en estos modos.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Se produce un error de E/S, como cuando se especifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> y ya existe el archivo especificado por <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The system is running Windows 98 or Windows 98 Second Edition and <ph id="ph1">&lt;paramref name="share" /&gt;</ph> is set to <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>.</source>
          <target state="translated">El sistema está ejecutando Windows 98 o Windows 98 Segunda edición y se ha establecido <ph id="ph1">&lt;paramref name="share" /&gt;</ph> en <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The stream has been closed.</source>
          <target state="translated">Se ha cerrado la secuencia.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">El sistema operativo no permite el <ph id="ph1">&lt;paramref name="access" /&gt;</ph> solicitado para el <ph id="ph2">&lt;paramref name="path" /&gt;</ph> especificado, como sucede, por ejemplo, cuando <ph id="ph3">&lt;paramref name="access" /&gt;</ph> es <ph id="ph4">&lt;see langword="Write" /&gt;</ph> o <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> y el archivo o el directorio está establecido para el acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">para leer, escribir y anexar texto a archivos.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, y <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Constante que determina cómo abrir o crear el archivo.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Constante que determina cómo puede obtener acceso al archivo el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>This also determines the values returned by the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Esto también determina los valores que devuelven las propiedades <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> y <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> del objeto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> specifies a disk file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> si <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> especifica un archivo de disco.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">Constante que determina cómo compartirán el archivo los procesos.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valor <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> positivo mayor que 0 que indica el tamaño del búfer.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The default buffer size is 4096..</source>
          <target state="translated">El tamaño de búfer predeterminado es 4096.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>Specifies whether to use asynchronous I/O or synchronous I/O.</source>
          <target state="translated">Especifica si se va a utilizar E/S asincrónica o sincrónica.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>However, note that the underlying operating system might not support asynchronous I/O, so when specifying <ph id="ph1">&lt;see langword="true" /&gt;</ph>, the handle might be opened synchronously depending on the platform.</source>
          <target state="translated">Sin embargo, tenga en cuenta que el sistema operativo subyacente quizás no admita E/S asincrónica, por lo que cuando se especifica <ph id="ph1">&lt;see langword="true" /&gt;</ph>, puede que el identificador se abra de forma sincrónica en función de la plataforma.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>When opened asynchronously, the <ph id="ph1">&lt;see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> methods perform better on large reads or writes, but they might be much slower for small reads or writes.</source>
          <target state="translated">Cuando se abre de forma asincrónica, los métodos <ph id="ph1">&lt;see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> y <ph id="ph2">&lt;see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> proporcionan un rendimiento mejor en lecturas o escrituras grandes, pero es posible que sean mucho más lentos para lecturas o escrituras pequeñas.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>If the application is designed to take advantage of asynchronous I/O, set the <bpt id="p1">&lt;c&gt;</bpt>useAsync<ept id="p1">&lt;/c&gt;</ept> parameter to <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Si la aplicación se ha diseñado para aprovechar al máximo la E/S asincrónica, establezca el parámetro <bpt id="p1">&lt;c&gt;</bpt>useAsync<ept id="p1">&lt;/c&gt;</ept> en <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>Using asynchronous I/O correctly can speed up applications by as much as a factor of 10, but using it without redesigning the application for asynchronous I/O can decrease performance by as much as a factor of 10.</source>
          <target state="translated">El uso de la E/S asincrónica de forma correcta puede agilizar las aplicaciones en hasta un factor de 10, pero su uso sin volver a diseñar la aplicación para la E/S asincrónica puede disminuir el rendimiento en hasta un factor de 10.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, read/write and sharing permission, buffer size, and synchronous or asynchronous state.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con el estado sincrónico o asincrónico, el tamaño de búfer, el permiso de lectura y escritura y de uso compartido, el modo de creación y la ruta de acceso especificados.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">El <ph id="ph1">`path`</ph> parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> es <ph id="ph2">`true`</ph> para todos los <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objetos que encapsulan archivos.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`path`</ph> indica un dispositivo que no admite búsquedas, el <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> propiedad resultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> es <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información adicional, vea <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo escribir datos en un archivo de forma asincrónica y, a continuación, compruebe que los datos se han escrito correctamente.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>A <ph id="ph1">`State`</ph> object is created to pass information from the main thread to the <ph id="ph2">`EndReadCallback`</ph> and <ph id="ph3">`EndWriteCallback`</ph> methods.</source>
          <target state="translated">A <ph id="ph1">`State`</ph> objeto se crea para pasar información del subproceso principal en el <ph id="ph2">`EndReadCallback`</ph> y <ph id="ph3">`EndWriteCallback`</ph> métodos.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> es un valor negativo o es cero.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contain an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph> o <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contienen un valor no válido.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">No se encuentra el archivo, como cuando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> es <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, y no existe el archivo especificado por <ph id="ph4">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">El archivo ya debe existir en estos modos.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Se produce un error de E/S, como cuando se especifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> y ya existe el archivo especificado por <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The system is running Windows 98 or Windows 98 Second Edition and <ph id="ph1">&lt;paramref name="share" /&gt;</ph> is set to <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>.</source>
          <target state="translated">El sistema está ejecutando Windows 98 o Windows 98 Segunda edición y se ha establecido <ph id="ph1">&lt;paramref name="share" /&gt;</ph> en <ph id="ph2">&lt;see langword="FileShare.Delete" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The stream has been closed.</source>
          <target state="translated">Se ha cerrado la secuencia.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">El sistema operativo no permite el <ph id="ph1">&lt;paramref name="access" /&gt;</ph> solicitado para el <ph id="ph2">&lt;paramref name="path" /&gt;</ph> especificado, como sucede, por ejemplo, cuando <ph id="ph3">&lt;paramref name="access" /&gt;</ph> es <ph id="ph4">&lt;see langword="Write" /&gt;</ph> o <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> y el archivo o el directorio está establecido para el acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">para leer, escribir y anexar texto a archivos.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, y <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Constante que determina cómo abrir o crear el archivo.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines how the file can be accessed by the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Constante que determina cómo puede obtener acceso al archivo el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>This also determines the values returned by the <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> and <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> properties of the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> object.</source>
          <target state="translated">Esto también determina los valores que devuelven las propiedades <ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanRead" /&gt;</ph> y <ph id="ph2">&lt;see cref="P:System.IO.FileStream.CanWrite" /&gt;</ph> del objeto <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> if <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> specifies a disk file.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> es <ph id="ph2">&lt;see langword="true" /&gt;</ph> si <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> especifica un archivo de disco.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">Constante que determina cómo compartirán el archivo los procesos.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valor <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> positivo mayor que 0 que indica el tamaño del búfer.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">El tamaño de búfer predeterminado es 4096.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A value that specifies additional file options.</source>
          <target state="translated">Valor que especifica opciones de archivo adicionales.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, read/write and sharing permission, the access other FileStreams can have to the same file, the buffer size, and additional file options.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con la ruta de acceso, el modo de creación, los permisos de lectura y escritura y de uso compartido, el acceso que otras secuencias de archivos pueden tener al mismo archivo, el tamaño del búfer y otras opciones de archivo que se hayan especificado.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">`fileOptions`</ph> parameter is used to provide access to more advanced operations that can be leveraged when creating a <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">El <ph id="ph1">`fileOptions`</ph> parámetro se utiliza para proporcionar acceso a operaciones más avanzadas que se pueden aprovechar al crear un <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">El <ph id="ph1">`path`</ph> parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> es <ph id="ph2">`true`</ph> para todos los <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objetos que encapsulan archivos.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`path`</ph> indica un dispositivo que no admite búsquedas, el <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> propiedad resultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> es <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información adicional, vea <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The following example writes data to a file and then reads the data using the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">En el ejemplo siguiente se escribe datos en un archivo y, a continuación, lee los datos mediante la <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> es un valor negativo o es cero.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contain an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph> o <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contienen un valor no válido.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">No se encuentra el archivo, como cuando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> es <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, y no existe el archivo especificado por <ph id="ph4">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">El archivo ya debe existir en estos modos.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Se produce un error de E/S, como cuando se especifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> y ya existe el archivo especificado por <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The stream has been closed.</source>
          <target state="translated">Se ha cerrado la secuencia.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">El sistema operativo no permite el <ph id="ph1">&lt;paramref name="access" /&gt;</ph> solicitado para el <ph id="ph2">&lt;paramref name="path" /&gt;</ph> especificado, como sucede, por ejemplo, cuando <ph id="ph3">&lt;paramref name="access" /&gt;</ph> es <ph id="ph4">&lt;see langword="Write" /&gt;</ph> o <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> y el archivo o el directorio está establecido para el acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph> is specified for <ph id="ph2">&lt;paramref name="options" /&gt;</ph>, but file encryption is not supported on the current platform.</source>
          <target state="translated">Se ha especificado <ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph> para <ph id="ph2">&lt;paramref name="options" /&gt;</ph>, pero el cifrado de archivos no se admite en la plataforma actual.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">para leer, escribir y anexar texto a archivos.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, y <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Constante que determina cómo abrir o crear el archivo.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines the access rights to use when creating access and audit rules for the file.</source>
          <target state="translated">Constante que determina los derechos de acceso que se emplean al crear reglas de acceso y auditoría para el archivo.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">Constante que determina cómo compartirán el archivo los procesos.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valor <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> positivo mayor que 0 que indica el tamaño del búfer.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">El tamaño de búfer predeterminado es 4096.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>A constant that specifies additional file options.</source>
          <target state="translated">Constante que especifica opciones de archivo adicionales.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, access rights and sharing permission, the buffer size, and additional file options.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con la ruta de acceso, el modo de creación, los derechos de acceso y el permiso de uso compartido, el tamaño de búfer y opciones de archivo adicionales que se hayan especificado.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>Use this <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%2A&gt;</ph> constructor to apply access rights at the point of creation of a file.</source>
          <target state="translated">Utilícelo <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%2A&gt;</ph> constructor al que aplicar el acceso de derechos en el momento de creación de un archivo.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>To access or modify rights on an existing file, consider using the <ph id="ph1">&lt;xref:System.IO.File.GetAccessControl%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.File.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">Para obtener acceso o modificar los derechos en un archivo existente, considere el uso de la <ph id="ph1">&lt;xref:System.IO.File.GetAccessControl%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IO.File.SetAccessControl%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">`fileOptions`</ph> parameter is used to provide access to more advanced operations that can be leveraged when creating a <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">El <ph id="ph1">`fileOptions`</ph> parámetro se utiliza para proporcionar acceso a operaciones más avanzadas que se pueden aprovechar al crear un <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">El <ph id="ph1">`path`</ph> parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> es <ph id="ph2">`true`</ph> para todos los <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objetos que encapsulan archivos.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`path`</ph> indica un dispositivo que no admite búsquedas, el <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> propiedad resultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> es <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información adicional, vea <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> es un valor negativo o es cero.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contain an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph> o <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contienen un valor no válido.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">No se encuentra el archivo, como cuando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> es <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, y no existe el archivo especificado por <ph id="ph4">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">El archivo ya debe existir en estos modos.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The current operating system is not Windows NT or later.</source>
          <target state="translated">El sistema operativo actual no es Windows NT o una versión posterior.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Se produce un error de E/S, como cuando se especifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> y ya existe el archivo especificado por <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The stream has been closed.</source>
          <target state="translated">Se ha cerrado la secuencia.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">El sistema operativo no permite el <ph id="ph1">&lt;paramref name="access" /&gt;</ph> solicitado para el <ph id="ph2">&lt;paramref name="path" /&gt;</ph> especificado, como sucede, por ejemplo, cuando <ph id="ph3">&lt;paramref name="access" /&gt;</ph> es <ph id="ph4">&lt;see langword="Write" /&gt;</ph> o <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> y el archivo o el directorio está establecido para el acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph> is specified for <ph id="ph2">&lt;paramref name="options" /&gt;</ph>, but file encryption is not supported on the current platform.</source>
          <target state="translated">Se ha especificado <ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph> para <ph id="ph2">&lt;paramref name="options" /&gt;</ph>, pero el cifrado de archivos no se admite en la plataforma actual.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>The specified <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">El valor especificado para <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">para leer, escribir y anexar texto a archivos.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, y <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A relative or absolute path for the file that the current <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object will encapsulate.</source>
          <target state="translated">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A constant that determines how to open or create the file.</source>
          <target state="translated">Constante que determina cómo abrir o crear el archivo.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A constant that determines the access rights to use when creating access and audit rules for the file.</source>
          <target state="translated">Constante que determina los derechos de acceso que se emplean al crear reglas de acceso y auditoría para el archivo.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A constant that determines how the file will be shared by processes.</source>
          <target state="translated">Constante que determina cómo compartirán el archivo los procesos.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A positive <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value greater than 0 indicating the buffer size.</source>
          <target state="translated">Valor <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> positivo mayor que 0 que indica el tamaño del búfer.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The default buffer size is 4096.</source>
          <target state="translated">El tamaño de búfer predeterminado es 4096.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A constant that specifies additional file options.</source>
          <target state="translated">Constante que especifica opciones de archivo adicionales.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>A constant that determines the access control and audit security for the file.</source>
          <target state="translated">Constante que determina el control de acceso y la seguridad de auditoría del archivo.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> class with the specified path, creation mode, access rights and sharing permission, the buffer size, additional file options, access control and audit security.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> con la ruta de acceso, el modo de creación, los derechos de acceso y el permiso de uso compartido, el tamaño de búfer, las opciones de archivo adicionales, el control de acceso y la seguridad de auditoría que se hayan especificado.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>Use this <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%2A&gt;</ph> constructor to apply access rights at the point of creation of a file.</source>
          <target state="translated">Utilícelo <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%2A&gt;</ph> constructor al que aplicar el acceso de derechos en el momento de creación de un archivo.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>To access or modify rights on an existing file, consider using the <ph id="ph1">&lt;xref:System.IO.File.GetAccessControl%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.File.SetAccessControl%2A&gt;</ph> methods.</source>
          <target state="translated">Para obtener acceso o modificar los derechos en un archivo existente, considere el uso de la <ph id="ph1">&lt;xref:System.IO.File.GetAccessControl%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IO.File.SetAccessControl%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The <ph id="ph1">`fileOptions`</ph> parameter is used to provide access to more advanced operations that can be leveraged when creating a <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">El <ph id="ph1">`fileOptions`</ph> parámetro se utiliza para proporcionar acceso a operaciones más avanzadas que se pueden aprovechar al crear un <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The <ph id="ph1">`path`</ph> parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</source>
          <target state="translated">El <ph id="ph1">`path`</ph> parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">`path`</ph> is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</source>
          <target state="translated"><ph id="ph1">`path`</ph> no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>For example, depending on the system, this class can access a physical device.</source>
          <target state="translated">Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> is <ph id="ph2">`true`</ph> for all <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objects that encapsulate files.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph> es <ph id="ph2">`true`</ph> para todos los <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> objetos que encapsulan archivos.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>If <ph id="ph1">`path`</ph> indicates a device that does not support seeking, the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property on the resulting <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> is <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">`path`</ph> indica un dispositivo que no admite búsquedas, el <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> propiedad resultante <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> es <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información adicional, vea <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</source>
          <target state="translated">Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The following example writes data to a file and then reads the data using the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object.</source>
          <target state="translated">En el ejemplo siguiente se escribe datos en un archivo y, a continuación, lee los datos mediante la <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is an empty string (""), contains only white space, or contains one or more invalid characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> es un valor negativo o es cero.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contain an invalid value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph>, <ph id="ph2">&lt;paramref name="access" /&gt;</ph> o <ph id="ph3">&lt;paramref name="share" /&gt;</ph> contienen un valor no válido.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The file cannot be found, such as when <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> or <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, and the file specified by <ph id="ph4">&lt;paramref name="path" /&gt;</ph> does not exist.</source>
          <target state="translated">No se encuentra el archivo, como cuando <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> es <ph id="ph2">&lt;see langword="FileMode.Truncate" /&gt;</ph> o <ph id="ph3">&lt;see langword="FileMode.Open" /&gt;</ph>, y no existe el archivo especificado por <ph id="ph4">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The file must already exist in these modes.</source>
          <target state="translated">El archivo ya debe existir en estos modos.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>An I/O error, such as specifying <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> when the file specified by <ph id="ph2">&lt;paramref name="path" /&gt;</ph> already exists, occurred.</source>
          <target state="translated">Se produce un error de E/S, como cuando se especifica <ph id="ph1">&lt;see langword="FileMode.CreateNew" /&gt;</ph> y ya existe el archivo especificado por <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The stream has been closed.</source>
          <target state="translated">Se ha cerrado la secuencia.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The specified path is invalid, such as being on an unmapped drive.</source>
          <target state="translated">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The <ph id="ph1">&lt;paramref name="access" /&gt;</ph> requested is not permitted by the operating system for the specified <ph id="ph2">&lt;paramref name="path" /&gt;</ph>, such as when <ph id="ph3">&lt;paramref name="access" /&gt;</ph> is <ph id="ph4">&lt;see langword="Write" /&gt;</ph> or <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> and the file or directory is set for read-only access.</source>
          <target state="translated">El sistema operativo no permite el <ph id="ph1">&lt;paramref name="access" /&gt;</ph> solicitado para el <ph id="ph2">&lt;paramref name="path" /&gt;</ph> especificado, como sucede, por ejemplo, cuando <ph id="ph3">&lt;paramref name="access" /&gt;</ph> es <ph id="ph4">&lt;see langword="Write" /&gt;</ph> o <ph id="ph5">&lt;see langword="ReadWrite" /&gt;</ph> y el archivo o el directorio está establecido para el acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source><ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph> is specified for <ph id="ph2">&lt;paramref name="options" /&gt;</ph>, but file encryption is not supported on the current platform.</source>
          <target state="translated">Se ha especificado <ph id="ph1">&lt;see cref="F:System.IO.FileOptions.Encrypted" /&gt;</ph> para <ph id="ph2">&lt;paramref name="options" /&gt;</ph>, pero el cifrado de archivos no se admite en la plataforma actual.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The specified <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">El valor especificado para <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Por ejemplo, en plataformas basadas en Windows, las rutas de acceso deben tener menos de 248 caracteres y los nombres de archivo deben tener menos de 260 caracteres.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>The current operating system is not Windows NT or later.</source>
          <target state="translated">El sistema operativo actual no es Windows NT o una versión posterior.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>for reading, writing, and appending to files.</source>
          <target state="translated">para leer, escribir y anexar texto a archivos.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)">
          <source>Associated enumerations: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, and <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</source>
          <target state="translated">Enumeraciones asociadas: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph>, y <ph id="ph3">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The buffer to read data into.</source>
          <target state="translated">Búfer en el que se leen los datos.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The byte offset in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which to begin reading.</source>
          <target state="translated">Desplazamiento de bytes de <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> donde va a comenzar la lectura.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">Número máximo de bytes que se pueden leer.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The method to be called when the asynchronous read operation is completed.</source>
          <target state="translated">Método al que se va a llamar cuando se complete la operación de lectura asincrónica.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous read request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de lectura asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous read operation.</source>
          <target state="translated">Comienza una operación de lectura asincrónica.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">(Considere usar <ph id="ph1">&lt;see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> en su lugar).</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that references the asynchronous read.</source>
          <target state="translated">Objeto que hace referencia a la lectura asincrónica.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">.NET Framework 4 y versiones anteriores, tendrá que usar métodos como <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> para implementar operaciones de archivo asincrónicas.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">Estos métodos siguen estando disponibles en la <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> para admitir código heredado; sin embargo, los nuevos métodos asincrónicos, como <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, y <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, ayuda implementar operaciones de archivo asincrónicas más fácilmente.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> must be called exactly once for every call to <ph id="ph2">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> debe llamar exactamente una vez por cada llamada a <ph id="ph2">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</source>
          <target state="translated">Si no se finaliza un proceso de lectura antes de comenzar otra lectura puede provocar un comportamiento no deseado, como el interbloqueo.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> provides two different modes of operation: synchronous I/O and asynchronous I/O.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> proporciona dos modos diferentes de operación: E/S sincrónica y E/S asincrónica.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>While either can be used, the underlying operating system resources might allow access in only one of these modes.</source>
          <target state="translated">Aunque se puede utilizar cualquiera, los recursos del sistema operativo subyacente pueden permitir el acceso sólo en uno de estos modos.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>By default, <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> opens the operating system handle synchronously.</source>
          <target state="translated">De forma predeterminada, <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> abre el identificador del sistema operativo de forma sincrónica.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>In Windows, this slows down asynchronous methods.</source>
          <target state="translated">En Windows, esto ralentiza los métodos asincrónicos.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>If asynchronous methods are used, use the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Si se utilizan métodos asincrónicos, utilice la <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> propiedad para determinar si la instancia actual admite operaciones de lectura.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanRead%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información adicional, vea <ph id="ph1">&lt;xref:System.IO.Stream.CanRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
          <target state="translated">Si una secuencia está cerrada o se pasa un argumento no válido, se producirán inmediatamente excepciones de <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Errors that occur during an asynchronous read request, such as a disk failure during the IO request, occur on the thread pool thread and become visible upon a call to <ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph>.</source>
          <target state="translated">Errores que se producen durante una solicitud de lectura asincrónica, como un error de disco durante la solicitud de E/S, tienen lugar en el subproceso del grupo y se hacen visibles en una llamada a <ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph> must be called with this <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to find out how many bytes were read.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph> se debe llamar a este <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> para averiguar el número de bytes que se leyeron.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Multiple simultaneous asynchronous requests render the request completion order uncertain.</source>
          <target state="translated">Varias solicitudes asincrónicas simultáneas representan el orden de finalización de la solicitud no sabe con seguridad.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The array length minus <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph>.</source>
          <target state="translated">La longitud de la matriz menos <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> es menor que <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>An asynchronous read was attempted past the end of the file.</source>
          <target state="translated">Se intentó efectuar una lectura asincrónica más allá del final del archivo.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The buffer containing data to write to the current stream.</source>
          <target state="translated">Búfer que contiene los datos que se van a escribir en la secuencia actual.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which to begin copying bytes to the current stream.</source>
          <target state="translated">Desplazamiento de bytes de base cero de <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> donde comenzar a copiar bytes en la secuencia actual.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Número máximo de bytes que se pueden escribir.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The method to be called when the asynchronous write operation is completed.</source>
          <target state="translated">Método al que se va a llamar cuando se complete la operación de escritura asincrónica.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous write request from other requests.</source>
          <target state="translated">Objeto proporcionado por el usuario que distingue esta solicitud de lectura asincrónica de otras.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous write operation.</source>
          <target state="translated">Comienza una operación de escritura asincrónica.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">(Considere usar <ph id="ph1">&lt;see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> en su lugar).</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that references the asynchronous write.</source>
          <target state="translated">Objeto que hace referencia a la escritura asincrónica.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">.NET Framework 4 y versiones anteriores, tendrá que usar métodos como <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> para implementar operaciones de archivo asincrónicas.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">Estos métodos siguen estando disponibles en la <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> para admitir código heredado; sin embargo, los nuevos métodos asincrónicos, como <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, y <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, ayuda implementar operaciones de archivo asincrónicas más fácilmente.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> must be called exactly once on every <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> from <ph id="ph3">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> se debe llamar exactamente una vez en cada <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> de <ph id="ph3">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> will block until the I/O operation has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> se bloqueará hasta que se complete la operación de E/S.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.BeginWrite%2A&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.BeginWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> provides two different modes of operation: synchronous I/O and asynchronous I/O.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> proporciona dos modos diferentes de operación: E/S sincrónica y E/S asincrónica.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>While either can be used, the underlying operating system resources might allow access in only one of these modes.</source>
          <target state="translated">Aunque se puede utilizar cualquiera, los recursos del sistema operativo subyacente pueden permitir el acceso sólo en uno de estos modos.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>By default, <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> opens the operating system handle synchronously.</source>
          <target state="translated">De forma predeterminada, <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> abre el identificador del sistema operativo de forma sincrónica.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>In Windows, this slows down asynchronous methods.</source>
          <target state="translated">En Windows, esto ralentiza los métodos asincrónicos.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>If asynchronous methods are used, use the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Si se utilizan métodos asincrónicos, utilice la <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</source>
          <target state="translated">Si una secuencia está cerrada o se pasa un argumento no válido, se producirán inmediatamente excepciones de <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Errors that occur during an asynchronous write request, such as a disk failure during the IO request, occur on the thread pool thread and become visible upon a call to <ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph>.</source>
          <target state="translated">Errores que se producen durante una solicitud de escritura asincrónica, como un error de disco durante la solicitud de E/S, tienen lugar en el subproceso del grupo y se hacen visibles en una llamada a <ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Multiple simultaneous asynchronous requests render the request completion order uncertain.</source>
          <target state="translated">Varias solicitudes asincrónicas simultáneas representan el orden de finalización de la solicitud no sabe con seguridad.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> length minus <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> is less than <ph id="ph3">&lt;paramref name="numBytes" /&gt;</ph>.</source>
          <target state="translated">La longitud de <ph id="ph1">&lt;paramref name="array" /&gt;</ph> menos <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> es menor que <ph id="ph3">&lt;paramref name="numBytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="numBytes" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The stream does not support writing.</source>
          <target state="translated">La secuencia no admite escritura.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The stream is closed.</source>
          <target state="translated">La secuencia está cerrada.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>An I/O error occurred.</source>
          <target state="translated">Error de E/S.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.CanRead">
          <source>Gets a value indicating whether the current stream supports reading.</source>
          <target state="translated">Obtiene un valor que indica si la secuencia actual admite lectura.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream supports reading; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the stream is closed or was opened with write-only access.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la secuencia admite lectura; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> si la secuencia está cerrada o se abrió con acceso de solo escritura.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support reading, calls to the <ph id="ph2">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.ReadByte%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> methods throw a <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Si una clase derivada de <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> no admite la lectura, las llamadas a la <ph id="ph2">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.ReadByte%2A&gt;</ph>, y <ph id="ph4">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> métodos lanzan una <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Si la secuencia está cerrada, esta propiedad devuelve <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source>The following example demonstrates a use of the <ph id="ph1">`CanRead`</ph> property.</source>
          <target state="translated">En el ejemplo siguiente se muestra un uso de la <ph id="ph1">`CanRead`</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source>The output of this code is "MyFile.txt is not writable."</source>
          <target state="translated">El resultado de este código es "MyFile.txt no es grabable."</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanRead">
          <source>To get the output message "MyFile.txt can be both written to and read from.", change the <ph id="ph1">`FileAccess`</ph> parameter to <ph id="ph2">`ReadWrite`</ph> in the <ph id="ph3">`FileStream`</ph> constructor.</source>
          <target state="translated">Para obtener el mensaje de salida "MyFile.txt puede ser tanto escriben y se leen desde.", cambiar el <ph id="ph1">`FileAccess`</ph> parámetro <ph id="ph2">`ReadWrite`</ph> en el <ph id="ph3">`FileStream`</ph> constructor.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.CanSeek">
          <source>Gets a value indicating whether the current stream supports seeking.</source>
          <target state="translated">Obtiene un valor que indica si la secuencia actual admite búsquedas.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanSeek">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream supports seeking; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the stream is closed or if the <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> was constructed from an operating-system handle such as a pipe or output to the console.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la secuencia admite búsquedas; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> si la secuencia está cerrada o si <ph id="ph3">&lt;see langword="FileStream" /&gt;</ph> se construyó a partir de un identificador del sistema operativo, como una canalización o una salida a la consola.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanSeek">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support seeking, calls to <ph id="ph2">&lt;xref:System.IO.FileStream.Length%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.SetLength%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.Position%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> throw a <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Si una clase derivada de <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> no admite búsquedas, las llamadas a <ph id="ph2">&lt;xref:System.IO.FileStream.Length%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.SetLength%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.Position%2A&gt;</ph>, y <ph id="ph5">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> producir un <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanSeek">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Si la secuencia está cerrada, esta propiedad devuelve <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanSeek">
          <source>The following example uses the <ph id="ph1">`CanSeek`</ph> property to check whether a stream supports seeking.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">`CanSeek`</ph> propiedad para comprobar si una secuencia admite búsquedas.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.CanWrite">
          <source>Gets a value indicating whether the current stream supports writing.</source>
          <target state="translated">Obtiene un valor que indica si la secuencia actual admite escritura.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream supports writing; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the stream is closed or was opened with read-only access.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la secuencia admite escritura; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> si la secuencia está cerrada o se abrió con acceso de solo lectura.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support writing, a call to <ph id="ph2">&lt;xref:System.IO.FileStream.SetLength%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.IO.FileStream.WriteByte%2A&gt;</ph> throws a <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Si una clase derivada de <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> no admite la escritura, una llamada a <ph id="ph2">&lt;xref:System.IO.FileStream.SetLength%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.Write%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>, o <ph id="ph5">&lt;xref:System.IO.FileStream.WriteByte%2A&gt;</ph> produce una <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Si la secuencia está cerrada, esta propiedad devuelve <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>The following example uses the <ph id="ph1">`CanWrite`</ph> property to check whether a stream supports writing.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">`CanWrite`</ph> propiedad para comprobar si una secuencia admite escritura.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>The following is an example using the <ph id="ph1">`CanWrite`</ph> property.</source>
          <target state="translated">El siguiente es un ejemplo utilizando la <ph id="ph1">`CanWrite`</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>The output of this code is "MyFile.txt is writable."</source>
          <target state="translated">El resultado de este código es "MyFile.txt es grabable."</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.CanWrite">
          <source>To get the output message "MyFile.txt can be both written to and read from.", change the <ph id="ph1">`FileAccess`</ph> parameter to <ph id="ph2">`ReadWrite`</ph> in the <ph id="ph3">`FileStream`</ph> constructor.</source>
          <target state="translated">Para obtener el mensaje de salida "MyFile.txt puede ser tanto escriben y se leen desde.", cambiar el <ph id="ph1">`FileAccess`</ph> parámetro <ph id="ph2">`ReadWrite`</ph> en el <ph id="ph3">`FileStream`</ph> constructor.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> para liberar tanto recursos administrados como no administrados; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> para liberar únicamente recursos no administrados.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> and optionally releases the managed resources.</source>
          <target state="translated">Libera los recursos no administrados que usa <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> y, de forma opcional, libera los recursos administrados.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Se llama a este método público <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> método y <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> invokes the protected <ph id="ph2">&lt;xref:System.IO.FileStream.Dispose%2A&gt;</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> se invoca el protegido <ph id="ph2">&lt;xref:System.IO.FileStream.Dispose%2A&gt;</ph> método con el <ph id="ph3">`disposing`</ph> parámetro establecido en <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id="ph2">&lt;xref:System.IO.FileStream.Dispose%2A&gt;</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invoca <ph id="ph2">&lt;xref:System.IO.FileStream.Dispose%2A&gt;</ph> con <ph id="ph3">`disposing`</ph> establecido en <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> references.</source>
          <target state="translated">Cuando el parámetro <ph id="ph1">`disposing`</ph> es <ph id="ph2">`true`</ph>, este método libera todos los recursos retenidos por los objetos administrados a los que el control <ph id="ph3">&lt;xref:System.IO.FileStream&gt;</ph> hace referencia.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method of each referenced object.</source>
          <target state="translated">Este método invoca al método <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> de cada uno de los objetos a los que se hace referencia.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> puede recibir varias llamadas de otros objetos.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /&gt;</ph> be careful not to reference objects that have been previously disposed of in an earlier call to <ph id="ph2">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>.</source>
          <target state="translated">Al reemplazar <ph id="ph1">&lt;see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /&gt;</ph> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <ph id="ph2">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre cómo implementar <ph id="ph1">&lt;see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /&gt;</ph>, consulte <bpt id="p1">[</bpt>implementa un método Dispose<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de <ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> y <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, consulte <bpt id="p1">[</bpt>limpiar recursos no administrados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>The reference to the pending asynchronous request to wait for.</source>
          <target state="translated">Referencia a la solicitud asincrónica pendiente a la que se debe esperar.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>Waits for the pending asynchronous read operation to complete.</source>
          <target state="translated">Espera a que se complete la operación asincrónica de lectura que se encuentra pendiente.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">(Considere usar <ph id="ph1">&lt;see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> en su lugar).</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>The number of bytes read from the stream, between 0 and the number of bytes you requested.</source>
          <target state="translated">Número de bytes leídos de la secuencia, que se encuentra entre 0 y el número de bytes solicitado.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>Streams only return 0 at the end of the stream, otherwise, they should block until at least 1 byte is available.</source>
          <target state="translated">Las secuencias solo devuelven 0 al final de la secuencia; de lo contrario, se deben bloquear hasta que haya al menos 1 byte disponible.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">.NET Framework 4 y versiones anteriores, tendrá que usar métodos como <ph id="ph1">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> para implementar operaciones de archivo asincrónicas.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">Estos métodos siguen estando disponibles en la <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> para admitir código heredado; sin embargo, los nuevos métodos asincrónicos, como <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, y <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, ayuda implementar operaciones de archivo asincrónicas más fácilmente.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> must be called exactly for every call to <ph id="ph2">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> se debe llamar exactamente para todas las llamadas a <ph id="ph2">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</source>
          <target state="translated">Si no se finaliza un proceso de lectura antes de comenzar otra lectura puede provocar un comportamiento no deseado, como el interbloqueo.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> can be called on every <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> from <ph id="ph3">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> se puede llamar en cada <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> de <ph id="ph3">&lt;xref:System.IO.FileStream.BeginRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>Calling <ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> tells you how many bytes were read from the stream.</source>
          <target state="translated">Al llamar a <ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> indica el número de bytes leído de la secuencia.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> will block until the I/O operation has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndRead%2A&gt;</ph> se bloqueará hasta que se complete la operación de E/S.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>This <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object was not created by calling <ph id="ph2">&lt;see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> on this class.</source>
          <target state="translated">Este objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> no se creó mediante una llamada a <ph id="ph2">&lt;see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> en esta clase.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /&gt;</ph> is called multiple times.</source>
          <target state="translated">Se llama a <ph id="ph1">&lt;see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /&gt;</ph> varias veces.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndRead(System.IAsyncResult)">
          <source>The stream is closed or an internal error has occurred.</source>
          <target state="translated">La secuencia está cerrada o se produjo un error interno.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>The pending asynchronous I/O request.</source>
          <target state="translated">La solicitud de E/S asincrónica pendiente.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>Ends an asynchronous write operation and blocks until the I/O operation is complete.</source>
          <target state="translated">Termina una operación de escritura asincrónica y se bloquea hasta que se completa la operación de E/S.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">(Considere usar <ph id="ph1">&lt;see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> en su lugar).</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">.NET Framework 4 y versiones anteriores, tendrá que usar métodos como <ph id="ph1">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> para implementar operaciones de archivo asincrónicas.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">Estos métodos siguen estando disponibles en la <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> para admitir código heredado; sin embargo, los nuevos métodos asincrónicos, como <ph id="ph2">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph>, y <ph id="ph5">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph>, ayuda implementar operaciones de archivo asincrónicas más fácilmente.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.EndWrite%2A&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.EndWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> must be called exactly once on every <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> from <ph id="ph3">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> se debe llamar exactamente una vez en cada <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> de <ph id="ph3">&lt;xref:System.IO.FileStream.BeginWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> will block until the I/O operation has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.FileStream.EndWrite%2A&gt;</ph> se bloqueará hasta que se complete la operación de E/S.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>This <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object was not created by calling <ph id="ph2">&lt;see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> on this class.</source>
          <target state="translated">Este objeto <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> no se creó mediante una llamada a <ph id="ph2">&lt;see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> en esta clase.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /&gt;</ph> is called multiple times.</source>
          <target state="translated">Se llama a <ph id="ph1">&lt;see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /&gt;</ph> varias veces.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.EndWrite(System.IAsyncResult)">
          <source>The stream is closed or an internal error has occurred.</source>
          <target state="translated">La secuencia está cerrada o se produjo un error interno.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Finalize">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</source>
          <target state="translated">Garantiza que se liberen los recursos y se realicen otras operaciones de limpieza cuando el recolector de elementos no utilizados reclama <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Finalize">
          <source>The garbage collector calls <ph id="ph1">`Finalize`</ph> when the current object is ready to be finalized.</source>
          <target state="translated">El recolector de elementos no utilizados llame <ph id="ph1">`Finalize`</ph> cuando el objeto actual está preparado para finalizarse.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Finalize">
          <source><ph id="ph1">`Finalize`</ph> closes the <ph id="ph2">`FileStream`</ph>.</source>
          <target state="translated"><ph id="ph1">`Finalize`</ph> cierra el <ph id="ph2">`FileStream`</ph>.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="T:System.IO.FileStream">
          <source>Clears buffers for this stream and causes any buffered data to be written to the file.</source>
          <target state="translated">Borra los búferes de esta secuencia y hace que todos los datos almacenados en los búferes se escriban en el archivo.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Flush">
          <source>Clears buffers for this stream and causes any buffered data to be written to the file.</source>
          <target state="translated">Borra los búferes de esta secuencia y hace que todos los datos almacenados en los búferes se escriban en el archivo.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>When you call the <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType&gt;</ph> method, the operating system I/O buffer is also flushed.</source>
          <target state="translated">Cuando se llama a la <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType&gt;</ph> también se vacía en el método, el búfer de E/S del sistema operativo.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>A stream’s encoder is not flushed unless you explicitly call <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> or dispose of the object.</source>
          <target state="translated">Codificador de la secuencia no se vacía a menos que se llame explícitamente a <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> o eliminar el objeto.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>Setting <ph id="ph1">&lt;xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType&gt;</ph> to <ph id="ph2">`true`</ph> means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</source>
          <target state="translated">Establecer <ph id="ph1">&lt;xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType&gt;</ph> a <ph id="ph2">`true`</ph> significa que los datos se vaciarán del búfer en la secuencia, pero el estado del codificador no se vaciará.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</source>
          <target state="translated">Esto permite al codificador mantener su estado (caracteres parciales) para que sea posible codificar el siguiente bloque de caracteres correctamente.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</source>
          <target state="translated">Este escenario afecta a UTF8 y UTF7 donde ciertos caracteres sólo pueden codificarse después de que el codificador reciba el carácter o caracteres adyacentes.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>Because a buffer can be used for either reading or writing, <ph id="ph1">&lt;xref:System.IO.FileStream.Flush&gt;</ph> performs the following two functions:</source>
          <target state="translated">Dado que se puede utilizar un búfer para leer o escribir, <ph id="ph1">&lt;xref:System.IO.FileStream.Flush&gt;</ph> realiza las dos funciones siguientes:</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>Any data previously written to the buffer is copied to the file and the buffer is cleared except for its encoder state.</source>
          <target state="translated">Los datos escritos anteriormente en el búfer se copian en el archivo y se borra el búfer excepto el estado del codificador.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>If <ph id="ph1">&lt;xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType&gt;</ph> is <ph id="ph2">`true`</ph> and data was previously copied from the file to the buffer for reading, the current position within the file is decremented by the number of unread bytes in the buffer.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType&gt;</ph> es <ph id="ph2">`true`</ph> y anteriormente se copiaron los datos del archivo en el búfer para leer, la posición actual dentro del archivo se reduce el número de bytes no leídos en el búfer.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>The buffer is then cleared.</source>
          <target state="translated">A continuación, se borra el búfer.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%28System.Boolean%29&gt;</ph> method overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%28System.Boolean%29&gt;</ph> sobrecarga de método cuando desee asegurarse de que todos los datos almacenados en búfer en búferes de archivos intermedios se escriben en el disco.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph> method.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Flush">
          <source>An I/O error occurred.</source>
          <target state="translated">Error de E/S.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Flush">
          <source>The stream is closed.</source>
          <target state="translated">La secuencia está cerrada.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Flush(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to flush all intermediate file buffers; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para vaciar todos los búferes de archivos intermedios; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Flush(System.Boolean)">
          <source>Clears buffers for this stream and causes any buffered data to be written to the file, and also clears all intermediate file buffers.</source>
          <target state="translated">Borra los búferes de esta secuencia, hace que todos los datos almacenados en los búferes se escriban en el archivo y borra también todos los búferes de archivos intermedios.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush(System.Boolean)">
          <source>Use this overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.</source>
          <target state="translated">Utilice esta sobrecarga cuando desee asegurarse de que todos los datos almacenados en búfer en búferes de archivos intermedios se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Flush(System.Boolean)">
          <source>When you call the <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> method, the operating system I/O buffer is also flushed.</source>
          <target state="translated">Cuando se llama a la <ph id="ph1">&lt;xref:System.IO.FileStream.Flush%2A&gt;</ph> también se vacía en el método, el búfer de E/S del sistema operativo.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Token para supervisar solicitudes de cancelación.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</source>
          <target state="translated">Borra asincrónicamente todos los búferes del flujo actual, hace que todos los datos almacenados en el búfer se escriban en el dispositivo subyacente y supervisa las solicitudes de cancelación.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous flush operation.</source>
          <target state="translated">Tarea que representa la operación de vaciado asincrónico.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>When you call the <ph id="ph1">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph> method, the operating system I/O buffer is also flushed.</source>
          <target state="translated">Cuando se llama a la <ph id="ph1">&lt;xref:System.IO.FileStream.FlushAsync%2A&gt;</ph> también se vacía en el método, el búfer de E/S del sistema operativo.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">Si la operación se cancela antes de que finalice, la tarea devuelta contiene la <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> valor para el <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>If the handle to the file is disposed, the returned task contains the <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> exception in the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
          <target state="translated">Si se elimina el identificador del archivo, la tarea devuelta contiene la <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> excepción en el <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">Se ha eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> object that encapsulates the access control list (ACL) entries for the file described by the current <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object.</source>
          <target state="translated">Obtiene un objeto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> que encapsula las entradas de lista de control de acceso (ACL) del archivo descrito por el objeto <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>An object that encapsulates the access control settings for the file described by the current <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object.</source>
          <target state="translated">Objeto que encapsula la configuración de control de acceso correspondiente al archivo descrito por el objeto <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.GetAccessControl">
          <source>While the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class and <ph id="ph2">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> can be used to retrieve the access control list (ACL) entries of an existing file, consider using <ph id="ph3">&lt;xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> method, as it is easier to use.</source>
          <target state="translated">Mientras el <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> clase y <ph id="ph2">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> puede usarse para recuperar las entradas de lista (ACL) del control de acceso de un archivo existente, considere el uso de <ph id="ph3">&lt;xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType&gt;</ph> método, tal y como es más fácil de usar.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.GetAccessControl">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> method to retrieve the ACL entries for a file.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> método para recuperar las entradas ACL de un archivo.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.GetAccessControl">
          <source>An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file.</source>
          <target state="translated">Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo especificado.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.GetAccessControl">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Add or Remove Access Control List Entries<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</source>
          <target state="translated">Para más información, consulte <bpt id="p1">[</bpt>How to: Add or Remove Access Control List Entries<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept> (Cómo: Agregar o quitar entradas de la lista de control de acceso).</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>The file is closed.</source>
          <target state="translated">El archivo está cerrado.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>An I/O error occurred while opening the file.</source>
          <target state="translated">Se produjo un error de E/S al abrir el archivo.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>The file could not be found.</source>
          <target state="translated">No se encuentra el archivo.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>This operation is not supported on the current platform.</source>
          <target state="translated">Esta operación no es compatible con la plataforma actual.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.GetAccessControl">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Handle">
          <source>Gets the operating system file handle for the file that the current <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object encapsulates.</source>
          <target state="translated">Obtiene el identificador de archivo del sistema operativo correspondiente al archivo que el objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> encapsula.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>The operating system file handle for the file encapsulated by this <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> object, or -1 if the <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> has been closed.</source>
          <target state="translated">Identificador de archivo del sistema operativo correspondiente al archivo encapsulado por este objeto <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> o -1 si se ha cerrado <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>This property is an operating system handle for use with operating-system-provided system calls (such as <ph id="ph1">`ReadFile`</ph> on Windows).</source>
          <target state="translated">Esta propiedad es un identificador del sistema operativo para su uso con llamadas al sistema operativo proporcionadas por el sistema (como <ph id="ph1">`ReadFile`</ph> en Windows).</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>It will not work with C library functions that expect a file descriptor, such as <ph id="ph1">`fread`</ph>.</source>
          <target state="translated">No funcionará con funciones de la biblioteca de C que esperan un descriptor de archivo, como <ph id="ph1">`fread`</ph>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>The operating system handle might have been opened synchronously or asynchronously, depending on which <ph id="ph1">`FileStream`</ph> constructor was called.</source>
          <target state="translated">El identificador del sistema operativo puede haber ha abierto de forma sincrónica o asincrónica, dependiendo de qué <ph id="ph1">`FileStream`</ph> se ha llamado constructor.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property to discover whether this handle was opened asynchronously.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> propiedad para detectar si este identificador se abrió de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>In Win32, this means the handle was opened for overlapped IO, and it requires different parameters to <ph id="ph1">`ReadFile`</ph> and <ph id="ph2">`WriteFile`</ph>.</source>
          <target state="translated">En Win32, esto significa que se abrió el identificador para la E/S superpuesta y requiere parámetros distintos a <ph id="ph1">`ReadFile`</ph> y <ph id="ph2">`WriteFile`</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>Data corruption might occur if a <ph id="ph1">`FileStream`</ph> is created, its handle is passed, some operation moves the handle's file pointer, and then the <ph id="ph2">`FileStream`</ph> is used again.</source>
          <target state="translated">Pueden producirse daños en los datos si un <ph id="ph1">`FileStream`</ph> está creado, se pasa su identificador, alguna operación mueve el puntero de archivo del controlador y, a continuación, el <ph id="ph2">`FileStream`</ph> se vuelve a usar.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>Multiple threads cannot safely write to the same file simultaneously, and <ph id="ph1">`FileStream`</ph> buffering code assumes that it exclusively controls the handle.</source>
          <target state="translated">Varios subprocesos no se pueden escribir sin ningún riesgo en el mismo archivo simultáneamente, y <ph id="ph1">`FileStream`</ph> el código de búfer se da por supuesto que controla el identificador de forma exclusiva.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source><ph id="ph1">`FileStream`</ph> might throw an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> if <ph id="ph3">`FileStream`</ph> detects that some other process has moved the file pointer.</source>
          <target state="translated"><ph id="ph1">`FileStream`</ph> podría producir un <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> si <ph id="ph3">`FileStream`</ph> detecta que algún otro proceso ha movido el puntero de archivo.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>To avoid this, do not write any data into a portion of the file that <ph id="ph1">`FileStream`</ph> might have buffered, and restore the file pointer to the location it had when methods were last called on <ph id="ph2">`FileStream`</ph>.</source>
          <target state="translated">Para evitar esta situación, no escriba ningún dato en una parte del archivo que <ph id="ph1">`FileStream`</ph> posible que haya almacenado en búfer y restaurar el puntero de archivo en la ubicación que tenía cuando se llame por última vez métodos en <ph id="ph2">`FileStream`</ph>.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Handle">
          <source>The caller does not have the required permission.</source>
          <target state="translated">El llamador no dispone del permiso requerido.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>for the ability to access unmanaged code.</source>
          <target state="translated">la capacidad tener acceso a código no administrado.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph> Security action: <ph id="ph2">&lt;see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /&gt;</ph>.</source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph> acción de seguridad: <ph id="ph2">&lt;see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Handle">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.IsAsync">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> was opened asynchronously or synchronously.</source>
          <target state="translated">Obtiene un valor que indica si se abrió <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> de forma sincrónica o asincrónica.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> was opened asynchronously; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see langword="FileStream" /&gt;</ph> se abrió de forma asincrónica; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>The <ph id="ph1">`IsAsync`</ph> property detects whether the <ph id="ph2">`FileStream`</ph> handle was opened asynchronously, enabling your code to use the <ph id="ph3">&lt;xref:System.IO.FileStream.Handle%2A&gt;</ph> property correctly.</source>
          <target state="translated">El <ph id="ph1">`IsAsync`</ph> propiedad detecta si el <ph id="ph2">`FileStream`</ph> identificador se abrió de forma asincrónica, lo que permite el código para usar el <ph id="ph3">&lt;xref:System.IO.FileStream.Handle%2A&gt;</ph> propiedad correctamente.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>In Win32, <ph id="ph1">`IsAsync`</ph> being true means the handle was opened for overlapped I/O, and thus requires different parameters to <ph id="ph2">`ReadFile`</ph> and <ph id="ph3">`WriteFile`</ph>.</source>
          <target state="translated">En Win32, <ph id="ph1">`IsAsync`</ph> sea true significa el identificador se abrió para la E/S superpuesta y, por tanto, requiere parámetros distintos a <ph id="ph2">`ReadFile`</ph> y <ph id="ph3">`WriteFile`</ph>.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>You specify this value when you create an instance of the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class using a constructor that has an <ph id="ph2">`isAsync`</ph>, <ph id="ph3">`useAsync`</ph>, or <ph id="ph4">`options`</ph> parameter.</source>
          <target state="translated">Especifique este valor cuando se crea una instancia de la <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> clase utilizando un constructor que tiene un <ph id="ph2">`isAsync`</ph>, <ph id="ph3">`useAsync`</ph>, o <ph id="ph4">`options`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>When the property is <ph id="ph1">`true`</ph>, the stream utilizes overlapped I/O to perform file operations asynchronously.</source>
          <target state="translated">Cuando la propiedad es <ph id="ph1">`true`</ph>, la secuencia utiliza E/S superpuesta para realizar operaciones de archivo de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>However, the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property does not have to be <ph id="ph2">`true`</ph> to call the <ph id="ph3">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> method.</source>
          <target state="translated">Sin embargo, el <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> propiedad no tiene que ser <ph id="ph2">`true`</ph> para llamar a la <ph id="ph3">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph>, o <ph id="ph5">&lt;xref:System.IO.Stream.CopyToAsync%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>When the <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> property is <ph id="ph2">`false`</ph> and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</source>
          <target state="translated">Cuando el <ph id="ph1">&lt;xref:System.IO.FileStream.IsAsync%2A&gt;</ph> propiedad es <ph id="ph2">`false`</ph> y llama a la lectura asincrónica y las operaciones de escritura, no sigue se bloquea el subproceso de interfaz de usuario, pero la operación de E/S real se realiza de forma sincrónica.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.IsAsync">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Length">
          <source>Gets the length in bytes of the stream.</source>
          <target state="translated">Devuelve la longitud en bytes del flujo.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Length">
          <source>A long value representing the length of the stream in bytes.</source>
          <target state="translated">Un valor Long que representa la longitud de la secuencia en bytes.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Length">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Length">
          <source>The following example uses the <ph id="ph1">`Length`</ph> and <ph id="ph2">`Position`</ph> properties to check for an end-of-file condition.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">`Length`</ph> y <ph id="ph2">`Position`</ph> propiedades para comprobar una condición de final de archivo.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Length">
          <source><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> for this stream is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.IO.FileStream.CanSeek" /&gt;</ph> para esta secuencia es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Length">
          <source>An I/O error, such as the file being closed, occurred.</source>
          <target state="translated">Se produjo un error de E/S, como el cierre del archivo.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The beginning of the range to lock.</source>
          <target state="translated">Comienzo del intervalo que se va a bloquear.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The value of this parameter must be equal to or greater than zero (0).</source>
          <target state="translated">El valor de este parámetro debe ser igual o mayor que cero (0).</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The range to be locked.</source>
          <target state="translated">El intervalo que se va a bloquear.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>Prevents other processes from reading from or writing to the <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph>.</source>
          <target state="translated">Impide que otros procesos lean de <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> o escriban en él.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>Locking a range of a file stream gives the threads of the locking process exclusive access to that range of the file stream.</source>
          <target state="translated">Bloqueo de un intervalo de una secuencia de archivos proporciona los subprocesos de al proceso bloqueo acceso exclusivo a ese intervalo de la secuencia de archivos.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo bloquear parte de un archivo para que otro proceso no puede tener acceso a esa parte del archivo aunque tenga acceso de lectura/escritura al archivo.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>Run the program simultaneously in different command windows and investigate using the different console input options.</source>
          <target state="translated">Ejecutar el programa simultáneamente en ventanas de comandos diferentes e investigar utilizando las opciones de entrada de consola diferentes.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> o <ph id="ph2">&lt;paramref name="length" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The file is closed.</source>
          <target state="translated">El archivo se cierra.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Lock(System.Int64,System.Int64)">
          <source>The process cannot access the file because another process has locked a portion of the file.</source>
          <target state="translated">El proceso no puede obtener acceso al archivo porque otro proceso ha bloqueado una parte de este.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Name">
          <source>Gets the name of the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> that was passed to the constructor.</source>
          <target state="translated">Obtiene el nombre del <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> que se pasó al constructor.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Name">
          <source>A string that is the name of the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</source>
          <target state="translated">Cadena que es el nombre del <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Name">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Name">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Name">
          <source>for access to the path.</source>
          <target state="translated">Para obtener acceso a la ruta de acceso.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Name">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>Gets or sets the current position of this stream.</source>
          <target state="translated">Obtiene o establece la posición actual de esta secuencia.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>The current position of this stream.</source>
          <target state="translated">Posición actual de esta secuencia.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>Seeking to any location beyond the length of the stream is supported.</source>
          <target state="translated">Se admite la búsqueda en cualquier ubicación más allá de la longitud de la secuencia.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>When you seek beyond the length of the file, the file size grows.</source>
          <target state="translated">Cuando se busca más allá de la longitud del archivo, aumente el tamaño del archivo.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>In Microsoft Windows NT and newer, any data added to the end of the file is set to zero.</source>
          <target state="translated">En Microsoft Windows NT y versiones más recientes, los datos agregados al final del archivo se establecen en cero.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>In Microsoft Windows 98 or earlier, any data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream.</source>
          <target state="translated">En Microsoft Windows 98 o versiones anteriores, los datos agregados al final del archivo no se establecen en cero, lo que significa que los datos previamente eliminados está visible para la secuencia.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>Setting the position of the stream to a large value beyond the end of the stream in Windows 98 or earlier may result in an exception being raised.</source>
          <target state="translated">Establecer la posición de la secuencia en un valor grande más allá del final de la secuencia en Windows 98 o versiones anteriores puede provocar una excepción que se está generando.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.Position">
          <source>The following example uses the <ph id="ph1">`Length`</ph> and <ph id="ph2">`Position`</ph> properties to check for an end-of-file condition.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">`Length`</ph> y <ph id="ph2">`Position`</ph> propiedades para comprobar una condición de final de archivo.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>The stream does not support seeking.</source>
          <target state="translated">La secuencia no admite búsqueda.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>An I/O error occurred.</source>
          <target state="translated">Error de E/S.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> o -</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>The position was set to a very large value beyond the end of the stream in Windows 98 or earlier.</source>
          <target state="translated">La posición se estableció en un valor muy grande más allá del final de la secuencia en Windows 98 o versiones anteriores.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>Attempted to set the position to a negative value.</source>
          <target state="translated">Se intentó establecer la posición en un valor negativo.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.Position">
          <source>Attempted seeking past the end of a stream that does not support this.</source>
          <target state="translated">Se intentó buscar más allá del final de una secuencia que no admite esto.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>When this method returns, contains the specified byte array with the values between <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept> and (<bpt id="p2">&lt;c&gt;</bpt>offset<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1<bpt id="p4">&lt;c&gt;</bpt>)<ept id="p4">&lt;/c&gt;</ept> replaced by the bytes read from the current source.</source>
          <target state="translated">Cuando este método finaliza, contiene la matriz de bytes especificada con los valores comprendidos entre <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept> y (<bpt id="p2">&lt;c&gt;</bpt>offset<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1<bpt id="p4">&lt;c&gt;</bpt>)<ept id="p4">&lt;/c&gt;</ept> reemplazada por los bytes leídos del origen actual.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The byte offset in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which the read bytes will be placed.</source>
          <target state="translated">Desplazamiento de bytes de <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> donde se van a colocar los bytes leídos.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">Número máximo de bytes que se pueden leer.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Reads a block of bytes from the stream and writes the data in a given buffer.</source>
          <target state="translated">Lee un bloque de bytes de la secuencia y escribe los datos en un búfer dado.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The total number of bytes read into the buffer.</source>
          <target state="translated">Número total de bytes leídos en el búfer.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This might be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached.</source>
          <target state="translated">Puede ser menor que el número de bytes solicitado si ese número de bytes no está disponible actualmente o cero si se ha alcanzado el final de la secuencia.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Read%2A&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.Read%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`offset`</ph> parameter gives the offset of the byte in <ph id="ph2">`array`</ph> (the buffer index) at which to begin reading, and the <ph id="ph3">`count`</ph> parameter gives the maximum number of bytes to be read from this stream.</source>
          <target state="translated">El <ph id="ph1">`offset`</ph> parámetro indica el desplazamiento del byte en <ph id="ph2">`array`</ph> (el índice de búfer) en que se va a comenzar la lectura y el <ph id="ph3">`count`</ph> parámetro proporciona el número máximo de bytes que se lee en esta secuencia.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</source>
          <target state="translated">El valor devuelto es el número real de bytes leídos, o cero si se alcanza el final de la secuencia.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If the read operation is successful, the current position of the stream is advanced by the number of bytes read.</source>
          <target state="translated">Si la operación de lectura se realiza correctamente, la posición actual de la secuencia avanza por el número de bytes leídos.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If an exception occurs, the current position of the stream is unchanged.</source>
          <target state="translated">Si se produce una excepción, no se modifica la posición actual de la secuencia.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> method returns zero only after reaching the end of the stream.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> método devuelva cero únicamente después de alcanzar el final de la secuencia.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Otherwise, <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> always reads at least one byte from the stream before returning.</source>
          <target state="translated">En caso contrario, <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph> siempre lee al menos un byte de la secuencia antes de devolver.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If no data is available from the stream upon a call to <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, the method will block until at least one byte of data can be returned.</source>
          <target state="translated">Si no hay datos disponibles en la secuencia tras una llamada a <ph id="ph1">&lt;xref:System.IO.FileStream.Read%2A&gt;</ph>, el método se bloqueará hasta que se puede devolver al menos un byte de datos.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</source>
          <target state="translated">Una implementación es gratuita devolver menos bytes de los solicitados incluso si no se ha alcanzado el final de la secuencia.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> for reading primitive data types.</source>
          <target state="translated">Utilice <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> para leer los tipos de datos primitivos.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Do not interrupt a thread that is performing a read operation.</source>
          <target state="translated">No se interrumpirá un subproceso que está realizando una operación de lectura.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability.</source>
          <target state="translated">Aunque puede parecer que la aplicación para que se ejecute correctamente después de que el subproceso se desbloquea, la interrupción puede disminuir el rendimiento y la confiabilidad de la aplicación.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The following example reads the contents from a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> and writes it into another <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se lee el contenido de un <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> y lo escribe en otro <ph id="ph2">&lt;xref:System.IO.FileStream&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The stream does not support reading.</source>
          <target state="translated">La secuencia no admite lectura.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>An I/O error occurred.</source>
          <target state="translated">Error de E/S.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> describe an invalid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> describen un intervalo no válido en <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Methods were called after the stream was closed.</source>
          <target state="translated">Se efectuó una llamada a los métodos después de cerrar la secuencia.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write the data into.</source>
          <target state="translated">Búfer en el que se escriben los datos.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin writing data from the stream.</source>
          <target state="translated">Desplazamiento de bytes de <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> donde se van a empezar a escribir datos de la secuencia.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">Número máximo de bytes que se pueden leer.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Token para supervisar solicitudes de cancelación.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</source>
          <target state="translated">Lee de forma asincrónica una secuencia de bytes en la secuencia actual, se hace avanzar la posición dentro de la secuencia el número de bytes leídos y controla las solicitudes de cancelación.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous read operation.</source>
          <target state="translated">Tarea que representa la operación de lectura asincrónica.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The value of the <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> parameter contains the total number of bytes read into the buffer.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> contiene el número total de bytes leídos en el búfer.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</source>
          <target state="translated">El valor del resultado puede ser menor que el número de bytes solicitados si el número de bytes disponibles actualmente es menor que el número solicitado o puede ser 0 (cero) si se ha llegado al final de la secuencia.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph> method enables you to perform resource-intensive file operations without blocking the main thread.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.FileStream.ReadAsync%2A&gt;</ph> método le permite realizar operaciones de archivos de gran cantidad de recursos sin bloquear el subproceso principal.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>This performance consideration is particularly important in a <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> app or <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</source>
          <target state="translated">Esta consideración de rendimiento es especialmente importante en una aplicación de la <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> o una aplicación de <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> en que una operación de streaming prolongada puede bloquear el subproceso de interfaz de usuario y hacer que parezca que una aplicación ha dejado de responder.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The async methods are used in conjunction with the <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> keywords in Visual Basic and C#.</source>
          <target state="translated">Los métodos asincrónicos se usan junto con la <ph id="ph1">`async`</ph> y <ph id="ph2">`await`</ph> palabras clave en Visual Basic y C#.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> propiedad para determinar si la instancia actual admite operaciones de lectura.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">Si la operación se cancela antes de que finalice, la tarea devuelta contiene la <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> valor para el <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the handle to the file is disposed, the returned task contains the <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> exception in the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
          <target state="translated">Si se elimina el identificador del archivo, la tarea devuelta contiene la <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> excepción en el <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The following example shows how to read from a file asynchronously.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo se leen desde un archivo de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated">La suma de <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es mayor que la longitud del búfer.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream does not support reading.</source>
          <target state="translated">La secuencia no admite lectura.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">Se ha eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream is currently in use by a previous read operation.</source>
          <target state="translated">Una operación de lectura anterior está usando actualmente la secuencia.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadByte">
          <source>Reads a byte from the file and advances the read position one byte.</source>
          <target state="translated">Lee un byte del archivo y avanza la posición de lectura un byte.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadByte">
          <source>The byte, cast to an <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>, or -1 if the end of the stream has been reached.</source>
          <target state="translated">El byte, convertido en un <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>, o -1 si se ha alcanzado el final de la secuencia.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.ReadByte%2A&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.ReadByte%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.IO.FileStream.CanRead%2A&gt;</ph> propiedad para determinar si la instancia actual admite operaciones de lectura.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanRead%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información adicional, vea <ph id="ph1">&lt;xref:System.IO.Stream.CanRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo escribir datos en un archivo, byte a byte y, a continuación, compruebe que los datos se han escrito correctamente.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadByte">
          <source>The current stream does not support reading.</source>
          <target state="translated">La secuencia actual no admite lectura.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.ReadByte">
          <source>The current stream is closed.</source>
          <target state="translated">Se cierra la secuencia actual.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>The default implementation on <ph id="ph1">&lt;see langword="Stream" /&gt;</ph> creates a new single-byte array and then calls <ph id="ph2">&lt;see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /&gt;</ph>.</source>
          <target state="translated">La implementación predeterminada de <ph id="ph1">&lt;see langword="Stream" /&gt;</ph> crea una nueva matriz de un solo byte y, a continuación, se llama <ph id="ph2">&lt;see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>While this is formally correct, it is inefficient.</source>
          <target state="translated">Aunque esto es formalmente correcto, no es eficaz.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</source>
          <target state="translated">Cualquier secuencia que posea un búfer interno debe reemplazar este método y proporcionar una versión mucho más eficaz que lea el búfer directamente, evitando la asignación adicional de matrices en cada llamada.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.ReadByte">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>Gets a <ph id="ph1">&lt;see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /&gt;</ph> object that represents the operating system file handle for the file that the current <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object encapsulates.</source>
          <target state="translated">Obtiene un objeto <ph id="ph1">&lt;see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /&gt;</ph> que representa el identificador de archivos del sistema operativo correspondiente al archivo que el objeto <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> actual encapsula.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>An object that represents the operating system file handle for the file that the current <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object encapsulates.</source>
          <target state="translated">Objeto que representa el identificador de archivos del sistema operativo correspondiente al archivo que el objeto <ph id="ph1">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> actual encapsula.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> property automatically flushes the stream and sets the current stream position to 0.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> propiedad vacía la secuencia y establece la posición de la secuencia actual en 0 automáticamente.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>This allows the file to be moved or the stream position to be reset by another stream using the <ph id="ph1">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> returned by this property.</source>
          <target state="translated">Esto permite que el archivo que se va a mover o la posición de la secuencia restablecerán por otro flujo mediante la <ph id="ph1">&lt;xref:System.IO.FileStream.SafeFileHandle%2A&gt;</ph> devuelta por esta propiedad.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>for permission to call unmanaged code.</source>
          <target state="translated">Para obtener permiso llamar a código no administrado.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>Security action: Link Demand</source>
          <target state="translated">Acción de seguridad: petición de vínculo</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Enumeración asociada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.FileStream.SafeFileHandle">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The point relative to <bpt id="p1">&lt;c&gt;</bpt>origin<ept id="p1">&lt;/c&gt;</ept> from which to begin seeking.</source>
          <target state="translated">Punto con respecto a <bpt id="p1">&lt;c&gt;</bpt>origin<ept id="p1">&lt;/c&gt;</ept> desde el que se va a comenzar a buscar.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Specifies the beginning, the end, or the current position as a reference point for <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept>, using a value of type <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>.</source>
          <target state="translated">Especifica el comienzo, el final o la posición actual como un punto de referencia para <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept>, con un valor de tipo <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Sets the current position of this stream to the given value.</source>
          <target state="translated">Establece la posición actual de esta secuencia actual en el valor dado.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The new position in the stream.</source>
          <target state="translated">Nueva posición en la secuencia.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType&gt;</ph> property to determine whether the current instance supports seeking.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType&gt;</ph> propiedad para determinar si la instancia actual admite búsquedas.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obtener información adicional, vea <ph id="ph1">&lt;xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>You can seek to any location beyond the length of the stream.</source>
          <target state="translated">Se puede buscar en cualquier ubicación más allá de la longitud de la secuencia.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>When you seek beyond the length of the file, the file size grows.</source>
          <target state="translated">Cuando se busca más allá de la longitud del archivo, aumente el tamaño del archivo.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>In Windows NT and later versions, data added to the end of the file is set to zero.</source>
          <target state="translated">En Windows NT y versiones posteriores, los datos agregados al final del archivo se establecen en cero.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>In Windows 98 or earlier versions, data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream.</source>
          <target state="translated">En Windows 98 o versiones anteriores, los datos agregados al final del archivo no se establecen en cero, lo que significa que los datos previamente eliminados está visible para la secuencia.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo escribir datos en un archivo, byte a byte y, a continuación, compruebe que los datos se han escrito correctamente.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <ph id="ph1">&lt;xref:System.IO.SeekOrigin&gt;</ph> values with the <ph id="ph2">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se lee el texto en la dirección inversa, desde el final del archivo al principio del archivo, mediante el uso de los distintos <ph id="ph1">&lt;xref:System.IO.SeekOrigin&gt;</ph> los valores que tienen la <ph id="ph2">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>An I/O error occurred.</source>
          <target state="translated">Error de E/S.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The stream does not support seeking, such as if the <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> is constructed from a pipe or console output.</source>
          <target state="translated">La secuencia no admite operaciones Seek, como sucede cuando se crea <ph id="ph1">&lt;see langword="FileStream" /&gt;</ph> a partir de una canalización o una salida a la consola.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Seeking is attempted before the beginning of the stream.</source>
          <target state="translated">La búsqueda se intenta antes del comienzo de la secuencia.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Methods were called after the stream was closed.</source>
          <target state="translated">Se efectuó una llamada a los métodos después de cerrar la secuencia.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>An object that describes an ACL entry to apply to the current file.</source>
          <target state="translated">Objeto que describe una entrada ACL que se va a aplicar al archivo actual.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>Applies access control list (ACL) entries described by a <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> object to the file described by the current <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> object.</source>
          <target state="translated">Aplica las entradas de la lista de control de acceso (ACL) descritas por un objeto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.FileSecurity" /&gt;</ph> al archivo descrito por el objeto <ph id="ph2">&lt;see cref="T:System.IO.FileStream" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>While the <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> class and <ph id="ph2">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> can be used on an existing file, consider using the <ph id="ph3">&lt;xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph> method as it is easier to use.</source>
          <target state="translated">Mientras el <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> clase y <ph id="ph2">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> se pueden usar en un archivo existente, considere el uso de la <ph id="ph3">&lt;xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType&gt;</ph> método porque es más fácil de usar.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> method applies access control list (ACL) entries to a file that represents the noninherited ACL list.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> método aplica las entradas de lista (ACL) de control de acceso a un archivo que representa la lista ACL no heredada.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The ACL specified for the <ph id="ph1">`fileSecurity`</ph> parameter replaces the existing ACL for the file.</source>
          <target state="translated">La ACL especificada para el <ph id="ph1">`fileSecurity`</ph> parámetro reemplaza la ACL existente para el archivo.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>To add permissions for a new user, use the <ph id="ph1">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> method to obtain the existing ACL, modify it, and then use <ph id="ph2">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> to apply it back to the file.</source>
          <target state="translated">Para agregar permisos para un usuario nuevo, use la <ph id="ph1">&lt;xref:System.IO.FileStream.GetAccessControl%2A&gt;</ph> método para obtener la lista ACL existente, modificarlo y, a continuación, usar <ph id="ph2">&lt;xref:System.IO.FileStream.SetAccessControl%2A&gt;</ph> para aplicarlo al archivo.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file.</source>
          <target state="translated">Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo especificado.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Add or Remove Access Control List Entries<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept>.</source>
          <target state="translated">Para más información, consulte <bpt id="p1">[</bpt>How to: Add or Remove Access Control List Entries<ept id="p1">](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)</ept> (Cómo: Agregar o quitar entradas de la lista de control de acceso).</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The file is closed.</source>
          <target state="translated">El archivo está cerrado.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The <ph id="ph1">&lt;paramref name="fileSecurity" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="fileSecurity" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The file could not be found or modified.</source>
          <target state="translated">No se pudo encontrar o modificar el archivo.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)">
          <source>The current process does not have access to open the file.</source>
          <target state="translated">El proceso actual no tiene acceso para abrir el archivo.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>The new length of the stream.</source>
          <target state="translated">La nueva longitud de la secuencia.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>Sets the length of this stream to the given value.</source>
          <target state="translated">Establece la longitud de esta secuencia en el valor dado.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>If the given value is less than the current length of the stream, the stream is truncated.</source>
          <target state="translated">Si el valor especificado es menor que la longitud actual de la secuencia, se trunca la secuencia.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>In this scenario, if the current position is greater than the new length, the current position is moved to the last byte of the stream.</source>
          <target state="translated">En este escenario, si la posición actual es mayor que la nueva longitud, se mueve la posición actual hasta el último byte de la secuencia.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>If the given value is larger than the current length of the stream, the stream is expanded, and the current position remains the same.</source>
          <target state="translated">Si el valor especificado es mayor que la longitud actual de la secuencia, la secuencia se expande y la posición actual sigue siendo el mismo.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>If the stream is expanded, the contents of the stream between the old and the new length are undefined.</source>
          <target state="translated">Si la secuencia se expande, el contenido de la secuencia entre la antigua y la nueva longitud es indefinido.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>A stream must support both writing and seeking for <ph id="ph1">`SetLength`</ph> to work.</source>
          <target state="translated">Una secuencia debe admitir operaciones de escritura y de que deseen usar <ph id="ph1">`SetLength`</ph> para que funcione.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports writing, and the <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> property to determine whether seeking is supported.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> propiedad para determinar si la instancia actual admite operaciones de escritura y el <ph id="ph2">&lt;xref:System.IO.FileStream.CanSeek%2A&gt;</ph> propiedad para determinar si se admite la búsqueda.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</source>
          <target state="translated">Para más información, consulte <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IO.Stream.CanSeek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>An I/O error has occurred.</source>
          <target state="translated">Se produjo un error de E/S.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>The stream does not support both writing and seeking.</source>
          <target state="translated">La secuencia no admite operaciones de escritura ni de búsqueda.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.SetLength(System.Int64)">
          <source>Attempted to set the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter to less than 0.</source>
          <target state="translated">Se ha intentado establecer el parámetro <ph id="ph1">&lt;paramref name="value" /&gt;</ph> en menos de 0.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>The beginning of the range to unlock.</source>
          <target state="translated">El comienzo del intervalo que se va a desbloquear.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>The range to be unlocked.</source>
          <target state="translated">El intervalo que se va a desbloquear.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>Allows access by other processes to all or part of a file that was previously locked.</source>
          <target state="translated">Permite que otros procesos tengan acceso total o parcial a un archivo previamente bloqueado.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file .</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo bloquear parte de un archivo para que otro proceso no puede tener acceso a esa parte del archivo, aunque tenga acceso de lectura/escritura al archivo y, a continuación, desbloquear la parte especificada del archivo.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source>Run the program simultaneously in different command windows and investigate using the different console input options.</source>
          <target state="translated">Ejecutar el programa simultáneamente en ventanas de comandos diferentes e investigar utilizando las opciones de entrada de consola diferentes.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="position" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="position" /&gt;</ph> o <ph id="ph2">&lt;paramref name="length" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The buffer containing data to write to the stream.</source>
          <target state="translated">Búfer que contiene los datos que se van a escribir en la secuencia.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> from which to begin copying bytes to the stream.</source>
          <target state="translated">Desplazamiento de bytes de base cero de <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> desde donde se va a comenzar a copiar los bytes en la secuencia.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Número máximo de bytes que se pueden escribir.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Writes a block of bytes to the file stream.</source>
          <target state="translated">Escribe un bloque de bytes en la secuencia de archivo.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`offset`</ph> parameter gives the offset of the byte in <ph id="ph2">`array`</ph> (the buffer index) at which to begin copying, and the <ph id="ph3">`count`</ph> parameter gives the number of bytes that will be written to the stream.</source>
          <target state="translated">El <ph id="ph1">`offset`</ph> parámetro indica el desplazamiento del byte en <ph id="ph2">`array`</ph> (el índice de búfer) en el que se comienzan a copiar y el <ph id="ph3">`count`</ph> parámetro proporciona el número de bytes que se escribirán en la secuencia.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>If the write operation is successful, the current position of the stream is advanced by the number of bytes written.</source>
          <target state="translated">Si la operación de escritura se realiza correctamente, la posición actual de la secuencia avanza por el número de bytes escritos.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>If an exception occurs, the current position of the stream is unchanged.</source>
          <target state="translated">Si se produce una excepción, no se modifica la posición actual de la secuencia.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports writing.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> propiedad para determinar si la instancia actual admite escritura.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información adicional, vea <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Do not interrupt a thread that is performing a write operation.</source>
          <target state="translated">No se interrumpirá un subproceso que está realizando una operación de escritura.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability.</source>
          <target state="translated">Aunque puede parecer que la aplicación para que se ejecute correctamente después de que el subproceso se desbloquea, la interrupción puede disminuir el rendimiento y la confiabilidad de la aplicación.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph> method.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.FileStream.Lock%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> describe an invalid range in <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> describen un intervalo no válido en <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>An I/O error occurred.</source>
          <target state="translated">Error de E/S.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> o -</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Another thread may have caused an unexpected change in the position of the operating system's file handle.</source>
          <target state="translated">Otro subproceso puede haber producido un cambio inesperado en la posición del identificador de archivo del sistema operativo.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The stream is closed.</source>
          <target state="translated">La secuencia está cerrada.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The current stream instance does not support writing.</source>
          <target state="translated">La instancia actual de la secuencia no admite la escritura.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write data from.</source>
          <target state="translated">Búfer del que se van a escribir datos.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> from which to begin copying bytes to the stream.</source>
          <target state="translated">Desplazamiento de bytes de base cero de <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> desde donde se van a empezar a copiar bytes en la secuencia.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Número máximo de bytes que se pueden escribir.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Token para supervisar solicitudes de cancelación.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</source>
          <target state="translated">Escribe de forma asincrónica una secuencia de bytes en la secuencia actual, se hace avanzar la posición actual dentro de la secuencia por el número de bytes escritos y controla las solicitudes de cancelación.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous write operation.</source>
          <target state="translated">Tarea que representa la operación de escritura asincrónica.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph> method enables you to perform resource-intensive file operations without blocking the main thread.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.FileStream.WriteAsync%2A&gt;</ph> método le permite realizar operaciones de archivos de gran cantidad de recursos sin bloquear el subproceso principal.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>This performance consideration is particularly important in a <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> app or <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</source>
          <target state="translated">Esta consideración de rendimiento es especialmente importante en una aplicación de la <ph id="ph1">[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]</ph> o una aplicación de <ph id="ph2">[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)]</ph> en que una operación de streaming prolongada puede bloquear el subproceso de interfaz de usuario y hacer que parezca que una aplicación ha dejado de responder.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The async methods are used in conjunction with the <ph id="ph1">`async`</ph> and <ph id="ph2">`await`</ph> keywords in Visual Basic and C#.</source>
          <target state="translated">Los métodos asincrónicos se usan junto con la <ph id="ph1">`async`</ph> y <ph id="ph2">`await`</ph> palabras clave en Visual Basic y C#.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> propiedad para determinar si la instancia actual admite operaciones de lectura.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">Si la operación se cancela antes de que finalice, la tarea devuelta contiene la <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> valor para el <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the handle to the file is disposed, the returned task contains the <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> exception in the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
          <target state="translated">Si se elimina el identificador del archivo, la tarea devuelta contiene la <ph id="ph1">&lt;xref:System.ObjectDisposedException&gt;</ph> excepción en el <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The following example shows how to write asynchronously to a file.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo escribir asincrónicamente en un archivo.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated">La suma de <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es mayor que la longitud del búfer.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream does not support writing.</source>
          <target state="translated">La secuencia no admite escritura.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">Se ha eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream is currently in use by a previous write operation.</source>
          <target state="translated">La secuencia está actualmente en uso por una operación de escritura anterior.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>A byte to write to the stream.</source>
          <target state="translated">Un byte que se va a escribir en la secuencia.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>Writes a byte to the current position in the file stream.</source>
          <target state="translated">Escribe un byte en la posición actual de la secuencia de archivo.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>Use <ph id="ph1">`WriteByte`</ph> to write a byte to a <ph id="ph2">`FileStream`</ph> efficiently.</source>
          <target state="translated">Use <ph id="ph1">`WriteByte`</ph> para escribir un byte en un <ph id="ph2">`FileStream`</ph> eficazmente.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>If the stream is closed or not writable, an exception will be thrown.</source>
          <target state="translated">Si la secuencia está cerrada o no pueden modificarse, se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports writing.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.IO.FileStream.CanWrite%2A&gt;</ph> propiedad para determinar si la instancia actual admite escritura.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información adicional, vea <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo escribir datos en un archivo, byte a byte y, a continuación, compruebe que los datos se han escrito correctamente.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>The stream is closed.</source>
          <target state="translated">La secuencia está cerrada.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>The stream does not support writing.</source>
          <target state="translated">La secuencia no admite escritura.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>The default implementation on <ph id="ph1">&lt;see langword="Stream" /&gt;</ph> creates a new single-byte array and then calls <ph id="ph2">&lt;see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /&gt;</ph>.</source>
          <target state="translated">La implementación predeterminada de <ph id="ph1">&lt;see langword="Stream" /&gt;</ph> crea una nueva matriz de un solo byte y, a continuación, se llama <ph id="ph2">&lt;see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>While this is formally correct, it is inefficient.</source>
          <target state="translated">Aunque esto es formalmente correcto, no es eficaz.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</source>
          <target state="translated">Cualquier secuencia que posea un búfer interno debe reemplazar este método y proporcionar una versión mucho más eficaz que lea el búfer directamente, evitando la asignación adicional de matrices en cada llamada.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.FileStream.WriteByte(System.Byte)">
          <source>For a list of common file and directory operations, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Para obtener una lista de operaciones de directorio y archivo común, consulte <bpt id="p1">[</bpt>tareas de E/S comunes<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>