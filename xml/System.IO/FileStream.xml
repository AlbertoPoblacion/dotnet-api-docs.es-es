<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7a06f70b77d575d1a15d0e980c99c1c5daf7ad47" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53395492" /></Metadata><TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type FileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona un <see cref="T:System.IO.Stream" /> para un archivo, lo que permite operaciones de lectura y escritura sincrónica y asincrónica.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.FileStream> clase para leer, escribir, abrir y cerrar archivos en un sistema de archivos y para manipular otros identificadores del sistema operativo relacionados con el archivo, como canalizaciones, entrada estándar y salida estándar. Puede usar el <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.Stream.CopyTo%2A>, y <xref:System.IO.FileStream.Flush%2A> métodos para realizar operaciones sincrónicas, o la <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, y <xref:System.IO.FileStream.FlushAsync%2A> métodos para realizar asincrónica operaciones. Utilice los métodos asincrónicos para realizar las operaciones de archivos de gran cantidad de recursos sin bloquear el subproceso principal. Esta consideración de rendimiento es especialmente importante en una aplicación de la [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o una aplicación de [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] en que una operación de streaming prolongada puede bloquear el subproceso de interfaz de usuario y hacer que parezca que una aplicación ha dejado de responder. <xref:System.IO.FileStream> los búferes de entrada y salida para mejorar el rendimiento.  
  
> [!IMPORTANT]
>  Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo, debe deshacerse de él directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él, indirectamente, usar una construcción de lenguaje, como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
 El <xref:System.IO.FileStream.IsAsync%2A> propiedad detecta si el identificador de archivo se abrió de forma asincrónica. Especifique este valor cuando se crea una instancia de la <xref:System.IO.FileStream> clase mediante un constructor que tiene un `isAsync`, `useAsync`, o `options` parámetro. Cuando la propiedad es `true`, la secuencia utiliza E/S superpuesta para realizar las operaciones de archivos de forma asincrónica. Sin embargo, el <xref:System.IO.FileStream.IsAsync%2A> propiedad no tiene que ser `true` para llamar a la <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, o <xref:System.IO.Stream.CopyToAsync%2A> método. Cuando el <xref:System.IO.FileStream.IsAsync%2A> propiedad es `false` y llamar a la lectura asincrónica y las operaciones de escritura, no todavía se bloquea el subproceso de interfaz de usuario, pero la operación de E/S real se realiza de forma sincrónica.  
  
 El <xref:System.IO.FileStream.Seek%2A> método admite el acceso aleatorio a archivos. <xref:System.IO.FileStream.Seek%2A> permite que la posición de lectura/escritura se muevan a cualquier posición dentro del archivo. Esto se hace con los parámetros de punto de referencia de desplazamiento de bytes. El desplazamiento de bytes es relativa al punto de referencia de búsqueda, que puede ser el principio, la posición actual o el final del archivo subyacente, representado por los tres miembros de la <xref:System.IO.SeekOrigin> enumeración.  
  
> [!NOTE]
>  Archivos de disco siempre admiten el acceso aleatorio. En el momento de construcción, el <xref:System.IO.FileStream.CanSeek%2A> el valor de propiedad se establece en `true` o `false` según el tipo de archivo subyacente. Si el tipo de archivo subyacente es FILE_TYPE_DISK, tal como se define en winbase.h, el <xref:System.IO.FileStream.CanSeek%2A> es el valor de propiedad `true`. En caso contrario, el <xref:System.IO.FileStream.CanSeek%2A> es el valor de propiedad `false`.  
  
 Si un proceso finaliza con la parte de un archivo bloqueado o cierra un archivo que tiene bloqueos pendientes, el comportamiento es indefinido.  
  
 Para las operaciones de directorio y otras operaciones de archivo, consulte el <xref:System.IO.File>, <xref:System.IO.Directory>, y <xref:System.IO.Path> clases. El <xref:System.IO.File> es una clase de utilidad que tiene métodos estáticos principalmente para la creación de <xref:System.IO.FileStream> objetos basados en rutas de acceso de archivo. El <xref:System.IO.MemoryStream> clase crea un flujo desde una matriz de bytes y es similar a la <xref:System.IO.FileStream> clase.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
## <a name="detection-of-stream-position-changes"></a>Detección de cambios de la posición de Stream  
 Cuando un <xref:System.IO.FileStream> objeto no tiene control exclusivo sobre su identificador, otro subproceso puede tener acceso al identificador de archivo al mismo tiempo y cambiar la posición del puntero de archivo del sistema operativo que está asociado con el identificador de archivo. En este caso, la posición almacenada en caché en el <xref:System.IO.FileStream> objeto y los datos en caché en el búfer podrían verse comprometidos. El <xref:System.IO.FileStream> objeto habitualmente realiza comprobaciones en los métodos que tener acceso al búfer en caché para garantizar que la posición del identificador del sistema operativo es el mismo que la posición almacenada en caché utilizada por el <xref:System.IO.FileStream> objeto.  
  
 Si se detecta un cambio inesperado en la posición del identificador en una llamada a la <xref:System.IO.FileStream.Read%2A> método, .NET Framework descarta el contenido del búfer y se vuelve a leer la secuencia del archivo. Esto puede afectar al rendimiento, dependiendo del tamaño del archivo y los demás procesos que podrían afectar a la posición de la secuencia de archivos.  
  
 Si se detecta un cambio inesperado en la posición del identificador en una llamada a la <xref:System.IO.FileStream.Write%2A> método, el contenido del búfer se descartan y un <xref:System.IO.IOException> es una excepción.  
  
 Un <xref:System.IO.FileStream> objeto no tendrá exclusivo sobre su identificador cuando cualquier el <xref:System.IO.FileStream.SafeFileHandle%2A> acceso a la propiedad para exponer el identificador o el <xref:System.IO.FileStream> objeto se asigna el <xref:System.IO.FileStream.SafeFileHandle%2A> propiedad en su constructor.  
  
   
  
## Examples  
 El ejemplo siguiente muestra algunas de las <xref:System.IO.FileStream> constructores.  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 El ejemplo siguiente muestra cómo se escriben en un archivo de forma asincrónica. Este código se ejecuta en una aplicación WPF que tiene un bloque de texto denominado /userinput y un botón enlazado a un controlador de eventos Click denominado Button_Click. La ruta de acceso debe cambiarse a un archivo que existe en el equipo.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
    <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Cómo: Leer y escribir en un archivo de datos recién creado</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de archivo para el archivo que el objeto <see langword="FileStream" /> actual va a encapsular.</param>
        <param name="access">Constante que establece las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> para el identificador de archivo especificado, con el permiso de lectura y escritura especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.IO.Stream.Close%2A> es llamado, se cierra también el identificador y el recuento de identificadores del archivo va disminuyendo.  
  
 `FileStream` se supone que tiene control exclusivo sobre el identificador. Lectura, escritura o búsqueda mientras un `FileStream` también contiene un identificador podría provocar daños en los datos. Por motivos de seguridad de datos, llame a <xref:System.IO.FileStream.Flush%2A> antes mediante el identificador y evite llamar a ningún método distinto `Close` cuando haya terminado con el identificador.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 `FileShare.Read` es el valor predeterminado para aquellos <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> no es un campo de <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como un error de disco.  
  
O bien 
Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El <paramref name="access" /> solicitado no está permitido por el sistema operativo para el identificador de archivo especificado, como cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el identificador de archivo está establecido para el acceso de solo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de archivo para el archivo que el objeto <see langword="FileStream" /> actual va a encapsular.</param>
        <param name="access">Constante que establece las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> para el identificador de archivo especificado, con el permiso de lectura y escritura especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.IO.Stream.Close%2A> es llamado, se cierra también el identificador y el recuento de identificadores del archivo va disminuyendo.  
  
 `FileStream` se supone que tiene control exclusivo sobre el identificador. Lectura, escritura o búsqueda mientras un `FileStream` también contiene un identificador podría provocar daños en los datos. Por motivos de seguridad de datos, llame a <xref:System.IO.FileStream.Flush%2A> antes mediante el identificador y evite llamar a ningún método distinto `Close` cuando haya terminado con el identificador.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 `FileShare.Read` es el valor predeterminado para aquellos <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> no es un campo de <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como un error de disco.  
  
O bien 
Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El <paramref name="access" /> solicitado no está permitido por el sistema operativo para el identificador de archivo especificado, como cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el identificador de archivo está establecido para el acceso de solo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see langword="FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con el modo de creación y la ruta de acceso especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura Universal (UNC).  
  
 El constructor se concede acceso de lectura/escritura al archivo y se abre compartiendo el acceso de lectura (es decir, las solicitudes para abrir el archivo para escritura de este u otro proceso producirá errores hasta que el `FileStream` objeto se ha cerrado, pero los intentos de lectura se realizará correctamente).  
  
 No se puede utilizar este constructor para abrir archivos de solo lectura; en su lugar, debe usar un constructor que acepta un `FileAccess` parámetro con el valor establecido en `FileAccess.Read`.  
  
 El tamaño del búfer se establece en el tamaño predeterminado de 4096 bytes (4 KB).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan los archivos. Si `path` indica un dispositivo que no admite búsquedas, la <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` es el valor predeterminado para aquellos <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
 Para los constructores sin un <xref:System.IO.FileAccess> parámetro, si la `mode` parámetro está establecido en <xref:System.IO.FileMode.Append>, <xref:System.IO.FileAccess.Write> es el acceso predeterminado. En caso contrario, el acceso está establecido en <xref:System.IO.FileAccess.ReadWrite>.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo escribir datos en un archivo, byte a byte y, a continuación, compruebe que los datos se han escrito correctamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.  
  
O bien 
 <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno distinto de NTFS.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y el archivo especificado por <paramref name="path" /> no existe. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> cuando el archivo especificado por <paramref name="path" /> ya existe.  
  
O bien 
Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contiene un valor no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de archivo para el archivo que el objeto <see langword="FileStream" /> actual va a encapsular.</param>
        <param name="access">Constante <see cref="T:System.IO.FileAccess" /> que establece las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> para el identificador de archivo especificado, con el tamaño de búfer y el permiso de lectura y escritura especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` se supone que tiene control exclusivo sobre el identificador. Lectura, escritura o búsqueda mientras un `FileStream` también contiene un identificador podría provocar daños en los datos. Por motivos de seguridad de datos, llame a <xref:System.IO.FileStream.Flush%2A> antes mediante el identificador y evite llamar a ningún método distinto `Close` cuando haya terminado con el identificador. Como alternativa, leer y escribir en el controlador antes de llamar a esto `FileStream` constructor.  
  
 `FileShare.Read` es el valor predeterminado para aquellos <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="handle" /> tiene un identificador que no es válido.  
  
O bien 
El parámetro <paramref name="handle" /> es un identificador sincrónico y se usó de forma asincrónica.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="bufferSize" /> es negativo.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como un error de disco.  
  
O bien 
Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El <paramref name="access" /> solicitado no está permitido por el sistema operativo para el identificador de archivo especificado, como cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el identificador de archivo está establecido para el acceso de solo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener permiso llamar a código no administrado. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de archivo para el archivo que el objeto <see langword="FileStream" /> actual va a encapsular.</param>
        <param name="access">Constante que establece las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />.</param>
        <param name="ownsHandle">Es <see langword="true" /> si esta instancia de <see langword="FileStream" /> va a ser la propietaria del identificador de archivo; en caso contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> para el identificador de archivo especificado, con el permiso de lectura y escritura establecido y la propiedad de la instancia de <see langword="FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `FileStream` se proporciona el acceso especificado al objeto en el archivo. La propiedad del identificador será como se especifica. Si este proceso posee el identificador, una llamada a la <xref:System.IO.Stream.Close%2A> método también cerrará el identificador y el recuento de identificadores del archivo va disminuyendo. La `FileStream` objeto se asigna el tamaño de búfer predeterminado de 4096 bytes.  
  
 `FileStream` se supone que tiene control exclusivo sobre el identificador. Lectura, escritura o búsqueda mientras un `FileStream` también contiene un identificador podría provocar daños en los datos. Por motivos de seguridad de datos, llame a <xref:System.IO.FileStream.Flush%2A> antes de utilizar el identificador y evitar llamar a métodos distintos de `Close` cuando haya terminado con el identificador.  
  
 `FileShare.Read` es el valor predeterminado para aquellos <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> no es un campo de <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como un error de disco.  
  
O bien 
Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El <paramref name="access" /> solicitado no está permitido por el sistema operativo para el identificador de archivo especificado, como cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el identificador de archivo está establecido para el acceso de solo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see langword="FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <param name="access">Constante que determina cómo puede obtener acceso al archivo el objeto <see langword="FileStream" />. Esto también determina los valores que devuelven las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> es <see langword="true" /> si <paramref name="path" /> especifica un archivo de disco.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con el permiso de lectura y escritura, el modo de creación y la ruta de acceso especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura Universal (UNC).  
  
 El constructor se concede acceso de lectura/escritura al archivo y se abre compartiendo el acceso de lectura (es decir, las solicitudes para abrir el archivo para escritura de este u otro proceso producirá errores hasta que el `FileStream` objeto se ha cerrado, pero los intentos de lectura se realizará correctamente). El tamaño del búfer se establece en el tamaño predeterminado de 4096 bytes (4 KB).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan los archivos. Si `path` indica un dispositivo que no admite búsquedas, la <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` es el valor predeterminado para aquellos <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o contiene uno o más caracteres no válidos.  
  
O bien 
 <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno distinto de NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y el archivo especificado por <paramref name="path" /> no existe. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> cuando el archivo especificado por <paramref name="path" /> ya existe.  
  
O bien 
Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el objeto <paramref name="access" /> solicitado para el objeto <paramref name="path" /> especificado, como cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el archivo o directorio está establecido para el acceso de solo lectura.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contiene un valor no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de archivo para el archivo que este objeto <see langword="FileStream" /> va a encapsular.</param>
        <param name="access">Constante que establece las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <param name="isAsync">Es <see langword="true" /> si se abrió el identificador de forma asincrónica (es decir, en modo de E/S superpuesta); de lo contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> para el identificador de archivo especificado, y con el permiso de lectura y escritura, el tamaño de búfer y el estado sincrónico o asincrónico especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establece el `isAsync` parámetro `true` para abrir el identificador de archivo de forma asincrónica. Cuando el parámetro es `true`, la secuencia utiliza E/S superpuesta para realizar las operaciones de archivos de forma asincrónica. Sin embargo, el parámetro no tiene que ser `true` para llamar a la <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, o <xref:System.IO.Stream.CopyToAsync%2A> método. Cuando el `isAsync` parámetro es `false` y llamar a la lectura asincrónica y las operaciones de escritura, no todavía se bloquea el subproceso de interfaz de usuario, pero la operación de E/S real se realiza de forma sincrónica.  
  
 `FileStream` se supone que tiene control exclusivo sobre el identificador. Lectura, escritura o búsqueda mientras un `FileStream` también contiene un identificador podría provocar daños en los datos. Por motivos de seguridad de datos, llame a <xref:System.IO.FileStream.Flush%2A> antes mediante el identificador y evite llamar a ningún método distinto `Close` cuando haya terminado con el identificador. Como alternativa, leer y escribir en el controlador antes de llamar a esto `FileStream` constructor.  
  
 `FileShare.Read` es el valor predeterminado para aquellos <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="handle" /> tiene un identificador que no es válido.  
  
O bien 
El parámetro <paramref name="handle" /> es un identificador sincrónico y se usó de forma asincrónica.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="bufferSize" /> es negativo.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como un error de disco.  
  
O bien 
Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El <paramref name="access" /> solicitado no está permitido por el sistema operativo para el identificador de archivo especificado, como cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el identificador de archivo está establecido para el acceso de solo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener permiso llamar a código no administrado. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de archivo para el archivo que este objeto <see langword="FileStream" /> va a encapsular.</param>
        <param name="access">Constante que establece las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />.</param>
        <param name="ownsHandle">Es <see langword="true" /> si esta instancia de <see langword="FileStream" /> va a ser la propietaria del identificador de archivo; en caso contrario, es <see langword="false" />.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> para el identificador de archivo especificado, con el tamaño de búfer, la propiedad de la instancia de <see langword="FileStream" /> y el permiso de lectura y escritura especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `FileStream` se proporciona el acceso especificado al objeto en el archivo. La propiedad del identificador será como se especifica. Si este `FileStream` posee el identificador, una llamada a la <xref:System.IO.Stream.Close%2A> método también cerrará el identificador. En concreto, el recuento de identificadores del archivo es reducido. La `FileStream` objeto se asigna el tamaño de búfer especificado.  
  
 `FileStream` se supone que tiene control exclusivo sobre el identificador. Lectura, escritura o búsqueda mientras un `FileStream` también contiene un identificador podría provocar daños en los datos. Por motivos de seguridad de datos, llame a <xref:System.IO.FileStream.Flush%2A> antes mediante el identificador y evite llamar a ningún método distinto `Close` cuando haya terminado con el identificador. Como alternativa, leer y escribir en el controlador antes de llamar a esto `FileStream` constructor.  
  
 `FileShare.Read` es el valor predeterminado para aquellos <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> es negativo.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como un error de disco.  
  
O bien 
Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El <paramref name="access" /> solicitado no está permitido por el sistema operativo para el identificador de archivo especificado, como cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el identificador de archivo está establecido para el acceso de solo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see langword="FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <param name="access">Constante que determina cómo puede obtener acceso al archivo el objeto <see langword="FileStream" />. Esto también determina los valores que devuelven las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> es <see langword="true" /> si <paramref name="path" /> especifica un archivo de disco.</param>
        <param name="share">Constante que determina cómo compartirán el archivo los procesos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con el permiso de uso compartido, el permiso de lectura y escritura, el modo de creación y la ruta de acceso especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura Universal (UNC).  
  
 El constructor se concede acceso de lectura/escritura al archivo y se abre compartiendo el acceso de lectura (es decir, las solicitudes para abrir el archivo para escritura de este u otro proceso producirá errores hasta que el `FileStream` objeto se ha cerrado, pero los intentos de lectura se realizará correctamente). El tamaño del búfer se establece en el tamaño predeterminado de 4096 bytes (4 KB).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan los archivos. Si `path` indica un dispositivo que no admite búsquedas, la <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.IO.FileStream.Lock%2A> método.  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o contiene uno o más caracteres no válidos.  
  
O bien 
 <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno distinto de NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y el archivo especificado por <paramref name="path" /> no existe. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> cuando el archivo especificado por <paramref name="path" /> ya existe.  
  
O bien 
El sistema dispone de Windows 98 o Windows 98 Second Edition y <paramref name="share" /> está establecido en <see langword="FileShare.Delete" />.  
  
O bien 
Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el objeto <paramref name="access" /> solicitado para el objeto <paramref name="path" /> especificado, como cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el archivo o directorio está establecido para el acceso de solo lectura.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contiene un valor no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de archivo para el archivo que este objeto <see langword="FileStream" /> va a encapsular.</param>
        <param name="access">Constante que establece las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />.</param>
        <param name="ownsHandle">Es <see langword="true" /> si esta instancia de <see langword="FileStream" /> va a ser la propietaria del identificador de archivo; en caso contrario, es <see langword="false" />.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <param name="isAsync">Es <see langword="true" /> si se abrió el identificador de forma asincrónica (es decir, en modo de E/S superpuesta); de lo contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> para el identificador de archivo especificado, con el estado sincrónico o asincrónico, el tamaño de búfer, la propiedad de la instancia de <see langword="FileStream" /> y el permiso de lectura y escritura especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `FileStream` se proporciona el acceso especificado al objeto en el archivo. La propiedad del identificador será como se especifica. Si este `FileStream` posee el identificador, una llamada a la <xref:System.IO.Stream.Close%2A> método también cerrará el identificador. En concreto, el recuento de identificadores del archivo es reducido. La `FileStream` objeto se asigna el tamaño de búfer especificado.  
  
 `FileStream` se supone que tiene control exclusivo sobre el identificador. Lectura, escritura o búsqueda mientras un `FileStream` también contiene un identificador podría provocar daños en los datos. Por motivos de seguridad de datos, llame a <xref:System.IO.FileStream.Flush%2A> antes mediante el identificador y evite llamar a ningún método distinto `Close` cuando haya terminado con el identificador. Como alternativa, leer y escribir en el controlador antes de llamar a esto `FileStream` constructor.  
  
 `FileShare.Read` es el valor predeterminado para aquellos <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="access" /> es menor que <see langword="FileAccess.Read" /> o mayor que <see langword="FileAccess.ReadWrite" /> o <paramref name="bufferSize" /> es menor o igual que 0.</exception>
        <exception cref="T:System.ArgumentException">El identificador no es válido.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como un error de disco.  
  
O bien 
Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El <paramref name="access" /> solicitado no está permitido por el sistema operativo para el identificador de archivo especificado, como cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el identificador de archivo está establecido para el acceso de solo lectura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see langword="FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <param name="access">Constante que determina cómo puede obtener acceso al archivo el objeto <see langword="FileStream" />. Esto también determina los valores que devuelven las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> es <see langword="true" /> si <paramref name="path" /> especifica un archivo de disco.</param>
        <param name="share">Constante que determina cómo compartirán el archivo los procesos.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con el tamaño de búfer, el permiso de lectura y escritura y de uso compartido, el modo de creación y la ruta de acceso especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan los archivos. Si `path` indica un dispositivo que no admite búsquedas, la <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o contiene uno o más caracteres no válidos.  
  
O bien 
 <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno distinto de NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> es un valor negativo o es cero.  
  
O bien 
 <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> contienen un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y el archivo especificado por <paramref name="path" /> no existe. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> cuando el archivo especificado por <paramref name="path" /> ya existe.  
  
O bien 
El sistema dispone de Windows 98 o Windows 98 Second Edition y <paramref name="share" /> está establecido en <see langword="FileShare.Delete" />.  
  
O bien 
Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el objeto <paramref name="access" /> solicitado para el objeto <paramref name="path" /> especificado, como cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el archivo o directorio está establecido para el acceso de solo lectura.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, useAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see langword="FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <param name="access">Constante que determina cómo puede obtener acceso al archivo el objeto <see langword="FileStream" />. Esto también determina los valores que devuelven las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> es <see langword="true" /> si <paramref name="path" /> especifica un archivo de disco.</param>
        <param name="share">Constante que determina cómo compartirán el archivo los procesos.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <param name="useAsync">Especifica si se va a utilizar E/S asincrónica o sincrónica. Sin embargo, tenga en cuenta que el sistema operativo subyacente quizás no admita E/S asincrónica, por lo que cuando se especifica <see langword="true" />, puede que el identificador se abra de forma sincrónica en función de la plataforma. Cuando se abre de forma asincrónica, los métodos <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> y <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> proporcionan un rendimiento mejor en lecturas o escrituras grandes, pero es posible que sean mucho más lentos para lecturas o escrituras pequeñas. Si la aplicación se ha diseñado para aprovechar al máximo la E/S asincrónica, establezca el parámetro <paramref name="useAsync" /> en <see langword="true" />. El uso de la E/S asincrónica de forma correcta puede agilizar las aplicaciones en hasta un factor de 10, pero su uso sin volver a diseñar la aplicación para la E/S asincrónica puede disminuir el rendimiento en hasta un factor de 10.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con el estado sincrónico o asincrónico, el tamaño de búfer, el permiso de lectura y escritura y de uso compartido, el modo de creación y la ruta de acceso especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan los archivos. Si `path` indica un dispositivo que no admite búsquedas, la <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo escribir datos en un archivo de forma asincrónica y, a continuación, compruebe que los datos se han escrito correctamente. Un `State` se crea el objeto para pasar información del subproceso principal para el `EndReadCallback` y `EndWriteCallback` métodos.  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o contiene uno o más caracteres no válidos.  
  
O bien 
 <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno distinto de NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> es un valor negativo o es cero.  
  
O bien 
 <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> contienen un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y el archivo especificado por <paramref name="path" /> no existe. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> cuando el archivo especificado por <paramref name="path" /> ya existe.  
  
O bien 
El sistema dispone de Windows 98 o Windows 98 Second Edition y <paramref name="share" /> está establecido en <see langword="FileShare.Delete" />.  
  
O bien 
Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el objeto <paramref name="access" /> solicitado para el objeto <paramref name="path" /> especificado, como cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el archivo o directorio está establecido para el acceso de solo lectura.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="T:System.IO.File" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see langword="FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <param name="access">Constante que determina cómo puede obtener acceso al archivo el objeto <see langword="FileStream" />. Esto también determina los valores que devuelven las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> es <see langword="true" /> si <paramref name="path" /> especifica un archivo de disco.</param>
        <param name="share">Constante que determina cómo compartirán el archivo los procesos.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <param name="options">Valor que especifica opciones de archivo adicionales.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con la ruta de acceso, el modo de creación, los permisos de lectura y escritura y de uso compartido, el acceso que otras secuencias de archivos pueden tener al mismo archivo, el tamaño del búfer y otras opciones de archivo que se hayan especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 El `fileOptions` parámetro se utiliza para proporcionar acceso a las operaciones más avanzadas que se pueden aprovechar al crear un <xref:System.IO.FileStream> objeto.  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan los archivos. Si `path` indica un dispositivo que no admite búsquedas, la <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente escribe datos en un archivo y, a continuación, lee los datos mediante el <xref:System.IO.FileStream> objeto.  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o contiene uno o más caracteres no válidos.  
  
O bien 
 <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno distinto de NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> es un valor negativo o es cero.  
  
O bien 
 <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> contienen un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y el archivo especificado por <paramref name="path" /> no existe. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> cuando el archivo especificado por <paramref name="path" /> ya existe.  
  
O bien 
Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El <paramref name="access" /> solicitado no está permitido por el sistema operativo para el <paramref name="path" /> especificado, como cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el archivo o directorio está establecido para el acceso de solo lectura.  
  
O bien 
 <see cref="F:System.IO.FileOptions.Encrypted" /> se ha especificado para <paramref name="options" />, pero no se admite el cifrado de archivos en la plataforma actual.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see cref="T:System.IO.FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <param name="rights">Constante que determina los derechos de acceso que se emplean al crear reglas de acceso y auditoría para el archivo.</param>
        <param name="share">Constante que determina cómo compartirán el archivo los procesos.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <param name="options">Constante que especifica opciones de archivo adicionales.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con la ruta de acceso, el modo de creación, los derechos de acceso y el permiso de uso compartido, el tamaño de búfer y opciones de archivo adicionales que se hayan especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 Use esta <xref:System.IO.FileStream.%23ctor%2A> constructor al aplicar el acceso de derechos en el momento de creación de un archivo. Para obtener acceso o modificar los derechos en un archivo existente, considere el uso de la <xref:System.IO.File.GetAccessControl%2A> y <xref:System.IO.File.SetAccessControl%2A> métodos.  
  
 El `fileOptions` parámetro se utiliza para proporcionar acceso a las operaciones más avanzadas que se pueden aprovechar al crear un <xref:System.IO.FileStream> objeto.  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan los archivos. Si `path` indica un dispositivo que no admite búsquedas, la <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o contiene uno o más caracteres no válidos.  
  
O bien 
 <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno distinto de NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> es un valor negativo o es cero.  
  
O bien 
 <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> contienen un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y el archivo especificado por <paramref name="path" /> no existe. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o una versión posterior.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> cuando el archivo especificado por <paramref name="path" /> ya existe.  
  
O bien 
Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El <paramref name="access" /> solicitado no está permitido por el sistema operativo para el <paramref name="path" /> especificado, como cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el archivo o directorio está establecido para el acceso de solo lectura.  
  
O bien 
 <see cref="F:System.IO.FileOptions.Encrypted" /> se ha especificado para <paramref name="options" />, pero no se admite el cifrado de archivos en la plataforma actual.</exception>
        <exception cref="T:System.IO.PathTooLongException">La <paramref name="path" /> especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see cref="T:System.IO.FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <param name="rights">Constante que determina los derechos de acceso que se emplean al crear reglas de acceso y auditoría para el archivo.</param>
        <param name="share">Constante que determina cómo compartirán el archivo los procesos.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <param name="options">Constante que especifica opciones de archivo adicionales.</param>
        <param name="fileSecurity">Constante que determina el control de acceso y la seguridad de auditoría del archivo.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con la ruta de acceso, el modo de creación, los derechos de acceso y el permiso de uso compartido, el tamaño de búfer, las opciones de archivo adicionales, el control de acceso y la seguridad de auditoría que se hayan especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 Use esta <xref:System.IO.FileStream.%23ctor%2A> constructor al aplicar el acceso de derechos en el momento de creación de un archivo. Para obtener acceso o modificar los derechos en un archivo existente, considere el uso de la <xref:System.IO.File.GetAccessControl%2A> y <xref:System.IO.File.SetAccessControl%2A> métodos.  
  
 El `fileOptions` parámetro se utiliza para proporcionar acceso a las operaciones más avanzadas que se pueden aprovechar al crear un <xref:System.IO.FileStream> objeto.  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan los archivos. Si `path` indica un dispositivo que no admite búsquedas, la <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y podrían provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente escribe datos en un archivo y, a continuación, lee los datos mediante el <xref:System.IO.FileStream> objeto.  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o contiene uno o más caracteres no válidos.  
  
O bien 
 <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno distinto de NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> es un valor negativo o es cero.  
  
O bien 
 <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> contienen un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y el archivo especificado por <paramref name="path" /> no existe. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> cuando el archivo especificado por <paramref name="path" /> ya existe.  
  
O bien 
Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El <paramref name="access" /> solicitado no está permitido por el sistema operativo para el <paramref name="path" /> especificado, como cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el archivo o directorio está establecido para el acceso de solo lectura.  
  
O bien 
 <see cref="F:System.IO.FileOptions.Encrypted" /> se ha especificado para <paramref name="options" />, pero no se admite el cifrado de archivos en la plataforma actual.</exception>
        <exception cref="T:System.IO.PathTooLongException">La <paramref name="path" /> especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o una versión posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="numBytes">To be added.</param>
        <param name="userCallback">To be added.</param>
        <param name="stateObject">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="numBytes">To be added.</param>
        <param name="userCallback">To be added.</param>
        <param name="stateObject">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la secuencia actual admite lectura.</summary>
        <value>Es <see langword="true" /> si la secuencia admite lectura; es <see langword="false" /> si la secuencia está cerrada o se abrió con acceso de solo escritura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si una clase derivada de <xref:System.IO.Stream> no admite la lectura, las llamadas a la <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, y <xref:System.IO.FileStream.BeginRead%2A> métodos inician una <xref:System.NotSupportedException>.  
  
 Si la secuencia está cerrada, esta propiedad devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un uso de la `CanRead` propiedad. El resultado de este código es "No es grabable MyFile.txt". Para obtener el mensaje de salida "MyFile.txt se puede escribir en y leen.", cambie el `FileAccess` parámetro `ReadWrite` en el `FileStream` constructor.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la secuencia actual admite búsquedas.</summary>
        <value>Es <see langword="true" /> si la secuencia admite búsquedas; es <see langword="false" /> si la secuencia está cerrada o si <see langword="FileStream" /> se construyó a partir de un identificador del sistema operativo, como una canalización o una salida a la consola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si una clase derivada de <xref:System.IO.Stream> no admite búsquedas, las llamadas a <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>, y <xref:System.IO.FileStream.Seek%2A> producir una <xref:System.NotSupportedException>.  
  
 Si la secuencia está cerrada, esta propiedad devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `CanSeek` propiedad para comprobar si una secuencia admite búsquedas.  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la secuencia actual admite escritura.</summary>
        <value>Es <see langword="true" /> si la secuencia admite escritura; es <see langword="false" /> si la secuencia está cerrada o se abrió con acceso de solo lectura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si una clase derivada de <xref:System.IO.Stream> no admite la escritura, una llamada a <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, o <xref:System.IO.FileStream.WriteByte%2A> produce una <xref:System.NotSupportedException>.  
  
 Si la secuencia está cerrada, esta propiedad devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `CanWrite` propiedad para comprobar si una secuencia admite escritura.  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 El siguiente es un ejemplo utilizando el `CanWrite` propiedad. El resultado de este código es "MyFile.txt es grabable." Para obtener el mensaje de salida "MyFile.txt se puede escribir en y leen.", cambie el `FileAccess` parámetro `ReadWrite` en el `FileStream` constructor.  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="fileStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Este miembro reemplaza a <see cref="M:System.IO.Stream.Close" />; puede haber documentación más completa en ese tema.

Cierra la secuencia actual y libera todos los recursos (como sockets e identificadores de archivo) asociados a esta.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.IO.FileStream" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama por el público <xref:System.ComponentModel.Component.Dispose%2A> método y el <xref:System.Object.Finalize%2A> método. <xref:System.ComponentModel.Component.Dispose%2A> invoca el protegido <xref:System.IO.FileStream.Dispose%2A> método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca <xref:System.IO.FileStream.Dispose%2A> con `disposing` establecido en `false`.  
  
 Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.IO.FileStream> hace referencia. Este método invoca al método <xref:System.ComponentModel.Component.Dispose%2A> de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> puede recibir varias llamadas de otros objetos. Cuando se reemplaza <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see cref="M:System.ComponentModel.Component.Dispose" />. Para obtener más información sobre cómo implementar <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obtener más información acerca de <see cref="M:System.ComponentModel.Component.Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="fileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Referencia a la solicitud asincrónica pendiente a la que se debe esperar.</param>
        <summary>Espera a que se complete la operación asincrónica de lectura que se encuentra pendiente. (Considere usar <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> en su lugar).</summary>
        <returns>Número de bytes leídos de la secuencia, que se encuentra entre 0 y el número de bytes solicitado. Las secuencias solo devuelven 0 al final de la secuencia; de lo contrario, se deben bloquear hasta que haya al menos 1 byte disponible.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En .NET Framework 4 y versiones anteriores, tendrá que utilizar métodos como <xref:System.IO.FileStream.BeginRead%2A> y <xref:System.IO.FileStream.EndRead%2A> para implementar operaciones de archivos asincrónica. Estos métodos siguen estando disponibles en el [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para admitir código heredado; sin embargo, los nuevos métodos asincrónicos, como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, y <xref:System.IO.FileStream.FlushAsync%2A>, ayuda implementa operaciones de archivo asincrónicas más fácilmente.  
  
 <xref:System.IO.FileStream.EndRead%2A> se debe llamar exactamente para cada llamada a <xref:System.IO.FileStream.BeginRead%2A>. No se puede terminar un proceso de lectura antes de comenzar otra lectura puede provocar un comportamiento no deseado, como el interbloqueo.  
  
 Este método invalida <xref:System.IO.Stream.EndRead%2A>.  
  
 <xref:System.IO.FileStream.EndRead%2A> se puede llamar en cada <xref:System.IAsyncResult> desde <xref:System.IO.FileStream.BeginRead%2A>. Una llamada a <xref:System.IO.FileStream.EndRead%2A> le indica cuántos bytes se leyeron de la secuencia. <xref:System.IO.FileStream.EndRead%2A> se bloqueará hasta que se ha completado la operación de E/S.  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Este objeto <see cref="T:System.IAsyncResult" /> no se creó mediante una llamada a <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> en esta clase.</exception>
        <exception cref="T:System.InvalidOperationException">Se llama a <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> varias veces.</exception>
        <exception cref="T:System.IO.IOException">La secuencia está cerrada o se produjo un error interno.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">E/S de archivos asincrónica</related>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="fileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">La solicitud de E/S asincrónica pendiente.</param>
        <summary>Termina una operación de escritura asincrónica y se bloquea hasta que se completa la operación de E/S. (Considere usar <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> en su lugar).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En .NET Framework 4 y versiones anteriores, tendrá que utilizar métodos como <xref:System.IO.FileStream.BeginWrite%2A> y <xref:System.IO.FileStream.EndWrite%2A> para implementar operaciones de archivos asincrónica. Estos métodos siguen estando disponibles en el [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para admitir código heredado; sin embargo, los nuevos métodos asincrónicos, como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, y <xref:System.IO.FileStream.FlushAsync%2A>, ayuda implementa operaciones de archivo asincrónicas más fácilmente.  
  
 Este método invalida <xref:System.IO.Stream.EndWrite%2A>.  
  
 <xref:System.IO.FileStream.EndWrite%2A> se debe llamar exactamente una vez en cada <xref:System.IAsyncResult> desde <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A> se bloqueará hasta que se ha completado la operación de E/S.  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Este objeto <see cref="T:System.IAsyncResult" /> no se creó mediante una llamada a <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> en esta clase.</exception>
        <exception cref="T:System.InvalidOperationException">Se llama a <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> varias veces.</exception>
        <exception cref="T:System.IO.IOException">La secuencia está cerrada o se produjo un error interno.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">E/S de archivos asincrónica</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garantiza que se liberen los recursos y se realicen otras operaciones de limpieza cuando el recolector de elementos no utilizados reclama <see langword="FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El recolector de elementos no utilizados llame al `Finalize` cuando el objeto actual está preparado para finalizarse. `Finalize` cierra el `FileStream`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Borra los búferes de esta secuencia y hace que todos los datos almacenados en los búferes se escriban en el archivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="fileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra los búferes de esta secuencia y hace que todos los datos almacenados en los búferes se escriban en el archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>.  
  
 Cuando se llama a la <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> también se vacía el método, el búfer de E/S en sistema operativo.  
  
 Codificador de la secuencia no se vacía a menos que se llame explícitamente a <xref:System.IO.FileStream.Flush%2A> o desechar el objeto. Establecer <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> a `true` significa que los datos del búfer se vaciará en el flujo, pero no se vaciará el estado del codificador. Esto permite al codificador mantener su estado (caracteres parciales) para que puede codificar correctamente el siguiente bloque de caracteres. Esta situación afecta a UTF8 y UTF7 donde ciertos caracteres solo se pueden codificar después de que el codificador reciba el carácter o caracteres adyacentes.  
  
 Dado que puede usarse un búfer de lectura o escritura, <xref:System.IO.FileStream.Flush> realiza las dos funciones siguientes:  
  
-   Los datos escritos previamente en el búfer se copian en el archivo y se borra el búfer, excepto el estado de su codificador.  
  
-   Si <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> es `true` y anteriormente se copiaron los datos desde el archivo en el búfer para leer, disminuye el número de bytes no leídos en el búfer de la posición actual dentro del archivo. A continuación, se borra el búfer.  
  
 Use el <xref:System.IO.FileStream.Flush%28System.Boolean%29> sobrecarga del método cuando desee asegurarse de que todos los datos almacenados en búfer en búferes de archivos intermedios se escribe en el disco.  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.IO.FileStream.Lock%2A> método.  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ObjectDisposedException">La secuencia está cerrada.</exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="fileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk"><see langword="true" /> para vaciar todos los búferes de archivos intermedios; de lo contrario, <see langword="false" />.</param>
        <summary>Borra los búferes de esta secuencia, hace que todos los datos almacenados en los búferes se escriban en el archivo y borra también todos los búferes de archivos intermedios.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga cuando desee asegurarse de que todos los datos almacenados en búfer en búferes de archivos intermedios se escribe en el disco.  
  
 Cuando se llama a la <xref:System.IO.FileStream.Flush%2A> también se vacía el método, el búfer de E/S en sistema operativo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token para supervisar solicitudes de cancelación.</param>
        <summary>Borra asincrónicamente todos los búferes del flujo actual, hace que todos los datos almacenados en el búfer se escriban en el dispositivo subyacente y supervisa las solicitudes de cancelación.</summary>
        <returns>Tarea que representa la operación de vaciado asincrónico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama a la <xref:System.IO.FileStream.FlushAsync%2A> también se vacía el método, el búfer de E/S en sistema operativo.  
  
 Si se cancela la operación antes de que finalice, la tarea devuelta contiene la <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para el <xref:System.Threading.Tasks.Task.Status%2A> propiedad. Si se elimina el identificador del archivo, la tarea devuelta contiene la <xref:System.ObjectDisposedException> excepción en el <xref:System.Threading.Tasks.Task.Exception%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado la secuencia.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula las entradas de lista de control de acceso (ACL) del archivo descrito por el objeto <see cref="T:System.IO.FileStream" /> actual.</summary>
        <returns>Objeto que encapsula la configuración de control de acceso correspondiente al archivo descrito por el objeto <see cref="T:System.IO.FileStream" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mientras el <xref:System.IO.FileStream> clase y <xref:System.IO.FileStream.GetAccessControl%2A> puede usarse para recuperar las entradas de lista (ACL) del control de acceso de un archivo existente, plantéese usar <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> método, ya que es más fácil de usar.  
  
 Use el <xref:System.IO.FileStream.GetAccessControl%2A> método para recuperar las entradas ACL para un archivo.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo dado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El archivo está cerrado.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.SystemException">No se encuentra el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Esta operación no es compatible con la plataforma actual.  
  
O bien 
El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador de archivo del sistema operativo correspondiente al archivo que el objeto <see langword="FileStream" /> encapsula.</summary>
        <value>Identificador de archivo del sistema operativo correspondiente al archivo encapsulado por este objeto <see langword="FileStream" /> o -1 si se ha cerrado <see langword="FileStream" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es un identificador del sistema operativo para su uso con las llamadas del sistema operativo proporcionadas por el sistema (como `ReadFile` en Windows). No funcionará con las funciones de la biblioteca de C que esperan un descriptor de archivo, como `fread`.  
  
 El identificador del sistema operativo puede haber sido abierto sincrónica o asincrónicamente, dependiendo de qué `FileStream` se llamó al constructor. Use el <xref:System.IO.FileStream.IsAsync%2A> propiedad para detectar si este identificador se abrió de forma asincrónica. En Win32, esto significa que se abrió el identificador para la E/S superpuesta y requiere parámetros distintos a `ReadFile` y `WriteFile`.  
  
> [!CAUTION]
>  Pueden producirse daños en los datos si un `FileStream` está creado, se pasa su identificador, alguna operación mueve el puntero de archivo del controlador y, a continuación, el `FileStream` se vuelve a usar. Varios subprocesos con seguridad no se pueden escribir en el mismo archivo simultáneamente, y `FileStream` el código de búfer se da por supuesto que controla el identificador de forma exclusiva. `FileStream` podría producir un <xref:System.IO.IOException> si `FileStream` detecta que algún otro proceso ha movido el puntero de archivo. Para evitar esto, no escriba ningún dato en una parte del archivo que `FileStream` podría haber almacenado en búfer y restaurar el puntero de archivo en la ubicación que tenía cuando se llamó por última vez métodos en `FileStream`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder tener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se abrió <see langword="FileStream" /> de forma sincrónica o asincrónica.</summary>
        <value>Es <see langword="true" /> si <see langword="FileStream" /> se abrió de forma asincrónica; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `IsAsync` propiedad detecta si el `FileStream` identificador se abrió de forma asincrónica, permitiendo que el código usar el <xref:System.IO.FileStream.Handle%2A> propiedad correctamente. En Win32, `IsAsync` que se va a true significa que el controlador se abrió para la E/S superpuesta y, por tanto, requiere parámetros distintos a `ReadFile` y `WriteFile`.  
  
 Especifique este valor cuando se crea una instancia de la <xref:System.IO.FileStream> clase mediante un constructor que tiene un `isAsync`, `useAsync`, o `options` parámetro. Cuando la propiedad es `true`, la secuencia utiliza E/S superpuesta para realizar las operaciones de archivos de forma asincrónica. Sin embargo, el <xref:System.IO.FileStream.IsAsync%2A> propiedad no tiene que ser `true` para llamar a la <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, o <xref:System.IO.Stream.CopyToAsync%2A> método. Cuando el <xref:System.IO.FileStream.IsAsync%2A> propiedad es `false` y llamar a la lectura asincrónica y las operaciones de escritura, no todavía se bloquea el subproceso de interfaz de usuario, pero la operación de E/S real se realiza de forma sincrónica.  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve la longitud en bytes del flujo.</summary>
        <value>Un valor Long que representa la longitud de la secuencia en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `Length` y `Position` propiedades para comprobar una condición de final de archivo.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="P:System.IO.FileStream.CanSeek" /> para esta secuencia es <see langword="false" />.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como el cierre del archivo.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Lock : int64 * int64 -&gt; unit&#xA;override this.Lock : int64 * int64 -&gt; unit" Usage="fileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Comienzo del intervalo que se va a bloquear. El valor de este parámetro debe ser igual o mayor que cero (0).</param>
        <param name="length">El intervalo que se va a bloquear.</param>
        <summary>Impide que otros procesos lean de <see cref="T:System.IO.FileStream" /> o escriban en él.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bloqueo de un intervalo de una secuencia de archivos ofrece los subprocesos de al proceso bloqueo acceso exclusivo a ese rango de la secuencia de archivos.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo bloquear parte de un archivo para que otro proceso no puede acceder a esa parte del archivo aunque tenga acceso de lectura y escritura al archivo. Ejecute el programa simultáneamente en ventanas de comandos e investigue el uso de las opciones de entrada de consola diferentes.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> o <paramref name="length" /> es negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">El archivo se cierra.</exception>
        <exception cref="T:System.IO.IOException">El proceso no puede obtener acceso al archivo porque otro proceso ha bloqueado una parte de este.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso absoluta del archivo abierto en <see langword="FileStream" />.</summary>
        <value>Cadena que es la ruta de acceso absoluta del archivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Si no se conoce la ruta de acceso absoluta, esta propiedad devuelve una cadena similar a "[desconocido]".

 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la posición actual de esta secuencia.</summary>
        <value>Posición actual de esta secuencia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se admite la búsqueda en cualquier ubicación más allá de la longitud de la secuencia.  Cuando se busca más allá de la longitud del archivo, que aumenta el tamaño del archivo.  En Microsoft Windows NT y versiones más recientes, los datos agregados al final del archivo se establecen en cero.  En Microsoft Windows 98 o versiones anteriores, todos los datos agregados al final del archivo no se establecen en cero, lo que significa que los datos eliminados anteriormente está visible en la secuencia. Establecer la posición de la secuencia en un valor grande más allá del final de la secuencia en Windows 98 o una versión anterior puede provocar una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `Length` y `Position` propiedades para comprobar una condición de final de archivo.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La secuencia no admite búsqueda.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.  
  
O bien 
La posición se estableció en un valor muy grande más allá del final de la secuencia en Windows 98 o versiones anteriores.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Se intentó establecer la posición en un valor negativo.</exception>
        <exception cref="T:System.IO.EndOfStreamException">Se intentó buscar más allá del final de una secuencia que no admite esto.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="fileStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Cuando este método devuelve un valor, contiene la matriz de bytes especificada con los valores entre <paramref name="offset" /> y (<paramref name="offset" /> + <paramref name="count" /> - 1<c>)</c> reemplazados por los bytes leídos desde el origen actual.</param>
        <param name="offset">Desplazamiento de bytes en <paramref name="array" /> donde se colocarán los bytes leídos.</param>
        <param name="count">Número máximo de bytes que se pueden leer.</param>
        <summary>Lee un bloque de bytes de la secuencia y escribe los datos en un búfer dado.</summary>
        <returns>Número total de bytes leídos en el búfer. Puede ser menor que el número de bytes solicitado si ese número de bytes no está disponible actualmente o cero si se ha alcanzado el final de la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.IO.Stream.Read%2A>.  
  
 El `offset` parámetro indica el desplazamiento del byte de `array` (índice de búfer) en el que se va a comenzar la lectura y el `count` parámetro proporciona el número máximo de bytes que se lee en esta secuencia. El valor devuelto es el número real de bytes leídos, o cero si se alcanza el final de la secuencia. Si la operación de lectura se realiza correctamente, avanza la posición actual de la secuencia por el número de bytes leídos. Si se produce una excepción, se modifica la posición actual de la secuencia.  
  
 El <xref:System.IO.FileStream.Read%2A> método devuelve cero únicamente después de alcanzar el final de la secuencia. En caso contrario, <xref:System.IO.FileStream.Read%2A> lee siempre al menos un byte de la secuencia antes de devolver. Si no hay datos disponibles en la secuencia tras una llamada a <xref:System.IO.FileStream.Read%2A>, el método se bloqueará hasta que se puede devolver al menos un byte de datos. Una implementación es gratis devolver menos bytes de los solicitados, incluso si no se alcanzó el final de la secuencia.  
  
 Use <xref:System.IO.BinaryReader> para leer los tipos de datos primitivos.  
  
 No se interrumpe un subproceso que está realizando una operación de lectura. Aunque puede parecer que la aplicación se ejecute correctamente después de que el subproceso se desbloquea, la interrupción puede disminuir el rendimiento y la confiabilidad de la aplicación.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se lee el contenido de un <xref:System.IO.FileStream> y lo escribe en otro <xref:System.IO.FileStream>.  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.NotSupportedException">La secuencia no admite lectura.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> y <paramref name="count" /> describen un intervalo no válido en <paramref name="array" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se efectuó una llamada a los métodos después de cerrar la secuencia.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer en el que se escriben los datos.</param>
        <param name="offset">Posición de desplazamiento en bytes de <paramref name="buffer" /> donde se comienza a escribir los datos del flujo.</param>
        <param name="count">Número máximo de bytes que se pueden leer.</param>
        <param name="cancellationToken">Token para supervisar solicitudes de cancelación.</param>
        <summary>Lee de forma asincrónica una secuencia de bytes en la secuencia actual, se hace avanzar la posición dentro de la secuencia el número de bytes leídos y controla las solicitudes de cancelación.</summary>
        <returns>Tarea que representa la operación de lectura asincrónica. El valor del parámetro <paramref name="TResult" /> contiene el número total de bytes leídos en el búfer. El valor del resultado puede ser menor que el número de bytes solicitados si el número de bytes disponibles actualmente es menor que el número solicitado o puede ser 0 (cero) si se ha llegado al final de la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileStream.ReadAsync%2A> método le permite realizar operaciones de archivos de gran cantidad de recursos sin bloquear el subproceso principal. Esta consideración de rendimiento es especialmente importante en una aplicación de la [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o una aplicación de [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] en que una operación de streaming prolongada puede bloquear el subproceso de interfaz de usuario y hacer que parezca que una aplicación ha dejado de responder. Los métodos asincrónicos se usan junto con la `async` y `await` palabras clave en Visual Basic y C#.  
  
 Use el <xref:System.IO.FileStream.CanRead%2A> propiedad para determinar si la instancia actual admite lectura.  
  
 Si se cancela la operación antes de que finalice, la tarea devuelta contiene la <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para el <xref:System.Threading.Tasks.Task.Status%2A> propiedad. Si se elimina el identificador del archivo, la tarea devuelta contiene la <xref:System.ObjectDisposedException> excepción en el <xref:System.Threading.Tasks.Task.Exception%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo se leen desde un archivo de forma asincrónica.  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.ArgumentException">La suma de <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud del búfer.</exception>
        <exception cref="T:System.NotSupportedException">La secuencia no admite lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado la secuencia.</exception>
        <exception cref="T:System.InvalidOperationException">Una operación de lectura anterior está usando actualmente la secuencia.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="fileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee un byte del archivo y avanza la posición de lectura un byte.</summary>
        <returns>El byte, convertido en un <see cref="T:System.Int32" />, o -1 si se ha alcanzado el final de la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.IO.Stream.ReadByte%2A>.  
  
> [!NOTE]
>  Use el <xref:System.IO.FileStream.CanRead%2A> propiedad para determinar si la instancia actual admite lectura. Para obtener información adicional, vea <xref:System.IO.Stream.CanRead%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo escribir datos en un archivo, byte a byte y, a continuación, compruebe que los datos se han escrito correctamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La secuencia actual no admite lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se cierra la secuencia actual.</exception>
        <block subset="none" type="overrides"><para>La implementación predeterminada de <see langword="Stream" /> crea una nueva matriz de byte único y, a continuación, llama a <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Aunque esto es formalmente correcto, no es eficaz. Cualquier secuencia con un búfer interno debe reemplazar este método y proporcionar una versión mucho más eficaz que lee el búfer directamente, evitando la asignación adicional de matrices en cada llamada.  
  
Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> que representa el identificador de archivos del sistema operativo correspondiente al archivo que el objeto <see cref="T:System.IO.FileStream" /> actual encapsula.</summary>
        <value>Objeto que representa el identificador de archivos del sistema operativo correspondiente al archivo que el objeto <see cref="T:System.IO.FileStream" /> actual encapsula.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileStream.SafeFileHandle%2A> propiedad vacía la secuencia y establece la posición actual de la secuencia en 0 automáticamente.  Esto permite mover el archivo o la posición del flujo restablecerse otra secuencia utilizando el <xref:System.IO.FileStream.SafeFileHandle%2A> devuelto por esta propiedad.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener permiso llamar a código no administrado.  
  
Acción de seguridad: Petición de vínculo 
Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="fileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">El punto relativo a <paramref name="origin" /> desde el que comienza la operación Seek.</param>
        <param name="origin">Especifica el comienzo, el final o la posición actual como un punto de referencia para <paramref name="offset" />, mediante el uso de un valor de tipo <see cref="T:System.IO.SeekOrigin" />.</param>
        <summary>Establece la posición actual de esta secuencia actual en el valor dado.</summary>
        <returns>Nueva posición en la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Use el <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> propiedad para determinar si la instancia actual admite búsquedas. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>.  
  
 Puede buscar cualquier ubicación más allá de la longitud de la secuencia. Cuando se busca más allá de la longitud del archivo, que aumenta el tamaño del archivo. En Windows NT y versiones posteriores, los datos agregados al final del archivo se establecen en cero. En Windows 98 o versiones anteriores, los datos agregados al final del archivo no se establecen en cero, lo que significa que los datos eliminados anteriormente está visible en la secuencia.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo escribir datos en un archivo, byte a byte y, a continuación, compruebe que los datos se han escrito correctamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 El ejemplo siguiente lee el texto en la dirección inversa, desde el final del archivo al principio del archivo, mediante el uso de los distintos <xref:System.IO.SeekOrigin> valores con el <xref:System.IO.FileStream.Seek%2A> método.  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.NotSupportedException">La secuencia no admite búsquedas, por ejemplo, si el <see langword="FileStream" /> se construye a partir de una canalización o una consola de salida.</exception>
        <exception cref="T:System.ArgumentException">La búsqueda se intenta antes del comienzo de la secuencia.</exception>
        <exception cref="T:System.ObjectDisposedException">Se efectuó una llamada a los métodos después de cerrar la secuencia.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileStream.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">Objeto que describe una entrada ACL que se va a aplicar al archivo actual.</param>
        <summary>Aplica las entradas de la lista de control de acceso (ACL) descritas por un objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> al archivo descrito por el objeto <see cref="T:System.IO.FileStream" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mientras el <xref:System.IO.FileStream> clase y <xref:System.IO.FileStream.SetAccessControl%2A> puede usarse en un archivo existente, puede usar el <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> es más fácil usar el método.  
  
 El <xref:System.IO.FileStream.SetAccessControl%2A> método aplica las entradas de lista (ACL) de control de acceso a un archivo que representa la lista ACL no heredada.  
  
> [!CAUTION]
>  Especifica la ACL para el `fileSecurity` parámetro reemplaza la ACL existente para el archivo. Para agregar permisos para un usuario nuevo, use el <xref:System.IO.FileStream.GetAccessControl%2A> método para obtener la ACL existente, modificarlo y, a continuación, usar <xref:System.IO.FileStream.SetAccessControl%2A> para aplicarla al archivo.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo dado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El archivo está cerrado.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="fileSecurity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">No se pudo encontrar o modificar el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El proceso actual no tiene acceso para abrir el archivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="fileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">La nueva longitud de la secuencia.</param>
        <summary>Establece la longitud de esta secuencia en el valor dado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.IO.Stream.SetLength%2A>.  
  
 Si el valor especificado es menor que la longitud actual de la secuencia, se trunca la secuencia. En este escenario, si la posición actual es mayor que la nueva longitud, se mueve la posición actual hasta el último byte de la secuencia. Si el valor especificado es mayor que la longitud actual de la secuencia, se expande la secuencia y la posición actual sigue siendo el mismo. Si se expande la secuencia, el contenido de la secuencia entre la antigua y la nueva longitud es indefinido.  
  
 Una secuencia debe admitir operaciones de escritura y de búsqueda para `SetLength` funcione.  
  
> [!NOTE]
>  Use la <xref:System.IO.FileStream.CanWrite%2A> propiedad para determinar si la instancia actual admite operaciones de escritura y el <xref:System.IO.FileStream.CanSeek%2A> propiedad para determinar si se admite la búsqueda. Para más información, consulte <xref:System.IO.Stream.CanWrite%2A> y <xref:System.IO.Stream.CanSeek%2A>.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S.</exception>
        <exception cref="T:System.NotSupportedException">La secuencia no admite operaciones de escritura ni de búsqueda.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Se intentó establecer el parámetro <paramref name="value" /> en menos de 0.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Unlock : int64 * int64 -&gt; unit&#xA;override this.Unlock : int64 * int64 -&gt; unit" Usage="fileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">El comienzo del intervalo que se va a desbloquear.</param>
        <param name="length">El intervalo que se va a desbloquear.</param>
        <summary>Permite que otros procesos tengan acceso total o parcial a un archivo previamente bloqueado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo bloquear parte de un archivo para que otro proceso no puede tener acceso a esa parte del archivo, incluso aunque tenga acceso de lectura y escritura al archivo y, a continuación, desbloquear la parte especificada del archivo. Ejecute el programa simultáneamente en ventanas de comandos e investigue el uso de las opciones de entrada de consola diferentes.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> o <paramref name="length" /> es negativo.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="fileStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Búfer que contiene los datos que se van a escribir en la secuencia.</param>
        <param name="offset">Desplazamiento en bytes de base cero de <paramref name="array" /> desde donde se comienzan a copiar los bytes en la secuencia.</param>
        <param name="count">Número máximo de bytes que se pueden escribir.</param>
        <summary>Escribe un bloque de bytes en la secuencia de archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.IO.Stream.Write%2A>.  
  
 El `offset` parámetro indica el desplazamiento del byte de `array` (índice de búfer) donde se comienzan a copiar y el `count` parámetro proporciona el número de bytes que se escribirán en la secuencia. Si la operación de escritura se realiza correctamente, avanza la posición actual de la secuencia por el número de bytes escritos. Si se produce una excepción, se modifica la posición actual de la secuencia.  
  
> [!NOTE]
>  Use el <xref:System.IO.FileStream.CanWrite%2A> propiedad para determinar si la instancia actual admite escritura. Para obtener información adicional, vea <xref:System.IO.Stream.CanWrite%2A>.  
  
 No se interrumpe un subproceso que está realizando una operación de escritura. Aunque puede parecer que la aplicación se ejecute correctamente después de que el subproceso se desbloquea, la interrupción puede disminuir el rendimiento y la confiabilidad de la aplicación.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.IO.FileStream.Lock%2A> método.  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> y <paramref name="count" /> describen un intervalo no válido en <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.  
  
O bien 
Otro subproceso puede haber producido un cambio inesperado en la posición del identificador de archivo del sistema operativo.</exception>
        <exception cref="T:System.ObjectDisposedException">La secuencia está cerrada.</exception>
        <exception cref="T:System.NotSupportedException">La instancia actual de la secuencia no admite la escritura.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer del que se van a escribir datos.</param>
        <param name="offset">Desplazamiento en bytes de base cero de <paramref name="buffer" /> desde donde se comienzan a copiar los bytes en la secuencia.</param>
        <param name="count">Número máximo de bytes que se pueden escribir.</param>
        <param name="cancellationToken">Token para supervisar solicitudes de cancelación.</param>
        <summary>Escribe de forma asincrónica una secuencia de bytes en la secuencia actual, se hace avanzar la posición actual dentro de la secuencia por el número de bytes escritos y controla las solicitudes de cancelación.</summary>
        <returns>Tarea que representa la operación de escritura asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileStream.WriteAsync%2A> método le permite realizar operaciones de archivos de gran cantidad de recursos sin bloquear el subproceso principal. Esta consideración de rendimiento es especialmente importante en una aplicación de la [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o una aplicación de [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] en que una operación de streaming prolongada puede bloquear el subproceso de interfaz de usuario y hacer que parezca que una aplicación ha dejado de responder. Los métodos asincrónicos se usan junto con la `async` y `await` palabras clave en Visual Basic y C#.  
  
 Use el <xref:System.IO.FileStream.CanWrite%2A> propiedad para determinar si la instancia actual admite escritura.  
  
 Si se cancela la operación antes de que finalice, la tarea devuelta contiene la <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para el <xref:System.Threading.Tasks.Task.Status%2A> propiedad. Si se elimina el identificador del archivo, la tarea devuelta contiene la <xref:System.ObjectDisposedException> excepción en el <xref:System.Threading.Tasks.Task.Exception%2A> propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo escribir asincrónicamente en un archivo.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.ArgumentException">La suma de <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud del búfer.</exception>
        <exception cref="T:System.NotSupportedException">La secuencia no admite escritura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado la secuencia.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está actualmente en uso por una operación de escritura anterior.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="fileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Un byte que se va a escribir en la secuencia.</param>
        <summary>Escribe un byte en la posición actual de la secuencia de archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.IO.Stream.WriteByte%2A>.  
  
 Use `WriteByte` para escribir un byte en un `FileStream` eficazmente. Si la secuencia está cerrada o no se puede escribir, se producirá una excepción.  
  
> [!NOTE]
>  Use el <xref:System.IO.FileStream.CanWrite%2A> propiedad para determinar si la instancia actual admite escritura. Para obtener información adicional, vea <xref:System.IO.Stream.CanWrite%2A>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo escribir datos en un archivo, byte a byte y, a continuación, compruebe que los datos se han escrito correctamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">La secuencia está cerrada.</exception>
        <exception cref="T:System.NotSupportedException">La secuencia no admite escritura.</exception>
        <block subset="none" type="overrides"><para>La implementación predeterminada de <see langword="Stream" /> crea una nueva matriz de byte único y, a continuación, llama a <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Aunque esto es formalmente correcto, no es eficaz. Cualquier secuencia con un búfer interno debe reemplazar este método y proporcionar una versión mucho más eficaz que lee el búfer directamente, evitando la asignación adicional de matrices en cada llamada.  
  
Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
  </Members>
</Type>