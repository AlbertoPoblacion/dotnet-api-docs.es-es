<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="dcfd61af2ebaa502d576b0c9b8678e446f13ce2b" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36484707" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type FileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona un <see cref="T:System.IO.Stream" /> para un archivo, lo que permite operaciones de lectura y escritura sincrónica y asincrónica.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.FileStream> clase para leer, escribir, abrir y cerrar archivos en un sistema de archivos y para manipular otros identificadores del sistema operativo relacionados con el archivo, como canalizaciones, entrada estándar y salida estándar. Puede usar el <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.Stream.CopyTo%2A>, y <xref:System.IO.FileStream.Flush%2A> métodos para realizar las operaciones sincrónicas, o la <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, y <xref:System.IO.FileStream.FlushAsync%2A> métodos para realizar asincrónica operaciones. Use los métodos asincrónicos para realizar operaciones de archivos de gran cantidad de recursos sin bloquear el subproceso principal. Esta consideración de rendimiento es especialmente importante en una aplicación de la [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o una aplicación de [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] en que una operación de streaming prolongada puede bloquear el subproceso de interfaz de usuario y hacer que parezca que una aplicación ha dejado de responder. <xref:System.IO.FileStream> búferes de entrada y salida para mejorar el rendimiento.  
  
> [!IMPORTANT]
>  Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo, debe eliminar del mismo directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él indirectamente, use una construcción de lenguaje como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
 El <xref:System.IO.FileStream.IsAsync%2A> propiedad detecta si se abrió el identificador de archivo de forma asincrónica. Especifique este valor cuando se crea una instancia de la <xref:System.IO.FileStream> clase utilizando un constructor que tiene un `isAsync`, `useAsync`, o `options` parámetro. Cuando la propiedad es `true`, la secuencia utiliza E/S superpuesta para realizar operaciones de archivo de forma asincrónica. Sin embargo, el <xref:System.IO.FileStream.IsAsync%2A> propiedad no tiene que ser `true` para llamar a la <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, o <xref:System.IO.Stream.CopyToAsync%2A> método. Cuando el <xref:System.IO.FileStream.IsAsync%2A> propiedad es `false` y llama a la lectura asincrónica y las operaciones de escritura, no sigue se bloquea el subproceso de interfaz de usuario, pero la operación de E/S real se realiza de forma sincrónica.  
  
 El <xref:System.IO.FileStream.Seek%2A> método admite el acceso aleatorio a los archivos. <xref:System.IO.FileStream.Seek%2A> permite la posición de lectura/escritura se muevan a cualquier posición dentro del archivo. Esto se realiza con parámetros de punto de referencia de desplazamiento de bytes. El desplazamiento de byte es relativo al punto de referencia de búsqueda, que puede ser el comienzo, la posición actual o el final del archivo subyacente, tal como está representado por los tres miembros de la <xref:System.IO.SeekOrigin> enumeración.  
  
> [!NOTE]
>  Archivos de disco siempre admiten el acceso aleatorio. En el momento de construcción, el <xref:System.IO.FileStream.CanSeek%2A> valor de la propiedad se establece en `true` o `false` según el tipo de archivo subyacente. Si el tipo de archivo subyacente es FILE_TYPE_DISK, tal como se define en winbase.h, el <xref:System.IO.FileStream.CanSeek%2A> es el valor de la propiedad `true`. En caso contrario, el <xref:System.IO.FileStream.CanSeek%2A> es el valor de la propiedad `false`.  
  
 Si un proceso termina con parte de un archivo bloqueado o cierra un archivo que tiene bloqueos pendientes, el comportamiento es indefinido.  
  
 Para las operaciones de directorio y otras operaciones de archivo, consulte la <xref:System.IO.File>, <xref:System.IO.Directory>, y <xref:System.IO.Path> clases. El <xref:System.IO.File> es una clase de utilidad que tiene métodos estáticos principalmente para la creación de <xref:System.IO.FileStream> objetos basados en las rutas de acceso de archivo. El <xref:System.IO.MemoryStream> clase crea una secuencia a partir de una matriz de bytes y es similar a la <xref:System.IO.FileStream> clase.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
## <a name="detection-of-stream-position-changes"></a>Detección de cambios de la posición de secuencia  
 Cuando un <xref:System.IO.FileStream> objeto no tiene control exclusivo sobre su identificador, otro subproceso podría tener acceso al identificador de archivo al mismo tiempo y cambiar la posición del puntero de archivo del sistema operativo que está asociado con el identificador de archivo. En este caso, la posición almacenada en caché en el <xref:System.IO.FileStream> objeto y los datos en caché en el búfer pudieron verse comprometidos. El <xref:System.IO.FileStream> objeto habitualmente realiza comprobaciones en los métodos que tener acceso al búfer almacenado en caché para asegurarse de que la posición del identificador del sistema operativo es igual que la posición almacenada en caché utilizada por el <xref:System.IO.FileStream> objeto.  
  
 Si se detecta un cambio inesperado en la posición del identificador en una llamada a la <xref:System.IO.FileStream.Read%2A> (método), .NET Framework descarta el contenido del búfer y vuelve a leer la secuencia del archivo. Esto puede afectar al rendimiento, dependiendo del tamaño del archivo y ningún otro proceso que podría afectar a la posición de la secuencia de archivos.  
  
 Si se detecta un cambio inesperado en la posición del identificador en una llamada a la <xref:System.IO.FileStream.Write%2A> método, el contenido del búfer se descartan y <xref:System.IO.IOException> se produce la excepción.  
  
 A <xref:System.IO.FileStream> objeto no tendrán una suspensión exclusivo sobre su identificador cuando ya sea el <xref:System.IO.FileStream.SafeFileHandle%2A> acceso a la propiedad para exponer el identificador o el <xref:System.IO.FileStream> se proporciona al objeto el <xref:System.IO.FileStream.SafeFileHandle%2A> propiedad en su constructor.  
  
   
  
## Examples  
 El ejemplo siguiente muestra algunas de las <xref:System.IO.FileStream> constructores.  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 En el ejemplo siguiente se muestra cómo escribir en un archivo de forma asincrónica. Este código se ejecuta en una aplicación WPF que tiene un TextBlock denominado /userinput y un botón enlazarse a un controlador de eventos Click denominado Button_Click. La ruta de acceso de archivo debe cambiarse a un archivo que exista en el equipo.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de archivo para el archivo que el objeto <see langword="FileStream" /> actual va a encapsular.</param>
        <param name="access">Constante que establece las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> para el identificador de archivo especificado, con el permiso de lectura y escritura especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.IO.Stream.Close%2A> es llama, se cierra también el identificador y el recuento de identificadores del archivo va disminuyendo.  
  
 `FileStream` se da por supuesto que tiene control exclusivo sobre el identificador. Lectura, escritura o búsqueda mientras un `FileStream` también contiene un identificador podría provocar daños en los datos. Por motivos de seguridad de datos, llame a <xref:System.IO.FileStream.Flush%2A> antes de utilizar el identificador y evite llamar a cualquier método distinto de `Close` cuando haya terminado con el identificador.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.  
  
 `FileShare.Read` es el valor predeterminado para los <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> no es un campo de <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como un error de disco.  -o bien- Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el <paramref name="access" /> solicitado para el identificador de archivo especificado, como sucede, por ejemplo, cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el identificador de archivo está establecido para el acceso de sólo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar texto a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de archivo para el archivo que el objeto <see langword="FileStream" /> actual va a encapsular.</param>
        <param name="access">Constante que establece las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> para el identificador de archivo especificado, con el permiso de lectura y escritura especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.IO.Stream.Close%2A> es llama, se cierra también el identificador y el recuento de identificadores del archivo va disminuyendo.  
  
 `FileStream` se da por supuesto que tiene control exclusivo sobre el identificador. Lectura, escritura o búsqueda mientras un `FileStream` también contiene un identificador podría provocar daños en los datos. Por motivos de seguridad de datos, llame a <xref:System.IO.FileStream.Flush%2A> antes de utilizar el identificador y evite llamar a cualquier método distinto de `Close` cuando haya terminado con el identificador.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.  
  
 `FileShare.Read` es el valor predeterminado para los <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> no es un campo de <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como un error de disco.  -o bien- Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el <paramref name="access" /> solicitado para el identificador de archivo especificado, como sucede, por ejemplo, cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el identificador de archivo está establecido para el acceso de sólo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar texto a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see langword="FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con el modo de creación y la ruta de acceso especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).  
  
 El constructor se concede acceso de lectura/escritura al archivo y se abre compartiendo el acceso de lectura (es decir, las solicitudes para abrir el archivo para escritura por esta u otro proceso producirá errores hasta que el `FileStream` se ha cerrado el objeto, pero los intentos de lectura se realice correctamente).  
  
 No se puede utilizar este constructor para abrir archivos de solo lectura; en su lugar, debe usar un constructor que acepta un `FileAccess` parámetro con el valor establecido en `FileAccess.Read`.  
  
 El tamaño del búfer se establece en el tamaño predeterminado de 4096 bytes (4 KB).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan archivos. Si `path` indica un dispositivo que no admite búsquedas, el <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` es el valor predeterminado para los <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
 Para los constructores sin un <xref:System.IO.FileAccess> parámetro, si la `mode` parámetro está establecido en <xref:System.IO.FileMode.Append>, <xref:System.IO.FileAccess.Write> es el acceso predeterminado. En caso contrario, el acceso está establecido en <xref:System.IO.FileAccess.ReadWrite>.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo escribir datos en un archivo, byte a byte y, a continuación, compruebe que los datos se han escrito correctamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.  -o bien- <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y no existe el archivo especificado por <paramref name="path" />. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> y ya existe el archivo especificado por <paramref name="path" />.  -o bien- Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valor no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar texto a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de archivo para el archivo que el objeto <see langword="FileStream" /> actual va a encapsular.</param>
        <param name="access">Constante <see cref="T:System.IO.FileAccess" /> que establece las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> para el identificador de archivo especificado, con el tamaño de búfer y el permiso de lectura y escritura especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` se da por supuesto que tiene control exclusivo sobre el identificador. Lectura, escritura o búsqueda mientras un `FileStream` también contiene un identificador podría provocar daños en los datos. Por motivos de seguridad de datos, llame a <xref:System.IO.FileStream.Flush%2A> antes de utilizar el identificador y evite llamar a cualquier método distinto de `Close` cuando haya terminado con el identificador. Como alternativa, leer y escribir en el controlador antes de llamar a este `FileStream` constructor.  
  
 `FileShare.Read` es el valor predeterminado para los <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="handle" /> no es un identificador válido.  -o bien- El parámetro <paramref name="handle" /> es un identificador sincrónico y se usó de forma asincrónica.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor del parámetro <paramref name="bufferSize" /> es negativo.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como un error de disco.  -o bien- Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el <paramref name="access" /> solicitado para el identificador de archivo especificado, como sucede, por ejemplo, cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el identificador de archivo está establecido para el acceso de sólo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar texto a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener permiso llamar a código no administrado. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de archivo para el archivo que el objeto <see langword="FileStream" /> actual va a encapsular.</param>
        <param name="access">Constante que establece las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />.</param>
        <param name="ownsHandle">Es <see langword="true" /> si esta instancia de <see langword="FileStream" /> va a ser la propietaria del identificador de archivo; en caso contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> para el identificador de archivo especificado, con el permiso de lectura y escritura establecido y la propiedad de la instancia de <see langword="FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `FileStream` se proporciona el acceso especificado al objeto en el archivo. La propiedad del identificador será según se haya especificado. Si este proceso posee el identificador, una llamada a la <xref:System.IO.Stream.Close%2A> método también cerrará el identificador y el recuento de identificadores del archivo va disminuyendo. La `FileStream` objeto recibe el tamaño de búfer predeterminado de 4096 bytes.  
  
 `FileStream` se da por supuesto que tiene control exclusivo sobre el identificador. Lectura, escritura o búsqueda mientras un `FileStream` también contiene un identificador podría provocar daños en los datos. Por motivos de seguridad de datos, llame a <xref:System.IO.FileStream.Flush%2A> antes de utilizar el identificador y evite llamar a métodos distintos de `Close` cuando haya terminado con el identificador.  
  
 `FileShare.Read` es el valor predeterminado para los <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> no es un campo de <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como un error de disco.  -o bien- Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el <paramref name="access" /> solicitado para el identificador de archivo especificado, como sucede, por ejemplo, cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el identificador de archivo está establecido para el acceso de sólo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar texto a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see langword="FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <param name="access">Constante que determina cómo puede obtener acceso al archivo el objeto <see langword="FileStream" />. Esto también determina los valores que devuelven las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> es <see langword="true" /> si <c>path</c> especifica un archivo de disco.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con el permiso de lectura y escritura, el modo de creación y la ruta de acceso especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).  
  
 El constructor se concede acceso de lectura/escritura al archivo y se abre compartiendo el acceso de lectura (es decir, las solicitudes para abrir el archivo para escritura por esta u otro proceso producirá errores hasta que el `FileStream` se ha cerrado el objeto, pero los intentos de lectura se realice correctamente). El tamaño del búfer se establece en el tamaño predeterminado de 4096 bytes (4 KB).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan archivos. Si `path` indica un dispositivo que no admite búsquedas, el <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` es el valor predeterminado para los <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.  -o bien- <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y no existe el archivo especificado por <paramref name="path" />. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> y ya existe el archivo especificado por <paramref name="path" />.  -o bien- Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el <paramref name="access" /> solicitado para el <paramref name="path" /> especificado, como sucede, por ejemplo, cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el archivo o el directorio está establecido para el acceso de solo lectura.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valor no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar texto a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de archivo para el archivo que este objeto <see langword="FileStream" /> va a encapsular.</param>
        <param name="access">Constante que establece las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <param name="isAsync">Es <see langword="true" /> si se abrió el identificador de forma asincrónica (es decir, en modo de E/S superpuesta); de lo contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> para el identificador de archivo especificado, y con el permiso de lectura y escritura, el tamaño de búfer y el estado sincrónico o asincrónico especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establece el `isAsync` parámetro `true` para abrir el identificador de archivo de forma asincrónica. Cuando el parámetro es `true`, la secuencia utiliza E/S superpuesta para realizar operaciones de archivo de forma asincrónica. Sin embargo, el parámetro no tiene que ser `true` para llamar a la <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, o <xref:System.IO.Stream.CopyToAsync%2A> método. Cuando el `isAsync` parámetro es `false` y llama a la lectura asincrónica y las operaciones de escritura, no sigue se bloquea el subproceso de interfaz de usuario, pero la operación de E/S real se realiza de forma sincrónica.  
  
 `FileStream` se da por supuesto que tiene control exclusivo sobre el identificador. Lectura, escritura o búsqueda mientras un `FileStream` también contiene un identificador podría provocar daños en los datos. Por motivos de seguridad de datos, llame a <xref:System.IO.FileStream.Flush%2A> antes de utilizar el identificador y evite llamar a cualquier método distinto de `Close` cuando haya terminado con el identificador. Como alternativa, leer y escribir en el controlador antes de llamar a este `FileStream` constructor.  
  
 `FileShare.Read` es el valor predeterminado para los <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="handle" /> no es un identificador válido.  -o bien- El parámetro <paramref name="handle" /> es un identificador sincrónico y se usó de forma asincrónica.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor del parámetro <paramref name="bufferSize" /> es negativo.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como un error de disco.  -o bien- Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el <paramref name="access" /> solicitado para el identificador de archivo especificado, como sucede, por ejemplo, cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el identificador de archivo está establecido para el acceso de sólo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar texto a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener permiso llamar a código no administrado. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de archivo para el archivo que este objeto <see langword="FileStream" /> va a encapsular.</param>
        <param name="access">Constante que establece las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />.</param>
        <param name="ownsHandle">Es <see langword="true" /> si esta instancia de <see langword="FileStream" /> va a ser la propietaria del identificador de archivo; en caso contrario, es <see langword="false" />.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> para el identificador de archivo especificado, con el tamaño de búfer, la propiedad de la instancia de <see langword="FileStream" /> y el permiso de lectura y escritura especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `FileStream` se proporciona el acceso especificado al objeto en el archivo. La propiedad del identificador será según se haya especificado. Si este `FileStream` posee el identificador, una llamada a la <xref:System.IO.Stream.Close%2A> método también cerrará el identificador. En concreto, el recuento de identificadores del archivo es reducido. El `FileStream` se proporciona el tamaño de búfer especificado al objeto.  
  
 `FileStream` se da por supuesto que tiene control exclusivo sobre el identificador. Lectura, escritura o búsqueda mientras un `FileStream` también contiene un identificador podría provocar daños en los datos. Por motivos de seguridad de datos, llame a <xref:System.IO.FileStream.Flush%2A> antes de utilizar el identificador y evite llamar a cualquier método distinto de `Close` cuando haya terminado con el identificador. Como alternativa, leer y escribir en el controlador antes de llamar a este `FileStream` constructor.  
  
 `FileShare.Read` es el valor predeterminado para los <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> es negativo.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como un error de disco.  -o bien- Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el <paramref name="access" /> solicitado para el identificador de archivo especificado, como sucede, por ejemplo, cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el identificador de archivo está establecido para el acceso de sólo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar texto a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see langword="FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <param name="access">Constante que determina cómo puede obtener acceso al archivo el objeto <see langword="FileStream" />. Esto también determina los valores que devuelven las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> es <see langword="true" /> si <c>path</c> especifica un archivo de disco.</param>
        <param name="share">Constante que determina cómo compartirán el archivo los procesos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con el permiso de uso compartido, el permiso de lectura y escritura, el modo de creación y la ruta de acceso especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).  
  
 El constructor se concede acceso de lectura/escritura al archivo y se abre compartiendo el acceso de lectura (es decir, las solicitudes para abrir el archivo para escritura por esta u otro proceso producirá errores hasta que el `FileStream` se ha cerrado el objeto, pero los intentos de lectura se realice correctamente). El tamaño del búfer se establece en el tamaño predeterminado de 4096 bytes (4 KB).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan archivos. Si `path` indica un dispositivo que no admite búsquedas, el <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.FileStream.Lock%2A> método.  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.  -o bien- <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y no existe el archivo especificado por <paramref name="path" />. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> y ya existe el archivo especificado por <paramref name="path" />.  -o bien- El sistema dispone de Windows 98 o Windows 98 Second Edition y <paramref name="share" /> está establecido en <see langword="FileShare.Delete" />.  -o bien- Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el <paramref name="access" /> solicitado para el <paramref name="path" /> especificado, como sucede, por ejemplo, cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el archivo o el directorio está establecido para el acceso de solo lectura.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contiene un valor no válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar texto a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Identificador de archivo para el archivo que este objeto <see langword="FileStream" /> va a encapsular.</param>
        <param name="access">Constante que establece las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />.</param>
        <param name="ownsHandle">Es <see langword="true" /> si esta instancia de <see langword="FileStream" /> va a ser la propietaria del identificador de archivo; en caso contrario, es <see langword="false" />.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <param name="isAsync">Es <see langword="true" /> si se abrió el identificador de forma asincrónica (es decir, en modo de E/S superpuesta); de lo contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> para el identificador de archivo especificado, con el estado sincrónico o asincrónico, el tamaño de búfer, la propiedad de la instancia de <see langword="FileStream" /> y el permiso de lectura y escritura especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `FileStream` se proporciona el acceso especificado al objeto en el archivo. La propiedad del identificador será según se haya especificado. Si este `FileStream` posee el identificador, una llamada a la <xref:System.IO.Stream.Close%2A> método también cerrará el identificador. En concreto, el recuento de identificadores del archivo es reducido. El `FileStream` se proporciona el tamaño de búfer especificado al objeto.  
  
 `FileStream` se da por supuesto que tiene control exclusivo sobre el identificador. Lectura, escritura o búsqueda mientras un `FileStream` también contiene un identificador podría provocar daños en los datos. Por motivos de seguridad de datos, llame a <xref:System.IO.FileStream.Flush%2A> antes de utilizar el identificador y evite llamar a cualquier método distinto de `Close` cuando haya terminado con el identificador. Como alternativa, leer y escribir en el controlador antes de llamar a este `FileStream` constructor.  
  
 `FileShare.Read` es el valor predeterminado para los <xref:System.IO.FileStream> constructores sin un `FileShare` parámetro.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="access" /> es menor que <see langword="FileAccess.Read" /> o mayor que <see langword="FileAccess.ReadWrite" /> o <paramref name="bufferSize" /> es menor que o igual a 0.</exception>
        <exception cref="T:System.ArgumentException">El identificador no es válido.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como un error de disco.  -o bien- Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el <paramref name="access" /> solicitado para el identificador de archivo especificado, como sucede, por ejemplo, cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el identificador de archivo está establecido para el acceso de sólo lectura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see langword="FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <param name="access">Constante que determina cómo puede obtener acceso al archivo el objeto <see langword="FileStream" />. Esto también determina los valores que devuelven las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> es <see langword="true" /> si <c>path</c> especifica un archivo de disco.</param>
        <param name="share">Constante que determina cómo compartirán el archivo los procesos.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con el tamaño de búfer, el permiso de lectura y escritura y de uso compartido, el modo de creación y la ruta de acceso especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan archivos. Si `path` indica un dispositivo que no admite búsquedas, el <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.  -o bien- <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> es un valor negativo o es cero.  -o bien- <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> contienen un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y no existe el archivo especificado por <paramref name="path" />. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> y ya existe el archivo especificado por <paramref name="path" />.  -o bien- El sistema dispone de Windows 98 o Windows 98 Second Edition y <paramref name="share" /> está establecido en <see langword="FileShare.Delete" />.  -o bien- Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el <paramref name="access" /> solicitado para el <paramref name="path" /> especificado, como sucede, por ejemplo, cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el archivo o el directorio está establecido para el acceso de solo lectura.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar texto a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, useAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see langword="FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <param name="access">Constante que determina cómo puede obtener acceso al archivo el objeto <see langword="FileStream" />. Esto también determina los valores que devuelven las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> es <see langword="true" /> si <c>path</c> especifica un archivo de disco.</param>
        <param name="share">Constante que determina cómo compartirán el archivo los procesos.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <param name="useAsync">Especifica si se va a utilizar E/S asincrónica o sincrónica. Sin embargo, tenga en cuenta que el sistema operativo subyacente quizás no admita E/S asincrónica, por lo que cuando se especifica <see langword="true" />, puede que el identificador se abra de forma sincrónica en función de la plataforma. Cuando se abre de forma asincrónica, los métodos <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> y <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> proporcionan un rendimiento mejor en lecturas o escrituras grandes, pero es posible que sean mucho más lentos para lecturas o escrituras pequeñas. Si la aplicación se ha diseñado para aprovechar al máximo la E/S asincrónica, establezca el parámetro <c>useAsync</c> en <see langword="true" />. El uso de la E/S asincrónica de forma correcta puede agilizar las aplicaciones en hasta un factor de 10, pero su uso sin volver a diseñar la aplicación para la E/S asincrónica puede disminuir el rendimiento en hasta un factor de 10.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con el estado sincrónico o asincrónico, el tamaño de búfer, el permiso de lectura y escritura y de uso compartido, el modo de creación y la ruta de acceso especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan archivos. Si `path` indica un dispositivo que no admite búsquedas, el <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo escribir datos en un archivo de forma asincrónica y, a continuación, compruebe que los datos se han escrito correctamente. A `State` objeto se crea para pasar información del subproceso principal en el `EndReadCallback` y `EndWriteCallback` métodos.  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.  -o bien- <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> es un valor negativo o es cero.  -o bien- <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> contienen un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y no existe el archivo especificado por <paramref name="path" />. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> y ya existe el archivo especificado por <paramref name="path" />.  -o bien- El sistema dispone de Windows 98 o Windows 98 Second Edition y <paramref name="share" /> está establecido en <see langword="FileShare.Delete" />.  -o bien- Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el <paramref name="access" /> solicitado para el <paramref name="path" /> especificado, como sucede, por ejemplo, cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el archivo o el directorio está establecido para el acceso de solo lectura.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar texto a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="T:System.IO.File" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see langword="FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <param name="access">Constante que determina cómo puede obtener acceso al archivo el objeto <see langword="FileStream" />. Esto también determina los valores que devuelven las propiedades <see cref="P:System.IO.FileStream.CanRead" /> y <see cref="P:System.IO.FileStream.CanWrite" /> del objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" /> es <see langword="true" /> si <c>path</c> especifica un archivo de disco.</param>
        <param name="share">Constante que determina cómo compartirán el archivo los procesos.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <param name="options">Valor que especifica opciones de archivo adicionales.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con la ruta de acceso, el modo de creación, los permisos de lectura y escritura y de uso compartido, el acceso que otras secuencias de archivos pueden tener al mismo archivo, el tamaño del búfer y otras opciones de archivo que se hayan especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 El `fileOptions` parámetro se utiliza para proporcionar acceso a operaciones más avanzadas que se pueden aprovechar al crear un <xref:System.IO.FileStream> objeto.  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan archivos. Si `path` indica un dispositivo que no admite búsquedas, el <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se escribe datos en un archivo y, a continuación, lee los datos mediante la <xref:System.IO.FileStream> objeto.  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.  -o bien- <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> es un valor negativo o es cero.  -o bien- <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> contienen un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y no existe el archivo especificado por <paramref name="path" />. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> y ya existe el archivo especificado por <paramref name="path" />.  -o bien- Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el <paramref name="access" /> solicitado para el <paramref name="path" /> especificado, como sucede, por ejemplo, cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el archivo o el directorio está establecido para el acceso de solo lectura.  -o bien- <see cref="F:System.IO.FileOptions.Encrypted" /> se ha especificado para <paramref name="options" />, pero no se admite el cifrado de archivos en la plataforma actual.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar texto a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see cref="T:System.IO.FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <param name="rights">Constante que determina los derechos de acceso que se emplean al crear reglas de acceso y auditoría para el archivo.</param>
        <param name="share">Constante que determina cómo compartirán el archivo los procesos.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <param name="options">Constante que especifica opciones de archivo adicionales.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con la ruta de acceso, el modo de creación, los derechos de acceso y el permiso de uso compartido, el tamaño de búfer y opciones de archivo adicionales que se hayan especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 Utilícelo <xref:System.IO.FileStream.%23ctor%2A> constructor al que aplicar el acceso de derechos en el momento de creación de un archivo. Para obtener acceso o modificar los derechos en un archivo existente, considere el uso de la <xref:System.IO.File.GetAccessControl%2A> y <xref:System.IO.File.SetAccessControl%2A> métodos.  
  
 El `fileOptions` parámetro se utiliza para proporcionar acceso a operaciones más avanzadas que se pueden aprovechar al crear un <xref:System.IO.FileStream> objeto.  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan archivos. Si `path` indica un dispositivo que no admite búsquedas, el <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.  -o bien- <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> es un valor negativo o es cero.  -o bien- <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> contienen un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y no existe el archivo especificado por <paramref name="path" />. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o una versión posterior.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> y ya existe el archivo especificado por <paramref name="path" />.  -o bien- Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el <paramref name="access" /> solicitado para el <paramref name="path" /> especificado, como sucede, por ejemplo, cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el archivo o el directorio está establecido para el acceso de solo lectura.  -o bien- <see cref="F:System.IO.FileOptions.Encrypted" /> se ha especificado para <paramref name="options" />, pero no se admite el cifrado de archivos en la plataforma actual.</exception>
        <exception cref="T:System.IO.PathTooLongException">El valor especificado para <paramref name="path" />, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar texto a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa o absoluta del archivo que va a encapsular el objeto <see cref="T:System.IO.FileStream" /> actual.</param>
        <param name="mode">Constante que determina cómo abrir o crear el archivo.</param>
        <param name="rights">Constante que determina los derechos de acceso que se emplean al crear reglas de acceso y auditoría para el archivo.</param>
        <param name="share">Constante que determina cómo compartirán el archivo los procesos.</param>
        <param name="bufferSize">Valor <see cref="T:System.Int32" /> positivo mayor que 0 que indica el tamaño del búfer. El tamaño de búfer predeterminado es 4096.</param>
        <param name="options">Constante que especifica opciones de archivo adicionales.</param>
        <param name="fileSecurity">Constante que determina el control de acceso y la seguridad de auditoría del archivo.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileStream" /> con la ruta de acceso, el modo de creación, los derechos de acceso y el permiso de uso compartido, el tamaño de búfer, las opciones de archivo adicionales, el control de acceso y la seguridad de auditoría que se hayan especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework no admite el acceso directo a discos físicos a través de rutas de acceso que son los nombres de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 Utilícelo <xref:System.IO.FileStream.%23ctor%2A> constructor al que aplicar el acceso de derechos en el momento de creación de un archivo. Para obtener acceso o modificar los derechos en un archivo existente, considere el uso de la <xref:System.IO.File.GetAccessControl%2A> y <xref:System.IO.File.SetAccessControl%2A> métodos.  
  
 El `fileOptions` parámetro se utiliza para proporcionar acceso a operaciones más avanzadas que se pueden aprovechar al crear un <xref:System.IO.FileStream> objeto.  
  
 El `path` parámetro puede ser un nombre de archivo, incluido un archivo en un recurso compartido de convención de nomenclatura universal (UNC, Universal Naming Convention).  
  
> [!NOTE]
>  `path` no es necesario que sea un archivo almacenado en el disco; puede ser cualquier parte de un sistema que admite el acceso a través de secuencias. Por ejemplo, dependiendo del sistema, esta clase puede acceder a un dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A> es `true` para todos los <xref:System.IO.FileStream> objetos que encapsulan archivos. Si `path` indica un dispositivo que no admite búsquedas, el <xref:System.IO.FileStream.CanSeek%2A> propiedad resultante <xref:System.IO.FileStream> es `false`. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pudieron provocar que se produzca una excepción.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se escribe datos en un archivo y, a continuación, lee los datos mediante la <xref:System.IO.FileStream> objeto.  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena vacía (""), solo contiene espacios en blanco o uno o más caracteres no válidos.  -o bien- <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> hace referencia a un dispositivo que no es un archivo, como "con:", "com1:", "lpt1:", etc. en un entorno que no es NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> es un valor negativo o es cero.  -o bien- <paramref name="mode" />, <paramref name="access" /> o <paramref name="share" /> contienen un valor no válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo, como cuando <paramref name="mode" /> es <see langword="FileMode.Truncate" /> o <see langword="FileMode.Open" />, y no existe el archivo especificado por <paramref name="path" />. El archivo ya debe existir en estos modos.</exception>
        <exception cref="T:System.IO.IOException">Se produce un error de E/S, como cuando se especifica <see langword="FileMode.CreateNew" /> y ya existe el archivo especificado por <paramref name="path" />.  -o bien- Se ha cerrado la secuencia.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida, porque, por ejemplo, está en una unidad no asignada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo no permite el <paramref name="access" /> solicitado para el <paramref name="path" /> especificado, como sucede, por ejemplo, cuando <paramref name="access" /> es <see langword="Write" /> o <see langword="ReadWrite" /> y el archivo o el directorio está establecido para el acceso de solo lectura.  -o bien- <see cref="F:System.IO.FileOptions.Encrypted" /> se ha especificado para <paramref name="options" />, pero no se admite el cifrado de archivos en la plataforma actual.</exception>
        <exception cref="T:System.IO.PathTooLongException">El valor especificado para <paramref name="path" />, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o una versión posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer, escribir y anexar texto a archivos. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="array">Búfer en el que se leen los datos.</param>
        <param name="buffer">To be added.</param>
        <param name="offset">Desplazamiento de bytes de <c>array</c> donde va a comenzar la lectura.</param>
        <param name="numBytes">Número máximo de bytes que se pueden leer.</param>
        <param name="count">To be added.</param>
        <param name="userCallback">Método al que se va a llamar cuando se complete la operación de lectura asincrónica.</param>
        <param name="callback">To be added.</param>
        <param name="stateObject">Objeto proporcionado por el usuario que distingue esta solicitud de lectura asincrónica de otras.</param>
        <param name="state">To be added.</param>
        <summary>Comienza una operación de lectura asincrónica. (Considere usar <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> en su lugar).</summary>
        <returns>Objeto que hace referencia a la lectura asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 4 y versiones anteriores, tendrá que usar métodos como <xref:System.IO.FileStream.BeginRead%2A> y <xref:System.IO.FileStream.EndRead%2A> para implementar operaciones de archivo asincrónicas. Estos métodos siguen estando disponibles en la [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para admitir código heredado; sin embargo, los nuevos métodos asincrónicos, como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, y <xref:System.IO.FileStream.FlushAsync%2A>, ayuda implementar operaciones de archivo asincrónicas más fácilmente.  
  
 <xref:System.IO.FileStream.EndRead%2A> debe llamar exactamente una vez por cada llamada a <xref:System.IO.FileStream.BeginRead%2A>. Si no se finaliza un proceso de lectura antes de comenzar otra lectura puede provocar un comportamiento no deseado, como el interbloqueo.  
  
 <xref:System.IO.FileStream> proporciona dos modos diferentes de operación: E/S sincrónica y E/S asincrónica. Aunque se puede utilizar cualquiera, los recursos del sistema operativo subyacente pueden permitir el acceso sólo en uno de estos modos. De forma predeterminada, <xref:System.IO.FileStream> abre el identificador del sistema operativo de forma sincrónica. En Windows, esto ralentiza los métodos asincrónicos. Si se utilizan métodos asincrónicos, utilice la <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  
  
> [!NOTE]
>  Use la <xref:System.IO.FileStream.CanRead%2A> propiedad para determinar si la instancia actual admite operaciones de lectura. Para obtener información adicional, vea <xref:System.IO.Stream.CanRead%2A>.  
  
 Si una secuencia está cerrada o se pasa un argumento no válido, se producirán inmediatamente excepciones de <xref:System.IO.FileStream.BeginRead%2A>. Errores que se producen durante una solicitud de lectura asincrónica, como un error de disco durante la solicitud de E/S, tienen lugar en el subproceso del grupo y se hacen visibles en una llamada a <xref:System.IO.FileStream.EndRead%2A>.  
  
 <xref:System.IO.Stream.EndRead%2A> se debe llamar a este <xref:System.IAsyncResult> para averiguar el número de bytes que se leyeron.  
  
 Varias solicitudes asincrónicas simultáneas representan el orden de finalización de la solicitud no sabe con seguridad.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud de la matriz menos <paramref name="offset" /> es menor que <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="numBytes" /> es negativo.</exception>
        <exception cref="T:System.IO.IOException">Se intentó efectuar una lectura asincrónica más allá del final del archivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="array">Búfer que contiene los datos que se van a escribir en la secuencia actual.</param>
        <param name="buffer">To be added.</param>
        <param name="offset">Desplazamiento de bytes de base cero de <c>array</c> donde comenzar a copiar bytes en la secuencia actual.</param>
        <param name="numBytes">Número máximo de bytes que se pueden escribir.</param>
        <param name="count">To be added.</param>
        <param name="userCallback">Método al que se va a llamar cuando se complete la operación de escritura asincrónica.</param>
        <param name="callback">To be added.</param>
        <param name="stateObject">Objeto proporcionado por el usuario que distingue esta solicitud de lectura asincrónica de otras.</param>
        <param name="state">To be added.</param>
        <summary>Comienza una operación de escritura asincrónica. (Considere usar <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> en su lugar).</summary>
        <returns>Objeto que hace referencia a la escritura asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 4 y versiones anteriores, tendrá que usar métodos como <xref:System.IO.FileStream.BeginWrite%2A> y <xref:System.IO.FileStream.EndWrite%2A> para implementar operaciones de archivo asincrónicas. Estos métodos siguen estando disponibles en la [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para admitir código heredado; sin embargo, los nuevos métodos asincrónicos, como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, y <xref:System.IO.FileStream.FlushAsync%2A>, ayuda implementar operaciones de archivo asincrónicas más fácilmente.  
  
 <xref:System.IO.FileStream.EndWrite%2A> se debe llamar exactamente una vez en cada <xref:System.IAsyncResult> de <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A> se bloqueará hasta que se complete la operación de E/S.  
  
 Este método invalida <xref:System.IO.Stream.BeginWrite%2A>.  
  
 <xref:System.IO.FileStream> proporciona dos modos diferentes de operación: E/S sincrónica y E/S asincrónica. Aunque se puede utilizar cualquiera, los recursos del sistema operativo subyacente pueden permitir el acceso sólo en uno de estos modos. De forma predeterminada, <xref:System.IO.FileStream> abre el identificador del sistema operativo de forma sincrónica. En Windows, esto ralentiza los métodos asincrónicos. Si se utilizan métodos asincrónicos, utilice la <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  
  
 Si una secuencia está cerrada o se pasa un argumento no válido, se producirán inmediatamente excepciones de <xref:System.IO.FileStream.BeginWrite%2A>. Errores que se producen durante una solicitud de escritura asincrónica, como un error de disco durante la solicitud de E/S, tienen lugar en el subproceso del grupo y se hacen visibles en una llamada a <xref:System.IO.FileStream.EndWrite%2A>.  
  
 Varias solicitudes asincrónicas simultáneas representan el orden de finalización de la solicitud no sabe con seguridad.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="array" /> menos <paramref name="offset" /> es menor que <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="numBytes" /> es negativo.</exception>
        <exception cref="T:System.NotSupportedException">La secuencia no admite escritura.</exception>
        <exception cref="T:System.ObjectDisposedException">La secuencia está cerrada.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la secuencia actual admite lectura.</summary>
        <value>Es <see langword="true" /> si la secuencia admite lectura; es <see langword="false" /> si la secuencia está cerrada o se abrió con acceso de solo escritura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si una clase derivada de <xref:System.IO.Stream> no admite la lectura, las llamadas a la <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, y <xref:System.IO.FileStream.BeginRead%2A> métodos lanzan una <xref:System.NotSupportedException>.  
  
 Si la secuencia está cerrada, esta propiedad devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un uso de la `CanRead` propiedad. El resultado de este código es "MyFile.txt no es grabable." Para obtener el mensaje de salida "MyFile.txt puede ser tanto escriben y se leen desde.", cambiar el `FileAccess` parámetro `ReadWrite` en el `FileStream` constructor.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la secuencia actual admite búsquedas.</summary>
        <value>Es <see langword="true" /> si la secuencia admite búsquedas; es <see langword="false" /> si la secuencia está cerrada o si <see langword="FileStream" /> se construyó a partir de un identificador del sistema operativo, como una canalización o una salida a la consola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si una clase derivada de <xref:System.IO.Stream> no admite búsquedas, las llamadas a <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>, y <xref:System.IO.FileStream.Seek%2A> producir un <xref:System.NotSupportedException>.  
  
 Si la secuencia está cerrada, esta propiedad devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `CanSeek` propiedad para comprobar si una secuencia admite búsquedas.  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la secuencia actual admite escritura.</summary>
        <value>Es <see langword="true" /> si la secuencia admite escritura; es <see langword="false" /> si la secuencia está cerrada o se abrió con acceso de solo lectura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si una clase derivada de <xref:System.IO.Stream> no admite la escritura, una llamada a <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, o <xref:System.IO.FileStream.WriteByte%2A> produce una <xref:System.NotSupportedException>.  
  
 Si la secuencia está cerrada, esta propiedad devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `CanWrite` propiedad para comprobar si una secuencia admite escritura.  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 El siguiente es un ejemplo utilizando la `CanWrite` propiedad. El resultado de este código es "MyFile.txt es grabable." Para obtener el mensaje de salida "MyFile.txt puede ser tanto escriben y se leen desde.", cambiar el `FileAccess` parámetro `ReadWrite` en el `FileStream` constructor.  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.IO.FileStream" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama a este método público <xref:System.ComponentModel.Component.Dispose%2A> método y <xref:System.Object.Finalize%2A> método. <xref:System.ComponentModel.Component.Dispose%2A> se invoca el protegido <xref:System.IO.FileStream.Dispose%2A> método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca <xref:System.IO.FileStream.Dispose%2A> con `disposing` establecido en `false`.  
  
 Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.IO.FileStream> hace referencia. Este método invoca al método <xref:System.ComponentModel.Component.Dispose%2A> de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> puede recibir varias llamadas de otros objetos. Al reemplazar <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see cref="M:System.ComponentModel.Component.Dispose" />. Para obtener más información sobre cómo implementar <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />, vea [implementar un Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Para obtener más información acerca de <see cref="M:System.ComponentModel.Component.Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpieza seguridad Resources](~/docs/standard/garbage-collection/unmanaged.md) no administrado.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="fileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Referencia a la solicitud asincrónica pendiente a la que se debe esperar.</param>
        <summary>Espera a que se complete la operación asincrónica de lectura que se encuentra pendiente. (Considere usar <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> en su lugar).</summary>
        <returns>Número de bytes leídos de la secuencia, que se encuentra entre 0 y el número de bytes solicitado. Las secuencias solo devuelven 0 al final de la secuencia; de lo contrario, se deben bloquear hasta que haya al menos 1 byte disponible.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 4 y versiones anteriores, tendrá que usar métodos como <xref:System.IO.FileStream.BeginRead%2A> y <xref:System.IO.FileStream.EndRead%2A> para implementar operaciones de archivo asincrónicas. Estos métodos siguen estando disponibles en la [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para admitir código heredado; sin embargo, los nuevos métodos asincrónicos, como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, y <xref:System.IO.FileStream.FlushAsync%2A>, ayuda implementar operaciones de archivo asincrónicas más fácilmente.  
  
 <xref:System.IO.FileStream.EndRead%2A> se debe llamar exactamente para todas las llamadas a <xref:System.IO.FileStream.BeginRead%2A>. Si no se finaliza un proceso de lectura antes de comenzar otra lectura puede provocar un comportamiento no deseado, como el interbloqueo.  
  
 Este método invalida <xref:System.IO.Stream.EndRead%2A>.  
  
 <xref:System.IO.FileStream.EndRead%2A> se puede llamar en cada <xref:System.IAsyncResult> de <xref:System.IO.FileStream.BeginRead%2A>. Al llamar a <xref:System.IO.FileStream.EndRead%2A> indica el número de bytes leído de la secuencia. <xref:System.IO.FileStream.EndRead%2A> se bloqueará hasta que se complete la operación de E/S.  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Este objeto <see cref="T:System.IAsyncResult" /> no se creó mediante una llamada a <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> en esta clase.</exception>
        <exception cref="T:System.InvalidOperationException">Se llama a <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> varias veces.</exception>
        <exception cref="T:System.IO.IOException">La secuencia está cerrada o se produjo un error interno.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="fileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">La solicitud de E/S asincrónica pendiente.</param>
        <summary>Termina una operación de escritura asincrónica y se bloquea hasta que se completa la operación de E/S. (Considere usar <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> en su lugar).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 4 y versiones anteriores, tendrá que usar métodos como <xref:System.IO.FileStream.BeginWrite%2A> y <xref:System.IO.FileStream.EndWrite%2A> para implementar operaciones de archivo asincrónicas. Estos métodos siguen estando disponibles en la [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para admitir código heredado; sin embargo, los nuevos métodos asincrónicos, como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, y <xref:System.IO.FileStream.FlushAsync%2A>, ayuda implementar operaciones de archivo asincrónicas más fácilmente.  
  
 Este método invalida <xref:System.IO.Stream.EndWrite%2A>.  
  
 <xref:System.IO.FileStream.EndWrite%2A> se debe llamar exactamente una vez en cada <xref:System.IAsyncResult> de <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A> se bloqueará hasta que se complete la operación de E/S.  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Este objeto <see cref="T:System.IAsyncResult" /> no se creó mediante una llamada a <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> en esta clase.</exception>
        <exception cref="T:System.InvalidOperationException">Se llama a <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> varias veces.</exception>
        <exception cref="T:System.IO.IOException">La secuencia está cerrada o se produjo un error interno.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garantiza que se liberen los recursos y se realicen otras operaciones de limpieza cuando el recolector de elementos no utilizados reclama <see langword="FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El recolector de elementos no utilizados llame `Finalize` cuando el objeto actual está preparado para finalizarse. `Finalize` cierra el `FileStream`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Borra los búferes de esta secuencia y hace que todos los datos almacenados en los búferes se escriban en el archivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="fileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra los búferes de esta secuencia y hace que todos los datos almacenados en los búferes se escriban en el archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>.  
  
 Cuando se llama a la <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> también se vacía en el método, el búfer de E/S del sistema operativo.  
  
 Codificador de la secuencia no se vacía a menos que se llame explícitamente a <xref:System.IO.FileStream.Flush%2A> o eliminar el objeto. Establecer <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> a `true` significa que los datos se vaciarán del búfer en la secuencia, pero el estado del codificador no se vaciará. Esto permite al codificador mantener su estado (caracteres parciales) para que sea posible codificar el siguiente bloque de caracteres correctamente. Este escenario afecta a UTF8 y UTF7 donde ciertos caracteres sólo pueden codificarse después de que el codificador reciba el carácter o caracteres adyacentes.  
  
 Dado que se puede utilizar un búfer para leer o escribir, <xref:System.IO.FileStream.Flush> realiza las dos funciones siguientes:  
  
-   Los datos escritos anteriormente en el búfer se copian en el archivo y se borra el búfer excepto el estado del codificador.  
  
-   Si <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> es `true` y anteriormente se copiaron los datos del archivo en el búfer para leer, la posición actual dentro del archivo se reduce el número de bytes no leídos en el búfer. A continuación, se borra el búfer.  
  
 Use la <xref:System.IO.FileStream.Flush%28System.Boolean%29> sobrecarga de método cuando desee asegurarse de que todos los datos almacenados en búfer en búferes de archivos intermedios se escriben en el disco.  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.FileStream.Lock%2A> método.  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ObjectDisposedException">La secuencia está cerrada.</exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="fileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">
          <see langword="true" /> para vaciar todos los búferes de archivos intermedios; de lo contrario, <see langword="false" />.</param>
        <summary>Borra los búferes de esta secuencia, hace que todos los datos almacenados en los búferes se escriban en el archivo y borra también todos los búferes de archivos intermedios.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga cuando desee asegurarse de que todos los datos almacenados en búfer en búferes de archivos intermedios se escribe en el disco.  
  
 Cuando se llama a la <xref:System.IO.FileStream.Flush%2A> también se vacía en el método, el búfer de E/S del sistema operativo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token para supervisar solicitudes de cancelación.</param>
        <summary>Borra asincrónicamente todos los búferes del flujo actual, hace que todos los datos almacenados en el búfer se escriban en el dispositivo subyacente y supervisa las solicitudes de cancelación.</summary>
        <returns>Tarea que representa la operación de vaciado asincrónico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama a la <xref:System.IO.FileStream.FlushAsync%2A> también se vacía en el método, el búfer de E/S del sistema operativo.  
  
 Si la operación se cancela antes de que finalice, la tarea devuelta contiene la <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para el <xref:System.Threading.Tasks.Task.Status%2A> propiedad. Si se elimina el identificador del archivo, la tarea devuelta contiene la <xref:System.ObjectDisposedException> excepción en el <xref:System.Threading.Tasks.Task.Exception%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula las entradas de lista de control de acceso (ACL) del archivo descrito por el objeto <see cref="T:System.IO.FileStream" /> actual.</summary>
        <returns>Objeto que encapsula la configuración de control de acceso correspondiente al archivo descrito por el objeto <see cref="T:System.IO.FileStream" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mientras el <xref:System.IO.FileStream> clase y <xref:System.IO.FileStream.GetAccessControl%2A> puede usarse para recuperar las entradas de lista (ACL) del control de acceso de un archivo existente, considere el uso de <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> método, tal y como es más fácil de usar.  
  
 Use la <xref:System.IO.FileStream.GetAccessControl%2A> método para recuperar las entradas ACL de un archivo.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo especificado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El archivo está cerrado.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S al abrir el archivo.</exception>
        <exception cref="T:System.SystemException">No se encuentra el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Esta operación no es compatible con la plataforma actual.  -o bien- El autor de la llamada no dispone del permiso necesario.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador de archivo del sistema operativo correspondiente al archivo que el objeto <see langword="FileStream" /> encapsula.</summary>
        <value>Identificador de archivo del sistema operativo correspondiente al archivo encapsulado por este objeto <see langword="FileStream" /> o -1 si se ha cerrado <see langword="FileStream" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es un identificador del sistema operativo para su uso con llamadas al sistema operativo proporcionadas por el sistema (como `ReadFile` en Windows). No funcionará con funciones de la biblioteca de C que esperan un descriptor de archivo, como `fread`.  
  
 El identificador del sistema operativo puede haber ha abierto de forma sincrónica o asincrónica, dependiendo de qué `FileStream` se ha llamado constructor. Use la <xref:System.IO.FileStream.IsAsync%2A> propiedad para detectar si este identificador se abrió de forma asincrónica. En Win32, esto significa que se abrió el identificador para la E/S superpuesta y requiere parámetros distintos a `ReadFile` y `WriteFile`.  
  
> [!CAUTION]
>  Pueden producirse daños en los datos si un `FileStream` está creado, se pasa su identificador, alguna operación mueve el puntero de archivo del controlador y, a continuación, el `FileStream` se vuelve a usar. Varios subprocesos no se pueden escribir sin ningún riesgo en el mismo archivo simultáneamente, y `FileStream` el código de búfer se da por supuesto que controla el identificador de forma exclusiva. `FileStream` podría producir un <xref:System.IO.IOException> si `FileStream` detecta que algún otro proceso ha movido el puntero de archivo. Para evitar esta situación, no escriba ningún dato en una parte del archivo que `FileStream` posible que haya almacenado en búfer y restaurar el puntero de archivo en la ubicación que tenía cuando se llame por última vez métodos en `FileStream`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacidad tener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se abrió <see langword="FileStream" /> de forma sincrónica o asincrónica.</summary>
        <value>Es <see langword="true" /> si <see langword="FileStream" /> se abrió de forma asincrónica; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `IsAsync` propiedad detecta si el `FileStream` identificador se abrió de forma asincrónica, lo que permite el código para usar el <xref:System.IO.FileStream.Handle%2A> propiedad correctamente. En Win32, `IsAsync` sea true significa el identificador se abrió para la E/S superpuesta y, por tanto, requiere parámetros distintos a `ReadFile` y `WriteFile`.  
  
 Especifique este valor cuando se crea una instancia de la <xref:System.IO.FileStream> clase utilizando un constructor que tiene un `isAsync`, `useAsync`, o `options` parámetro. Cuando la propiedad es `true`, la secuencia utiliza E/S superpuesta para realizar operaciones de archivo de forma asincrónica. Sin embargo, el <xref:System.IO.FileStream.IsAsync%2A> propiedad no tiene que ser `true` para llamar a la <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, o <xref:System.IO.Stream.CopyToAsync%2A> método. Cuando el <xref:System.IO.FileStream.IsAsync%2A> propiedad es `false` y llama a la lectura asincrónica y las operaciones de escritura, no sigue se bloquea el subproceso de interfaz de usuario, pero la operación de E/S real se realiza de forma sincrónica.  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve la longitud en bytes del flujo.</summary>
        <value>Un valor Long que representa la longitud de la secuencia en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `Length` y `Position` propiedades para comprobar una condición de final de archivo.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="P:System.IO.FileStream.CanSeek" /> para esta secuencia es <see langword="false" />.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S, como el cierre del archivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Lock : int64 * int64 -&gt; unit&#xA;override this.Lock : int64 * int64 -&gt; unit" Usage="fileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Comienzo del intervalo que se va a bloquear. El valor de este parámetro debe ser igual o mayor que cero (0).</param>
        <param name="length">El intervalo que se va a bloquear.</param>
        <summary>Impide que otros procesos lean de <see cref="T:System.IO.FileStream" /> o escriban en él.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bloqueo de un intervalo de una secuencia de archivos proporciona los subprocesos de al proceso bloqueo acceso exclusivo a ese intervalo de la secuencia de archivos.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo bloquear parte de un archivo para que otro proceso no puede tener acceso a esa parte del archivo aunque tenga acceso de lectura/escritura al archivo. Ejecutar el programa simultáneamente en ventanas de comandos diferentes e investigar utilizando las opciones de entrada de consola diferentes.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> o <paramref name="length" /> es negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">El archivo se cierra.</exception>
        <exception cref="T:System.IO.IOException">El proceso no puede obtener acceso al archivo porque otro proceso ha bloqueado una parte de este.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre del <see langword="FileStream" /> que se pasó al constructor.</summary>
        <value>Cadena que es el nombre del <see langword="FileStream" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la posición actual de esta secuencia.</summary>
        <value>Posición actual de esta secuencia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se admite la búsqueda en cualquier ubicación más allá de la longitud de la secuencia.  Cuando se busca más allá de la longitud del archivo, aumente el tamaño del archivo.  En Microsoft Windows NT y versiones más recientes, los datos agregados al final del archivo se establecen en cero.  En Microsoft Windows 98 o versiones anteriores, los datos agregados al final del archivo no se establecen en cero, lo que significa que los datos previamente eliminados está visible para la secuencia. Establecer la posición de la secuencia en un valor grande más allá del final de la secuencia en Windows 98 o versiones anteriores puede provocar una excepción que se está generando.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `Length` y `Position` propiedades para comprobar una condición de final de archivo.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La secuencia no admite búsqueda.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.  \-o bien- La posición se estableció en un valor muy grande más allá del final de la secuencia en Windows 98 o versiones anteriores.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Se intentó establecer la posición en un valor negativo.</exception>
        <exception cref="T:System.IO.EndOfStreamException">Se intentó buscar más allá del final de una secuencia que no admite esto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="fileStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Cuando este método finaliza, contiene la matriz de bytes especificada con los valores comprendidos entre <c>offset</c> y (<c>offset</c> + <c>count</c> - 1<c>)</c> reemplazada por los bytes leídos del origen actual.</param>
        <param name="offset">Desplazamiento de bytes de <c>array</c> donde se van a colocar los bytes leídos.</param>
        <param name="count">Número máximo de bytes que se pueden leer.</param>
        <summary>Lee un bloque de bytes de la secuencia y escribe los datos en un búfer dado.</summary>
        <returns>Número total de bytes leídos en el búfer. Puede ser menor que el número de bytes solicitado si ese número de bytes no está disponible actualmente o cero si se ha alcanzado el final de la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.IO.Stream.Read%2A>.  
  
 El `offset` parámetro indica el desplazamiento del byte en `array` (el índice de búfer) en que se va a comenzar la lectura y el `count` parámetro proporciona el número máximo de bytes que se lee en esta secuencia. El valor devuelto es el número real de bytes leídos, o cero si se alcanza el final de la secuencia. Si la operación de lectura se realiza correctamente, la posición actual de la secuencia avanza por el número de bytes leídos. Si se produce una excepción, no se modifica la posición actual de la secuencia.  
  
 El <xref:System.IO.FileStream.Read%2A> método devuelva cero únicamente después de alcanzar el final de la secuencia. En caso contrario, <xref:System.IO.FileStream.Read%2A> siempre lee al menos un byte de la secuencia antes de devolver. Si no hay datos disponibles en la secuencia tras una llamada a <xref:System.IO.FileStream.Read%2A>, el método se bloqueará hasta que se puede devolver al menos un byte de datos. Una implementación es gratuita devolver menos bytes de los solicitados incluso si no se ha alcanzado el final de la secuencia.  
  
 Utilice <xref:System.IO.BinaryReader> para leer los tipos de datos primitivos.  
  
 No se interrumpirá un subproceso que está realizando una operación de lectura. Aunque puede parecer que la aplicación para que se ejecute correctamente después de que el subproceso se desbloquea, la interrupción puede disminuir el rendimiento y la confiabilidad de la aplicación.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se lee el contenido de un <xref:System.IO.FileStream> y lo escribe en otro <xref:System.IO.FileStream>.  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.NotSupportedException">La secuencia no admite lectura.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> y <paramref name="count" /> describen un intervalo no válido en <paramref name="array" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se efectuó una llamada a los métodos después de cerrar la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer en el que se escriben los datos.</param>
        <param name="offset">Desplazamiento de bytes de <c>buffer</c> donde se van a empezar a escribir datos de la secuencia.</param>
        <param name="count">Número máximo de bytes que se pueden leer.</param>
        <param name="cancellationToken">Token para supervisar solicitudes de cancelación.</param>
        <summary>Lee de forma asincrónica una secuencia de bytes en la secuencia actual, se hace avanzar la posición dentro de la secuencia el número de bytes leídos y controla las solicitudes de cancelación.</summary>
        <returns>Tarea que representa la operación de lectura asincrónica. El valor del parámetro <paramref name="TResult" /> contiene el número total de bytes leídos en el búfer. El valor del resultado puede ser menor que el número de bytes solicitados si el número de bytes disponibles actualmente es menor que el número solicitado o puede ser 0 (cero) si se ha llegado al final de la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileStream.ReadAsync%2A> método le permite realizar operaciones de archivos de gran cantidad de recursos sin bloquear el subproceso principal. Esta consideración de rendimiento es especialmente importante en una aplicación de la [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o una aplicación de [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] en que una operación de streaming prolongada puede bloquear el subproceso de interfaz de usuario y hacer que parezca que una aplicación ha dejado de responder. Los métodos asincrónicos se usan junto con la `async` y `await` palabras clave en Visual Basic y C#.  
  
 Use la <xref:System.IO.FileStream.CanRead%2A> propiedad para determinar si la instancia actual admite operaciones de lectura.  
  
 Si la operación se cancela antes de que finalice, la tarea devuelta contiene la <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para el <xref:System.Threading.Tasks.Task.Status%2A> propiedad. Si se elimina el identificador del archivo, la tarea devuelta contiene la <xref:System.ObjectDisposedException> excepción en el <xref:System.Threading.Tasks.Task.Exception%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo se leen desde un archivo de forma asincrónica.  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.ArgumentException">La suma de <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud del búfer.</exception>
        <exception cref="T:System.NotSupportedException">La secuencia no admite lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado la secuencia.</exception>
        <exception cref="T:System.InvalidOperationException">Una operación de lectura anterior está usando actualmente la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="fileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee un byte del archivo y avanza la posición de lectura un byte.</summary>
        <returns>El byte, convertido en un <see cref="T:System.Int32" />, o -1 si se ha alcanzado el final de la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.IO.Stream.ReadByte%2A>.  
  
> [!NOTE]
>  Use la <xref:System.IO.FileStream.CanRead%2A> propiedad para determinar si la instancia actual admite operaciones de lectura. Para obtener información adicional, vea <xref:System.IO.Stream.CanRead%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo escribir datos en un archivo, byte a byte y, a continuación, compruebe que los datos se han escrito correctamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La secuencia actual no admite lectura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se cierra la secuencia actual.</exception>
        <block subset="none" type="overrides">
          <para>La implementación predeterminada de <see langword="Stream" /> crea una nueva matriz de un solo byte y, a continuación, se llama <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Aunque esto es formalmente correcto, no es eficaz. Cualquier secuencia que posea un búfer interno debe reemplazar este método y proporcionar una versión mucho más eficaz que lea el búfer directamente, evitando la asignación adicional de matrices en cada llamada.  Para obtener una lista de operaciones de directorio y archivo común, consulte [Tasks](~/docs/standard/io/common-i-o-tasks.md) E/S común.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> que representa el identificador de archivos del sistema operativo correspondiente al archivo que el objeto <see cref="T:System.IO.FileStream" /> actual encapsula.</summary>
        <value>Objeto que representa el identificador de archivos del sistema operativo correspondiente al archivo que el objeto <see cref="T:System.IO.FileStream" /> actual encapsula.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileStream.SafeFileHandle%2A> propiedad vacía la secuencia y establece la posición de la secuencia actual en 0 automáticamente.  Esto permite que el archivo que se va a mover o la posición de la secuencia restablecerán por otro flujo mediante la <xref:System.IO.FileStream.SafeFileHandle%2A> devuelta por esta propiedad.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener permiso llamar a código no administrado.  Acción de seguridad: enumeración de asociados de petición de vínculo: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="fileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Punto con respecto a <c>origin</c> desde el que se va a comenzar a buscar.</param>
        <param name="origin">Especifica el comienzo, el final o la posición actual como un punto de referencia para <c>offset</c>, con un valor de tipo <see cref="T:System.IO.SeekOrigin" />.</param>
        <summary>Establece la posición actual de esta secuencia actual en el valor dado.</summary>
        <returns>Nueva posición en la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Use la <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> propiedad para determinar si la instancia actual admite búsquedas. Para obtener información adicional, vea <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>.  
  
 Se puede buscar en cualquier ubicación más allá de la longitud de la secuencia. Cuando se busca más allá de la longitud del archivo, aumente el tamaño del archivo. En Windows NT y versiones posteriores, los datos agregados al final del archivo se establecen en cero. En Windows 98 o versiones anteriores, los datos agregados al final del archivo no se establecen en cero, lo que significa que los datos previamente eliminados está visible para la secuencia.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo escribir datos en un archivo, byte a byte y, a continuación, compruebe que los datos se han escrito correctamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 En el ejemplo siguiente se lee el texto en la dirección inversa, desde el final del archivo al principio del archivo, mediante el uso de los distintos <xref:System.IO.SeekOrigin> los valores que tienen la <xref:System.IO.FileStream.Seek%2A> método.  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.NotSupportedException">La secuencia no admite operaciones Seek, como sucede cuando se crea <see langword="FileStream" /> a partir de una canalización o una salida a la consola.</exception>
        <exception cref="T:System.ArgumentException">La búsqueda se intenta antes del comienzo de la secuencia.</exception>
        <exception cref="T:System.ObjectDisposedException">Se efectuó una llamada a los métodos después de cerrar la secuencia.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileStream.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">Objeto que describe una entrada ACL que se va a aplicar al archivo actual.</param>
        <summary>Aplica las entradas de la lista de control de acceso (ACL) descritas por un objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> al archivo descrito por el objeto <see cref="T:System.IO.FileStream" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mientras el <xref:System.IO.FileStream> clase y <xref:System.IO.FileStream.SetAccessControl%2A> se pueden usar en un archivo existente, considere el uso de la <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> método porque es más fácil de usar.  
  
 El <xref:System.IO.FileStream.SetAccessControl%2A> método aplica las entradas de lista (ACL) de control de acceso a un archivo que representa la lista ACL no heredada.  
  
> [!CAUTION]
>  La ACL especificada para el `fileSecurity` parámetro reemplaza la ACL existente para el archivo. Para agregar permisos para un usuario nuevo, use la <xref:System.IO.FileStream.GetAccessControl%2A> método para obtener la lista ACL existente, modificarlo y, a continuación, usar <xref:System.IO.FileStream.SetAccessControl%2A> para aplicarlo al archivo.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo especificado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El archivo está cerrado.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="fileSecurity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">No se pudo encontrar o modificar el archivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El proceso actual no tiene acceso para abrir el archivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="fileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">La nueva longitud de la secuencia.</param>
        <summary>Establece la longitud de esta secuencia en el valor dado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.IO.Stream.SetLength%2A>.  
  
 Si el valor especificado es menor que la longitud actual de la secuencia, se trunca la secuencia. En este escenario, si la posición actual es mayor que la nueva longitud, se mueve la posición actual hasta el último byte de la secuencia. Si el valor especificado es mayor que la longitud actual de la secuencia, la secuencia se expande y la posición actual sigue siendo el mismo. Si la secuencia se expande, el contenido de la secuencia entre la antigua y la nueva longitud es indefinido.  
  
 Una secuencia debe admitir operaciones de escritura y de que deseen usar `SetLength` para que funcione.  
  
> [!NOTE]
>  Use la <xref:System.IO.FileStream.CanWrite%2A> propiedad para determinar si la instancia actual admite operaciones de escritura y el <xref:System.IO.FileStream.CanSeek%2A> propiedad para determinar si se admite la búsqueda. Para más información, consulte <xref:System.IO.Stream.CanWrite%2A> y <xref:System.IO.Stream.CanSeek%2A>.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S.</exception>
        <exception cref="T:System.NotSupportedException">La secuencia no admite operaciones de escritura ni de búsqueda.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Se ha intentado establecer el parámetro <paramref name="value" /> en menos de 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Unlock : int64 * int64 -&gt; unit&#xA;override this.Unlock : int64 * int64 -&gt; unit" Usage="fileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">El comienzo del intervalo que se va a desbloquear.</param>
        <param name="length">El intervalo que se va a desbloquear.</param>
        <summary>Permite que otros procesos tengan acceso total o parcial a un archivo previamente bloqueado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo bloquear parte de un archivo para que otro proceso no puede tener acceso a esa parte del archivo, aunque tenga acceso de lectura/escritura al archivo y, a continuación, desbloquear la parte especificada del archivo. Ejecutar el programa simultáneamente en ventanas de comandos diferentes e investigar utilizando las opciones de entrada de consola diferentes.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> o <paramref name="length" /> es negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="fileStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Búfer que contiene los datos que se van a escribir en la secuencia.</param>
        <param name="offset">Desplazamiento de bytes de base cero de <c>array</c> desde donde se va a comenzar a copiar los bytes en la secuencia.</param>
        <param name="count">Número máximo de bytes que se pueden escribir.</param>
        <summary>Escribe un bloque de bytes en la secuencia de archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.IO.Stream.Write%2A>.  
  
 El `offset` parámetro indica el desplazamiento del byte en `array` (el índice de búfer) en el que se comienzan a copiar y el `count` parámetro proporciona el número de bytes que se escribirán en la secuencia. Si la operación de escritura se realiza correctamente, la posición actual de la secuencia avanza por el número de bytes escritos. Si se produce una excepción, no se modifica la posición actual de la secuencia.  
  
> [!NOTE]
>  Use la <xref:System.IO.FileStream.CanWrite%2A> propiedad para determinar si la instancia actual admite escritura. Para obtener información adicional, vea <xref:System.IO.Stream.CanWrite%2A>.  
  
 No se interrumpirá un subproceso que está realizando una operación de escritura. Aunque puede parecer que la aplicación para que se ejecute correctamente después de que el subproceso se desbloquea, la interrupción puede disminuir el rendimiento y la confiabilidad de la aplicación.  
  
 Para obtener una lista de operaciones de directorio y archivo común, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.FileStream.Lock%2A> método.  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> y <paramref name="count" /> describen un intervalo no válido en <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.  \-o bien- Otro subproceso puede haber producido un cambio inesperado en la posición del identificador de archivo del sistema operativo.</exception>
        <exception cref="T:System.ObjectDisposedException">La secuencia está cerrada.</exception>
        <exception cref="T:System.NotSupportedException">La instancia actual de la secuencia no admite la escritura.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer del que se van a escribir datos.</param>
        <param name="offset">Desplazamiento de bytes de base cero de <c>buffer</c> desde donde se van a empezar a copiar bytes en la secuencia.</param>
        <param name="count">Número máximo de bytes que se pueden escribir.</param>
        <param name="cancellationToken">Token para supervisar solicitudes de cancelación.</param>
        <summary>Escribe de forma asincrónica una secuencia de bytes en la secuencia actual, se hace avanzar la posición actual dentro de la secuencia por el número de bytes escritos y controla las solicitudes de cancelación.</summary>
        <returns>Tarea que representa la operación de escritura asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileStream.WriteAsync%2A> método le permite realizar operaciones de archivos de gran cantidad de recursos sin bloquear el subproceso principal. Esta consideración de rendimiento es especialmente importante en una aplicación de la [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] o una aplicación de [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] en que una operación de streaming prolongada puede bloquear el subproceso de interfaz de usuario y hacer que parezca que una aplicación ha dejado de responder. Los métodos asincrónicos se usan junto con la `async` y `await` palabras clave en Visual Basic y C#.  
  
 Use la <xref:System.IO.FileStream.CanWrite%2A> propiedad para determinar si la instancia actual admite escritura.  
  
 Si la operación se cancela antes de que finalice, la tarea devuelta contiene la <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para el <xref:System.Threading.Tasks.Task.Status%2A> propiedad. Si se elimina el identificador del archivo, la tarea devuelta contiene la <xref:System.ObjectDisposedException> excepción en el <xref:System.Threading.Tasks.Task.Exception%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo escribir asincrónicamente en un archivo.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.ArgumentException">La suma de <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud del búfer.</exception>
        <exception cref="T:System.NotSupportedException">La secuencia no admite escritura.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado la secuencia.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia está actualmente en uso por una operación de escritura anterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="fileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Un byte que se va a escribir en la secuencia.</param>
        <summary>Escribe un byte en la posición actual de la secuencia de archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.IO.Stream.WriteByte%2A>.  
  
 Use `WriteByte` para escribir un byte en un `FileStream` eficazmente. Si la secuencia está cerrada o no pueden modificarse, se producirá una excepción.  
  
> [!NOTE]
>  Use la <xref:System.IO.FileStream.CanWrite%2A> propiedad para determinar si la instancia actual admite escritura. Para obtener información adicional, vea <xref:System.IO.Stream.CanWrite%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo escribir datos en un archivo, byte a byte y, a continuación, compruebe que los datos se han escrito correctamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">La secuencia está cerrada.</exception>
        <exception cref="T:System.NotSupportedException">La secuencia no admite escritura.</exception>
        <block subset="none" type="overrides">
          <para>La implementación predeterminada de <see langword="Stream" /> crea una nueva matriz de un solo byte y, a continuación, se llama <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Aunque esto es formalmente correcto, no es eficaz. Cualquier secuencia que posea un búfer interno debe reemplazar este método y proporcionar una versión mucho más eficaz que lea el búfer directamente, evitando la asignación adicional de matrices en cada llamada.  Para obtener una lista de operaciones de directorio y archivo común, consulte [Tasks](~/docs/standard/io/common-i-o-tasks.md) E/S común.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>