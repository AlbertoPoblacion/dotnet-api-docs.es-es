<Type Name="Directory" FullName="System.IO.Directory">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fd142fc3ebbd6e7860ad7e0df4dc713b0f786afe" />
    <Meta Name="ms.sourcegitcommit" Value="29c771f79cf4eac4f49e5fae5f1aa8b457acf146" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/21/2018" />
    <Meta Name="ms.locfileid" Value="36299108" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Directory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Directory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Directory" />
  <TypeSignature Language="VB.NET" Value="Public Class Directory" />
  <TypeSignature Language="C++ CLI" Value="public ref class Directory abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Expone métodos estáticos para crear, mover y enumerar archivos en directorios y subdirectorios. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.Directory> clase para las operaciones típicas como copiar, mover, cambiar el nombre, crear y eliminar directorios.  
  
-   Para crear un directorio, utilice uno de los <xref:System.IO.Directory.CreateDirectory%2A> métodos.  
  
-   Para eliminar un directorio, use uno de los <xref:System.IO.Directory.Delete%2A> métodos.  
  
-   Para obtener o establecer el directorio actual para una aplicación, use la <xref:System.IO.Directory.GetCurrentDirectory%2A> o <xref:System.IO.Directory.SetCurrentDirectory%2A> método.  
  
-   Para manipular <xref:System.DateTime> información relacionada con la creación, acceso y la escritura de un directorio, utilizan métodos como <xref:System.IO.Directory.SetLastAccessTime%2A> y <xref:System.IO.Directory.SetCreationTime%2A>.  
  
 Los métodos estáticos de la <xref:System.IO.Directory> clase realizar comprobaciones de seguridad en todos los métodos. Si va a utilizar un objeto varias veces, considere la posibilidad de usar el método de instancia correspondiente de <xref:System.IO.DirectoryInfo> en su lugar, dado que la comprobación de seguridad no siempre que sea necesario.  
  
 Si va a realizar solo una acción relacionada con el directorio, puede que sea más eficaz utilizar una variable static <xref:System.IO.Directory> método en lugar de su correspondiente <xref:System.IO.DirectoryInfo> método de instancia. La mayoría <xref:System.IO.Directory> métodos requieren la ruta de acceso al directorio que está manipulando.  
  
> [!NOTE]
>  En los miembros que aceptan una cadena `path` parámetro, dicha ruta de acceso debe ser correcto o se produce una excepción. Por ejemplo, si una ruta de acceso está completa pero comienza con un espacio ("c:\temp"), no recorta la cadena de ruta de acceso, por lo que la ruta de acceso se considera incorrecto y se produce una excepción. Además, una ruta de acceso o una combinación de rutas de acceso no puede ser completo dos veces. Por ejemplo, "c:\temp c:\windows" también genera una excepción. Asegúrese de que las rutas de acceso sean correctos cuando se utilizan los métodos que aceptan una cadena de ruta de acceso. Para obtener más información, vea <xref:System.IO.Path>.  
  
 En los miembros que aceptan una ruta de acceso, la ruta de acceso puede hacer referencia a un archivo o un directorio. Puede usar una ruta de acceso completa, una ruta de acceso relativa o una ruta de acceso de convención de nomenclatura universal (UNC, Universal Naming Convention) para un nombre de servidor y recurso compartido. Por ejemplo, todos los requisitos siguientes son las rutas de acceso aceptables:  
  
-   "c:\\\MyDir" en C# o "c:\MyDir" en Visual Basic.  
  
-   "MyDir\\\MySubdir" en C# o "Midir\misubdir" en Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" en C#, o "\\\MyServer\MyShare" en Visual Basic.  
  
 De forma predeterminada, se concede acceso completo de lectura/escritura a los nuevos directorios a todos los usuarios. Sin embargo, la aplicación debe tener la seguridad correctas para tener acceso a directorios existentes.  
  
 Para solicitar permisos para un directorio y todos sus subdirectorios, el final de la cadena de ruta de acceso con el carácter de separador de directorios. (Por ejemplo, "C:\Temp\\" concede acceso a C:\Temp\ y todos sus subdirectorios.) Para solicitar permisos solo para un directorio concreto, la cadena de ruta de acceso con un punto final. (Por ejemplo, "C:\Temp\\." concede acceso solo a C:\Temp\\, no a sus subdirectorios.)  
  
 En los miembros que aceptan un `searchPattern` parámetro, la cadena de búsqueda puede ser cualquier combinación de caracteres literales y dos caracteres comodín; \* y?. Este parámetro no reconoce las expresiones regulares. Para obtener más información, consulte el <xref:System.IO.Directory.EnumerateDirectories%28System.String%2CSystem.String%29> método o cualquier otro método que usa el `searchPattern` parámetro.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 <xref:System.IO.Directory> y <xref:System.IO.DirectoryInfo> no se admiten para su uso en [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplicaciones. Para obtener información sobre cómo obtener acceso a archivos y carpetas en [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplicaciones, consulte [acceso a datos y archivos (aplicaciones de la tienda de Windows)](http://msdn.microsoft.com/library/windows/apps/hh758319.aspx).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo recuperar todos los archivos de texto de un directorio y moverlos a un nuevo directorio. Después de que los archivos se mueven, ya no existen en el directorio original.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.IO.Directory.EnumerateFiles%2A> método para recuperar una colección de archivos de texto desde un directorio y, a continuación, usar esa colección en una consulta para buscar todas las líneas que contienen "Ejemplo".  
  
 [!code-csharp[System.IO.Directory#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class3.cs#11)]
 [!code-vb[System.IO.Directory#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class3.vb#11)]  
  
 En el ejemplo siguiente se muestra cómo mover un directorio y todos sus archivos a un nuevo directorio. El directorio original ya no existe después de que se ha movido.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.DirectoryInfo" />
    <altmember cref="T:System.IO.FileInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateDirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea todos los directorios de una ruta de acceso especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Directorio que se va a crear.</param>
        <summary>Crea todos los directorios y subdirectorios en la ruta de acceso especificada, a menos que ya existan.</summary>
        <returns>Un objeto que representa el directorio en la ruta de acceso especificada. Este objeto se devuelve sin importar si ya existe un directorio en la ruta especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los directorios especificados en `path` se crean, salvo que ya existan o que alguna parte de `path` no es válido. Si el directorio ya existe, este método no crea un nuevo directorio, pero devuelve un <xref:System.IO.DirectoryInfo> objeto para el directorio existente.  
  
 El `path` parámetro especifica una ruta de acceso de directorio, no una ruta de acceso de archivo.  
  
 Los espacios finales se quitan del final de la `path` parámetro antes de crear el directorio.  
  
 Puede crear un directorio en un equipo remoto, en un recurso compartido que tenga acceso de escritura a. Se admiten las rutas de acceso UNC; Por ejemplo, puede especificar lo siguiente para `path`: `\\2009\Archives\December` en Visual Basic, y `\\\\2009\\Archives\\December` en C#.  
  
 Crear un directorio con solo el carácter de dos puntos (:) no se admite y producirá una `NotSupportedException` que se produzca.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea y se elimina el directorio especificado.  
  
 [!code-cpp[Dir_CreateDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_CreateDir/CPP/dir_createdir.cpp#1)]
 [!code-csharp[Dir_CreateDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_CreateDir/CS/dir_createdir.cs#1)]
 [!code-vb[Dir_CreateDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_CreateDir/VB/dir_createdir.vb#1)]  
  
 Para crear el directorio C:\Users\User1\Public\Html cuando el directorio actual es C:\Users\User1, utilice cualquiera de las siguientes llamadas para asegurarse de que la barra diagonal inversa se interprete correctamente.  
  
 En Visual Basic:  
  
```  
Directory.CreateDirectory("Public\Html")   
    Directory.CreateDirectory("\Users\User1\Public\Html")   
    Directory.CreateDirectory("c:\Users\User1\Public\Html")  
```  
  
 En C#:  
  
```  
Directory.CreateDirectory("Public\\Html");  
    Directory.CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory.CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 En C++:  
  
```  
Directory::CreateDirectory("Public\\Html");  
    Directory::CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory::CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El directorio especificado por <paramref name="path" /> es un archivo.  -o bien- El nombre de la red es desconocido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos usando el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  -o bien- <paramref name="path" /> tiene como prefijo o contiene solo un carácter de dos puntos (:).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> contiene un carácter de dos puntos (:) que no forma parte de una etiqueta de unidad ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir archivos o directorios. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">Directorio que se va a crear.</param>
        <param name="directorySecurity">Control de acceso que se aplica al directorio.</param>
        <summary>Crea todos los directorios en la ruta de acceso especificada, salvo que ya existan, aplicando la seguridad de Windows especificada.</summary>
        <returns>Un objeto que representa el directorio en la ruta de acceso especificada. Este objeto se devuelve sin importar si ya existe un directorio en la ruta especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga del método para crear un directorio con control de acceso, de modo que no hay ninguna posibilidad puede tener acceso a directorio antes de que se aplica la seguridad.  
  
 Todos los directorios especificados en la `path` se crean parámetros, salvo que ya existan o que alguna parte de `path` no es válido. El `path` parámetro especifica una ruta de acceso de directorio, no una ruta de acceso de archivo. Si el directorio ya existe, este método no crea un nuevo directorio, pero devuelve un <xref:System.IO.DirectoryInfo> objeto para el directorio existente.  
  
 Los espacios finales se quitan del final de la `path` parámetro antes de crear el directorio.  
  
 Puede crear un directorio en un equipo remoto, en un recurso compartido que tenga acceso de escritura a. Se admiten las rutas de acceso UNC; Por ejemplo, puede especificar lo siguiente para `path`: `\\2009\Archives\December` en Visual Basic, y `\\\\2009\\Archives\\December` en C#.  
  
 Crear un directorio con solo el carácter de dos puntos (:) no se admite y se hace un `NotSupportedException` que se produzca.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un nuevo directorio con las reglas de acceso para dos cuentas de usuario.  
  
 [!code-csharp[System.IO.Directory#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class7.cs#15)]
 [!code-vb[System.IO.Directory#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class7.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El directorio especificado por <paramref name="path" /> es un archivo.  -o bien- El nombre de la red es desconocido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos usando el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  -o bien- <paramref name="path" /> tiene como prefijo o contiene solo un carácter de dos puntos (:).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> contiene un carácter de dos puntos (:) que no forma parte de una etiqueta de unidad ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir archivos y directorios y para el acceso al directorio de destino. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Elimina un directorio especificado y opcionalmente cualquier subdirectorio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nombre del directorio vacío que se va a quitar. El directorio debe permitir la escritura y estar vacío.</param>
        <summary>Elimina un directorio vacío de una ruta de acceso especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se comporta idénticamente a <xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29> con `false` especificado para el segundo parámetro.  
  
 El `path` parámetro puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Los espacios finales se quitan del final de la `path` parámetro antes de eliminar el directorio.  
  
 Este método produce una <xref:System.IO.IOException> si el directorio especificado en el `path` parámetro contiene archivos o subdirectorios.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 En algunos casos, si tiene el directorio especificado abierto en el Explorador de archivos, la <xref:System.IO.Directory.Delete%2A> método no pueda eliminarlo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo crear un nuevo directorio y subdirectorio y, a continuación, elimine sólo el subdirectorio.  
  
 [!code-csharp[System.IO.Directory.Delete#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class1.cs#1)]
 [!code-vb[System.IO.Directory.Delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ya existe un archivo con el mismo nombre y ubicación especificados por <paramref name="path" />.  -o bien- El directorio es el directorio de trabajo actual de la aplicación.  -o bien- El directorio especificado por <paramref name="path" /> no está vacío.  -o bien- El directorio es de solo lectura o contiene un archivo de solo lectura.  -o bien- Otro proceso está usando el directorio.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> no existe o no se pudo encontrar.  -o bien- La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path, bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path, bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String, recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path, bool recursive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Nombre del directorio que se va a quitar.</param>
        <param name="recursive">
          <see langword="true" /> para quitar directorios, subdirectorios y archivos de <c>path</c>; de lo contrario, <see langword="false" />.</param>
        <summary>Elimina el directorio especificado y, si está indicado, los subdirectorios y archivos que contiene.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` parámetro puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Los espacios finales se quitan del final de la `path` parámetro antes de eliminar el directorio.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Si el `recursive` parámetro es `true`, el usuario debe tener permiso de escritura para el directorio actual, así como para todos los subdirectorios.  
  
 El comportamiento de este método difiere ligeramente cuando se elimina un directorio que contiene un punto de reanálisis, como un vínculo simbólico o un punto de montaje. Si el punto de reanálisis es un directorio, como un punto de montaje, se desmonta y se elimina el punto de montaje. Este método no es recursivo a través del punto de reanálisis. Si el punto de reanálisis es un vínculo simbólico a un archivo, se elimina el punto de reanálisis y no el destino del vínculo simbólico.  
  
 En algunos casos, si tiene el directorio especificado abierto en el Explorador de archivos, la <xref:System.IO.Directory.Delete%2A> método no pueda eliminarlo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo crear un nuevo directorio, subdirectorios y archivos en el subdirectorio y, a continuación, eliminar todos los nuevos elementos de forma recursiva.  
  
 [!code-csharp[System.IO.Directory.Delete#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class2.cs#2)]
 [!code-vb[System.IO.Directory.Delete#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ya existe un archivo con el mismo nombre y ubicación especificados por <paramref name="path" />.  -o bien- El directorio especificado por <paramref name="path" /> es de solo lectura o <paramref name="recursive" /> es <see langword="false" /> y <paramref name="path" /> no es un directorio vacío.  -o bien- El directorio es el directorio de trabajo actual de la aplicación.  -o bien- El directorio contiene un archivo de solo lectura.  -o bien- Otro proceso está usando el directorio.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> no existe o no se pudo encontrar.  -o bien- La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una colección enumerable de nombres de directorio que satisfacen los criterios especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <summary>Devuelve una colección enumerable de nombres de directorio en una ruta de acceso especificada.</summary>
        <returns>Una colección enumerable de nombres completos (con sus rutas de acceso) para los directorios en el directorio especificado por <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede especificar la información de ruta de acceso relativa o absoluta en el `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método. Los nombres de directorio devuelto tienen el prefijo con el valor proporcionado en el `path` parámetro. Por ejemplo, si se proporciona una ruta de acceso relativa en el `path` parámetro, los nombres de directorio devuelta contendrá una ruta de acceso relativa.  
  
 El <xref:System.IO.Directory.EnumerateDirectories%2A> y <xref:System.IO.Directory.GetDirectories%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateDirectories%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetDirectories%2A>, debe esperar a que la matriz entera de nombres que se devuelvan antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateDirectories%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
   
  
## Examples  
 En el ejemplo siguiente se enumeran los directorios de nivel superior en una ruta de acceso especificada.  
  
 [!code-csharp[System.IO.EnumDirs1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs1/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs1/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos usando el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios de <c>path</c>.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Devuelve una colección enumerable de nombres de directorio que coinciden con un patrón de búsqueda en una ruta de acceso especificada.</summary>
        <returns>Una colección enumerable de nombres completos (con sus rutas de acceso) para los directorios en el directorio especificado por <paramref name="path" /> y que coinciden con el patrón de búsqueda especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido de <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener los caracteres no válidos. Puede consultar los caracteres no válidos usando el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Puede especificar la información de ruta de acceso relativa o absoluta en el `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método. Los nombres de directorio devuelto tienen el prefijo con el valor proporcionado en el `path` parámetro. Por ejemplo, si se proporciona una ruta de acceso relativa en el `path` parámetro, los nombres de directorio devuelta contendrá una ruta de acceso relativa.  
  
 El <xref:System.IO.Directory.EnumerateDirectories%2A> y <xref:System.IO.Directory.GetDirectories%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateDirectories%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetDirectories%2A>, debe esperar a que la matriz entera de nombres que se devuelvan antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateDirectories%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
   
  
## Examples  
 En el ejemplo siguiente se enumeran los directorios de nivel superior en una ruta de acceso especificada que coinciden con un patrón de búsqueda especificado.  
  
 [!code-csharp[System.IO.EnumDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs2/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs2/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  \-o bien- <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.  -o bien- <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios de <c>path</c>.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir solo el directorio actual o debe incluir todos los subdirectorios.  El valor predeterminado es <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Devuelve una colección enumerable de nombres de directorio que coinciden con un patrón de búsqueda en una ruta de acceso especificada y, opcionalmente, busca en subdirectorios.</summary>
        <returns>Una colección enumerable de nombres completos (con sus rutas de acceso) para los directorios en el directorio especificado por <paramref name="path" /> y que coinciden con el patrón de búsqueda y opción especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Exactamente un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido de <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener los caracteres no válidos. Puede consultar los caracteres no válidos usando el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Puede especificar la información de ruta de acceso relativa o absoluta en el `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método. Los nombres de directorio devuelto tienen el prefijo con el valor proporcionado en el `path` parámetro. Por ejemplo, si se proporciona una ruta de acceso relativa en el `path` parámetro, los nombres de directorio devuelta contendrá una ruta de acceso relativa.  
  
 El <xref:System.IO.Directory.EnumerateDirectories%2A> y <xref:System.IO.Directory.GetDirectories%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateDirectories%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetDirectories%2A>, debe esperar a que la matriz entera de nombres que se devuelvan antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateDirectories%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
   
  
## Examples  
 En el ejemplo siguiente se enumeran los directorios en una ruta de acceso especificada que coinciden con un patrón de búsqueda especificado. Usa el `searchOption` parámetro para especificar que se deben incluir todos los subdirectorios en la búsqueda.  
  
 [!code-csharp[System.IO.EnumDirs3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs3/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs3/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos usando el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  \-o bien- <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.  -o bien- <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> no es un valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una colección enumerable de nombres de archivo que satisfacen los criterios especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <summary>Devuelve una colección enumerable de nombres de archivo en una ruta de acceso especificada.</summary>
        <returns>Una colección enumerable de nombres completos (con sus rutas de acceso) para los archivos en el directorio especificado por <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede especificar la información de ruta de acceso relativa con el `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 El <xref:System.IO.Directory.EnumerateFiles%2A> y <xref:System.IO.Directory.GetFiles%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateFiles%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetFiles%2A>, debe esperar a que la matriz entera de nombres que se devuelvan antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo recuperar todos los archivos en un directorio y moverlos a un nuevo directorio. Después de que los archivos se mueven, ya no existen en el directorio original.  
  
 [!code-csharp[System.IO.Directory#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class4.cs#12)]
 [!code-vb[System.IO.Directory#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class4.vb#12)]  
  
 En el ejemplo siguiente se enumeran los archivos en el directorio especificado, se lee cada línea del archivo y muestra la línea si contiene la cadena "Europa".  
  
 [!code-csharp[System.IO.Directory.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos usando el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los archivos de <c>path</c>.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Devuelve una colección enumerable de nombres de archivo que coinciden con un patrón de búsqueda en una ruta de acceso especificada.</summary>
        <returns>Una colección enumerable de nombres completos (con sus rutas de acceso) para los archivos en el directorio especificado por <paramref name="path" /> y que coinciden con el patrón de búsqueda especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como se indica a continuación:  
>   
>  -   Si la extensión especificada es exactamente tres caracteres de longitud, el método devuelve archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
 `searchPattern` no puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido de <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener los caracteres no válidos. Puede consultar los caracteres no válidos usando el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Puede especificar la información de ruta de acceso relativa con el `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 El <xref:System.IO.Directory.EnumerateFiles%2A> y <xref:System.IO.Directory.GetFiles%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateFiles%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetFiles%2A>, debe esperar a que la matriz entera de nombres que se devuelvan antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo recuperar todos los archivos de texto en un directorio y moverlos a un nuevo directorio. Después de que los archivos se mueven, ya no existen en el directorio original.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 En el ejemplo siguiente se enumeran los archivos del directorio especificado que tienen la extensión .txt, lee cada línea del archivo y muestra la línea si contiene la cadena "Europa".  
  
 [!code-csharp[System.IO.Directory.EnumFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles2/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles2/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos usando el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  \-o bien- <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.  -o bien- <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los archivos de <c>path</c>.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir solo el directorio actual o debe incluir todos los subdirectorios.  El valor predeterminado es <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Devuelve una colección enumerable de nombres de archivo que coinciden con un patrón de búsqueda en una ruta de acceso especificada y, opcionalmente, busca en subdirectorios.</summary>
        <returns>Una colección enumerable de nombres completos (con sus rutas de acceso) para los archivos en el directorio especificado por <paramref name="path" /> y que coinciden con el patrón de búsqueda y opción especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como se indica a continuación:  
>   
>  -   Si la extensión especificada es exactamente tres caracteres de longitud, el método devuelve archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
 `searchPattern` no puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido de <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener los caracteres no válidos. Puede consultar los caracteres no válidos usando el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Puede especificar la información de ruta de acceso relativa con el `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 El <xref:System.IO.Directory.EnumerateFiles%2A> y <xref:System.IO.Directory.GetFiles%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateFiles%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetFiles%2A>, debe esperar a que la matriz entera de nombres que se devuelvan antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo recuperar todos los archivos de texto en un directorio y sus subdirectorios y moverlos a un nuevo directorio. Después de que los archivos se mueven, ya no existen en el directorio original.  
  
 [!code-csharp[System.IO.Directory#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class5.cs#13)]
 [!code-vb[System.IO.Directory#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class5.vb#13)]  
  
 Forma recursiva en el siguiente ejemplo enumeran todos los archivos que tienen una extensión .txt, lee cada línea del archivo y muestra la línea si contiene la cadena "Microsoft".  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos usando el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  \-o bien- <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.  -o bien- <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> no es un valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una colección enumerable de entradas del sistema de archivos que satisfacen los criterios especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <summary>Devuelve una colección enumerable de nombres de archivo y nombres de directorio en una ruta de acceso especificada.</summary>
        <returns>Colección enumerable de entradas del sistema de archivos en el directorio especificado por <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede especificar la información de ruta de acceso relativa con el `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 El <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> y <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, puede empezar a enumerar la colección de entradas antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetFileSystemEntries%2A>, debe esperar a que la matriz entera de entradas que se devolverán antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos usando el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de las entradas del sistema de archivos de <c>path</c>.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Devuelve una colección enumerable de nombres de archivo y nombres de directorio que coinciden con un patrón de búsqueda en una ruta de acceso especificada.</summary>
        <returns>Colección enumerable de entradas del sistema de archivos en el directorio especificado por <paramref name="path" />, y que coinciden con el patrón de búsqueda especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`...  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como se indica a continuación:  
>   
>  -   Si la extensión especificada es exactamente tres caracteres de longitud, el método devuelve archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
 `searchPattern` no puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido de <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener los caracteres no válidos. Puede consultar los caracteres no válidos usando el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Puede especificar la información de ruta de acceso relativa con el `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 El <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> y <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, puede empezar a enumerar la colección de entradas antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetFileSystemEntries%2A>, debe esperar a que la matriz entera de entradas que se devolverán antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos usando el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  \-o bien- <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.  -o bien- <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con las entradas del sistema de archivos de <c>path</c>.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir solo el directorio actual o debe incluir todos los subdirectorios.  El valor predeterminado es <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Devuelve una colección enumerable de nombres de archivo y de directorio que coinciden con un patrón de búsqueda en una ruta de acceso especificada y, opcionalmente, busca en subdirectorios.</summary>
        <returns>Colección enumerable de entradas del sistema de archivos en el directorio especificado por <paramref name="path" />, y que coinciden con el patrón de búsqueda y opción especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como se indica a continuación:  
>   
>  -   Si la extensión especificada es exactamente tres caracteres de longitud, el método devuelve archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
 `searchPattern` no puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido de <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener los caracteres no válidos. Puede consultar los caracteres no válidos usando el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Puede especificar la información de ruta de acceso relativa con el `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 El <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> y <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, puede empezar a enumerar la colección de entradas antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetFileSystemEntries%2A>, debe esperar a que la matriz entera de entradas que se devolverán antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos usando el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  \-o bien- <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.  -o bien- <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> no es un valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso que se va a probar.</param>
        <summary>Determina si la ruta de acceso dada hace referencia a un directorio existente en el disco.</summary>
        <returns>
          <see langword="true" /> si <paramref name="path" /> hace referencia a un directorio existente; <see langword="false" /> si el directorio no existe o se produce un error al intentar determinar si existe el directorio especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual.  
  
 Los espacios finales se quitan del final de la `path` parámetro antes de comprobar si existe el directorio.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Si no tiene en un permiso de solo lectura mínimo al directorio, el <xref:System.IO.Directory.Exists%2A> método devolverá `false`.  
  
 El <xref:System.IO.Directory.Exists%2A> método `false` si se produce un error al intentar determinar si existe el archivo especificado. Esto puede ocurrir en las situaciones que provocan excepciones, como pasar un nombre de archivo con caracteres no válidos o hay demasiados caracteres, un disco con errores o que faltan, o si el llamador no tiene permiso para leer el archivo.  
  
   
  
## Examples  
 En el ejemplo siguiente se toma una matriz de nombres de archivo o directorio en la línea de comandos, determina qué tipo de nombre es y lo procesa de forma adecuada.  
  
 [!code-cpp[Recursive file finder#2](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#2)]
 [!code-csharp[Recursive file finder#2](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#2)]
 [!code-vb[Recursive file finder#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer archivos. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve la lista de control de acceso (ACL) de Windows para un directorio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso a un directorio que contiene un objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que describe la información de la lista de control de acceso (ACL) del archivo.</param>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que encapsula las entradas de la lista de control de acceso (ACL) para un directorio especificado.</summary>
        <returns>Objeto que encapsula las reglas de control de acceso correspondientes al archivo descrito por el parámetro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.Directory.GetAccessControl%2A> método para recuperar las entradas de lista (ACL) del control de acceso para un directorio.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo especificado o el directorio. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 En entornos de NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> se conceden al usuario si el usuario tiene <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> derechos en la carpeta principal. Para denegar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, denegar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> en el directorio principal.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.Directory.GetAccessControl%2A> y <xref:System.IO.Directory.SetAccessControl%2A> métodos para agregar un acceso controlar la entrada de la lista (ACL) y, a continuación, quitar una entrada ACL de un directorio.  Para ejecutar este ejemplo, debe proporcionar una cuenta de usuario o grupo válida.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S al abrir el directorio.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows 2000 o posterior.</exception>
        <exception cref="T:System.SystemException">Se produjo un error en el nivel del sistema, como que no se encontró el directorio. La excepción específica puede ser una subclase de <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El parámetro <paramref name="path" /> especifica un directorio que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- El autor de la llamada no dispone del permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso enumerar la lista de control de acceso (ACL) para un directorio. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" /> acción de seguridad: petición.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso a un directorio que contiene un objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que describe la información de la lista de control de acceso (ACL) del archivo.</param>
        <param name="includeSections">Uno de los valores <see cref="T:System.Security.AccessControl.AccessControlSections" /> que especifica el tipo de información de la lista de control de acceso (ACL) que se recibe.</param>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que encapsula el tipo especificado de las entradas de la lista de control de acceso (ACL) para un directorio especificado.</summary>
        <returns>Objeto que encapsula las reglas de control de acceso correspondientes al archivo descrito por el parámetro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.Directory.GetAccessControl%2A> método para recuperar las entradas de lista (ACL) del control de acceso para un directorio.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo especificado o el directorio. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 En entornos de NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> se conceden al usuario si el usuario tiene <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> derechos en la carpeta principal. Para denegar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, denegar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> en el directorio principal.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S al abrir el directorio.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows 2000 o posterior.</exception>
        <exception cref="T:System.SystemException">Se produjo un error en el nivel del sistema, como que no se encontró el directorio. La excepción específica puede ser una subclase de <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El parámetro <paramref name="path" /> especifica un directorio que es de solo lectura.  -o bien- Esta operación no es compatible con la plataforma actual.  -o bien- El autor de la llamada no dispone del permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso enumerar la lista de control de acceso (ACL) para un directorio. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" /> acción de seguridad: petición.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso del directorio.</param>
        <summary>Obtiene la fecha y hora de creación de un directorio.</summary>
        <returns>Estructura que se establece en la fecha y hora de creación para el directorio especificado. Este valor se expresa en hora local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no se pueden actualizar continuamente el sistema operativo.  
  
 Este método es equivalente a <xref:System.IO.File.GetCreationTime%2A?displayProperty=nameWithType>.  
  
 Si el directorio se describe en el `path` parámetro no existe, este método devuelve 12:00 de la medianoche del 1 de enero de 1601 D.C. (E.C.) Hora Universal coordinada (UTC), se ajusta a la hora local.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene la hora de creación del directorio especificado.  
  
 [!code-cpp[Dir_GetCreation#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCreation/CPP/dir_getcreation.cpp#1)]
 [!code-csharp[Dir_GetCreation#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCreation/CS/dir_getcreation.cs#1)]
 [!code-vb[Dir_GetCreation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCreation/VB/dir_getcreation.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso del directorio.</param>
        <summary>Obtiene la fecha y hora de creación, en formato de Hora universal coordinada (UTC), de un directorio.</summary>
        <returns>Estructura que se establece en la fecha y hora de creación para el directorio especificado. Este valor se expresa en hora UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no se pueden actualizar continuamente el sistema operativo.  
  
 Si el directorio se describe en el `path` parámetro no existe, este método devuelve 12:00 de la medianoche del 1 de enero de 1601 D.C. (E.C.) Hora de Universal coordinada (UTC).  
  
 Utilice este método para obtener la hora de creación de un directorio basado en hora Universal coordinada (UTC).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra las diferencias en la salida cuando se utiliza la salida de hora Universal coordinada (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static string GetCurrentDirectory ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCurrentDirectory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentDirectory () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCurrentDirectory();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el directorio de trabajo actual de la aplicación.</summary>
        <returns>Cadena que contiene la ruta de acceso del directorio de trabajo actual y no finaliza con una barra diagonal inversa (\\).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El directorio actual es distinto del directorio original, que es el de la que se inició el proceso.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el siguiente ejemplo se muestra cómo se utiliza el método `GetCurrentDirectory`.  
  
 [!code-cpp[Dir_GetCurDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCurDir/CPP/dir_getcurdir.cpp#1)]
 [!code-csharp[Dir_GetCurDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCurDir/CS/dir_getcurdir.cs#1)]
 [!code-vb[Dir_GetCurDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCurDir/VB/dir_getcurdir.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.NotSupportedException">El sistema operativo es Windows CE, que no tiene la funcionalidad de directorio actual.  Este método está disponible en .NET Compact Framework, pero no se admite actualmente.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve los nombres de los subdirectorios que cumplen los criterios especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <summary>Devuelve los nombres de los subdirectorios (con sus rutas de acceso) del directorio especificado.</summary>
        <returns>Una matriz de los nombres completos (con sus rutas de acceso) de los subdirectorios de la ruta de acceso especificada, o una matriz vacía si no se encuentran directorios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es idéntico a <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29> con el asterisco (\*) especifica que el patrón de búsqueda, por lo que devuelve todos los subdirectorios. Si tiene que buscar en los subdirectorios, utilice la <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> método, que le permite especificar una búsqueda en subdirectorios con el `searchOption` parámetro.  
  
 El <xref:System.IO.Directory.EnumerateDirectories%2A> y <xref:System.IO.Directory.GetDirectories%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateDirectories%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetDirectories%2A>, debe esperar a que la matriz entera de nombres que se devuelvan antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateDirectories%2A> puede ser más eficaz.  
  
 El `path` parámetro puede especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Los nombres devueltos por este método tienen el prefijo con la información de directorio proporcionada en `path`.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se toma una matriz de nombres de archivo o directorio en la línea de comandos, determina qué tipo de nombre es y lo procesa de forma adecuada.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para tener acceso a información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los subdirectorios de <c>path</c>. Este parámetro puede contener una combinación de literales válidos y caracteres comodín, pero no admite expresiones regulares.</param>
        <summary>Devuelve los nombres de los subdirectorios (con sus rutas de acceso) que coinciden con el patrón de búsqueda especificado en el directorio especificado.</summary>
        <returns>Una matriz de los nombres completos (con sus rutas de acceso) de los subdirectorios que coinciden con el patrón de búsqueda en el directorio especificado, o una matriz vacía si no se encuentran directorios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve todos los subdirectorios directamente en el directorio especificado que coinciden con el patrón de búsqueda especificado. Si el directorio especificado no tiene ningún subdirectorio o coincide con ningún subdirectorio en el `searchPattern` parámetro, este método devuelve una matriz vacía. Se busca solo en el directorio superior. Si desea buscar también los subdirectorios, utilice la <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> método y especifique <xref:System.IO.SearchOption.AllDirectories> en el `searchOption` parámetro.  
  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido de <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener los caracteres no válidos. Puede consultar los caracteres no válidos usando el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 El `path` parámetro puede especificar la información de ruta de acceso absoluta o relativa y no distingue mayúsculas de minúsculas.  Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El <xref:System.IO.Directory.EnumerateDirectories%2A> y <xref:System.IO.Directory.GetDirectories%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateDirectories%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetDirectories%2A>, debe esperar a que la matriz entera de nombres que se devuelvan antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateDirectories%2A> puede ser más eficaz.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se cuenta el número de directorios en una ruta de acceso que comienzan por la letra especificada.  
  
 [!code-cpp[Dir_GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetDirs2/CPP/dir_getdirs2.cpp#1)]
 [!code-csharp[Dir_GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs2.cs#1)]
 [!code-vb[Dir_GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos mediante <see cref="M:System.IO.Path.GetInvalidPathChars" />.  -o bien- <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> o <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los subdirectorios de <c>path</c>. Este parámetro puede contener una combinación de literales válidos y caracteres comodín, pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir todos los subdirectorios o solo el directorio actual.</param>
        <summary>Devuelve los nombres de los subdirectorios (incluidas las rutas de acceso) que coinciden con el patrón de búsqueda especificado en el directorio especificado y, opcionalmente, busca en subdirectorios.</summary>
        <returns>Una matriz de los nombres completos (con sus rutas de acceso) de los subdirectorios que coinciden con los criterios especificados, o una matriz vacía si no se encuentran directorios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` parámetro puede especificar la información de ruta de acceso absoluta o relativa y no distingue mayúsculas de minúsculas. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido de <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener los caracteres no válidos. Puede consultar los caracteres no válidos usando el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 El <xref:System.IO.Directory.EnumerateDirectories%2A> y <xref:System.IO.Directory.GetDirectories%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateDirectories%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetDirectories%2A>, debe esperar a que la matriz entera de nombres que se devuelvan antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateDirectories%2A> puede ser más eficaz.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se cuenta el número de directorios que comienzan por la letra en una ruta de acceso especificada. Se busca sólo el directorio de nivel superior.  
  
 [!code-csharp[Dir_GetDirs2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs3.cs#2)]
 [!code-vb[Dir_GetDirs2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos usando el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  -o bien- <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> o <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> no es un valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryRoot">
      <MemberSignature Language="C#" Value="public static string GetDirectoryRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectoryRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryRoot(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso de un archivo o directorio.</param>
        <summary>Devuelve la información del volumen, la información de raíz o ambas para la ruta de acceso especificada.</summary>
        <returns>Cadena que contiene la información del volumen, la información de raíz o ambas para la ruta de acceso especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método obtiene el nombre de ruta de acceso completa de `path`, tal como lo devuelve <xref:System.IO.Path.GetFullPath%2A>, y devuelve información del directorio raíz. La ruta de acceso especificada no debe existir.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el directorio actual y mostrar la raíz del directorio.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve los nombres de los archivos que cumplen los criterios especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <summary>Devuelve los nombres de archivo (con sus rutas de acceso) del directorio especificado.</summary>
        <returns>Una matriz de los nombres completos (con sus rutas de acceso) para los archivos en el directorio especificado, o una matriz vacía si no se encuentran archivos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Directory.EnumerateFiles%2A> y <xref:System.IO.Directory.GetFiles%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateFiles%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetFiles%2A>, debe esperar a que la matriz entera de nombres que se devuelvan antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 Los nombres de archivo devueltos se anexan a proporcionado `path` parámetro.  
  
 Este método es idéntico a <xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29> con el asterisco (\*) especificado como el patrón de búsqueda.  
  
 El `path` parámetro puede especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 No se garantiza el orden de los nombres de archivo devueltos; Utilice la <xref:System.Array.Sort%2A> método si se requiere un criterio de ordenación concreto.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.IO.Directory.GetFiles%2A> método para devolver los nombres de archivo desde una ubicación especificada por el usuario. El ejemplo está configurado para catch todos los errores comunes a este método.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.  -o bien- Se ha producido un error de red.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no se encuentra o no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los archivos de <c>path</c>.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Devuelve los nombres de los archivos (con sus rutas de acceso) que coinciden con el patrón de búsqueda especificado en el directorio especificado.</summary>
        <returns>Una matriz de nombres completos (con sus rutas de acceso) para los archivos del directorio especificado que coinciden con el patrón de búsqueda especificado, o una matriz vacía si no se encuentra ningún archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los nombres de archivo devueltos se anexan a proporcionado `path` no se garantiza el parámetro y el orden de los nombres de archivo devueltos; utilice la <xref:System.Array.Sort%2A> método si se requiere un criterio de ordenación concreto.  
  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido de <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener los caracteres no válidos. Puede consultar los caracteres no válidos usando el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como se indica a continuación:  
>   
>  -   Si la extensión especificada es exactamente tres caracteres de longitud, el método devuelve archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
> [!NOTE]
>  Dado que este método comprueba con nombres de archivo con el formato de nombre de 8.3 archivo y el formato de nombre de archivo largo, un modelo de búsqueda similar a "\*1\*.txt" puede devolver nombres de archivo inesperado. Por ejemplo, con un patrón de búsqueda de "\*1\*.txt" devuelve "nombrelargoarchivo.txt", porque el formato de nombre de 8.3 archivo equivalente es "LONGFI~1.TXT".  
  
 El <xref:System.IO.Directory.EnumerateFiles%2A> y <xref:System.IO.Directory.GetFiles%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateFiles%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetFiles%2A>, debe esperar a que la matriz entera de nombres que se devuelvan antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 El `path` parámetro puede especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se cuenta el número de archivos que comienzan por la letra especificada.  
  
 [!code-cpp[Dir_GetFiles2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetFiles2/CPP/dir_getfiles2.cpp#1)]
 [!code-csharp[Dir_GetFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetFiles2/CS/dir_getfiles2.cs#1)]
 [!code-vb[Dir_GetFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetFiles2/VB/dir_getfiles2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.  -o bien- Se ha producido un error de red.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos mediante <see cref="M:System.IO.Path.GetInvalidPathChars" />.  -o bien- <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> o <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no se encuentra o no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los archivos de <c>path</c>.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir todos los subdirectorios o solo el directorio actual.</param>
        <summary>Devuelve los nombres de los archivos (con sus rutas de acceso) que coincidan con el patrón de búsqueda especificado en el directorio especificado, utilizando un valor para determinar si se debe buscar en los subdirectorios.</summary>
        <returns>Una matriz de nombres completos (con sus rutas de acceso) para los archivos del directorio especificado que coinciden con el patrón de búsqueda y opción especificados, o una matriz vacía si no se encuentra ningún archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los nombres de archivo devueltos se anexan al parámetro proporcionado `path` y no se garantiza el orden de los nombres de archivo devueltos; utilice la <xref:System.Array.Sort%2A> método si se requiere un criterio de ordenación concreto.  
  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido de <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener los caracteres no válidos. Puede consultar los caracteres no válidos usando el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como se indica a continuación:  
>   
>  -   Si la extensión especificada es exactamente tres caracteres de longitud, el método devuelve archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un modelo de búsqueda "file*.txt" devuelve ambos archivos.  
  
> [!NOTE]
>  Dado que este método comprueba con nombres de archivo con el formato de nombre de 8.3 archivo y el formato de nombre de archivo largo, un modelo de búsqueda similar a "\*1\*.txt" puede devolver nombres de archivo inesperado. Por ejemplo, con un patrón de búsqueda de "\*1\*.txt" devuelve "nombrelargoarchivo.txt", porque el formato de nombre de 8.3 archivo equivalente es "LONGFI~1.TXT".  
  
 El <xref:System.IO.Directory.EnumerateFiles%2A> y <xref:System.IO.Directory.GetFiles%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateFiles%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetFiles%2A>, debe esperar a que la matriz entera de nombres que se devuelvan antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 Los nombres de archivo incluyen la ruta de acceso completa.  
  
 El `path` parámetro puede especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  -o bien- <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> o <paramref name="searchpattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> no es un valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no se encuentra o no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.  -o bien- Se ha producido un error de red.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve los nombres de todos los archivos y subdirectorios que satisfacen los criterios especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <summary>Devuelve los nombres de todos los archivos y subdirectorios de una ruta de acceso especificada.</summary>
        <returns>Una matriz de los nombres de los archivos y subdirectorios en el directorio especificado, o una matriz vacía si no se encuentran archivos o subdirectorios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se garantiza el orden de los nombres de directorio y archivo devuelto; Utilice la <xref:System.Array.Sort%2A> método si se requiere un criterio de ordenación concreto.  
  
 El <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> y <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, puede empezar a enumerar la colección de entradas antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetFileSystemEntries%2A>, debe esperar a que la matriz entera de entradas que se devolverán antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 Este método es idéntico a <xref:System.IO.Directory.GetFileSystemEntries%2A> con el asterisco (\*) especificado como el patrón de búsqueda.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.Directory.GetFileSystemEntries%2A> método para rellenar una matriz de cadenas con los nombres de todos los archivos y subdirectorios en una ubicación especificada por el usuario e imprime cada cadena de la matriz en la consola. El ejemplo está configurado para catch todos los errores comunes a este método.  
  
 [!code-cpp[System.IO.Directory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#1)]
 [!code-csharp[System.IO.Directory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#1)]
 [!code-vb[System.IO.Directory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="T:System.IO.FileSystemInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios y archivos de <c>path</c>.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Devuelve una matriz o nombres de archivo y nombres de directorio que coinciden con un patrón de búsqueda en una ruta de acceso especificada.</summary>
        <returns>Una matriz de nombres de archivo y de directorio que coinciden con los criterios de búsqueda especificados, o una matriz vacía si no se encuentran archivos o directorios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se garantiza el orden de los nombres de directorio y archivo devuelto; Utilice la <xref:System.Array.Sort%2A> método si se requiere un criterio de ordenación concreto.  
  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido de <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener los caracteres no válidos. Puede consultar los caracteres no válidos usando el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como se indica a continuación:  
>   
>  -   Si la extensión especificada es exactamente tres caracteres de longitud, el método devuelve archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.Directory.GetFileSystemEntries%2A> método para rellenar una matriz de cadenas con los nombres de todos los archivos que coincidan con un filtro especificado por el usuario en una ubicación específica e imprime cada cadena de la matriz en la consola. El ejemplo está configurado para catch todos los errores comunes a este método.  
  
 [!code-cpp[System.IO.Directory#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#2)]
 [!code-csharp[System.IO.Directory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#2)]
 [!code-vb[System.IO.Directory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  -o bien- <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> o <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios y archivos de <c>path</c>.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir solo el directorio actual o debe incluir todos los subdirectorios.  El valor predeterminado es <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Devuelve una matriz de todos los nombres de archivo y de directorio que coinciden con un patrón de búsqueda en una ruta de acceso especificada y, opcionalmente, busca en subdirectorios.</summary>
        <returns>Una matriz de nombres de archivo y nombres de directorio que coincide con los criterios de búsqueda especificados, o una matriz vacía si no se encuentran archivos o directorios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se garantiza el orden de los nombres de directorio y archivo devuelto; Utilice la <xref:System.Array.Sort%2A> método si se requiere un criterio de ordenación concreto.  
  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido de <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener los caracteres no válidos. Puede consultar los caracteres no válidos usando el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como se indica a continuación:  
>   
>  -   Si la extensión especificada es exactamente tres caracteres de longitud, el método devuelve archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
 El <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> y <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos difieren como sigue: al usar <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, puede empezar a enumerar la colección de entradas antes de que se devuelve toda la colección; cuando se usa <xref:System.IO.Directory.GetFileSystemEntries%2A>, debe esperar a que la matriz entera de entradas que se devolverán antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 Puede especificar la información de ruta de acceso relativa con el `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos usando el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  \-o bien- <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.  -o bien- <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> no es un valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo o directorio para el que se va a obtener información de fecha y hora de acceso.</param>
        <summary>Devuelve la fecha y hora a la que se produjo el último acceso al archivo o directorio especificado.</summary>
        <returns>Estructura que se establece en la fecha y hora a la que se produjo el último acceso al archivo o directorio especificado. Este valor se expresa en hora local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no se pueden actualizar continuamente el sistema operativo.  
  
 Este método es idéntico a <xref:System.IO.File.GetLastAccessTime%2A?displayProperty=nameWithType>.  
  
 Si el directorio se describe en el `path` parámetro no existe, este método devuelve 12:00 de la medianoche del 1 de enero de 1601 D.C. (E.C.) Hora Universal coordinada (UTC), se ajusta a la hora local.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar `GetLastAccessTime`.  
  
 [!code-cpp[Dir_GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastAccess/CPP/dir_getlastaccess.cpp#1)]
 [!code-csharp[Dir_GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastAccess/CS/dir_getlastaccess.cs#1)]
 [!code-vb[Dir_GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastAccess/VB/dir_getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">El parámetro <paramref name="path" /> no tiene un formato válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo o directorio para el que se va a obtener información de fecha y hora de acceso.</param>
        <summary>Devuelve la fecha y la hora, en formato de Hora universal coordinada (UTC), a la que se produjo el último acceso al archivo o directorio especificado.</summary>
        <returns>Estructura que se establece en la fecha y hora a la que se produjo el último acceso al archivo o directorio especificado. Este valor se expresa en hora UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no se pueden actualizar continuamente el sistema operativo.  
  
 Si el directorio se describe en el `path` parámetro no existe, este método devuelve 12:00 de la medianoche del 1 de enero de 1601 D.C. (E.C.) Hora de Universal coordinada (UTC).  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra las diferencias en la salida cuando se utiliza la salida de hora Universal coordinada (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">El parámetro <paramref name="path" /> no tiene un formato válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo o directorio para el que se va a obtener información de fecha y hora de modificación.</param>
        <summary>Devuelve la fecha y hora a la que se escribió por última vez en el archivo o directorio especificado.</summary>
        <returns>Estructura que se establece en la fecha y hora a la que se escribió por última vez en el archivo o directorio especificado. Este valor se expresa en hora local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no se pueden actualizar continuamente el sistema operativo.  
  
 Si el directorio se describe en el `path` parámetro no existe, este método devuelve 12:00 de la medianoche del 1 de enero de 1601 D.C. (E.C.) Hora Universal coordinada (UTC), se ajusta a la hora local.  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar `GetLastWriteTime`.  
  
 [!code-cpp[Dir_GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastWrite/CPP/dir_getlastwrite.cpp#1)]
 [!code-csharp[Dir_GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastWrite/CS/dir_getlastwrite.cs#1)]
 [!code-vb[Dir_GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastWrite/VB/dir_getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo o directorio para el que se va a obtener información de fecha y hora de modificación.</param>
        <summary>Devuelve la fecha y la hora, en formato de Hora universal coordinada (UTC), a la que se escribió por última vez en el archivo o directorio especificado.</summary>
        <returns>Estructura que se establece en la fecha y hora a la que se escribió por última vez en el archivo o directorio especificado. Este valor se expresa en hora UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no se pueden actualizar continuamente el sistema operativo.  
  
 Si el directorio se describe en el `path` parámetro no existe, este método devuelve 12:00 de la medianoche del 1 de enero de 1601 D.C. (E.C.) Hora de Universal coordinada (UTC).  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra las diferencias en la salida cuando se utiliza la salida de hora Universal coordinada (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera los nombres de las unidades lógicas de este equipo con el formato "&lt;letra de unidad&gt;:\\".</summary>
        <returns>Unidades lógicas del equipo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetLogicalDrives devuelve todas las unidades accesibles en un equipo determinado, incluida la unidad de disquete y las unidades de medios ópticas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.Directory.GetLogicalDrives%2A> método para asignar el nombre de cada unidad en el equipo que realiza la llamada a una matriz de cadenas. Cada miembro de esta matriz de cadenas, a continuación, se imprime en la consola. El ejemplo está configurado para catch todos los errores comunes a este método.  
  
 [!code-cpp[System.IO.Directory#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#3)]
 [!code-csharp[System.IO.Directory#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#3)]
 [!code-vb[System.IO.Directory#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S (por ejemplo, un error de disco).</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado, como llamar a código nativo con la interoperabilidad COM o PInvoke. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetParent (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetParent(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetParent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParent (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetParent(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso para la cual se va a recuperar el directorio principal.</param>
        <summary>Recupera el directorio principal de la ruta especificada, incluidas tanto las rutas de acceso absolutas como las relativas.</summary>
        <returns>El directorio principal o <see langword="null" /> si <paramref name="path" /> es el directorio raíz, incluida la raíz de un servidor UNC o un nombre de uso compartido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` parámetro puede especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Los espacios finales se quitan del final de la `path` parámetro antes de obtener el directorio.  
  
 La cadena devuelta por este método está formada por todos los caracteres de la ruta de acceso hasta, pero no incluidos, la última <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>. Por ejemplo, pasar la ruta de acceso "C:\Directory\SubDirectory\test.txt" a <xref:System.IO.Directory.GetParent%2A> devuelve "C:\Directory\SubDirectory". Pasar "C:\Directory\SubDirectory" devuelve "C:\Directory". Sin embargo, pasar "C:\Directory\SubDirectory\\" devuelve "C:\Directory\SubDirectory", porque es el separador de directorio final después de "Subdirectorio".  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.IO.Directory.GetParent%2A> método para recuperar el directorio principal de una ubicación especificada por el usuario, "path". El valor devuelto por la <xref:System.IO.Directory.GetParent%2A> método, a continuación, se imprime en la consola. El ejemplo está configurado para catch todos los errores comunes a este método.  
  
 [!code-cpp[System.IO.Directory#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#4)]
 [!code-csharp[System.IO.Directory#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#4)]
 [!code-vb[System.IO.Directory#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El directorio que especifica <paramref name="path" /> es de solo lectura.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Para obtener más información, vea el tema <see cref="T:System.IO.PathTooLongException" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">Solo para .NET Framework: El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer de archivos o directorios. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceDirName, string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceDirName, string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceDirName As String, destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceDirName, System::String ^ destDirName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirName" Type="System.String" />
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirName">Ruta de acceso del archivo o del directorio que se va a mover.</param>
        <param name="destDirName">Ruta de acceso a la nueva ubicación de <c>sourceDirName</c>. Si <c>sourceDirName</c> es un archivo, <c>destDirName</c> también debe ser un nombre de archivo.</param>
        <summary>Mueve un archivo o directorio y su contenido a una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea un nuevo directorio con el nombre especificado por `destDirName` y mueve el contenido de `sourceDirName` al directorio de destino recién creado. Si intenta mover un directorio a un directorio que ya existe, un <xref:System.IO.IOException> se producirá. Por ejemplo, se producirá una excepción si se intenta mover c:\mydir a c:\public, y c:\public ya existe. Como alternativa, puede especificar "c:\\\public\\\mydir" como el `destDirName` parámetro, proporcionado que no existe "mydir" en "c:\\\public", o especificar un nuevo nombre de directorio, como "c:\\\newdir".  
  
 El `sourceDirName` y `destDirName` se permiten argumentos para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Los espacios finales se quitan del final de los parámetros de ruta de acceso antes de mover el directorio.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo mover un directorio y todos sus archivos a un nuevo directorio. El directorio original ya no existe después de que se ha movido.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se ha intentado mover un directorio a otro volumen.  -o bien-<paramref name="destDirName" /> ya existe.  -o bien- Los parámetros <paramref name="sourceDirName" /> y <paramref name="destDirName" /> hacen referencia al mismo archivo o directorio.  -o bien- El directorio o un archivo que otro proceso está usando.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceDirName" /> o <paramref name="destDirName" /> es una cadena de longitud cero, contiene solo espacios en blanco o contiene uno o más caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="sourceDirName" /> o <paramref name="destDirName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada por <paramref name="sourceDirName" /> no es válida (por ejemplo, se encuentra en una unidad de red no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer de <paramref name="sourceDirName" /> y escribir en <paramref name="sourceDirName" /> y <paramref name="destDirName" />. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">Directorio al que se van a agregar o del que se van a quitar entradas de la lista de control de acceso (ACL).</param>
        <param name="directorySecurity">Objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que describe una entrada de la ACL que se va a aplicar al directorio descrito por el parámetro <c>path</c>.</param>
        <summary>Aplica al directorio especificado las entradas de la lista de control de acceso (ACL) descritas por un objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Directory.SetAccessControl%2A> método aplica las entradas de lista (ACL) de control de acceso a un archivo que representa la lista ACL no heredada.  
  
> [!CAUTION]
>  La ACL especificada para el `directorySecurity` parámetro reemplaza la ACL existente para el directorio. Para agregar permisos para un usuario nuevo, use el <xref:System.IO.Directory.GetAccessControl%2A> método para obtener la lista ACL existente y modificarlo.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo especificado o el directorio. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 El <xref:System.IO.Directory.SetAccessControl%2A> método conserva solo <xref:System.Security.AccessControl.DirectorySecurity> objetos que se han modificado después de la creación de objetos.  Si un <xref:System.Security.AccessControl.DirectorySecurity> objeto no se ha modificado, no se conservarán en un archivo.  Por lo tanto, no es posible recuperar un <xref:System.Security.AccessControl.DirectorySecurity> de objetos de un archivo y vuelva a aplicar el mismo objeto a otro archivo.  
  
 Para copiar la información de la ACL de un archivo a otro:  
  
1.  Use la <xref:System.IO.Directory.GetAccessControl%2A> método para recuperar la <xref:System.Security.AccessControl.DirectorySecurity> objeto desde el archivo de origen.  
  
2.  Crear un nuevo <xref:System.Security.AccessControl.DirectorySecurity> objeto para el archivo de destino.  
  
3.  Use la <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> o <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> método del origen de <xref:System.Security.AccessControl.DirectorySecurity> objeto que se va a recuperar la información de la ACL.  
  
4.  Use la <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> o <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> método para copiar la información recuperada en el paso 3 en el destino <xref:System.Security.AccessControl.DirectorySecurity> objeto.  
  
5.  Establecer el destino <xref:System.Security.AccessControl.DirectorySecurity> objeto en el archivo de destino usando la <xref:System.IO.Directory.SetAccessControl%2A> método.  
  
 En entornos de NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> se conceden al usuario si el usuario tiene <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> derechos en la carpeta principal. Para denegar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, denegar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> en el directorio principal.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.Directory.GetAccessControl%2A> y <xref:System.IO.Directory.SetAccessControl%2A> métodos para agregar un acceso controlar la entrada de la lista (ACL) y, a continuación, quitar una entrada ACL de un directorio.  Para ejecutar este ejemplo, debe proporcionar una cuenta de usuario o grupo válida.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="directorySecurity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">No se ha encontrado el directorio.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> no era válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El proceso actual no tiene acceso para al directorio especificado por <paramref name="path" />.  -o bien- El proceso actual no tiene privilegios suficientes para establecer la entrada ACL.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows 2000 o posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso enumerar la lista de control de acceso (ACL) para un directorio. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" /> acción de seguridad: petición.</permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">El archivo o directorio para el que se va a establecer información de fecha y hora de creación.</param>
        <param name="creationTime">Fecha y hora en que escribió en el archivo o directorio por última vez. Este valor se expresa en hora local.</param>
        <summary>Establece la fecha y hora de creación del archivo o la carpeta especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra las diferencias en la salida cuando se utiliza la salida de hora Universal coordinada (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> especifica un valor fuera del intervalo de fechas u horas permitido para esta operación.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o una versión posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">El archivo o directorio para el que se va a establecer información de fecha y hora de creación.</param>
        <param name="creationTimeUtc">La fecha y hora en que se creó el directorio o archivo. Este valor se expresa en hora local.</param>
        <summary>Establece la fecha y hora de creación, en formato de Hora universal coordinada (UTC), del archivo o directorio especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> especifica un valor fuera del intervalo de fechas u horas permitido para esta operación.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o una versión posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static void SetCurrentDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCurrentDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCurrentDirectory (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCurrentDirectory(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso en la que se establece el directorio de trabajo actual.</param>
        <summary>Establece el directorio de trabajo actual de la aplicación en el directorio especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando finaliza la aplicación, el directorio de trabajo se restaura a su ubicación original (es decir, el directorio donde se inició el proceso).  
  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Los espacios finales se quitan del final de la `path` parámetro antes de establecer el directorio.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Si está configurando el directorio en una unidad con medios extraíbles, como ("A:" para una unidad de disquete) o "E:" para una unidad de CD-ROM, puede determinar si la unidad está lista usando el <xref:System.IO.DriveInfo.IsReady%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el directorio actual y mostrar la raíz del directorio.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido para obtener acceso al código no administrado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">No se encuentra el directorio especificado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en archivos o directorios. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">El archivo o directorio para el que se va a establecer información de fecha y hora de acceso.</param>
        <param name="lastAccessTime">Objeto que contiene el valor que se va a establecer para la fecha y hora de acceso de <c>path</c>. Este valor se expresa en hora local.</param>
        <summary>Establece la fecha y hora a la que se produjo el último acceso al archivo o directorio especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar `SetLastAccessTime`.  
  
 [!code-cpp[Dir_SetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastAccess/CPP/dir_setlastaccess.cpp#1)]
 [!code-csharp[Dir_SetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastAccess/CS/dir_setlastaccess.cs#1)]
 [!code-vb[Dir_SetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastAccess/VB/dir_setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o una versión posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTime" /> especifica un valor fuera del intervalo de fechas u horas permitido para esta operación.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">El archivo o directorio para el que se va a establecer información de fecha y hora de acceso.</param>
        <param name="lastAccessTimeUtc">Objeto que contiene el valor que se va a establecer para la fecha y hora de acceso de <c>path</c>. Este valor se expresa en hora UTC.</param>
        <summary>Establece la fecha y la hora, en formato de Hora universal coordinada (UTC), a la que se produjo el último acceso al archivo o directorio especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra las diferencias en la salida cuando se utiliza la salida de hora Universal coordinada (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o una versión posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTimeUtc" /> especifica un valor fuera del intervalo de fechas u horas permitido para esta operación.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso del directorio.</param>
        <param name="lastWriteTime">Fecha y hora en que escribió en el directorio por última vez. Este valor se expresa en hora local.</param>
        <summary>Establece la fecha y la hora en que escribió en un directorio por última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar `SetLastWriteTime`.  
  
 [!code-cpp[Dir_SetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastWrite/CPP/dir_setlastwrite.cpp#1)]
 [!code-csharp[Dir_SetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastWrite/CS/dir_setlastwrite.cs#1)]
 [!code-vb[Dir_SetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastWrite/VB/dir_setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o una versión posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTime" /> especifica un valor fuera del intervalo de fechas u horas permitido para esta operación.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso del directorio.</param>
        <param name="lastWriteTimeUtc">Fecha y hora en que escribió en el directorio por última vez. Este valor se expresa en hora UTC.</param>
        <summary>Establece la fecha y la hora, en formato de Hora universal coordinada (UTC), a la que se escribió en el directorio por última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` se permite el parámetro para especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, vea [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra las diferencias en la salida cuando se utiliza la salida de hora Universal coordinada (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o una versión posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTimeUtc" /> especifica un valor fuera del intervalo de fechas u horas permitido para esta operación.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
  </Members>
</Type>