<Type Name="Directory" FullName="System.IO.Directory">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3e3d3c2a42ecb6933086bd308c1c821610a4e5c8" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58717004" /></Metadata><TypeSignature Language="C#" Value="public static class Directory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Directory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Directory" />
  <TypeSignature Language="VB.NET" Value="Public Class Directory" />
  <TypeSignature Language="C++ CLI" Value="public ref class Directory abstract sealed" />
  <TypeSignature Language="F#" Value="type Directory = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Expone métodos estáticos para crear, mover y enumerar archivos en directorios y subdirectorios. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.IO.Directory> clase para las operaciones habituales, como copiar, mover, cambiar el nombre, crear y eliminar directorios.  
  
-   Para crear un directorio, use uno de los <xref:System.IO.Directory.CreateDirectory%2A> métodos.  
  
-   Para eliminar un directorio, use uno de los <xref:System.IO.Directory.Delete%2A> métodos.  
  
-   Para obtener o establecer el directorio actual para una aplicación, use la <xref:System.IO.Directory.GetCurrentDirectory%2A> o <xref:System.IO.Directory.SetCurrentDirectory%2A> método.  
  
-   Para manipular <xref:System.DateTime> información relacionada con la creación, acceso y la escritura de un directorio, usan los métodos como <xref:System.IO.Directory.SetLastAccessTime%2A> y <xref:System.IO.Directory.SetCreationTime%2A>.  
  
 Los métodos estáticos de la <xref:System.IO.Directory> clase realizar comprobaciones de seguridad en todos los métodos. Si va a utilizar un objeto varias veces, considere el uso del método de instancia correspondiente de <xref:System.IO.DirectoryInfo> en su lugar, dado que la comprobación de seguridad no siempre que sea necesario.  
  
 Si va a realizar solo una acción relacionada con Active, podría ser más eficaz utilizar estático <xref:System.IO.Directory> método en lugar del correspondiente <xref:System.IO.DirectoryInfo> método de instancia. La mayoría <xref:System.IO.Directory> métodos requieren la ruta de acceso al directorio que está manipulando.  
  
> [!NOTE]
>  En los miembros que aceptan una cadena `path` parámetro, esa ruta de acceso debe tener un formato correcto o se produce una excepción. Por ejemplo, si una ruta de acceso completa pero que empieza con un espacio ("c:\temp"), no se recorta la cadena de ruta de acceso, por lo que la ruta de acceso se considera incorrecto y se produce una excepción. Además, una ruta de acceso o una combinación de rutas de acceso no puede ser completo dos veces. Por ejemplo, "c:\temp c:\windows" también genera una excepción. Asegúrese de que las rutas de acceso correctos al usar métodos que aceptan una cadena de ruta de acceso. Para obtener más información, vea <xref:System.IO.Path>.  
  
 En los miembros que aceptan una ruta de acceso, la ruta de acceso puede hacer referencia a un archivo o un directorio. Puede usar una ruta de acceso completa, una ruta de acceso relativa o una ruta de acceso de convención de nomenclatura Universal (UNC) para un nombre de servidor y recurso compartido. Por ejemplo, todo lo siguiente es las rutas de acceso aceptables:  
  
-   "c:\\\MyDir" en C#, o "c:\MyDir" en Visual Basic.  
  
-   "MyDir\\\MySubdir" en C#, o "Midir\misubdir" en Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" en C#, o "\\\MyServer\MyShare" en Visual Basic.  
  
 De forma predeterminada, se concede acceso de lectura/escritura completo a los nuevos directorios a todos los usuarios. Sin embargo, la aplicación debe tener la seguridad correcta para tener acceso a directorios existentes.  
  
 Solicitar permisos para un directorio y todos sus subdirectorios, el final de la cadena de ruta de acceso con el carácter separador de directorio. (Por ejemplo, "C:\Temp\\" concede acceso a C:\Temp\ y todos sus subdirectorios.) Solicitar permisos solo para un directorio específico, la cadena de ruta de acceso con un punto final. (Por ejemplo, "C:\Temp\\." concede acceso solo a C:\Temp\\, no a sus subdirectorios.)  
  
 En los miembros que aceptan un `searchPattern` parámetro, la cadena de búsqueda puede ser cualquier combinación de caracteres literales y dos caracteres comodín; \* y?. Este parámetro no reconoce las expresiones regulares. Para obtener más información, consulte el <xref:System.IO.Directory.EnumerateDirectories%28System.String%2CSystem.String%29> método o cualquier otro método que usa el `searchPattern` parámetro.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 <xref:System.IO.Directory> y <xref:System.IO.DirectoryInfo> no se admiten para su uso en [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplicaciones. Para obtener información acerca de cómo obtener acceso a archivos y carpetas en [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplicaciones, vea [acceso a datos y archivos (aplicaciones de Windows Store)](https://msdn.microsoft.com/library/windows/apps/hh758319.aspx).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo recuperar todos los archivos de texto de un directorio y moverlos a un nuevo directorio. Después de mover los archivos, ya no existen en el directorio original.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.IO.Directory.EnumerateFiles%2A> método para recuperar una colección de archivos de texto de un directorio y, a continuación, usar esa colección en una consulta para buscar todas las líneas que contienen "Example".  
  
 [!code-csharp[System.IO.Directory#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class3.cs#11)]
 [!code-vb[System.IO.Directory#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class3.vb#11)]  
  
 El ejemplo siguiente muestra cómo mover un directorio y todos sus archivos a un nuevo directorio. El directorio original ya no existe una vez se ha movido.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.DirectoryInfo" />
    <altmember cref="T:System.IO.FileInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Cómo: Leer y escribir en un archivo de datos recién creado</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateDirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea todos los directorios de una ruta de acceso especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Directorio que se va a crear.</param>
        <summary>Crea todos los directorios y subdirectorios en la ruta de acceso especificada, a menos que ya existan.</summary>
        <returns>Un objeto que representa el directorio en la ruta de acceso especificada. Este objeto se devuelve sin importar si ya existe un directorio en la ruta especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los directorios especificados en `path` se crean, a menos que aún no existan o que alguna parte de `path` no es válido. Si el directorio ya existe, este método no crea un nuevo directorio, pero devuelve un <xref:System.IO.DirectoryInfo> objeto para el directorio existente.  
  
 El `path` parámetro especifica una ruta de acceso de directorio, no una ruta de acceso de archivo.  
  
 Se quitan los espacios finales del final de la `path` parámetro antes de crear el directorio.  
  
 Puede crear un directorio en un equipo remoto, en un recurso compartido que tienen acceso de escritura a. Se admiten rutas de acceso UNC; Por ejemplo, puede especificar lo siguiente para `path`: `\\2009\Archives\December` en Visual Basic, y `\\\\2009\\Archives\\December` en C#.  
  
 Creación de un directorio con el carácter de dos puntos (:) no se admite y producirá una `NotSupportedException` que se produzca.  
  
   
  
## Examples  
 El ejemplo siguiente se crea y elimina el directorio especificado.  
  
 [!code-cpp[Dir_CreateDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_CreateDir/CPP/dir_createdir.cpp#1)]
 [!code-csharp[Dir_CreateDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_CreateDir/CS/dir_createdir.cs#1)]
 [!code-vb[Dir_CreateDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_CreateDir/VB/dir_createdir.vb#1)]  
  
 Para crear el directorio C:\Users\User1\Public\Html cuando el directorio actual es C:\Users\User1, utilice cualquiera de las siguientes llamadas para asegurarse de que la barra diagonal inversa se interpreta correctamente.  
  
 En Visual Basic:  
  
```  
Directory.CreateDirectory("Public\Html")   
    Directory.CreateDirectory("\Users\User1\Public\Html")   
    Directory.CreateDirectory("c:\Users\User1\Public\Html")  
```  
  
 En C#:  
  
```  
Directory.CreateDirectory("Public\\Html");  
    Directory.CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory.CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 En C++:  
  
```  
Directory::CreateDirectory("Public\\Html");  
    Directory::CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory::CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El directorio especificado por <paramref name="path" /> es un archivo.  
  
O bien 
El nombre de la red es desconocido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
O bien 
 <paramref name="path" /> tiene como prefijo o contiene solamente un carácter de dos puntos (:).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> contiene un carácter de dos puntos (:) que no forma parte de una etiqueta de unidad ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir archivos o directorios. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Directorio que se va a crear.</param>
        <param name="directorySecurity">Control de acceso que se aplica al directorio.</param>
        <summary>Crea todos los directorios en la ruta de acceso especificada, salvo que ya existan, aplicando la seguridad de Windows especificada.</summary>
        <returns>Un objeto que representa el directorio en la ruta de acceso especificada. Este objeto se devuelve sin importar si ya existe un directorio en la ruta especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga del método para crear un directorio con el control de acceso, por lo que no hay ninguna posibilidad de que directorio puede obtenerse acceso antes de que se aplica la seguridad.  
  
 Todos los directorios especificados en el `path` se crean parámetros, salvo que aún no existan o que alguna parte de `path` no es válido. El `path` parámetro especifica una ruta de acceso de directorio, no una ruta de acceso de archivo. Si el directorio ya existe, este método no crea un nuevo directorio, pero devuelve un <xref:System.IO.DirectoryInfo> objeto para el directorio existente.  
  
 Se quitan los espacios finales del final de la `path` parámetro antes de crear el directorio.  
  
 Puede crear un directorio en un equipo remoto, en un recurso compartido que tienen acceso de escritura a. Se admiten rutas de acceso UNC; Por ejemplo, puede especificar lo siguiente para `path`: `\\2009\Archives\December` en Visual Basic, y `\\\\2009\\Archives\\December` en C#.  
  
 Creación de un directorio con el carácter de dos puntos (:) no se admite y produce una `NotSupportedException` que se produzca.  
  
   
  
## Examples  
 El ejemplo siguiente crea un nuevo directorio con reglas de acceso para dos cuentas de usuario.  
  
 [!code-csharp[System.IO.Directory#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class7.cs#15)]
 [!code-vb[System.IO.Directory#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class7.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El directorio especificado por <paramref name="path" /> es un archivo.  
  
O bien 
El nombre de la red es desconocido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos usando el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
O bien 
 <paramref name="path" /> tiene como prefijo o contiene solamente un carácter de dos puntos (:).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> contiene un carácter de dos puntos (:) que no forma parte de una etiqueta de unidad ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer y escribir archivos y directorios y para el acceso al directorio de destino. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Elimina un directorio especificado y opcionalmente cualquier subdirectorio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Directory.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nombre del directorio vacío que se va a quitar. El directorio debe permitir la escritura y estar vacío.</param>
        <summary>Elimina un directorio vacío de una ruta de acceso especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se comporta igual que <xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29> con `false` especificado para el segundo parámetro.  
  
 El `path` parámetro puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se quitan los espacios finales del final de la `path` parámetro antes de eliminar el directorio.  
  
 Este método produce una <xref:System.IO.IOException> si el directorio especificado en el `path` parámetro contiene archivos o subdirectorios.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 En algunos casos, si tiene abierto en el Explorador de archivos, el directorio especificado el <xref:System.IO.Directory.Delete%2A> método no pueda eliminarlo.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo crear un nuevo directorio y subdirectorio y, a continuación, elimine sólo el subdirectorio.  
  
 [!code-csharp[System.IO.Directory.Delete#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class1.cs#1)]
 [!code-vb[System.IO.Directory.Delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ya existe un archivo con el mismo nombre y ubicación especificados por <paramref name="path" />.  
  
O bien 
El directorio es el directorio de trabajo actual de la aplicación.  
  
O bien 
El directorio especificado por <paramref name="path" /> no está vacío.  
  
O bien 
El directorio es de solo lectura o contiene un archivo de solo lectura.  
  
O bien 
Otro proceso está usando el directorio.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> no existe o no se pudo encontrar.  
  
O bien 
La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path, bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path, bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String, recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path, bool recursive);" />
      <MemberSignature Language="F#" Value="static member Delete : string * bool -&gt; unit" Usage="System.IO.Directory.Delete (path, recursive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Nombre del directorio que se va a quitar.</param>
        <param name="recursive"><see langword="true" /> para quitar directorios, subdirectorios y archivos de <paramref name="path" />; de lo contrario, <see langword="false" />.</param>
        <summary>Elimina el directorio especificado y, si está indicado, los subdirectorios y archivos que contiene.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` parámetro puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se quitan los espacios finales del final de la `path` parámetro antes de eliminar el directorio.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Si el `recursive` parámetro es `true`, el usuario debe tener permiso de escritura para el directorio actual, así como para todos los subdirectorios.  
  
 El comportamiento de este método difiere ligeramente cuando se elimina un directorio que contiene un punto de reanálisis, como un vínculo simbólico o un punto de montaje. Si el punto de reanálisis es un directorio, por ejemplo, un punto de montaje, se desmonta y se elimina el punto de montaje. Este método no es recursivo a través del punto de reanálisis. Si el punto de reanálisis es un vínculo simbólico a un archivo, se elimina el punto de reanálisis y no el destino del vínculo simbólico.  
  
 En algunos casos, si tiene abierto en el Explorador de archivos, el directorio especificado el <xref:System.IO.Directory.Delete%2A> método no pueda eliminarlo.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo crear un nuevo directorio, el subdirectorio y el archivo en el subdirectorio y, a continuación, eliminar todos los nuevos elementos de forma recursiva.  
  
 [!code-csharp[System.IO.Directory.Delete#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class2.cs#2)]
 [!code-vb[System.IO.Directory.Delete#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ya existe un archivo con el mismo nombre y ubicación especificados por <paramref name="path" />.  
  
O bien 
El directorio especificado por <paramref name="path" /> es de solo lectura o <paramref name="recursive" /> es <see langword="false" /> y <paramref name="path" /> no es un directorio vacío.  
  
O bien 
El directorio es el directorio de trabajo actual de la aplicación.  
  
O bien 
El directorio contiene un archivo de solo lectura.  
  
O bien 
Otro proceso está usando el directorio.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> no existe o no se pudo encontrar.  
  
O bien 
La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una colección enumerable de nombres de directorio que satisfacen los criterios especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <summary>Devuelve una colección enumerable de nombres de directorio en una ruta de acceso especificada.</summary>
        <returns>Una colección enumerable de nombres completos (con sus rutas de acceso) para los directorios en el directorio especificado por <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede especificar información de ruta de acceso relativa o absoluta en el `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que se puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método. Los nombres de directorio devueltos prefijo con el valor proporcionado en el `path` parámetro. Por ejemplo, si proporciona una ruta de acceso relativa en el `path` parámetro, los nombres de directorio devuelta contendrá una ruta de acceso relativa.  
  
 El <xref:System.IO.Directory.EnumerateDirectories%2A> y <xref:System.IO.Directory.GetDirectories%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateDirectories%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetDirectories%2A>, debe esperar a que la matriz entera de nombres se devuelva antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateDirectories%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
   
  
## Examples  
 El ejemplo siguiente enumeran los directorios de nivel superior en una ruta de acceso especificada.  
  
 [!code-csharp[System.IO.EnumDirs1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs1/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs1/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios de <paramref name="path" />.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Devuelve una colección enumerable de nombres de directorio que coinciden con un patrón de búsqueda en una ruta de acceso especificada.</summary>
        <returns>Una colección enumerable de nombres completos (con sus rutas de acceso) para los directorios en el directorio especificado por <paramref name="path" /> y que coinciden con el patrón de búsqueda especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no se puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener caracteres no válidos. Puede consultar los caracteres no válidos con el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Puede especificar información de ruta de acceso relativa o absoluta en el `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que se puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método. Los nombres de directorio devueltos prefijo con el valor proporcionado en el `path` parámetro. Por ejemplo, si proporciona una ruta de acceso relativa en el `path` parámetro, los nombres de directorio devuelta contendrá una ruta de acceso relativa.  
  
 El <xref:System.IO.Directory.EnumerateDirectories%2A> y <xref:System.IO.Directory.GetDirectories%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateDirectories%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetDirectories%2A>, debe esperar a que la matriz entera de nombres se devuelva antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateDirectories%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
   
  
## Examples  
 En el ejemplo siguiente se enumera los directorios de nivel superior en una ruta de acceso especificado que coinciden con un patrón de búsqueda especificado.  
  
 [!code-csharp[System.IO.EnumDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs2/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs2/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
O bien 
 <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.  
  
O bien 
 <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios de <paramref name="path" />.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir solo el directorio actual o debe incluir todos los subdirectorios.  
  
El valor predeterminado es <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Devuelve una colección enumerable de nombres de directorio que coinciden con un patrón de búsqueda en una ruta de acceso especificada y, opcionalmente, busca en subdirectorios.</summary>
        <returns>Una colección enumerable de nombres completos (con sus rutas de acceso) para los directorios en el directorio especificado por <paramref name="path" /> y que coinciden con el patrón de búsqueda y opción especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Exactamente un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no se puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener caracteres no válidos. Puede consultar los caracteres no válidos con el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Puede especificar información de ruta de acceso relativa o absoluta en el `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que se puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método. Los nombres de directorio devueltos prefijo con el valor proporcionado en el `path` parámetro. Por ejemplo, si proporciona una ruta de acceso relativa en el `path` parámetro, los nombres de directorio devuelta contendrá una ruta de acceso relativa.  
  
 El <xref:System.IO.Directory.EnumerateDirectories%2A> y <xref:System.IO.Directory.GetDirectories%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateDirectories%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetDirectories%2A>, debe esperar a que la matriz entera de nombres se devuelva antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateDirectories%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
   
  
## Examples  
 El ejemplo siguiente enumera los directorios en una ruta de acceso especificado que coinciden con un patrón de búsqueda especificado. Usa el `searchOption` parámetro para especificar que se deben incluir todos los subdirectorios en la búsqueda.  
  
 [!code-csharp[System.IO.EnumDirs3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs3/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs3/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos usando el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
O bien 
 <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.  
  
O bien 
 <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> no es un valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una colección enumerable de nombres de archivo que satisfacen los criterios especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <summary>Devuelve una colección enumerable de nombres de archivo en una ruta de acceso especificada.</summary>
        <returns>Una colección enumerable de nombres completos (con sus rutas de acceso) para los archivos en el directorio especificado por <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede especificar información de ruta de acceso relativa con la `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que se puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 El <xref:System.IO.Directory.EnumerateFiles%2A> y <xref:System.IO.Directory.GetFiles%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateFiles%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetFiles%2A>, debe esperar a que la matriz entera de nombres se devuelva antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo recuperar todos los archivos en un directorio y moverlos a un nuevo directorio. Después de mover los archivos, ya no existen en el directorio original.  
  
 [!code-csharp[System.IO.Directory#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class4.cs#12)]
 [!code-vb[System.IO.Directory#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class4.vb#12)]  
  
 En el ejemplo siguiente se enumeran los archivos del directorio especificado, se lee cada línea del archivo y muestra la línea si contiene la cadena "Europa".  
  
 [!code-csharp[System.IO.Directory.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los archivos de <paramref name="path" />.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Devuelve una colección enumerable de nombres de archivo que coinciden con un patrón de búsqueda en una ruta de acceso especificada.</summary>
        <returns>Una colección enumerable de nombres completos (con sus rutas de acceso) para los archivos en el directorio especificado por <paramref name="path" /> y que coinciden con el patrón de búsqueda especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como sigue:  
>   
> -   Si la extensión especificada tiene exactamente tres caracteres, el método devuelve los archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
 `searchPattern` no se puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener caracteres no válidos. Puede consultar los caracteres no válidos con el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Puede especificar información de ruta de acceso relativa con la `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que se puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 El <xref:System.IO.Directory.EnumerateFiles%2A> y <xref:System.IO.Directory.GetFiles%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateFiles%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetFiles%2A>, debe esperar a que la matriz entera de nombres se devuelva antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo recuperar todos los archivos de texto en un directorio y moverlos a un nuevo directorio. Después de mover los archivos, ya no existen en el directorio original.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 En el ejemplo siguiente se enumeran los archivos del directorio especificado que tienen una extensión .txt, lee cada línea del archivo y muestra la línea si contiene la cadena "Europa".  
  
 [!code-csharp[System.IO.Directory.EnumFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles2/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles2/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
O bien 
 <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.  
  
O bien 
 <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los archivos de <paramref name="path" />.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir solo el directorio actual o debe incluir todos los subdirectorios.  
  
El valor predeterminado es <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Devuelve una colección enumerable de nombres de archivo que coinciden con un patrón de búsqueda en una ruta de acceso especificada y, opcionalmente, busca en subdirectorios.</summary>
        <returns>Una colección enumerable de nombres completos (con sus rutas de acceso) para los archivos en el directorio especificado por <paramref name="path" /> y que coinciden con el patrón de búsqueda y opción especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como sigue:  
>   
> -   Si la extensión especificada tiene exactamente tres caracteres, el método devuelve los archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
 `searchPattern` no se puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener caracteres no válidos. Puede consultar los caracteres no válidos con el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Puede especificar información de ruta de acceso relativa con la `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que se puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 El <xref:System.IO.Directory.EnumerateFiles%2A> y <xref:System.IO.Directory.GetFiles%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateFiles%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetFiles%2A>, debe esperar a que la matriz entera de nombres se devuelva antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo recuperar todos los archivos de texto en un directorio y sus subdirectorios y moverlos a un nuevo directorio. Después de mover los archivos, ya no existen en el directorio original.  
  
 [!code-csharp[System.IO.Directory#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class5.cs#13)]
 [!code-vb[System.IO.Directory#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class5.vb#13)]  
  
 Forma recursiva en el ejemplo siguiente enumera todos los archivos que tienen una extensión .txt, lee cada línea del archivo y muestra la línea si contiene la cadena "Microsoft".  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
O bien 
 <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.  
  
O bien 
 <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> no es un valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una colección enumerable de entradas del sistema de archivos que satisfacen los criterios especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <summary>Devuelve una colección enumerable de nombres de archivo y nombres de directorio en una ruta de acceso especificada.</summary>
        <returns>Colección enumerable de entradas del sistema de archivos en el directorio especificado por <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede especificar información de ruta de acceso relativa con la `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que se puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 El <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> y <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, puede empezar a enumerar la colección de entradas antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetFileSystemEntries%2A>, debe esperar a que la matriz entera de entradas que se devolverán antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de las entradas del sistema de archivos de <paramref name="path" />.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Devuelve una colección enumerable de nombres de archivo y nombres de directorio que coinciden con un patrón de búsqueda en una ruta de acceso especificada.</summary>
        <returns>Colección enumerable de entradas del sistema de archivos en el directorio especificado por <paramref name="path" />, y que coinciden con el patrón de búsqueda especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`. 
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como sigue:  
>   
> -   Si la extensión especificada tiene exactamente tres caracteres, el método devuelve los archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
 `searchPattern` no se puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener caracteres no válidos. Puede consultar los caracteres no válidos con el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Puede especificar información de ruta de acceso relativa con la `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que se puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 El <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> y <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, puede empezar a enumerar la colección de entradas antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetFileSystemEntries%2A>, debe esperar a que la matriz entera de entradas que se devolverán antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
O bien 
 <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.  
  
O bien 
 <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con entradas del sistema de archivos de <paramref name="path" />.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir solo el directorio actual o debe incluir todos los subdirectorios.  
  
El valor predeterminado es <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Devuelve una colección enumerable de nombres de archivo y de directorio que coinciden con un patrón de búsqueda en una ruta de acceso especificada y, opcionalmente, busca en subdirectorios.</summary>
        <returns>Colección enumerable de entradas del sistema de archivos en el directorio especificado por <paramref name="path" />, y que coinciden con el patrón de búsqueda y opción especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como sigue:  
>   
> -   Si la extensión especificada tiene exactamente tres caracteres, el método devuelve los archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
 `searchPattern` no se puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener caracteres no válidos. Puede consultar los caracteres no válidos con el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Puede especificar información de ruta de acceso relativa con la `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que se puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 El <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> y <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, puede empezar a enumerar la colección de entradas antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetFileSystemEntries%2A>, debe esperar a que la matriz entera de entradas que se devolverán antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 La colección devuelta no se almacena en caché; cada llamada a la <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> en la colección se iniciará una nueva enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
O bien 
 <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.  
  
O bien 
 <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> no es un valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.IO.Directory.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso que se va a probar.</param>
        <summary>Determina si la ruta de acceso dada hace referencia a un directorio existente en el disco.</summary>
        <returns><see langword="true" /> si <paramref name="path" /> hace referencia a un directorio existente; <see langword="false" /> si el directorio no existe o se produce un error al intentar determinar si existe el directorio especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` parámetro se puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual.  
  
 Se quitan los espacios finales del final de la `path` parámetro antes de comprobar si existe el directorio.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Si no dispone de un permiso de solo lectura mínimo en el directorio, el <xref:System.IO.Directory.Exists%2A> método devolverá `false`.  
  
 El <xref:System.IO.Directory.Exists%2A> devuelve del método `false` si se produce un error al intentar determinar si existe el archivo especificado. Esto puede ocurrir en situaciones en las que generan excepciones, como pasar un nombre de archivo con caracteres no válidos o hay demasiados caracteres, un disco con errores o que faltan, o si el llamador no tiene permiso para leer el archivo.  
  
   
  
## Examples  
 El siguiente ejemplo se toma una matriz de nombres de archivo o directorio en la línea de comandos, determina qué tipo de nombre y lo procesa de forma adecuada.  
  
 [!code-cpp[Recursive file finder#2](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#2)]
 [!code-csharp[Recursive file finder#2](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#2)]
 [!code-vb[Recursive file finder#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer los archivos. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve la lista de control de acceso (ACL) de Windows para un directorio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso a un directorio que contiene un objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que describe la información de la lista de control de acceso (ACL) del archivo.</param>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que encapsula las entradas de la lista de control de acceso (ACL) para un directorio especificado.</summary>
        <returns>Objeto que encapsula las reglas de control de acceso correspondientes al archivo descrito por el parámetro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.IO.Directory.GetAccessControl%2A> método para recuperar las entradas de lista (ACL) del control de acceso para un directorio.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo o directorio determinado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 En entornos de NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> se conceden al usuario si el usuario tiene <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> derechos en la carpeta primaria. Para denegar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, denegar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> en el directorio primario.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.Directory.GetAccessControl%2A> y <xref:System.IO.Directory.SetAccessControl%2A> métodos para agregar un acceso de control de entrada de la lista (ACL) y, a continuación, quitar una entrada ACL de un directorio.  Para ejecutar este ejemplo, debe proporcionar una cuenta de usuario o grupo válida.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S al abrir el directorio.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows 2000 o posterior.</exception>
        <exception cref="T:System.SystemException">Se produjo un error en el nivel del sistema, como que no se encontró el directorio. La excepción específica puede ser una subclase de <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El parámetro <paramref name="path" /> especificó un directorio que es de solo lectura.  
  
O bien 
Esta operación no es compatible con la plataforma actual.  
  
O bien 
El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso enumerar la lista de control de acceso (ACL) para un directorio. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Acción de seguridad: A petición.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl (path, includeSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso a un directorio que contiene un objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que describe la información de la lista de control de acceso (ACL) del archivo.</param>
        <param name="includeSections">Uno de los valores <see cref="T:System.Security.AccessControl.AccessControlSections" /> que especifica el tipo de información de la lista de control de acceso (ACL) que se recibe.</param>
        <summary>Obtiene un objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que encapsula el tipo especificado de las entradas de la lista de control de acceso (ACL) para un directorio especificado.</summary>
        <returns>Objeto que encapsula las reglas de control de acceso correspondientes al archivo descrito por el parámetro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.IO.Directory.GetAccessControl%2A> método para recuperar las entradas de lista (ACL) del control de acceso para un directorio.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo o directorio determinado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 En entornos de NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> se conceden al usuario si el usuario tiene <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> derechos en la carpeta primaria. Para denegar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, denegar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> en el directorio primario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error de E/S al abrir el directorio.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows 2000 o posterior.</exception>
        <exception cref="T:System.SystemException">Se produjo un error en el nivel del sistema, como que no se encontró el directorio. La excepción específica puede ser una subclase de <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El parámetro <paramref name="path" /> especificó un directorio que es de solo lectura.  
  
O bien 
Esta operación no es compatible con la plataforma actual.  
  
O bien 
El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso enumerar la lista de control de acceso (ACL) para un directorio. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Acción de seguridad: A petición.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTime : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso del directorio.</param>
        <summary>Obtiene la fecha y hora de creación de un directorio.</summary>
        <returns>Estructura que se establece en la fecha y hora de creación para el directorio especificado. Este valor se expresa en hora local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no pueden actualizarse continuamente por el sistema operativo.  
  
 Este método es equivalente a <xref:System.IO.File.GetCreationTime%2A?displayProperty=nameWithType>.  
  
 Si el directorio que se describe en el `path` parámetro no existe, este método devuelve 12:00 de la noche del 1 de enero de 1601 D.C. (C.E.) Hora Universal coordinada (UTC), se ajusta a la hora local.  
  
 El `path` parámetro se puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente obtiene la hora de creación del directorio especificado.  
  
 [!code-cpp[Dir_GetCreation#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCreation/CPP/dir_getcreation.cpp#1)]
 [!code-csharp[Dir_GetCreation#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCreation/CS/dir_getcreation.cs#1)]
 [!code-vb[Dir_GetCreation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCreation/VB/dir_getcreation.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso del directorio.</param>
        <summary>Obtiene la fecha y hora de creación, en formato de Hora universal coordinada (UTC), de un directorio.</summary>
        <returns>Estructura que se establece en la fecha y hora de creación para el directorio especificado. Este valor se expresa en hora UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no pueden actualizarse continuamente por el sistema operativo.  
  
 Si el directorio que se describe en el `path` parámetro no existe, este método devuelve 12:00 de la noche del 1 de enero de 1601 D.C. (C.E.) Hora de Universal coordinada (UTC).  
  
 Utilice este método para obtener la hora de creación de un directorio basado en hora Universal coordinada (UTC).  
  
   
  
## Examples  
 El ejemplo siguiente muestra las diferencias en la salida cuando se usa la salida de la hora Universal coordinada (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static string GetCurrentDirectory ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCurrentDirectory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentDirectory () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCurrentDirectory();" />
      <MemberSignature Language="F#" Value="static member GetCurrentDirectory : unit -&gt; string" Usage="System.IO.Directory.GetCurrentDirectory " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el directorio de trabajo actual de la aplicación.</summary>
        <returns>Cadena que contiene la ruta de acceso absoluta del directorio de trabajo actual y no finaliza con una barra diagonal inversa (\\).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El directorio actual es distinto del directorio original, que es la de la que se inició el proceso.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el siguiente ejemplo se muestra cómo se utiliza el método `GetCurrentDirectory`.  
  
 [!code-cpp[Dir_GetCurDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCurDir/CPP/dir_getcurdir.cpp#1)]
 [!code-csharp[Dir_GetCurDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCurDir/CS/dir_getcurdir.cs#1)]
 [!code-vb[Dir_GetCurDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCurDir/VB/dir_getcurdir.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.NotSupportedException">El sistema operativo es Windows CE, que no tiene la funcionalidad de directorio actual.  
  
Este método está disponible en .NET Compact Framework, pero no se admite actualmente.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve los nombres de los subdirectorios que cumplen los criterios especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; string[]" Usage="System.IO.Directory.GetDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <summary>Devuelve los nombres de los subdirectorios (con sus rutas de acceso) del directorio especificado.</summary>
        <returns>Una matriz de los nombres completos (con sus rutas de acceso) de los subdirectorios de la ruta de acceso especificada, o una matriz vacía si no se encuentran directorios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es idéntico a <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29> con el asterisco (\*) especificado como el patrón de búsqueda, por lo que devuelve todos los subdirectorios. Si tiene que buscar en los subdirectorios, utilice la <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> método, que le permite especificar una búsqueda en subdirectorios con el `searchOption` parámetro.  
  
 El <xref:System.IO.Directory.EnumerateDirectories%2A> y <xref:System.IO.Directory.GetDirectories%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateDirectories%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetDirectories%2A>, debe esperar a que la matriz entera de nombres se devuelva antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateDirectories%2A> puede ser más eficaz.  
  
 El `path` parámetro puede especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Los nombres devueltos por este método tienen el prefijo con la información del directorio proporcionada en `path`.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El siguiente ejemplo se toma una matriz de nombres de archivo o directorio en la línea de comandos, determina qué tipo de nombre y lo procesa de forma adecuada.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los subdirectorios de <paramref name="path" />. Este parámetro puede contener una combinación de literales válidos y caracteres comodín, pero no admite expresiones regulares.</param>
        <summary>Devuelve los nombres de los subdirectorios (con sus rutas de acceso) que coinciden con el patrón de búsqueda especificado en el directorio especificado.</summary>
        <returns>Una matriz de los nombres completos (con sus rutas de acceso) de los subdirectorios que coinciden con el patrón de búsqueda en el directorio especificado, o una matriz vacía si no se encuentran directorios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve todos los subdirectorios directamente en el directorio especificado que coinciden con el patrón de búsqueda especificado. Si el directorio especificado no tiene ningún subdirectorio o coincide con ningún subdirectorio en el `searchPattern` parámetro, este método devuelve una matriz vacía. Se busca sólo el directorio superior. Si desea buscar también los subdirectorios, utilice la <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> método y especifique <xref:System.IO.SearchOption.AllDirectories> en el `searchOption` parámetro.  
  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no se puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener caracteres no válidos. Puede consultar los caracteres no válidos con el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 El `path` parámetro puede especificar la información de ruta de acceso relativa o absoluta y no distingue mayúsculas de minúsculas.  Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El <xref:System.IO.Directory.EnumerateDirectories%2A> y <xref:System.IO.Directory.GetDirectories%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateDirectories%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetDirectories%2A>, debe esperar a que la matriz entera de nombres se devuelva antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateDirectories%2A> puede ser más eficaz.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente cuenta el número de directorios en una ruta de acceso que comienzan por la letra especificada.  
  
 [!code-cpp[Dir_GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetDirs2/CPP/dir_getdirs2.cpp#1)]
 [!code-csharp[Dir_GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs2.cs#1)]
 [!code-vb[Dir_GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos usando <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
O bien 
 <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> o <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los subdirectorios de <paramref name="path" />. Este parámetro puede contener una combinación de literales válidos y caracteres comodín, pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir todos los subdirectorios o solo el directorio actual.</param>
        <summary>Devuelve los nombres de los subdirectorios (incluidas las rutas de acceso) que coinciden con el patrón de búsqueda especificado en el directorio especificado y, opcionalmente, busca en subdirectorios.</summary>
        <returns>Una matriz de los nombres completos (con sus rutas de acceso) de los subdirectorios que coinciden con los criterios especificados, o una matriz vacía si no se encuentran directorios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` parámetro puede especificar la información de ruta de acceso relativa o absoluta y no distingue mayúsculas de minúsculas. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no se puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener caracteres no válidos. Puede consultar los caracteres no válidos con el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 El <xref:System.IO.Directory.EnumerateDirectories%2A> y <xref:System.IO.Directory.GetDirectories%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateDirectories%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetDirectories%2A>, debe esperar a que la matriz entera de nombres se devuelva antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateDirectories%2A> puede ser más eficaz.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente cuenta el número de directorios que empiezan por la letra en una ruta de acceso especificada. Se busca sólo el directorio de nivel superior.  
  
 [!code-csharp[Dir_GetDirs2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs3.cs#2)]
 [!code-vb[Dir_GetDirs2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
O bien 
 <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> o <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> no es un valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryRoot">
      <MemberSignature Language="C#" Value="public static string GetDirectoryRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectoryRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryRoot : string -&gt; string" Usage="System.IO.Directory.GetDirectoryRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso de un archivo o directorio.</param>
        <summary>Devuelve la información del volumen, la información de raíz o ambas para la ruta de acceso especificada.</summary>
        <returns>Cadena que contiene la información del volumen, la información de raíz o ambas para la ruta de acceso especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método obtiene el nombre de ruta de acceso completa de `path`, tal como lo devuelve <xref:System.IO.Path.GetFullPath%2A>, y devuelve información del directorio raíz. La ruta de acceso especificada no debe existir.  
  
 El `path` parámetro se puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el directorio actual y mostrar el directorio raíz.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve los nombres de los archivos que cumplen los criterios especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; string[]" Usage="System.IO.Directory.GetFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <summary>Devuelve los nombres de archivo (con sus rutas de acceso) del directorio especificado.</summary>
        <returns>Una matriz de los nombres completos (con sus rutas de acceso) para los archivos en el directorio especificado, o una matriz vacía si no se encuentran archivos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Directory.EnumerateFiles%2A> y <xref:System.IO.Directory.GetFiles%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateFiles%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetFiles%2A>, debe esperar a que la matriz entera de nombres se devuelva antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 Los nombres de archivo devueltos se anexan a proporcionado `path` parámetro.  
  
 Este método es idéntico a <xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29> con el asterisco (\*) especificado como el patrón de búsqueda.  
  
 El `path` parámetro puede especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 No se garantiza el orden de los nombres de archivo devueltos; Utilice el <xref:System.Array.Sort%2A> método si se requiere un orden específico.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.IO.Directory.GetFiles%2A> método para devolver los nombres de archivo desde una ubicación especificada por el usuario. El ejemplo está configurado para capturar todos los errores comunes a este método.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.  
  
O bien 
Se ha producido un error de red.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no se encuentra o no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los archivos de <paramref name="path" />.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Devuelve los nombres de los archivos (con sus rutas de acceso) que coinciden con el patrón de búsqueda especificado en el directorio especificado.</summary>
        <returns>Una matriz de nombres completos (con sus rutas de acceso) para los archivos del directorio especificado que coinciden con el patrón de búsqueda especificado, o una matriz vacía si no se encuentra ningún archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se anexan los nombres de archivo devueltos a proporcionado `path` ; no se garantiza el orden de los nombres de archivo devuelto y de parámetro, utilice el <xref:System.Array.Sort%2A> método si se requiere un orden específico.  
  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no se puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener caracteres no válidos. Puede consultar los caracteres no válidos con el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como sigue:  
>   
> -   Si la extensión especificada tiene exactamente tres caracteres, el método devuelve los archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
> [!NOTE]
>  Dado que este método comprueba los nombres de archivo con el formato de nombre de 8.3 archivo y el formato de nombre de archivo largos, un modelo de búsqueda similar a "\*1\*.txt" puede devolver los nombres de archivo inesperado. Por ejemplo, mediante un patrón de búsqueda de "\*1\*.txt" devuelve "nombrelargoarchivo.txt", porque el formato de nombre de 8.3 archivo equivalente es "LONGFI~1.TXT".  
  
 El <xref:System.IO.Directory.EnumerateFiles%2A> y <xref:System.IO.Directory.GetFiles%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateFiles%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetFiles%2A>, debe esperar a que la matriz entera de nombres se devuelva antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 El `path` parámetro puede especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente cuenta el número de archivos que comienzan por la letra especificada.  
  
 [!code-cpp[Dir_GetFiles2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetFiles2/CPP/dir_getfiles2.cpp#1)]
 [!code-csharp[Dir_GetFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetFiles2/CS/dir_getfiles2.cs#1)]
 [!code-vb[Dir_GetFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetFiles2/VB/dir_getfiles2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.  
  
O bien 
Se ha producido un error de red.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos usando <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
O bien 
 <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> o <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no se encuentra o no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los archivos de <paramref name="path" />.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir todos los subdirectorios o solo el directorio actual.</param>
        <summary>Devuelve los nombres de los archivos (con sus rutas de acceso) que coincidan con el patrón de búsqueda especificado en el directorio especificado, utilizando un valor para determinar si se debe buscar en los subdirectorios.</summary>
        <returns>Una matriz de nombres completos (con sus rutas de acceso) para los archivos del directorio especificado que coinciden con el patrón de búsqueda y opción especificados, o una matriz vacía si no se encuentra ningún archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los nombres de archivo devueltos se anexan con el parámetro proporcionado `path` y no se garantiza el orden de los nombres de archivo devueltos; utilice el <xref:System.Array.Sort%2A> método si se requiere un orden específico.  
  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no se puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener caracteres no válidos. Puede consultar los caracteres no válidos con el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como sigue:  
>   
> -   Si la extensión especificada tiene exactamente tres caracteres, el método devuelve los archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un modelo de búsqueda "file*.txt" devuelve ambos archivos.  
  
> [!NOTE]
>  Dado que este método comprueba los nombres de archivo con el formato de nombre de 8.3 archivo y el formato de nombre de archivo largos, un modelo de búsqueda similar a "\*1\*.txt" puede devolver los nombres de archivo inesperado. Por ejemplo, mediante un patrón de búsqueda de "\*1\*.txt" devuelve "nombrelargoarchivo.txt", porque el formato de nombre de 8.3 archivo equivalente es "LONGFI~1.TXT".  
  
 El <xref:System.IO.Directory.EnumerateFiles%2A> y <xref:System.IO.Directory.GetFiles%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateFiles%2A>, puede empezar a enumerar la colección de nombres antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetFiles%2A>, debe esperar a que la matriz entera de nombres se devuelva antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 Los nombres de archivo incluyen la ruta de acceso completa.  
  
 El `path` parámetro puede especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
O bien 
 <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> o <paramref name="searchpattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> no es un valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no se encuentra o no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.  
  
O bien 
Se ha producido un error de red.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve los nombres de todos los archivos y subdirectorios que satisfacen los criterios especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <summary>Devuelve los nombres de todos los archivos y subdirectorios de una ruta de acceso especificada.</summary>
        <returns>Una matriz de los nombres de los archivos y subdirectorios en el directorio especificado, o una matriz vacía si no se encuentran archivos o subdirectorios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se garantiza el orden de los nombres de directorio y archivo devuelto; Utilice el <xref:System.Array.Sort%2A> método si se requiere un orden específico.  
  
 El <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> y <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, puede empezar a enumerar la colección de entradas antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetFileSystemEntries%2A>, debe esperar a que la matriz entera de entradas que se devolverán antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 Este método es idéntico a <xref:System.IO.Directory.GetFileSystemEntries%2A> con el asterisco (\*) especificado como el patrón de búsqueda.  
  
 El `path` parámetro se puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.Directory.GetFileSystemEntries%2A> método para rellenar una matriz de cadenas con los nombres de todos los archivos y subdirectorios en una ubicación especificada por el usuario e imprime cada cadena de la matriz en la consola. El ejemplo está configurado para capturar todos los errores comunes a este método.  
  
 [!code-cpp[System.IO.Directory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#1)]
 [!code-csharp[System.IO.Directory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#1)]
 [!code-vb[System.IO.Directory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="T:System.IO.FileSystemInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios y archivos de <paramref name="path" />.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <summary>Devuelve una matriz o nombres de archivo y nombres de directorio que coinciden con un patrón de búsqueda en una ruta de acceso especificada.</summary>
        <returns>Una matriz de nombres de archivo y de directorio que coinciden con los criterios de búsqueda especificados, o una matriz vacía si no se encuentran archivos o directorios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se garantiza el orden de los nombres de directorio y archivo devuelto; Utilice el <xref:System.Array.Sort%2A> método si se requiere un orden específico.  
  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no se puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener caracteres no válidos. Puede consultar los caracteres no válidos con el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como sigue:  
>   
> -   Si la extensión especificada tiene exactamente tres caracteres, el método devuelve los archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
 El `path` parámetro se puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.Directory.GetFileSystemEntries%2A> método para rellenar una matriz de cadenas con los nombres de todos los archivos que coincidan con un filtro especificado por el usuario en una ubicación específica e imprime cada cadena de la matriz en la consola. El ejemplo está configurado para capturar todos los errores comunes a este método.  
  
 [!code-cpp[System.IO.Directory#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#2)]
 [!code-csharp[System.IO.Directory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#2)]
 [!code-vb[System.IO.Directory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
O bien 
 <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> o <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso para el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso absoluta o relativa al directorio que se va a buscar. Esta cadena no distingue entre mayúsculas y minúsculas.</param>
        <param name="searchPattern">Cadena de búsqueda que debe coincidir con los nombres de los directorios y archivos de <paramref name="path" />.  Este parámetro puede contener una combinación de ruta de acceso literal válida y caracteres comodín (* y ?), pero no admite expresiones regulares.</param>
        <param name="searchOption">Uno de los valores de enumeración que especifica si la operación de búsqueda debe incluir solo el directorio actual o debe incluir todos los subdirectorios.  
  
El valor predeterminado es <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Devuelve una matriz de todos los nombres de archivo y de directorio que coinciden con un patrón de búsqueda en una ruta de acceso especificada y, opcionalmente, busca en subdirectorios.</summary>
        <returns>Una matriz de nombres de archivo y nombres de directorio que coincide con los criterios de búsqueda especificados, o una matriz vacía si no se encuentran archivos o directorios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se garantiza el orden de los nombres de directorio y archivo devuelto; Utilice el <xref:System.Array.Sort%2A> método si se requiere un orden específico.  
  
 `searchPattern` puede ser una combinación de caracteres literales y caracteres comodín, pero no es compatible con expresiones regulares. Se permiten los siguientes especificadores comodín en `searchPattern`.  
  
|Especificador de carácter comodín|Coincidencias|  
|------------------------|-------------|  
|\* (asterisco)|Cero o más caracteres en esa posición.|  
|? (signo de interrogación)|Cero o un carácter en esa posición.|  
  
 Los caracteres que no sea el carácter comodín son caracteres literales. Por ejemplo, el `searchPattern` cadena "\*t" busca todos los nombres de `path` terminan con la letra "t". El `searchPattern` cadena "s\*" busca todos los nombres de `path` empiecen por la letra "s".  
  
 `searchPattern` no se puede terminar en dos puntos ("..") ni contener dos puntos ("..") seguido por <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>, ni puede contener caracteres no válidos. Puede consultar los caracteres no válidos con el método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Cuando se usa el carácter comodín de asterisco en un `searchPattern` como "\*.txt", el número de caracteres de la extensión especificada afecta a la búsqueda como sigue:  
>   
> -   Si la extensión especificada tiene exactamente tres caracteres, el método devuelve los archivos con extensiones que comienzan con la extensión especificada. Por ejemplo, "\*.xls" devuelve "book.xls" y "book.xlsx".  
> -   En todos los demás casos, el método devuelve archivos que coinciden exactamente con la extensión especificada. Por ejemplo, "\*. AI" devuelve "file.ai" pero no "file.aif".  
>   
>  Cuando se usa el carácter comodín de signo de interrogación, este método devuelve sólo los archivos que coinciden con la extensión de archivo especificado. Por ejemplo, dados dos archivos, "file1.txt" y "file1.txtother", en un directorio, un patrón de búsqueda de "archivo?. "txt" devuelve sólo el primer archivo, mientras que un patrón de búsqueda de "archivo\*.txt" devuelve ambos archivos.  
  
 El <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> y <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos difieren como sigue: Cuando usas <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, puede empezar a enumerar la colección de entradas antes de que se devuelve toda la colección; cuando se utiliza <xref:System.IO.Directory.GetFileSystemEntries%2A>, debe esperar a que la matriz entera de entradas que se devolverán antes de que puede tener acceso a la matriz. Por lo tanto, cuando se trabaja con muchos archivos y directorios, <xref:System.IO.Directory.EnumerateFiles%2A> puede ser más eficaz.  
  
 Puede especificar información de ruta de acceso relativa con la `path` parámetro. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual, que se puede determinar mediante el <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero y solo contiene espacios en blanco o caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
O bien 
 <paramref name="searchPattern" /> no contiene un patrón válido.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.  
  
O bien 
 <paramref name="searchPattern" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> no es un valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> no es válido, como hacer referencia a una unidad no asignada.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> es un nombre del archivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos combinados superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo o directorio para el que se va a obtener información de fecha y hora de acceso.</param>
        <summary>Devuelve la fecha y hora a la que se produjo el último acceso al archivo o directorio especificado.</summary>
        <returns>Estructura que se establece en la fecha y hora a la que se produjo el último acceso al archivo o directorio especificado. Este valor se expresa en hora local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no pueden actualizarse continuamente por el sistema operativo.  
  
 Este método es idéntico a <xref:System.IO.File.GetLastAccessTime%2A?displayProperty=nameWithType>.  
  
 Si el directorio que se describe en el `path` parámetro no existe, este método devuelve 12:00 de la noche del 1 de enero de 1601 D.C. (C.E.) Hora Universal coordinada (UTC), se ajusta a la hora local.  
  
 El `path` parámetro se puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar `GetLastAccessTime`.  
  
 [!code-cpp[Dir_GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastAccess/CPP/dir_getlastaccess.cpp#1)]
 [!code-csharp[Dir_GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastAccess/CS/dir_getlastaccess.cs#1)]
 [!code-vb[Dir_GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastAccess/VB/dir_getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">El parámetro <paramref name="path" /> tiene un formato que no es válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo o directorio para el que se va a obtener información de fecha y hora de acceso.</param>
        <summary>Devuelve la fecha y la hora, en formato de Hora universal coordinada (UTC), a la que se produjo el último acceso al archivo o directorio especificado.</summary>
        <returns>Estructura que se establece en la fecha y hora a la que se produjo el último acceso al archivo o directorio especificado. Este valor se expresa en hora UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no pueden actualizarse continuamente por el sistema operativo.  
  
 Si el directorio que se describe en el `path` parámetro no existe, este método devuelve 12:00 de la noche del 1 de enero de 1601 D.C. (C.E.) Hora de Universal coordinada (UTC).  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra las diferencias en la salida cuando se usa la salida de la hora Universal coordinada (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">El parámetro <paramref name="path" /> tiene un formato que no es válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo o directorio para el que se va a obtener información de fecha y hora de modificación.</param>
        <summary>Devuelve la fecha y hora a la que se escribió por última vez en el archivo o directorio especificado.</summary>
        <returns>Estructura que se establece en la fecha y hora a la que se escribió por última vez en el archivo o directorio especificado. Este valor se expresa en hora local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no pueden actualizarse continuamente por el sistema operativo.  
  
 Si el directorio que se describe en el `path` parámetro no existe, este método devuelve 12:00 de la noche del 1 de enero de 1601 D.C. (C.E.) Hora Universal coordinada (UTC), se ajusta a la hora local.  
  
 El `path` parámetro se puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar `GetLastWriteTime`.  
  
 [!code-cpp[Dir_GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastWrite/CPP/dir_getlastwrite.cpp#1)]
 [!code-csharp[Dir_GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastWrite/CS/dir_getlastwrite.cs#1)]
 [!code-vb[Dir_GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastWrite/VB/dir_getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Archivo o directorio para el que se va a obtener información de fecha y hora de modificación.</param>
        <summary>Devuelve la fecha y la hora, en formato de Hora universal coordinada (UTC), a la que se escribió por última vez en el archivo o directorio especificado.</summary>
        <returns>Estructura que se establece en la fecha y hora a la que se escribió por última vez en el archivo o directorio especificado. Este valor se expresa en hora UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método puede devolver un valor inexacto, porque utiliza las funciones nativas cuyos valores no pueden actualizarse continuamente por el sistema operativo.  
  
 Si el directorio que se describe en el `path` parámetro no existe, este método devuelve 12:00 de la noche del 1 de enero de 1601 D.C. (C.E.) Hora de Universal coordinada (UTC).  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra las diferencias en la salida cuando se usa la salida de la hora Universal coordinada (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.IO.Directory.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera los nombres de las unidades lógicas de este equipo con el formato "&lt;letra de unidad&gt;:\\".</summary>
        <returns>Unidades lógicas del equipo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetLogicalDrives devuelve todas las unidades accesibles en un equipo determinado, incluida la unidad de disquete y las unidades de disco ópticas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.Directory.GetLogicalDrives%2A> método para asignar el nombre de cada unidad en el equipo que realiza la llamada a una matriz de cadenas. Cada miembro de esta matriz de cadenas, a continuación, se imprime en la consola. El ejemplo está configurado para capturar todos los errores comunes a este método.  
  
 [!code-cpp[System.IO.Directory#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#3)]
 [!code-csharp[System.IO.Directory#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#3)]
 [!code-vb[System.IO.Directory#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S (por ejemplo, un error de disco).</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado, como llamar a código nativo con la interoperabilidad COM o PInvoke. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetParent (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetParent(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetParent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParent (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetParent(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParent : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.GetParent path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso para la cual se va a recuperar el directorio principal.</param>
        <summary>Recupera el directorio principal de la ruta especificada, incluidas tanto las rutas de acceso absolutas como las relativas.</summary>
        <returns>El directorio principal o <see langword="null" /> si <paramref name="path" /> es el directorio raíz, incluida la raíz de un servidor UNC o un nombre de uso compartido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` parámetro puede especificar la información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se quitan los espacios finales del final de la `path` parámetro antes de obtener el directorio.  
  
 La cadena devuelta por este método consta de todos los caracteres de la ruta de acceso hasta, pero no incluido, el último <xref:System.IO.Path.DirectorySeparatorChar> o <xref:System.IO.Path.AltDirectorySeparatorChar>. Por ejemplo, pasar la ruta de acceso "C:\Directory\SubDirectory\test.txt" a <xref:System.IO.Directory.GetParent%2A> devuelve "C:\Directory\SubDirectory". Pasar "C:\Directory\SubDirectory" devuelve "C:\Directory". Sin embargo, pasando "C:\Directory\SubDirectory\\" devuelve "C:\Directory\SubDirectory", porque es el separador de directorio final después de "Subdirectorio".  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.IO.Directory.GetParent%2A> método para recuperar el directorio principal de una ubicación especificada por el usuario, "path". El valor devuelto por la <xref:System.IO.Directory.GetParent%2A> método, a continuación, se imprime en la consola. El ejemplo está configurado para capturar todos los errores comunes a este método.  
  
 [!code-cpp[System.IO.Directory#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#4)]
 [!code-csharp[System.IO.Directory#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#4)]
 [!code-vb[System.IO.Directory#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El directorio especificado por <paramref name="path" /> es de solo lectura.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema. Para obtener más información, vea el tema <see cref="T:System.IO.PathTooLongException" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> está en un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">Solo .NET Framework: El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer de archivos o directorios. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceDirName, string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceDirName, string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceDirName As String, destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceDirName, System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="static member Move : string * string -&gt; unit" Usage="System.IO.Directory.Move (sourceDirName, destDirName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirName" Type="System.String" />
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirName">Ruta de acceso del archivo o del directorio que se va a mover.</param>
        <param name="destDirName">Ruta de acceso a la nueva ubicación para <paramref name="sourceDirName" />. Si <paramref name="sourceDirName" /> es un archivo, <paramref name="destDirName" /> debe ser también un nombre de archivo.</param>
        <summary>Mueve un archivo o directorio y su contenido a una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea un nuevo directorio con el nombre especificado por `destDirName` y mueve el contenido de `sourceDirName` al directorio de destino recién creado. Si intenta mover un directorio a un directorio que ya exista un <xref:System.IO.IOException> se producirá. Por ejemplo, se producirá una excepción si intenta mover c:\mydir a c:\public y c:\public ya existe. Como alternativa, puede especificar "c:\\\public\\\mydir" como el `destDirName` parámetro, proporcionado que no existe "mydir" en "c:\\\public", o especificar un nuevo nombre de directorio, como "c:\\\newdir".  
  
 El `sourceDirName` y `destDirName` argumentos se pueden especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se quitan los espacios finales del final de los parámetros de ruta de acceso antes de mover el directorio.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo mover un directorio y todos sus archivos a un nuevo directorio. El directorio original ya no existe una vez se ha movido.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se ha intentado mover un directorio a otro volumen.  
  
O bien 
 <paramref name="destDirName" /> ya existe.  
  
O bien 
Los parámetros <paramref name="sourceDirName" /> y <paramref name="destDirName" /> hacen referencia al mismo archivo o directorio.  
  
O bien 
El directorio o un archivo que se está siendo usando por otro proceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceDirName" /> o <paramref name="destDirName" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirName" /> o <paramref name="destDirName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso especificada por <paramref name="sourceDirName" /> no es válida (por ejemplo, está en una unidad no asignada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer desde <paramref name="sourceDirName" /> y escribir en <paramref name="sourceDirName" /> y <paramref name="destDirName" />. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member SetAccessControl : string * System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="System.IO.Directory.SetAccessControl (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Directorio al que se van a agregar o del que se van a quitar entradas de la lista de control de acceso (ACL).</param>
        <param name="directorySecurity">Objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que describe una entrada de ACL que se aplica al directorio descrito por el parámetro <paramref name="path" />.</param>
        <summary>Aplica al directorio especificado las entradas de la lista de control de acceso (ACL) descritas por un objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.Directory.SetAccessControl%2A> método aplica las entradas de lista (ACL) de control de acceso a un archivo que representa la lista ACL no heredada.  
  
> [!CAUTION]
>  Especifica la ACL para el `directorySecurity` parámetro reemplaza la ACL existente para el directorio. Para agregar permisos para un usuario nuevo, use el <xref:System.IO.Directory.GetAccessControl%2A> método para obtener la ACL existente y modificarlo.  
  
 Una ACL describe los individuos o grupos que tienen o no tienen derechos para realizar determinadas acciones en el archivo o directorio determinado. Para más información, consulte [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md) (Cómo: Agregar o quitar entradas de la lista de control de acceso).  
  
 El <xref:System.IO.Directory.SetAccessControl%2A> método conserva solo <xref:System.Security.AccessControl.DirectorySecurity> objetos que se han modificado después de la creación de objetos.  Si un <xref:System.Security.AccessControl.DirectorySecurity> objeto no se ha modificado, no se conservarán en un archivo.  Por lo tanto, no es posible recuperar un <xref:System.Security.AccessControl.DirectorySecurity> desde un archivo de objeto y vuelva a aplicar el mismo objeto a otro archivo.  
  
 Para copiar información de la ACL de un archivo a otro:  
  
1.  Use la <xref:System.IO.Directory.GetAccessControl%2A> método para recuperar el <xref:System.Security.AccessControl.DirectorySecurity> objeto desde el archivo de origen.  
  
2.  Cree un nuevo <xref:System.Security.AccessControl.DirectorySecurity> objeto para el archivo de destino.  
  
3.  Use la <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> o <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> método del origen de <xref:System.Security.AccessControl.DirectorySecurity> objeto para recuperar la información de la ACL.  
  
4.  Use la <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> o <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> método para copiar la información recuperada en el paso 3 en el destino <xref:System.Security.AccessControl.DirectorySecurity> objeto.  
  
5.  Establecer como destino <xref:System.Security.AccessControl.DirectorySecurity> objeto en el archivo de destino usando la <xref:System.IO.Directory.SetAccessControl%2A> método.  
  
 En entornos de NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> se conceden al usuario si el usuario tiene <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> derechos en la carpeta primaria. Para denegar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> y <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, denegar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> en el directorio primario.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.Directory.GetAccessControl%2A> y <xref:System.IO.Directory.SetAccessControl%2A> métodos para agregar un acceso de control de entrada de la lista (ACL) y, a continuación, quitar una entrada ACL de un directorio.  Para ejecutar este ejemplo, debe proporcionar una cuenta de usuario o grupo válida.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="directorySecurity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">No se ha encontrado el directorio.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> no fue válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El proceso actual no tiene acceso al directorio especificado por <paramref name="path" />.  
  
O bien 
El proceso actual no tiene privilegios suficientes para establecer la entrada ACL.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows 2000 o posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener permiso enumerar la lista de control de acceso (ACL) para un directorio. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Acción de seguridad: A petición.</permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberSignature Language="F#" Value="static member SetCreationTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTime (path, creationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">El archivo o directorio para el que se va a establecer información de fecha y hora de creación.</param>
        <param name="creationTime">Fecha y hora en que escribió en el archivo o directorio por última vez. Este valor se expresa en hora local.</param>
        <summary>Establece la fecha y hora de creación del archivo o la carpeta especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` parámetro se puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
   
  
## Examples  
 El ejemplo siguiente muestra las diferencias en la salida cuando se usa la salida de la hora Universal coordinada (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> especifica un valor fuera del intervalo de fechas u horas permitidas para esta operación.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetCreationTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTimeUtc (path, creationTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">El archivo o directorio para el que se va a establecer información de fecha y hora de creación.</param>
        <param name="creationTimeUtc">La fecha y hora en que se creó el directorio o archivo. Este valor se expresa en hora local.</param>
        <summary>Establece la fecha y hora de creación, en formato de Hora universal coordinada (UTC), del archivo o directorio especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` parámetro se puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> especifica un valor fuera del intervalo de fechas u horas permitidas para esta operación.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static void SetCurrentDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCurrentDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCurrentDirectory (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCurrentDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member SetCurrentDirectory : string -&gt; unit" Usage="System.IO.Directory.SetCurrentDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso en la que se establece el directorio de trabajo actual.</param>
        <summary>Establece el directorio de trabajo actual de la aplicación en el directorio especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando la aplicación termina, el directorio de trabajo se restaura a su ubicación original (es decir, el directorio donde se inició el proceso).  
  
 El `path` parámetro se puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se quitan los espacios finales del final de la `path` parámetro antes de establecer el directorio.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Si está configurando el directorio en una unidad con medios extraíbles (por ejemplo, "E:" para una unidad flash USB), puede determinar si la unidad está lista utilizando el <xref:System.IO.DriveInfo.IsReady%2A> propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el directorio actual y mostrar el directorio raíz.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido para obtener acceso al código no administrado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">No se encuentra el directorio especificado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en archivos o directorios. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTime (path, lastAccessTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">El archivo o directorio para el que se va a establecer información de fecha y hora de acceso.</param>
        <param name="lastAccessTime">Objeto que contiene el valor que se va a establecer para la fecha y hora de acceso de <paramref name="path" />. Este valor se expresa en hora local.</param>
        <summary>Establece la fecha y hora a la que se produjo el último acceso al archivo o directorio especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` parámetro se puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar `SetLastAccessTime`.  
  
 [!code-cpp[Dir_SetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastAccess/CPP/dir_setlastaccess.cpp#1)]
 [!code-csharp[Dir_SetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastAccess/CS/dir_setlastaccess.cs#1)]
 [!code-vb[Dir_SetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastAccess/VB/dir_setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTime" /> especifica un valor fuera del intervalo de fechas u horas permitidas para esta operación.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTimeUtc (path, lastAccessTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">El archivo o directorio para el que se va a establecer información de fecha y hora de acceso.</param>
        <param name="lastAccessTimeUtc">Objeto que contiene el valor que se va a establecer para la fecha y hora de acceso de <paramref name="path" />. Este valor se expresa en hora UTC.</param>
        <summary>Establece la fecha y la hora, en formato de Hora universal coordinada (UTC), a la que se produjo el último acceso al archivo o directorio especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` parámetro se puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra las diferencias en la salida cuando se usa la salida de la hora Universal coordinada (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró la ruta de acceso especificada.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTimeUtc" /> especifica un valor fuera del intervalo de fechas u horas permitidas para esta operación.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTime (path, lastWriteTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso del directorio.</param>
        <param name="lastWriteTime">Fecha y hora en que escribió en el directorio por última vez. Este valor se expresa en hora local.</param>
        <summary>Establece la fecha y la hora en que escribió en un directorio por última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` parámetro se puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar `SetLastWriteTime`.  
  
 [!code-cpp[Dir_SetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastWrite/CPP/dir_setlastwrite.cpp#1)]
 [!code-csharp[Dir_SetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastWrite/CS/dir_setlastwrite.cs#1)]
 [!code-vb[Dir_SetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastWrite/VB/dir_setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="path" /> (por ejemplo, el directorio no existe o está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">No se ha encontrado <paramref name="path" /> (por ejemplo, el directorio no existe o está en una unidad no asignada).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTime" /> especifica un valor fuera del intervalo de fechas u horas permitidas para esta operación.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTimeUtc (path, lastWriteTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso del directorio.</param>
        <param name="lastWriteTimeUtc">Fecha y hora en que escribió en el directorio por última vez. Este valor se expresa en hora UTC.</param>
        <summary>Establece la fecha y la hora, en formato de Hora universal coordinada (UTC), a la que se escribió en el directorio por última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `path` parámetro se puede especificar información de ruta de acceso relativa o absoluta. Información de ruta de acceso relativa se interpreta en relación con el directorio de trabajo actual. Para obtener el directorio de trabajo actual, vea <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 El `path` parámetro no distingue mayúsculas de minúsculas.  
  
 Para obtener una lista de tareas de E/S comunes, consulte [tareas de E/S comunes](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra las diferencias en la salida cuando se usa la salida de la hora Universal coordinada (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="path" /> (por ejemplo, el directorio no existe o está en una unidad no asignada).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">No se ha encontrado <paramref name="path" /> (por ejemplo, el directorio no existe o está en una unidad no asignada).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> es una cadena de longitud cero que solo contiene espacios en blanco o uno o varios caracteres no válidos. Puede consultar los caracteres no válidos con el método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Windows NT o posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTimeUtc" /> especifica un valor fuera del intervalo de fechas u horas permitidas para esta operación.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para escribir en el archivo o directorio especificado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">E/S de archivos y secuencias</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Cómo: Leer texto de un archivo</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Cómo: Escribir texto en un archivo</related>
      </Docs>
    </Member>
  </Members>
</Type>