<Type Name="MemoryStream" FullName="System.IO.MemoryStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="02ca3cbe99f600c2f813c7c537dac714efc08b5b" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MemoryStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit MemoryStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.MemoryStream" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryStream : System::IO::Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="7e9ba-101">Crea una secuencia cuya memoria auxiliar es la memoria.</span>
      <span class="sxs-lookup">
        <span data-stu-id="7e9ba-101">Creates a stream whose backing store is memory.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-102">La posición actual de una secuencia es la posición en la que la siguiente lectura o la operación de escritura llevara a cabo.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-102">The current position of a stream is the position at which the next read or write operation could take place.</span></span> <span data-ttu-id="7e9ba-103">La posición actual se puede recuperar o establecer a través de la <xref:System.IO.MemoryStream.Seek%2A> método.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-103">The current position can be retrieved or set through the <xref:System.IO.MemoryStream.Seek%2A> method.</span></span> <span data-ttu-id="7e9ba-104">Cuando una nueva instancia de <xref:System.IO.MemoryStream> se crea la actual posición está establecida en cero.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-104">When a new instance of <xref:System.IO.MemoryStream> is created, the current position is set to zero.</span></span>  
  
[!INCLUDE[note_unnecessary_dispose](~/includes/note-unnecessary-dispose.md)]
  
 <span data-ttu-id="7e9ba-105">Secuencias de memoria creadas con una matriz de bytes sin signo proporcionan un flujo invariable de los datos.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-105">Memory streams created with an unsigned byte array provide a non-resizable stream of the data.</span></span> <span data-ttu-id="7e9ba-106">Cuando se usa una matriz de bytes, se pueden anexar a ni reducir la secuencia, aunque es posible que pueda modificar el contenido existente en función de los parámetros pasados al constructor.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-106">When using a byte array, you can neither append to nor shrink the stream, although you might be able to modify the existing contents depending on the parameters passed into the constructor.</span></span> <span data-ttu-id="7e9ba-107">Secuencias de memoria vacías son de tamaño variable y pueden escritas y se leen desde.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-107">Empty memory streams are resizable, and can be written to and read from.</span></span>  
  
 <span data-ttu-id="7e9ba-108">Si un <xref:System.IO.MemoryStream> objeto se agrega a un archivo ResX o un archivo .resources, llame a la <xref:System.Resources.ResourceManager.GetStream%2A> método en tiempo de ejecución para recuperarlo.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-108">If a <xref:System.IO.MemoryStream> object is added to a ResX file or a .resources file, call the <xref:System.Resources.ResourceManager.GetStream%2A> method at runtime to retrieve it.</span></span>  
  
 <span data-ttu-id="7e9ba-109">Si un <xref:System.IO.MemoryStream> el objeto se serializa en un archivo de recursos que realmente se van a serializar como un <xref:System.IO.UnmanagedMemoryStream>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-109">If a <xref:System.IO.MemoryStream> object is serialized to a resource file it will actually be serialized as an <xref:System.IO.UnmanagedMemoryStream>.</span></span> <span data-ttu-id="7e9ba-110">Este comportamiento proporciona un mejor rendimiento, así como la capacidad para obtener un puntero a los datos directamente, sin tener que pasar por <xref:System.IO.Stream> métodos.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-110">This behavior provides better performance, as well as the ability to get a pointer to the data directly, without having to go through <xref:System.IO.Stream> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e9ba-111">En el ejemplo de código siguiente se muestra cómo leer y escribir datos utilizando la memoria como una memoria auxiliar.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-111">The following code example shows how to read and write data using memory as a backing store.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#1)]
 [!code-csharp[System.IO.MemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#1)]
 [!code-vb[System.IO.MemoryStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="7e9ba-112">Inicializa una nueva instancia de la clase <see cref="T:System.IO.MemoryStream" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-112">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7e9ba-113">Inicializa una nueva instancia de la clase <see cref="T:System.IO.MemoryStream" /> con una capacidad expansible inicializada con un valor cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-113">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class with an expandable capacity initialized to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-114">El <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, y <xref:System.IO.MemoryStream.CanWrite%2A> propiedades están establecidos en `true`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-114">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span>  
  
 <span data-ttu-id="7e9ba-115">La capacidad de la secuencia actual aumenta automáticamente cuando se usa el <xref:System.IO.MemoryStream.SetLength%2A> método para establecer la longitud en un valor mayor que la capacidad de la secuencia actual.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-115">The capacity of the current stream automatically increases when you use the <xref:System.IO.MemoryStream.SetLength%2A> method to set the length to a value larger than the capacity of the current stream.</span></span>  
  
 <span data-ttu-id="7e9ba-116">Este constructor expone subyacente transmitir por secuencias, que <xref:System.IO.MemoryStream.GetBuffer%2A> devuelve.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-116">This constructor exposes the underlying stream, which <xref:System.IO.MemoryStream.GetBuffer%2A> returns.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="7e9ba-117">Matriz de bytes sin signo a partir de la cual se crea la secuencia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-117">The array of unsigned bytes from which to create the current stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-118">Inicializa una nueva instancia invariable de la clase <see cref="T:System.IO.MemoryStream" /> de acuerdo con la matriz de bytes especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-118">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified byte array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-119">El <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, y <xref:System.IO.MemoryStream.CanWrite%2A> propiedades están establecidos en `true`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-119">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span> <span data-ttu-id="7e9ba-120"><xref:System.IO.MemoryStream.Capacity%2A> se establece en la longitud de la matriz de bytes especificada.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-120"><xref:System.IO.MemoryStream.Capacity%2A> is set to the length of the specified byte array.</span></span> <span data-ttu-id="7e9ba-121">La nueva secuencia puede escribirse en, pero no es de tamaño variable.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-121">The new stream can be written to, but is not resizable.</span></span>  
  
 <span data-ttu-id="7e9ba-122">No se puede establecer la longitud de la secuencia en un valor mayor que la longitud inicial de la matriz de bytes especificada; Sin embargo, se puede truncar la secuencia (vea <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="7e9ba-122">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="7e9ba-123">Este constructor no expone la secuencia subyacente.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-123">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="7e9ba-124"><xref:System.IO.MemoryStream.GetBuffer%2A> produce <xref:System.UnauthorizedAccessException>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-124"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7e9ba-125">
            <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-125">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <span data-ttu-id="7e9ba-126">Tamaño inicial de la matriz interna en bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-126">The initial size of the internal array in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-127">Inicializa una nueva instancia de la clase <see cref="T:System.IO.MemoryStream" /> con una capacidad expansible inicializada según lo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-127">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class with an expandable capacity initialized as specified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-128">El <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, y <xref:System.IO.MemoryStream.CanWrite%2A> propiedades están establecidos en `true`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-128">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span>  
  
 <span data-ttu-id="7e9ba-129">La capacidad aumenta automáticamente cuando se usa el <xref:System.IO.MemoryStream.SetLength%2A> método para establecer la longitud en un valor mayor que la capacidad de la secuencia actual.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-129">The capacity automatically increases when you use the <xref:System.IO.MemoryStream.SetLength%2A> method to set the length to a value larger than the capacity of the current stream.</span></span> <span data-ttu-id="7e9ba-130">Excepto para un `MemoryStream` construido con un parámetro byte [], escribir operaciones al final de un `MemoryStream` expandir la `MemoryStream`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-130">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
 <span data-ttu-id="7e9ba-131">Este constructor expone subyacente que transmitir <xref:System.IO.MemoryStream.GetBuffer%2A> devuelve.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-131">This constructor exposes the underlying stream that <xref:System.IO.MemoryStream.GetBuffer%2A> returns.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e9ba-132">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.MemoryStream> clase.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-132">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#2)]
 [!code-csharp[System.IO.MemoryStream#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#2)]
 [!code-vb[System.IO.MemoryStream#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7e9ba-133">
            <paramref name="capacity" /> es negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-133">
              <paramref name="capacity" /> is negative.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), writable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, bool writable);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="7e9ba-134">Matriz de bytes sin signo a partir de la cual se crea esta secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-134">The array of unsigned bytes from which to create this stream.</span>
          </span>
        </param>
        <param name="writable">
          <span data-ttu-id="7e9ba-135">Establecimiento de la propiedad <see cref="P:System.IO.MemoryStream.CanWrite" />, que determina si la secuencia admite escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-135">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-136">Inicializa una nueva instancia invariable de la clase <see cref="T:System.IO.MemoryStream" /> según la matriz de bytes especificada con la propiedad <see cref="P:System.IO.MemoryStream.CanWrite" /> establecida como se ha indicado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-136">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified byte array with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-137">El <xref:System.IO.MemoryStream.CanRead%2A> y <xref:System.IO.MemoryStream.CanSeek%2A> propiedades se establecen como `true`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-137">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="7e9ba-138"><xref:System.IO.MemoryStream.Capacity%2A> se establece en la longitud de la matriz de bytes especificada.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-138"><xref:System.IO.MemoryStream.Capacity%2A> is set to the length of the specified byte array.</span></span>  
  
 <span data-ttu-id="7e9ba-139">No se puede establecer la longitud de la secuencia en un valor mayor que la longitud inicial de la matriz de bytes especificada; Sin embargo, se puede truncar la secuencia (vea <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="7e9ba-139">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="7e9ba-140">Este constructor no expone la secuencia subyacente.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-140">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="7e9ba-141"><xref:System.IO.MemoryStream.GetBuffer%2A> produce <xref:System.UnauthorizedAccessException>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-141"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7e9ba-142">
            <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-142">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="7e9ba-143">Matriz de bytes sin signo a partir de la cual se crea esta secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-143">The array of unsigned bytes from which to create this stream.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="7e9ba-144">Índice dentro de <c>buffer</c> en el que empieza la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-144">The index into <c>buffer</c> at which the stream begins.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="7e9ba-145">Longitud de la secuencia en bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-145">The length of the stream in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-146">Inicializa una nueva instancia invariable de la clase <see cref="T:System.IO.MemoryStream" /> según la región especificada (índice) de una matriz de bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-146">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region (index) of a byte array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-147">El <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, y <xref:System.IO.MemoryStream.CanWrite%2A> propiedades están establecidos en `true`, pero no se puede cambiar la capacidad.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-147">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`, but the capacity cannot be changed.</span></span> <span data-ttu-id="7e9ba-148">El valor de <xref:System.IO.MemoryStream.Capacity%2A> está establecido en `count`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-148"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="7e9ba-149">No se puede establecer la longitud de la secuencia en un valor mayor que la longitud inicial de la matriz de bytes especificada; Sin embargo, se puede truncar la secuencia (vea <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="7e9ba-149">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="7e9ba-150">Este constructor no expone la secuencia subyacente.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-150">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="7e9ba-151"><xref:System.IO.MemoryStream.GetBuffer%2A> produce <xref:System.UnauthorizedAccessException>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-151"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span> <span data-ttu-id="7e9ba-152">Sin embargo, puede escribir en la secuencia.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-152">However, you can write to the stream.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7e9ba-153">
            <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-153">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7e9ba-154">
            <paramref name="index" /> o <paramref name="count" /> es menor que cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-154">
              <paramref name="index" /> or <paramref name="count" /> is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7e9ba-155">La longitud del búfer menos <paramref name="index" /> es menor que <paramref name="count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-155">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer, writable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count, bool writable);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="7e9ba-156">Matriz de bytes sin signo a partir de la cual se crea esta secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-156">The array of unsigned bytes from which to create this stream.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="7e9ba-157">Índice de <c>buffer</c> en el que empieza la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-157">The index in <c>buffer</c> at which the stream begins.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="7e9ba-158">Longitud de la secuencia en bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-158">The length of the stream in bytes.</span>
          </span>
        </param>
        <param name="writable">
          <span data-ttu-id="7e9ba-159">Establecimiento de la propiedad <see cref="P:System.IO.MemoryStream.CanWrite" />, que determina si la secuencia admite escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-159">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-160">Inicializa una nueva instancia invariable de la clase <see cref="T:System.IO.MemoryStream" /> según la región especificada de una matriz de bytes, con la propiedad <see cref="P:System.IO.MemoryStream.CanWrite" /> establecida como se ha indicado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-160">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region of a byte array, with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-161">El <xref:System.IO.MemoryStream.CanRead%2A> y <xref:System.IO.MemoryStream.CanSeek%2A> propiedades se establecen como `true`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-161">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="7e9ba-162">El valor de <xref:System.IO.MemoryStream.Capacity%2A> está establecido en `count`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-162"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="7e9ba-163">No se puede establecer la longitud de la secuencia en un valor mayor que la longitud inicial de la matriz de bytes especificada; Sin embargo, se puede truncar la secuencia (vea <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="7e9ba-163">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="7e9ba-164">Este constructor no expone la secuencia subyacente.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-164">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="7e9ba-165"><xref:System.IO.MemoryStream.GetBuffer%2A> produce <xref:System.UnauthorizedAccessException>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-165"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span> <span data-ttu-id="7e9ba-166">Sin embargo, puede escribir en la secuencia si `writable` es `true`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-166">However, you can write to the stream if `writable` is `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7e9ba-167">
            <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-167">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7e9ba-168">El valor de <paramref name="index" /> o <paramref name="count" /> es negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-168">
              <paramref name="index" /> or <paramref name="count" /> are negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7e9ba-169">La longitud del búfer menos <paramref name="index" /> es menor que <paramref name="count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-169">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable, bool publiclyVisible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer, writable As Boolean, publiclyVisible As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
        <Parameter Name="publiclyVisible" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="7e9ba-170">Matriz de bytes sin signo a partir de la cual se crea esta secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-170">The array of unsigned bytes from which to create this stream.</span>
          </span>
        </param>
        <param name="index">
          <span data-ttu-id="7e9ba-171">Índice dentro de <c>buffer</c> en el que empieza la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-171">The index into <c>buffer</c> at which the stream begins.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="7e9ba-172">Longitud de la secuencia en bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-172">The length of the stream in bytes.</span>
          </span>
        </param>
        <param name="writable">
          <span data-ttu-id="7e9ba-173">Establecimiento de la propiedad <see cref="P:System.IO.MemoryStream.CanWrite" />, que determina si la secuencia admite escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-173">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span>
          </span>
        </param>
        <param name="publiclyVisible">
          <span data-ttu-id="7e9ba-174">Es <see langword="true" /> para habilitar <see cref="M:System.IO.MemoryStream.GetBuffer" />, que devuelve la matriz de bytes sin signo desde la cual se creó la secuencia; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-174">
              <see langword="true" /> to enable <see cref="M:System.IO.MemoryStream.GetBuffer" />, which returns the unsigned byte array from which the stream was created; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-175">Inicializa una nueva instancia de la clase <see cref="T:System.IO.MemoryStream" /> según la región especificada de una matriz de bytes, con la propiedad <see cref="P:System.IO.MemoryStream.CanWrite" /> establecida como se ha indicado y la posibilidad de llamar a <see cref="M:System.IO.MemoryStream.GetBuffer" /> establecida según lo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-175">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region of a byte array, with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified, and the ability to call <see cref="M:System.IO.MemoryStream.GetBuffer" /> set as specified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-176">El <xref:System.IO.MemoryStream.CanRead%2A> y <xref:System.IO.MemoryStream.CanSeek%2A> propiedades se establecen como `true`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-176">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="7e9ba-177">El valor de <xref:System.IO.MemoryStream.Capacity%2A> está establecido en `count`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-177"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="7e9ba-178">Se puede escribir la nueva instancia de flujo, pero la <xref:System.IO.MemoryStream.Capacity%2A> del byte subyacente no se puede cambiar la matriz.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-178">The new stream instance can be written to, but the <xref:System.IO.MemoryStream.Capacity%2A> of the underlying byte array cannot be changed.</span></span> <span data-ttu-id="7e9ba-179">No se puede establecer la longitud de la secuencia en un valor mayor que la longitud inicial de la matriz de bytes especificada; Sin embargo, se puede truncar la secuencia (vea <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="7e9ba-179">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7e9ba-180">
            <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-180">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7e9ba-181">
            <paramref name="index" /> o <paramref name="count" /> es negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-181">
              <paramref name="index" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7e9ba-182">La longitud del búfer menos <paramref name="index" /> es menor que <paramref name="count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-182">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7e9ba-183">Obtiene un valor que indica si la secuencia actual admite lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-183">Gets a value indicating whether the current stream supports reading.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7e9ba-184">
            <see langword="true" /> si el flujo está abierto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-184">
              <see langword="true" /> if the stream is open.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-185">Si una clase derivada de <xref:System.IO.Stream> no admite la lectura, las llamadas a la <xref:System.IO.MemoryStream.Read%2A> y <xref:System.IO.MemoryStream.ReadByte%2A> métodos lanzan una <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-185">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.MemoryStream.Read%2A> and <xref:System.IO.MemoryStream.ReadByte%2A> methods throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="7e9ba-186">Si la secuencia está cerrada, esta propiedad devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-186">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7e9ba-187">Obtiene un valor que indica si la secuencia actual admite búsquedas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-187">Gets a value indicating whether the current stream supports seeking.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7e9ba-188">
            <see langword="true" /> si el flujo está abierto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-188">
              <see langword="true" /> if the stream is open.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-189">Si una clase derivada de <xref:System.IO.Stream> no admite búsquedas, las llamadas a <xref:System.IO.MemoryStream.Length%2A>, <xref:System.IO.MemoryStream.SetLength%2A>, <xref:System.IO.MemoryStream.Position%2A>, y <xref:System.IO.MemoryStream.Seek%2A> producir un <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-189">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.MemoryStream.Length%2A>, <xref:System.IO.MemoryStream.SetLength%2A>, <xref:System.IO.MemoryStream.Position%2A>, and <xref:System.IO.MemoryStream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="7e9ba-190">Si la secuencia está cerrada, esta propiedad devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-190">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7e9ba-191">Obtiene un valor que indica si la secuencia actual admite escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-191">Gets a value indicating whether the current stream supports writing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7e9ba-192">
            <see langword="true" /> si el flujo admite escritura; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-192">
              <see langword="true" /> if the stream supports writing; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-193">Si una clase derivada de <xref:System.IO.Stream> no admite la escritura, una llamada a <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Write%2A>, o <xref:System.IO.Stream.WriteByte%2A> produce una <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-193">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Write%2A>, or <xref:System.IO.Stream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="7e9ba-194">Si la secuencia está cerrada, esta propiedad devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-194">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7e9ba-195">Obtiene o establece el número de bytes asignados a esta secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-195">Gets or sets the number of bytes allocated for this stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7e9ba-196">Longitud de la parte utilizable del búfer para la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-196">The length of the usable portion of the buffer for the stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-197">`Capacity` es la longitud de búfer para matrices de bytes proporcionado por el sistema.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-197">`Capacity` is the buffer length for system-provided byte arrays.</span></span> <span data-ttu-id="7e9ba-198">`Capacity` no se puede establecer en un valor menor que la longitud actual de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-198">`Capacity` cannot be set to a value less than the current length of the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e9ba-199">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.MemoryStream> clase.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-199">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7e9ba-200">Se establece una capacidad de modo que sea negativa o menor que la longitud actual de la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-200">A capacity is set that is negative or less than the current length of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7e9ba-201">Se cierra la secuencia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-201">The current stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="7e9ba-202">Se invoca <see langword="set" /> en una secuencia cuya capacidad no se puede modificar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-202">
              <see langword="set" /> is invoked on a stream whose capacity cannot be modified.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public override void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bufferSize">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">
          <span data-ttu-id="7e9ba-203">Secuencia en la que se copiará el contenido de la secuencia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-203">The stream to which the contents of the current stream will be copied.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="7e9ba-204">Tamaño del búfer en bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-204">The size, in bytes, of the buffer.</span>
          </span>
          <span data-ttu-id="7e9ba-205">Este valor debe ser mayor que cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-205">This value must be greater than zero.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="7e9ba-206">Token para supervisar solicitudes de cancelación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-206">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-207">Lee asincrónicamente todos los bytes de la secuencia actual y los escribe en otra secuencia, utilizando el tamaño de búfer especificado y el token de cancelación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-207">Asynchronously reads all the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7e9ba-208">Tarea que representa la operación de copia asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-208">A task that represents the asynchronous copy operation.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7e9ba-209">
            <paramref name="destination" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-209">
              <paramref name="destination" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7e9ba-210">
            <paramref name="buffersize" /> es un valor negativo o es cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-210">
              <paramref name="buffersize" /> is negative or zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7e9ba-211">Se desecha la secuencia actual o la secuencia de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-211">Either the current stream or the destination stream is disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="7e9ba-212">La secuencia actual no admite lectura o la secuencia de destino no admite escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-212">The current stream does not support reading, or the destination stream does not support writing.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="7e9ba-213">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-213">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-214">Libera los recursos no administrados utilizados por la clase <see cref="T:System.IO.MemoryStream" /> y, de forma opcional, libera los recursos administrados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-214">Releases the unmanaged resources used by the <see cref="T:System.IO.MemoryStream" /> class and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-215">Se llama a este método público <xref:System.ComponentModel.Component.Dispose%2A> método y <xref:System.Object.Finalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-215">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="7e9ba-216"><xref:System.ComponentModel.Component.Dispose%2A> se invoca el protegido <xref:System.IO.MemoryStream.Dispose%2A> método con el `disposing` parámetro establecido en `true`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-216"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.MemoryStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="7e9ba-217"><xref:System.Object.Finalize%2A> invoca <xref:System.IO.MemoryStream.Dispose%2A> con `disposing` establecido en `false`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-217"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.MemoryStream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="7e9ba-218">Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.IO.MemoryStream> hace referencia.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-218">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.MemoryStream> references.</span></span> <span data-ttu-id="7e9ba-219">Este método invoca al método <xref:System.ComponentModel.Component.Dispose%2A> de cada uno de los objetos a los que se hace referencia.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-219">This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="7e9ba-220">
              <see cref="M:System.ComponentModel.Component.Dispose" /> puede recibir varias llamadas de otros objetos.</span>
            <span class="sxs-lookup">
              <span data-stu-id="7e9ba-220">
                <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="7e9ba-221">Al reemplazar <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see cref="M:System.ComponentModel.Component.Dispose" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="7e9ba-221">When overriding <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span>
            </span>
            <span data-ttu-id="7e9ba-222">Para obtener más información sobre cómo implementar <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />, consulte [implementa un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span>
            <span class="sxs-lookup">
              <span data-stu-id="7e9ba-222">For more information about how to implement <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span>
            </span>
            <span data-ttu-id="7e9ba-223">Para obtener más información acerca de <see cref="M:System.ComponentModel.Component.Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).</span>
            <span class="sxs-lookup">
              <span data-stu-id="7e9ba-223">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7e9ba-224">Reemplaza el método <see cref="M:System.IO.Stream.Flush" /> de modo que no se realice ninguna acción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-224">Overrides the <see cref="M:System.IO.Stream.Flush" /> method so that no action is performed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-225">Este método invalida el <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-225">This method overrides the <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="7e9ba-226">Dado que los datos escritos en un <xref:System.IO.MemoryStream> objeto se escribe en la memoria RAM, este método es redundante.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-226">Because any data written to a <xref:System.IO.MemoryStream> object is written into RAM, this method is redundant.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">
          <span data-ttu-id="7e9ba-227">Token para supervisar solicitudes de cancelación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-227">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-228">De forma asincrónica borra todos los búferes de esta secuencia y supervisa las solicitudes de cancelación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-228">Asynchronously clears all buffers for this stream, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7e9ba-229">Tarea que representa la operación de vaciado asincrónico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-229">A task that represents the asynchronous flush operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-230">Dado que los datos escritos en un <xref:System.IO.MemoryStream> objeto se escribe en la memoria RAM, este método es redundante.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-230">Because any data written to a <xref:System.IO.MemoryStream> object is written into RAM, this method is redundant.</span></span>  
  
 <span data-ttu-id="7e9ba-231">Si la operación se cancela antes de que finalice, la tarea devuelta contiene la <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para el <xref:System.Threading.Tasks.Task.Status%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-231">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="7e9ba-232">Puede crear un token de cancelación mediante la creación de una instancia de la <xref:System.Threading.CancellationTokenSource> clase y pasar la <xref:System.Threading.CancellationTokenSource.Token%2A> propiedad como el `cancellationToken` parámetro.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-232">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7e9ba-233">Se ha eliminado la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-233">The stream has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetBuffer">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.GetBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBuffer () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBuffer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7e9ba-234">Devuelve la matriz de bytes sin signo a partir de la cual se creó esta secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-234">Returns the array of unsigned bytes from which this stream was created.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7e9ba-235">Matriz de bytes desde la que se creó la secuencia o la matriz subyacente si la matriz de bytes no se proporcionó al constructor <see cref="T:System.IO.MemoryStream" /> durante la construcción de la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-235">The byte array from which this stream was created, or the underlying array if a byte array was not provided to the <see cref="T:System.IO.MemoryStream" /> constructor during construction of the current instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-236">Tenga en cuenta que el búfer contiene bytes asignados que podrían no haberse usados.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-236">Note that the buffer contains allocated bytes which might be unused.</span></span> <span data-ttu-id="7e9ba-237">Por ejemplo, si se escribe la cadena "test" en la <xref:System.IO.MemoryStream> (objeto), la longitud del búfer devuelto desde <xref:System.IO.MemoryStream.GetBuffer%2A> es 256, no 4 con 252 bytes sin usar.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-237">For example, if the string "test" is written into the <xref:System.IO.MemoryStream> object, the length of the buffer returned from <xref:System.IO.MemoryStream.GetBuffer%2A> is 256, not 4, with 252 bytes unused.</span></span> <span data-ttu-id="7e9ba-238">Para obtener únicamente los datos en el búfer, utilice el <xref:System.IO.MemoryStream.ToArray%2A> método; sin embargo, <xref:System.IO.MemoryStream.ToArray%2A> crea una copia de los datos en la memoria.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-238">To obtain only the data in the buffer, use the <xref:System.IO.MemoryStream.ToArray%2A> method; however, <xref:System.IO.MemoryStream.ToArray%2A> creates a copy of the data in memory.</span></span>  
  
 <span data-ttu-id="7e9ba-239">También puede ser el búfer `null`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-239">The buffer can also be `null`.</span></span>  
  
 <span data-ttu-id="7e9ba-240">Para crear un `MemoryStream` instancia con un búfer públicamente visible, utilice <xref:System.IO.MemoryStream.%23ctor%2A>, <xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29>, o <xref:System.IO.MemoryStream.%23ctor%28System.Int32%29>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-240">To create a `MemoryStream` instance with a publicly visible buffer, use <xref:System.IO.MemoryStream.%23ctor%2A>, <xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29>, or <xref:System.IO.MemoryStream.%23ctor%28System.Int32%29>.</span></span> <span data-ttu-id="7e9ba-241">Si la secuencia actual es de tamaño variable, dos llamadas a este método no devuelven la misma matriz si se cambia el tamaño de la matriz de bytes subyacente entre llamadas.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-241">If the current stream is resizable, two calls to this method do not return the same array if the underlying byte array is resized between calls.</span></span> <span data-ttu-id="7e9ba-242">Para obtener información adicional, vea <xref:System.IO.MemoryStream.Capacity%2A>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-242">For additional information, see <xref:System.IO.MemoryStream.Capacity%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7e9ba-243">Este método funciona cuando se cierra la secuencia de memoria.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-243">This method works when the memory stream is closed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="7e9ba-244">La instancia de <see langword="MemoryStream" /> no se ha creado con un búfer públicamente visible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-244">The <see langword="MemoryStream" /> instance was not created with a publicly visible buffer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7e9ba-245">Obtiene la longitud de la secuencia en bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-245">Gets the length of the stream in bytes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7e9ba-246">Longitud de la secuencia en bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-246">The length of the stream in bytes.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7e9ba-247">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.MemoryStream> clase.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-247">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7e9ba-248">La secuencia está cerrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-248">The stream is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7e9ba-249">Obtiene o establece la posición actual dentro de la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-249">Gets or sets the current position within the stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7e9ba-250">Posición actual dentro de la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-250">The current position within the stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7e9ba-251">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.MemoryStream> clase.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-251">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7e9ba-252">La posición está establecida en un valor negativo o un valor mayor que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-252">The position is set to a negative value or a value greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7e9ba-253">La secuencia está cerrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-253">The stream is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="7e9ba-254">Cuando este método finaliza, contiene la matriz de bytes especificada con los valores comprendidos entre <c>offset</c> y (<c>offset</c> + <c>count</c> - 1) reemplazada por los caracteres leídos de la secuencia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-254">When this method returns, contains the specified byte array with the values between <c>offset</c> and (<c>offset</c> + <c>count</c> - 1) replaced by the characters read from the current stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="7e9ba-255">Desplazamiento de bytes de base cero de <c>buffer</c> en el que se va a empezar a almacenar datos de la secuencia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-255">The zero-based byte offset in <c>buffer</c> at which to begin storing data from the current stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="7e9ba-256">Número máximo de bytes que se pueden leer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-256">The maximum number of bytes to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-257">Lee un bloque de bytes de la secuencia actual y escribe los datos en un búfer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-257">Reads a block of bytes from the current stream and writes the data to a buffer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7e9ba-258">Número total de bytes escritos en el búfer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-258">The total number of bytes written into the buffer.</span>
          </span>
          <span data-ttu-id="7e9ba-259">Puede ser menor que el número de bytes solicitado si ese número de bytes no está disponible, o bien puede ser cero si se alcanza el final de la secuencia antes de que se lea algún byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-259">This can be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached before any bytes are read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-260">Este método invalida <xref:System.IO.Stream.Read%2A>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-260">This method overrides <xref:System.IO.Stream.Read%2A>.</span></span>  
  
 <span data-ttu-id="7e9ba-261">El `offset` parámetro indica el desplazamiento del primer byte de `buffer` se escriban los datos de la secuencia actual.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-261">The `offset` parameter gives the offset of the first byte in `buffer` to which data from the current stream is written.</span></span> <span data-ttu-id="7e9ba-262">El `count` parámetro indica el número máximo de bytes que se leen de la secuencia actual.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-262">The `count` parameter gives the maximum number of bytes to read from the current stream.</span></span> <span data-ttu-id="7e9ba-263">El valor devuelto es el número real de bytes leídos, o cero si se alcanza el final de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-263">The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</span></span>  
  
 <span data-ttu-id="7e9ba-264">Si la operación de lectura se realiza correctamente, la posición actual dentro de la secuencia avanza según el número de bytes leídos.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-264">If the read operation is successful, the current position within the stream advances by the number of bytes read.</span></span> <span data-ttu-id="7e9ba-265">Si se produce una excepción, no cambie la posición actual dentro de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-265">If an exception occurs, the current position within the stream remains unchanged.</span></span>  
  
 <span data-ttu-id="7e9ba-266">El `Read` método devolverá cero sólo si se alcanza el final de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-266">The `Read` method will return zero only if the end of the stream is reached.</span></span> <span data-ttu-id="7e9ba-267">En todos los demás casos, `Read` siempre lee al menos un byte de la secuencia antes de devolver.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-267">In all other cases, `Read` always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="7e9ba-268">Por definición, si no hay datos disponibles en la secuencia tras una llamada a `Read`, el `Read` método devuelva cero (el final de la secuencia se alcanza de forma automática).</span><span class="sxs-lookup"><span data-stu-id="7e9ba-268">By definition, if no data is available from the stream upon a call to `Read`, the `Read` method returns zero (the end of the stream is reached automatically).</span></span> <span data-ttu-id="7e9ba-269">Una implementación es gratuita devolver menos bytes de los solicitados incluso si no se ha alcanzado el final de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-269">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="7e9ba-270">Utilice <xref:System.IO.BinaryReader> para leer los tipos de datos primitivos.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-270">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="7e9ba-271">Si la matriz de bytes especificado en el `buffer` parámetro es el búfer subyacente que devuelve el <xref:System.IO.MemoryStream.GetBuffer%2A> método, se sobrescribe el contenido de la matriz y se inicia ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-271">If the byte array specified in the `buffer` parameter is the underlying buffer returned by the <xref:System.IO.MemoryStream.GetBuffer%2A> method, the array contents are overwritten, and no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e9ba-272">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.MemoryStream> clase.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-272">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#7)]
 [!code-csharp[System.IO.MemoryStream#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#7)]
 [!code-vb[System.IO.MemoryStream#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7e9ba-273">
            <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-273">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7e9ba-274">
            <paramref name="offset" /> o <paramref name="count" /> es negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-274">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7e9ba-275">
            <paramref name="offset" />, restado de la longitud de búfer, es menor que <paramref name="count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-275">
              <paramref name="offset" /> subtracted from the buffer length is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7e9ba-276">La instancia de la secuencia actual está cerrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-276">The current stream instance is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; destination, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; destination, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Memory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="7e9ba-277">Búfer en el que se escriben los datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-277">The buffer to write the data into.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="7e9ba-278">Desplazamiento de bytes de <c>buffer</c> donde se van a empezar a escribir datos de la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-278">The byte offset in <c>buffer</c> at which to begin writing data from the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="7e9ba-279">Número máximo de bytes que se pueden leer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-279">The maximum number of bytes to read.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="7e9ba-280">Token para supervisar solicitudes de cancelación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-280">The token to monitor for cancellation requests.</span>
          </span>
          <span data-ttu-id="7e9ba-281">El valor predeterminado es <see cref="P:System.Threading.CancellationToken.None" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-281">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-282">Lee de forma asincrónica una secuencia de bytes en la secuencia actual, se hace avanzar la posición dentro de la secuencia el número de bytes leídos y controla las solicitudes de cancelación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-282">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7e9ba-283">Tarea que representa la operación de lectura asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-283">A task that represents the asynchronous read operation.</span>
          </span>
          <span data-ttu-id="7e9ba-284">El valor del parámetro <paramref name="TResult" /> contiene el número total de bytes leídos en el búfer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-284">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span>
          </span>
          <span data-ttu-id="7e9ba-285">El valor del resultado puede ser menor que el número de bytes solicitados si el número de bytes disponibles actualmente es menor que el número solicitado o puede ser 0 (cero) si se ha llegado al final de la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-285">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-286">Si la operación se cancela antes de que finalice, la tarea devuelta contiene la <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para el <xref:System.Threading.Tasks.Task.Status%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-286">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="7e9ba-287">Puede crear un token de cancelación mediante la creación de una instancia de la <xref:System.Threading.CancellationTokenSource> clase y pasar la <xref:System.Threading.CancellationTokenSource.Token%2A> propiedad como el `cancellationToken` parámetro.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-287">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7e9ba-288">
            <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-288">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7e9ba-289">
            <paramref name="offset" /> o <paramref name="count" /> es negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-289">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7e9ba-290">La suma de <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud del búfer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-290">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="7e9ba-291">La secuencia no admite lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-291">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7e9ba-292">Se ha eliminado la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-292">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="7e9ba-293">Una operación de lectura anterior está usando actualmente la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-293">The stream is currently in use by a previous read operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7e9ba-294">Lee un byte de la secuencia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-294">Reads a byte from the current stream.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7e9ba-295">El byte convertido en un <see cref="T:System.Int32" /> o -1 si se llega al final de la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-295">The byte cast to a <see cref="T:System.Int32" />, or -1 if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-296">Este método invalida <xref:System.IO.Stream.ReadByte%2A>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-296">This method overrides <xref:System.IO.Stream.ReadByte%2A>.</span></span>  
  
 <span data-ttu-id="7e9ba-297">Si la operación de lectura se realiza correctamente, se adelanta la posición actual dentro de la secuencia en un byte.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-297">If the read operation is successful, the current position within the stream is advanced by one byte.</span></span> <span data-ttu-id="7e9ba-298">Si se produce una excepción, no se modifica la posición actual dentro de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-298">If an exception occurs, the current position within the stream is unchanged.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e9ba-299">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.MemoryStream> clase.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-299">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#8)]
 [!code-csharp[System.IO.MemoryStream#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#8)]
 [!code-vb[System.IO.MemoryStream#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7e9ba-300">La instancia de la secuencia actual está cerrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-300">The current stream instance is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, loc As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin loc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="loc" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">
          <span data-ttu-id="7e9ba-301">Nueva posición dentro de la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-301">The new position within the stream.</span>
          </span>
          <span data-ttu-id="7e9ba-302">Está relacionada con el parámetro <c>loc</c> y puede ser positiva o negativa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-302">This is relative to the <c>loc</c> parameter, and can be positive or negative.</span>
          </span>
        </param>
        <param name="loc">
          <span data-ttu-id="7e9ba-303">Valor de tipo <see cref="T:System.IO.SeekOrigin" />, que actúa como el punto de referencia de las operaciones de búsqueda.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-303">A value of type <see cref="T:System.IO.SeekOrigin" />, which acts as the seek reference point.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-304">Establece la posición dentro de la secuencia actual en el valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-304">Sets the position within the current stream to the specified value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7e9ba-305">Nueva posición dentro de la secuencia, calculada mediante la combinación del punto de referencia inicial y del desplazamiento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-305">The new position within the stream, calculated by combining the initial reference point and the offset.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-306">Este método invalida <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-306">This method overrides <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="7e9ba-307">Se admite la búsqueda en cualquier ubicación más allá de la longitud de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-307">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 <span data-ttu-id="7e9ba-308">No utilice la <xref:System.IO.MemoryStream.Seek%2A> método para determinar la nueva posición en la secuencia, si la <xref:System.IO.MemoryStream> se inicializó con un desplazamiento distinto de cero.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-308">Do not use the <xref:System.IO.MemoryStream.Seek%2A> method to determine the new position in the stream if the <xref:System.IO.MemoryStream> was initialized with a non-zero offset.</span></span> <span data-ttu-id="7e9ba-309">Si lo hace, <xref:System.IO.MemoryStream.Seek%2A> devolverá un valor inexacto.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-309">If you do, <xref:System.IO.MemoryStream.Seek%2A> will return an inaccurate value.</span></span> <span data-ttu-id="7e9ba-310">En su lugar, use la <xref:System.IO.MemoryStream.Position%2A> propiedad que se va a obtener la nueva posición de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-310">Instead, use the <xref:System.IO.MemoryStream.Position%2A> property to get the new position of the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e9ba-311">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.MemoryStream> clase.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-311">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#6)]
 [!code-csharp[System.IO.MemoryStream#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#6)]
 [!code-vb[System.IO.MemoryStream#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="7e9ba-312">La búsqueda se intenta antes del comienzo de la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-312">Seeking is attempted before the beginning of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7e9ba-313">
            <paramref name="offset" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-313">
              <paramref name="offset" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7e9ba-314">Hay un <see cref="T:System.IO.SeekOrigin" /> no válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-314">There is an invalid <see cref="T:System.IO.SeekOrigin" />.</span>
          </span>
          <span data-ttu-id="7e9ba-315">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-315">-or-</span>
          </span>
          <span data-ttu-id="7e9ba-316">
            <paramref name="offset" /> produjo un desbordamiento aritmético.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-316">
              <paramref name="offset" /> caused an arithmetic overflow.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7e9ba-317">La instancia de la secuencia actual está cerrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-317">The current stream instance is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="7e9ba-318">Valor en el que establecer la longitud.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-318">The value at which to set the length.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-319">Establece la longitud de la secuencia actual en el valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-319">Sets the length of the current stream to the specified value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-320">Este método invalida <xref:System.IO.Stream.SetLength%2A>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-320">This method overrides <xref:System.IO.Stream.SetLength%2A>.</span></span>  
  
 <span data-ttu-id="7e9ba-321">Si el valor especificado es menor que la longitud actual de la secuencia, se trunca la secuencia.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-321">If the specified value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="7e9ba-322">Si el truncamiento la posición actual dentro de la secuencia está más allá del final de la secuencia, el <xref:System.IO.MemoryStream.ReadByte%2A> método devuelve -1, el <xref:System.IO.MemoryStream.Read%2A> método lee cero bytes en la matriz de bytes proporcionada, y <xref:System.IO.MemoryStream.Write%2A> y <xref:System.IO.MemoryStream.WriteByte%2A> métodos anexarán bytes especificados al final de la secuencia, aumentar su longitud.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-322">If after the truncation the current position within the stream is past the end of the stream, the <xref:System.IO.MemoryStream.ReadByte%2A> method returns -1, the <xref:System.IO.MemoryStream.Read%2A> method reads zero bytes into the provided byte array, and <xref:System.IO.MemoryStream.Write%2A> and <xref:System.IO.MemoryStream.WriteByte%2A> methods append specified bytes at the end of the stream, increasing its length.</span></span> <span data-ttu-id="7e9ba-323">Si el valor especificado es mayor que la capacidad actual y la secuencia es de tamaño variable, se aumenta la capacidad y la posición actual dentro de la secuencia se ha modificado.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-323">If the specified value is larger than the current capacity and the stream is resizable, the capacity is increased, and the current position within the stream is unchanged.</span></span> <span data-ttu-id="7e9ba-324">Si se aumenta la longitud, el contenido de la secuencia entre la antigua y la nueva longitud se inicializa a los ceros.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-324">If the length is increased, the contents of the stream between the old and the new length are initialized to zeros.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7e9ba-325">Un <xref:System.IO.MemoryStream> instancia debe admitir la escritura para este método funcione.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-325">A <xref:System.IO.MemoryStream> instance must support writing for this method to work.</span></span> <span data-ttu-id="7e9ba-326">Use la <xref:System.IO.MemoryStream.CanWrite%2A> propiedad para determinar si la instancia actual admite escritura.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-326">Use the <xref:System.IO.MemoryStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="7e9ba-327">Para obtener información adicional, vea <xref:System.IO.Stream.CanWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-327">For additional information, see <xref:System.IO.Stream.CanWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="7e9ba-328">La secuencia actual no es de tamaño variable y <paramref name="value" /> es mayor que la capacidad actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-328">The current stream is not resizable and <paramref name="value" /> is larger than the current capacity.</span>
          </span>
          <span data-ttu-id="7e9ba-329">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-329">-or-</span>
          </span>
          <span data-ttu-id="7e9ba-330">La secuencia actual no admite escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-330">The current stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7e9ba-331">
            <paramref name="value" /> es negativo o mayor que la longitud máxima de <see cref="T:System.IO.MemoryStream" />, donde la longitud máxima es (<see cref="F:System.Int32.MaxValue" />-origen) y el origen es el índice del búfer subyacente donde comienza la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-331">
              <paramref name="value" /> is negative or is greater than the maximum length of the <see cref="T:System.IO.MemoryStream" />, where the maximum length is(<see cref="F:System.Int32.MaxValue" /> - origin), and origin is the index into the underlying buffer at which the stream starts.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual byte[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ToArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7e9ba-332">Escribe el contenido de la secuencia en una matriz de bytes, independientemente de la propiedad <see cref="P:System.IO.MemoryStream.Position" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-332">Writes the stream contents to a byte array, regardless of the <see cref="P:System.IO.MemoryStream.Position" /> property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7e9ba-333">Nueva matriz de bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-333">A new byte array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-334">Este método omite los bytes en <xref:System.IO.MemoryStream> de la matriz.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-334">This method omits unused bytes in <xref:System.IO.MemoryStream> from the array.</span></span> <span data-ttu-id="7e9ba-335">Para obtener el búfer completo, utilice el <xref:System.IO.MemoryStream.GetBuffer%2A> método.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-335">To get the entire buffer, use the <xref:System.IO.MemoryStream.GetBuffer%2A> method.</span></span>  
  
 <span data-ttu-id="7e9ba-336">Este método devuelve una copia del contenido de la <xref:System.IO.MemoryStream> como una matriz de bytes.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-336">This method returns a copy of the contents of the <xref:System.IO.MemoryStream> as a byte array.</span></span> <span data-ttu-id="7e9ba-337">Si la instancia actual se construyó en una matriz de bytes proporcionada, se devuelve una copia de la sección de la matriz a la que esta instancia tiene acceso.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-337">If the current instance was constructed on a provided byte array, a copy of the section of the array to which this instance has access is returned.</span></span> <span data-ttu-id="7e9ba-338">Consulte la <xref:System.IO.MemoryStream.%23ctor%2A> constructor para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-338">See the <xref:System.IO.MemoryStream.%23ctor%2A> constructor for details.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7e9ba-339">Este método funciona cuando la <xref:System.IO.MemoryStream> está cerrado.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-339">This method works when the <xref:System.IO.MemoryStream> is closed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetBuffer">
      <MemberSignature Language="C#" Value="public virtual bool TryGetBuffer (out ArraySegment&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetBuffer([out] valuetype System.ArraySegment`1&lt;unsigned int8&gt;&amp; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetBuffer (ByRef buffer As ArraySegment(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetBuffer([Runtime::InteropServices::Out] ArraySegment&lt;System::Byte&gt; % buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ArraySegment&lt;System.Byte&gt;&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="7e9ba-340">El segmento de matriz de bytes desde el que se creó esta secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-340">The byte array segment from which this stream was created.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-341">Devuelve la matriz de bytes sin signo a partir de la cual se creó esta secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-341">Returns the array of unsigned bytes from which this stream was created.</span>
          </span>
          <span data-ttu-id="7e9ba-342">El valor devuelto indica si la conversión se realizó correctamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-342">The return value indicates whether the conversion succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7e9ba-343">Es <see langword="true" /> si la conversión se realiza correctamente; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-343">
              <see langword="true" /> if the conversion was successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (source As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="7e9ba-344">Búfer del que se van a escribir datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-344">The buffer to write data from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="7e9ba-345">Desplazamiento de bytes de base cero de <c>buffer</c> en donde se van a empezar a copiar bytes en la secuencia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-345">The zero-based byte offset in <c>buffer</c> at which to begin copying bytes to the current stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="7e9ba-346">Número máximo de bytes que se pueden escribir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-346">The maximum number of bytes to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-347">Escribe un bloque de bytes en la secuencia actual usando los datos leídos en un búfer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-347">Writes a block of bytes to the current stream using data read from a buffer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-348">Este método invalida <xref:System.IO.Stream.Write%2A>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-348">This method overrides <xref:System.IO.Stream.Write%2A>.</span></span>  
  
 <span data-ttu-id="7e9ba-349">El `offset` parámetro indica el desplazamiento del primer byte de `buffer` desde el que escribir y `count` parámetro proporciona el número de bytes que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-349">The `offset` parameter gives the offset of the first byte in `buffer` to write from, and the `count` parameter gives the number of bytes to write.</span></span> <span data-ttu-id="7e9ba-350">Si la operación de escritura se realiza correctamente, la posición actual dentro de la secuencia se avanza por el número de bytes escritos.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-350">If the write operation is successful, the current position within the stream is advanced by the number of bytes written.</span></span> <span data-ttu-id="7e9ba-351">Si se produce una excepción, no se modifica la posición actual dentro de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-351">If an exception occurs, the current position within the stream is unchanged.</span></span>  
  
 <span data-ttu-id="7e9ba-352">Excepto para un `MemoryStream` construido con un parámetro byte [], escribir operaciones al final de un `MemoryStream` expandir la `MemoryStream`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-352">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e9ba-353">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.MemoryStream> clase.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-353">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#3)]
 [!code-csharp[System.IO.MemoryStream#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#3)]
 [!code-vb[System.IO.MemoryStream#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7e9ba-354">
            <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-354">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="7e9ba-355">La secuencia no admite escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-355">The stream does not support writing.</span>
          </span>
          <span data-ttu-id="7e9ba-356">Para obtener más información, vea <see cref="P:System.IO.Stream.CanWrite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-356">For additional information see <see cref="P:System.IO.Stream.CanWrite" />.</span>
          </span>
          <span data-ttu-id="7e9ba-357">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-357">-or-</span>
          </span>
          <span data-ttu-id="7e9ba-358">La posición actual se encuentra más cerca que <paramref name="count" /> bytes al final de la secuencia, y la capacidad no puede modificar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-358">The current position is closer than <paramref name="count" /> bytes to the end of the stream, and the capacity cannot be modified.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7e9ba-359">
            <paramref name="offset" />, restado de la longitud de búfer, es menor que <paramref name="count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-359">
              <paramref name="offset" /> subtracted from the buffer length is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7e9ba-360">El valor de <paramref name="offset" /> o <paramref name="count" /> es negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-360">
              <paramref name="offset" /> or <paramref name="count" /> are negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="7e9ba-361">Error de E/S.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-361">An I/O error occurs.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7e9ba-362">La instancia de la secuencia actual está cerrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-362">The current stream instance is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; source, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="7e9ba-363">Búfer del que se van a escribir datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-363">The buffer to write data from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="7e9ba-364">Desplazamiento de bytes de base cero de <c>buffer</c> desde donde se van a empezar a copiar bytes en la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-364">The zero-based byte offset in <c>buffer</c> from which to begin copying bytes to the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="7e9ba-365">Número máximo de bytes que se pueden escribir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-365">The maximum number of bytes to write.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="7e9ba-366">Token para supervisar solicitudes de cancelación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-366">The token to monitor for cancellation requests.</span>
          </span>
          <span data-ttu-id="7e9ba-367">El valor predeterminado es <see cref="P:System.Threading.CancellationToken.None" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-367">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-368">Escribe de forma asincrónica una secuencia de bytes en la secuencia actual, se hace avanzar la posición actual dentro de la secuencia por el número de bytes escritos y controla las solicitudes de cancelación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-368">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7e9ba-369">Tarea que representa la operación de escritura asincrónica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-369">A task that represents the asynchronous write operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-370">Si la operación se cancela antes de que finalice, la tarea devuelta contiene la <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para el <xref:System.Threading.Tasks.Task.Status%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-370">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="7e9ba-371">Puede crear un token de cancelación mediante la creación de una instancia de la <xref:System.Threading.CancellationTokenSource> clase y pasar la <xref:System.Threading.CancellationTokenSource.Token%2A> propiedad como el `cancellationToken` parámetro.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-371">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7e9ba-372">
            <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-372">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="7e9ba-373">
            <paramref name="offset" /> o <paramref name="count" /> es negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-373">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7e9ba-374">La suma de <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud del búfer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-374">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="7e9ba-375">La secuencia no admite escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-375">The stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7e9ba-376">Se ha eliminado la secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-376">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="7e9ba-377">La secuencia está actualmente en uso por una operación de escritura anterior.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-377">The stream is currently in use by a previous write operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="7e9ba-378">Byte que se va a escribir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-378">The byte to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-379">Escribe un byte en la posición actual de la secuencia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-379">Writes a byte to the current stream at the current position.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-380">Este método invalida <xref:System.IO.Stream.WriteByte%2A>.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-380">This method overrides <xref:System.IO.Stream.WriteByte%2A>.</span></span>  
  
 <span data-ttu-id="7e9ba-381">Excepto para un `MemoryStream` construido con un parámetro byte [], escribir operaciones al final de un `MemoryStream` expandir la `MemoryStream`.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-381">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e9ba-382">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.MemoryStream> clase.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-382">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#4)]
 [!code-csharp[System.IO.MemoryStream#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#4)]
 [!code-vb[System.IO.MemoryStream#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="7e9ba-383">La secuencia no admite escritura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-383">The stream does not support writing.</span>
          </span>
          <span data-ttu-id="7e9ba-384">Para obtener más información, vea <see cref="P:System.IO.Stream.CanWrite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-384">For additional information see <see cref="P:System.IO.Stream.CanWrite" />.</span>
          </span>
          <span data-ttu-id="7e9ba-385">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-385">-or-</span>
          </span>
          <span data-ttu-id="7e9ba-386">La posición actual se encuentra al final de la secuencia y la capacidad no se puede modificar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-386">The current position is at the end of the stream, and the capacity cannot be modified.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7e9ba-387">Se cierra la secuencia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-387">The current stream is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public virtual void WriteTo (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteTo(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="7e9ba-388">Secuencia en la que se va a escribir esta secuencia de memoria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-388">The stream to write this memory stream to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7e9ba-389">Escribe el contenido completo de esta secuencia de memoria en otra secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-389">Writes the entire contents of this memory stream to another stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e9ba-390">Una vez abierta la secuencia actual, este método es equivalente a llamar a <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> en el búfer subyacente de esta secuencia.</span><span class="sxs-lookup"><span data-stu-id="7e9ba-390">When the current stream is open, this method is equivalent to calling <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> on the underlying buffer of this stream.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7e9ba-391">
            <paramref name="stream" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-391">
              <paramref name="stream" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7e9ba-392">La secuencia actual o de destino está cerrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7e9ba-392">The current or target stream is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>