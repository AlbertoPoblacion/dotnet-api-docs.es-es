<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MemoryStream.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86c02ca3cbe99f600c2f813c7c537dac714efc08b5b.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02ca3cbe99f600c2f813c7c537dac714efc08b5b</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.MemoryStream">
          <source>Creates a stream whose backing store is memory.</source>
          <target state="translated">Crea una secuencia cuya memoria auxiliar es la memoria.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>The current position of a stream is the position at which the next read or write operation could take place.</source>
          <target state="translated">La posición actual de una secuencia es la posición en la que la siguiente lectura o la operación de escritura llevara a cabo.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>The current position can be retrieved or set through the <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> method.</source>
          <target state="translated">La posición actual se puede recuperar o establecer a través de la <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>When a new instance of <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> is created, the current position is set to zero.</source>
          <target state="translated">Cuando una nueva instancia de <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> se crea la actual posición está establecida en cero.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>Memory streams created with an unsigned byte array provide a non-resizable stream of the data.</source>
          <target state="translated">Secuencias de memoria creadas con una matriz de bytes sin signo proporcionan un flujo invariable de los datos.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>When using a byte array, you can neither append to nor shrink the stream, although you might be able to modify the existing contents depending on the parameters passed into the constructor.</source>
          <target state="translated">Cuando se usa una matriz de bytes, se pueden anexar a ni reducir la secuencia, aunque es posible que pueda modificar el contenido existente en función de los parámetros pasados al constructor.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>Empty memory streams are resizable, and can be written to and read from.</source>
          <target state="translated">Secuencias de memoria vacías son de tamaño variable y pueden escritas y se leen desde.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>If a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> object is added to a ResX file or a .resources file, call the <ph id="ph2">&lt;xref:System.Resources.ResourceManager.GetStream%2A&gt;</ph> method at runtime to retrieve it.</source>
          <target state="translated">Si un <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> objeto se agrega a un archivo ResX o un archivo .resources, llame a la <ph id="ph2">&lt;xref:System.Resources.ResourceManager.GetStream%2A&gt;</ph> método en tiempo de ejecución para recuperarlo.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>If a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> object is serialized to a resource file it will actually be serialized as an <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph>.</source>
          <target state="translated">Si un <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> el objeto se serializa en un archivo de recursos que realmente se van a serializar como un <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>This behavior provides better performance, as well as the ability to get a pointer to the data directly, without having to go through <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> methods.</source>
          <target state="translated">Este comportamiento proporciona un mejor rendimiento, así como la capacidad para obtener un puntero a los datos directamente, sin tener que pasar por <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.MemoryStream">
          <source>The following code example shows how to read and write data using memory as a backing store.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo leer y escribir datos utilizando la memoria como una memoria auxiliar.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="T:System.IO.MemoryStream">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class with an expandable capacity initialized to zero.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> con una capacidad expansible inicializada con un valor cero.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> properties are all set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> propiedades están establecidos en <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor">
          <source>The capacity of the current stream automatically increases when you use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph> method to set the length to a value larger than the capacity of the current stream.</source>
          <target state="translated">La capacidad de la secuencia actual aumenta automáticamente cuando se usa el <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph> método para establecer la longitud en un valor mayor que la capacidad de la secuencia actual.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor">
          <source>This constructor exposes the underlying stream, which <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> returns.</source>
          <target state="translated">Este constructor expone subyacente transmitir por secuencias, que <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> devuelve.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>The array of unsigned bytes from which to create the current stream.</source>
          <target state="translated">Matriz de bytes sin signo a partir de la cual se crea la secuencia actual.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>Initializes a new non-resizable instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class based on the specified byte array.</source>
          <target state="translated">Inicializa una nueva instancia invariable de la clase <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> de acuerdo con la matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> properties are all set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> propiedades están establecidos en <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> is set to the length of the specified byte array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> se establece en la longitud de la matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>The new stream can be written to, but is not resizable.</source>
          <target state="translated">La nueva secuencia puede escribirse en, pero no es de tamaño variable.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</source>
          <target state="translated">No se puede establecer la longitud de la secuencia en un valor mayor que la longitud inicial de la matriz de bytes especificada; Sin embargo, se puede truncar la secuencia (vea <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source>This constructor does not expose the underlying stream.</source>
          <target state="translated">Este constructor no expone la secuencia subyacente.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throws <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> produce <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>The initial size of the internal array in bytes.</source>
          <target state="translated">Tamaño inicial de la matriz interna en bytes.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class with an expandable capacity initialized as specified.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> con una capacidad expansible inicializada según lo especificado.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> properties are all set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> propiedades están establecidos en <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>The capacity automatically increases when you use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph> method to set the length to a value larger than the capacity of the current stream.</source>
          <target state="translated">La capacidad aumenta automáticamente cuando se usa el <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph> método para establecer la longitud en un valor mayor que la capacidad de la secuencia actual.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>Except for a <ph id="ph1">`MemoryStream`</ph> constructed with a byte[] parameter, write operations at the end of a <ph id="ph2">`MemoryStream`</ph> expand the <ph id="ph3">`MemoryStream`</ph>.</source>
          <target state="translated">Excepto para un <ph id="ph1">`MemoryStream`</ph> construido con un parámetro byte [], escribir operaciones al final de un <ph id="ph2">`MemoryStream`</ph> expandir la <ph id="ph3">`MemoryStream`</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>This constructor exposes the underlying stream that <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> returns.</source>
          <target state="translated">Este constructor expone subyacente que transmitir <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> devuelve.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>The array of unsigned bytes from which to create this stream.</source>
          <target state="translated">Matriz de bytes sin signo a partir de la cual se crea esta secuencia.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>The setting of the <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property, which determines whether the stream supports writing.</source>
          <target state="translated">Establecimiento de la propiedad <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph>, que determina si la secuencia admite escritura.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>Initializes a new non-resizable instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class based on the specified byte array with the <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property set as specified.</source>
          <target state="translated">Inicializa una nueva instancia invariable de la clase <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> según la matriz de bytes especificada con la propiedad <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> establecida como se ha indicado.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> properties are both set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> propiedades se establecen como <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> is set to the length of the specified byte array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> se establece en la longitud de la matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</source>
          <target state="translated">No se puede establecer la longitud de la secuencia en un valor mayor que la longitud inicial de la matriz de bytes especificada; Sin embargo, se puede truncar la secuencia (vea <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source>This constructor does not expose the underlying stream.</source>
          <target state="translated">Este constructor no expone la secuencia subyacente.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throws <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> produce <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The array of unsigned bytes from which to create this stream.</source>
          <target state="translated">Matriz de bytes sin signo a partir de la cual se crea esta secuencia.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The index into <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which the stream begins.</source>
          <target state="translated">Índice dentro de <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> en el que empieza la secuencia.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The length of the stream in bytes.</source>
          <target state="translated">Longitud de la secuencia en bytes.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>Initializes a new non-resizable instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class based on the specified region (index) of a byte array.</source>
          <target state="translated">Inicializa una nueva instancia invariable de la clase <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> según la región especificada (índice) de una matriz de bytes.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> properties are all set to <ph id="ph4">`true`</ph>, but the capacity cannot be changed.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> propiedades están establecidos en <ph id="ph4">`true`</ph>, pero no se puede cambiar la capacidad.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> is set to <ph id="ph2">`count`</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> está establecido en <ph id="ph2">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</source>
          <target state="translated">No se puede establecer la longitud de la secuencia en un valor mayor que la longitud inicial de la matriz de bytes especificada; Sin embargo, se puede truncar la secuencia (vea <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>This constructor does not expose the underlying stream.</source>
          <target state="translated">Este constructor no expone la secuencia subyacente.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throws <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> produce <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>However, you can write to the stream.</source>
          <target state="translated">Sin embargo, puede escribir en la secuencia.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
          <source>The buffer length minus <ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">La longitud del búfer menos <ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The array of unsigned bytes from which to create this stream.</source>
          <target state="translated">Matriz de bytes sin signo a partir de la cual se crea esta secuencia.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The index in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which the stream begins.</source>
          <target state="translated">Índice de <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> en el que empieza la secuencia.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The length of the stream in bytes.</source>
          <target state="translated">Longitud de la secuencia en bytes.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The setting of the <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property, which determines whether the stream supports writing.</source>
          <target state="translated">Establecimiento de la propiedad <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph>, que determina si la secuencia admite escritura.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>Initializes a new non-resizable instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class based on the specified region of a byte array, with the <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property set as specified.</source>
          <target state="translated">Inicializa una nueva instancia invariable de la clase <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> según la región especificada de una matriz de bytes, con la propiedad <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> establecida como se ha indicado.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> properties are both set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> propiedades se establecen como <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> is set to <ph id="ph2">`count`</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> está establecido en <ph id="ph2">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</source>
          <target state="translated">No se puede establecer la longitud de la secuencia en un valor mayor que la longitud inicial de la matriz de bytes especificada; Sin embargo, se puede truncar la secuencia (vea <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>This constructor does not expose the underlying stream.</source>
          <target state="translated">Este constructor no expone la secuencia subyacente.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> throws <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> produce <ph id="ph2">&lt;xref:System.UnauthorizedAccessException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>However, you can write to the stream if <ph id="ph1">`writable`</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Sin embargo, puede escribir en la secuencia si <ph id="ph1">`writable`</ph> es <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> are negative.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="index" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
          <source>The buffer length minus <ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">La longitud del búfer menos <ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The array of unsigned bytes from which to create this stream.</source>
          <target state="translated">Matriz de bytes sin signo a partir de la cual se crea esta secuencia.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The index into <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which the stream begins.</source>
          <target state="translated">Índice dentro de <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> en el que empieza la secuencia.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The length of the stream in bytes.</source>
          <target state="translated">Longitud de la secuencia en bytes.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The setting of the <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property, which determines whether the stream supports writing.</source>
          <target state="translated">Establecimiento de la propiedad <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph>, que determina si la secuencia admite escritura.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to enable <ph id="ph2">&lt;see cref="M:System.IO.MemoryStream.GetBuffer" /&gt;</ph>, which returns the unsigned byte array from which the stream was created; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> para habilitar <ph id="ph2">&lt;see cref="M:System.IO.MemoryStream.GetBuffer" /&gt;</ph>, que devuelve la matriz de bytes sin signo desde la cual se creó la secuencia; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class based on the specified region of a byte array, with the <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> property set as specified, and the ability to call <ph id="ph3">&lt;see cref="M:System.IO.MemoryStream.GetBuffer" /&gt;</ph> set as specified.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> según la región especificada de una matriz de bytes, con la propiedad <ph id="ph2">&lt;see cref="P:System.IO.MemoryStream.CanWrite" /&gt;</ph> establecida como se ha indicado y la posibilidad de llamar a <ph id="ph3">&lt;see cref="M:System.IO.MemoryStream.GetBuffer" /&gt;</ph> establecida según lo especificado.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> properties are both set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanRead%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.IO.MemoryStream.CanSeek%2A&gt;</ph> propiedades se establecen como <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> is set to <ph id="ph2">`count`</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> está establecido en <ph id="ph2">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The new stream instance can be written to, but the <ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> of the underlying byte array cannot be changed.</source>
          <target state="translated">Se puede escribir la nueva instancia de flujo, pero la <ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph> del byte subyacente no se puede cambiar la matriz.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</source>
          <target state="translated">No se puede establecer la longitud de la secuencia en un valor mayor que la longitud inicial de la matriz de bytes especificada; Sin embargo, se puede truncar la secuencia (vea <ph id="ph1">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
          <source>The buffer length minus <ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">La longitud del búfer menos <ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.CanRead">
          <source>Gets a value indicating whether the current stream supports reading.</source>
          <target state="translated">Obtiene un valor que indica si la secuencia actual admite lectura.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanRead">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream is open.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el flujo está abierto.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanRead">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support reading, calls to the <ph id="ph2">&lt;xref:System.IO.MemoryStream.Read%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.IO.MemoryStream.ReadByte%2A&gt;</ph> methods throw a <ph id="ph4">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Si una clase derivada de <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> no admite la lectura, las llamadas a la <ph id="ph2">&lt;xref:System.IO.MemoryStream.Read%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.IO.MemoryStream.ReadByte%2A&gt;</ph> métodos lanzan una <ph id="ph4">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanRead">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Si la secuencia está cerrada, esta propiedad devuelve <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.CanSeek">
          <source>Gets a value indicating whether the current stream supports seeking.</source>
          <target state="translated">Obtiene un valor que indica si la secuencia actual admite búsquedas.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanSeek">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream is open.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el flujo está abierto.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanSeek">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support seeking, calls to <ph id="ph2">&lt;xref:System.IO.MemoryStream.Length%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.MemoryStream.Position%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> throw a <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Si una clase derivada de <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> no admite búsquedas, las llamadas a <ph id="ph2">&lt;xref:System.IO.MemoryStream.Length%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.MemoryStream.SetLength%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.MemoryStream.Position%2A&gt;</ph>, y <ph id="ph5">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> producir un <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanSeek">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Si la secuencia está cerrada, esta propiedad devuelve <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.CanWrite">
          <source>Gets a value indicating whether the current stream supports writing.</source>
          <target state="translated">Obtiene un valor que indica si la secuencia actual admite escritura.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanWrite">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream supports writing; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el flujo admite escritura; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanWrite">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support writing, a call to <ph id="ph2">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph> throws a <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Si una clase derivada de <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> no admite la escritura, una llamada a <ph id="ph2">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>, o <ph id="ph4">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph> produce una <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.CanWrite">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Si la secuencia está cerrada, esta propiedad devuelve <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Capacity">
          <source>Gets or sets the number of bytes allocated for this stream.</source>
          <target state="translated">Obtiene o establece el número de bytes asignados a esta secuencia.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Capacity">
          <source>The length of the usable portion of the buffer for the stream.</source>
          <target state="translated">Longitud de la parte utilizable del búfer para la secuencia.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Capacity">
          <source><ph id="ph1">`Capacity`</ph> is the buffer length for system-provided byte arrays.</source>
          <target state="translated"><ph id="ph1">`Capacity`</ph> es la longitud de búfer para matrices de bytes proporcionado por el sistema.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Capacity">
          <source><ph id="ph1">`Capacity`</ph> cannot be set to a value less than the current length of the stream.</source>
          <target state="translated"><ph id="ph1">`Capacity`</ph> no se puede establecer en un valor menor que la longitud actual de la secuencia.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Capacity">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Capacity">
          <source>A capacity is set that is negative or less than the current length of the stream.</source>
          <target state="translated">Se establece una capacidad de modo que sea negativa o menor que la longitud actual de la secuencia.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Capacity">
          <source>The current stream is closed.</source>
          <target state="translated">Se cierra la secuencia actual.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Capacity">
          <source><ph id="ph1">&lt;see langword="set" /&gt;</ph> is invoked on a stream whose capacity cannot be modified.</source>
          <target state="translated">Se invoca <ph id="ph1">&lt;see langword="set" /&gt;</ph> en una secuencia cuya capacidad no se puede modificar.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>The stream to which the contents of the current stream will be copied.</source>
          <target state="translated">Secuencia en la que se copiará el contenido de la secuencia actual.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>The size, in bytes, of the buffer.</source>
          <target state="translated">Tamaño del búfer en bytes.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>This value must be greater than zero.</source>
          <target state="translated">Este valor debe ser mayor que cero.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Token para supervisar solicitudes de cancelación.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously reads all the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.</source>
          <target state="translated">Lee asincrónicamente todos los bytes de la secuencia actual y los escribe en otra secuencia, utilizando el tamaño de búfer especificado y el token de cancelación.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous copy operation.</source>
          <target state="translated">Tarea que representa la operación de copia asincrónica.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="destination" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destination" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffersize" /&gt;</ph> is negative or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffersize" /&gt;</ph> es un valor negativo o es cero.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>Either the current stream or the destination stream is disposed.</source>
          <target state="translated">Se desecha la secuencia actual o la secuencia de destino.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <source>The current stream does not support reading, or the destination stream does not support writing.</source>
          <target state="translated">La secuencia actual no admite lectura o la secuencia de destino no admite escritura.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> para liberar tanto recursos administrados como no administrados; es <ph id="ph2">&lt;see langword="false" /&gt;</ph> para liberar únicamente recursos no administrados.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> class and optionally releases the managed resources.</source>
          <target state="translated">Libera los recursos no administrados utilizados por la clase <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> y, de forma opcional, libera los recursos administrados.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Se llama a este método público <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> método y <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> invokes the protected <ph id="ph2">&lt;xref:System.IO.MemoryStream.Dispose%2A&gt;</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> se invoca el protegido <ph id="ph2">&lt;xref:System.IO.MemoryStream.Dispose%2A&gt;</ph> método con el <ph id="ph3">`disposing`</ph> parámetro establecido en <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id="ph2">&lt;xref:System.IO.MemoryStream.Dispose%2A&gt;</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invoca <ph id="ph2">&lt;xref:System.IO.MemoryStream.Dispose%2A&gt;</ph> con <ph id="ph3">`disposing`</ph> establecido en <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.IO.MemoryStream&gt;</ph> references.</source>
          <target state="translated">Cuando el parámetro <ph id="ph1">`disposing`</ph> es <ph id="ph2">`true`</ph>, este método libera todos los recursos retenidos por los objetos administrados a los que el control <ph id="ph3">&lt;xref:System.IO.MemoryStream&gt;</ph> hace referencia.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method of each referenced object.</source>
          <target state="translated">Este método invoca al método <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> de cada uno de los objetos a los que se hace referencia.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> puede recibir varias llamadas de otros objetos.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /&gt;</ph> be careful not to reference objects that have been previously disposed of in an earlier call to <ph id="ph2">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>.</source>
          <target state="translated">Al reemplazar <ph id="ph1">&lt;see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /&gt;</ph> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <ph id="ph2">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre cómo implementar <ph id="ph1">&lt;see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /&gt;</ph>, consulte <bpt id="p1">[</bpt>implementa un método Dispose<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de <ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> y <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, consulte <bpt id="p1">[</bpt>limpiar recursos no administrados<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Flush">
          <source>Overrides the <ph id="ph1">&lt;see cref="M:System.IO.Stream.Flush" /&gt;</ph> method so that no action is performed.</source>
          <target state="translated">Reemplaza el método <ph id="ph1">&lt;see cref="M:System.IO.Stream.Flush" /&gt;</ph> de modo que no se realice ninguna acción.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Flush">
          <source>This method overrides the <ph id="ph1">&lt;xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Este método invalida el <ph id="ph1">&lt;xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Flush">
          <source>Because any data written to a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> object is written into RAM, this method is redundant.</source>
          <target state="translated">Dado que los datos escritos en un <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> objeto se escribe en la memoria RAM, este método es redundante.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Token para supervisar solicitudes de cancelación.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>Asynchronously clears all buffers for this stream, and monitors cancellation requests.</source>
          <target state="translated">De forma asincrónica borra todos los búferes de esta secuencia y supervisa las solicitudes de cancelación.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous flush operation.</source>
          <target state="translated">Tarea que representa la operación de vaciado asincrónico.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>Because any data written to a <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> object is written into RAM, this method is redundant.</source>
          <target state="translated">Dado que los datos escritos en un <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> objeto se escribe en la memoria RAM, este método es redundante.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">Si la operación se cancela antes de que finalice, la tarea devuelta contiene la <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> valor para el <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>You can create a cancellation token by creating an instance of the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> class and passing the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> property as the <ph id="ph3">`cancellationToken`</ph> parameter.</source>
          <target state="translated">Puede crear un token de cancelación mediante la creación de una instancia de la <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> clase y pasar la <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> propiedad como el <ph id="ph3">`cancellationToken`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">Se ha eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>Returns the array of unsigned bytes from which this stream was created.</source>
          <target state="translated">Devuelve la matriz de bytes sin signo a partir de la cual se creó esta secuencia.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>The byte array from which this stream was created, or the underlying array if a byte array was not provided to the <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> constructor during construction of the current instance.</source>
          <target state="translated">Matriz de bytes desde la que se creó la secuencia o la matriz subyacente si la matriz de bytes no se proporcionó al constructor <ph id="ph1">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph> durante la construcción de la instancia actual.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>Note that the buffer contains allocated bytes which might be unused.</source>
          <target state="translated">Tenga en cuenta que el búfer contiene bytes asignados que podrían no haberse usados.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>For example, if the string "test" is written into the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> object, the length of the buffer returned from <ph id="ph2">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> is 256, not 4, with 252 bytes unused.</source>
          <target state="translated">Por ejemplo, si se escribe la cadena "test" en la <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> (objeto), la longitud del búfer devuelto desde <ph id="ph2">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> es 256, no 4 con 252 bytes sin usar.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>To obtain only the data in the buffer, use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.ToArray%2A&gt;</ph> method; however, <ph id="ph2">&lt;xref:System.IO.MemoryStream.ToArray%2A&gt;</ph> creates a copy of the data in memory.</source>
          <target state="translated">Para obtener únicamente los datos en el búfer, utilice el <ph id="ph1">&lt;xref:System.IO.MemoryStream.ToArray%2A&gt;</ph> método; sin embargo, <ph id="ph2">&lt;xref:System.IO.MemoryStream.ToArray%2A&gt;</ph> crea una copia de los datos en la memoria.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>The buffer can also be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">También puede ser el búfer <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>To create a <ph id="ph1">`MemoryStream`</ph> instance with a publicly visible buffer, use <ph id="ph2">&lt;xref:System.IO.MemoryStream.%23ctor%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.MemoryStream.%23ctor%28System.Int32%29&gt;</ph>.</source>
          <target state="translated">Para crear un <ph id="ph1">`MemoryStream`</ph> instancia con un búfer públicamente visible, utilice <ph id="ph2">&lt;xref:System.IO.MemoryStream.%23ctor%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>, o <ph id="ph4">&lt;xref:System.IO.MemoryStream.%23ctor%28System.Int32%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>If the current stream is resizable, two calls to this method do not return the same array if the underlying byte array is resized between calls.</source>
          <target state="translated">Si la secuencia actual es de tamaño variable, dos llamadas a este método no devuelven la misma matriz si se cambia el tamaño de la matriz de bytes subyacente entre llamadas.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información adicional, vea <ph id="ph1">&lt;xref:System.IO.MemoryStream.Capacity%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>This method works when the memory stream is closed.</source>
          <target state="translated">Este método funciona cuando se cierra la secuencia de memoria.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.GetBuffer">
          <source>The <ph id="ph1">&lt;see langword="MemoryStream" /&gt;</ph> instance was not created with a publicly visible buffer.</source>
          <target state="translated">La instancia de <ph id="ph1">&lt;see langword="MemoryStream" /&gt;</ph> no se ha creado con un búfer públicamente visible.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Length">
          <source>Gets the length of the stream in bytes.</source>
          <target state="translated">Obtiene la longitud de la secuencia en bytes.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Length">
          <source>The length of the stream in bytes.</source>
          <target state="translated">Longitud de la secuencia en bytes.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Length">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Length">
          <source>The stream is closed.</source>
          <target state="translated">La secuencia está cerrada.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Position">
          <source>Gets or sets the current position within the stream.</source>
          <target state="translated">Obtiene o establece la posición actual dentro de la secuencia.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Position">
          <source>The current position within the stream.</source>
          <target state="translated">Posición actual dentro de la secuencia.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.MemoryStream.Position">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Position">
          <source>The position is set to a negative value or a value greater than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La posición está establecida en un valor negativo o un valor mayor que <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="P:System.IO.MemoryStream.Position">
          <source>The stream is closed.</source>
          <target state="translated">La secuencia está cerrada.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>When this method returns, contains the specified byte array with the values between <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept> and (<bpt id="p2">&lt;c&gt;</bpt>offset<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1) replaced by the characters read from the current stream.</source>
          <target state="translated">Cuando este método finaliza, contiene la matriz de bytes especificada con los valores comprendidos entre <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept> y (<bpt id="p2">&lt;c&gt;</bpt>offset<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1) reemplazada por los caracteres leídos de la secuencia actual.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin storing data from the current stream.</source>
          <target state="translated">Desplazamiento de bytes de base cero de <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> en el que se va a empezar a almacenar datos de la secuencia actual.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">Número máximo de bytes que se pueden leer.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Reads a block of bytes from the current stream and writes the data to a buffer.</source>
          <target state="translated">Lee un bloque de bytes de la secuencia actual y escribe los datos en un búfer.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The total number of bytes written into the buffer.</source>
          <target state="translated">Número total de bytes escritos en el búfer.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This can be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached before any bytes are read.</source>
          <target state="translated">Puede ser menor que el número de bytes solicitado si ese número de bytes no está disponible, o bien puede ser cero si se alcanza el final de la secuencia antes de que se lea algún byte.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Read%2A&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.Read%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`offset`</ph> parameter gives the offset of the first byte in <ph id="ph2">`buffer`</ph> to which data from the current stream is written.</source>
          <target state="translated">El <ph id="ph1">`offset`</ph> parámetro indica el desplazamiento del primer byte de <ph id="ph2">`buffer`</ph> se escriban los datos de la secuencia actual.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`count`</ph> parameter gives the maximum number of bytes to read from the current stream.</source>
          <target state="translated">El <ph id="ph1">`count`</ph> parámetro indica el número máximo de bytes que se leen de la secuencia actual.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</source>
          <target state="translated">El valor devuelto es el número real de bytes leídos, o cero si se alcanza el final de la secuencia.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If the read operation is successful, the current position within the stream advances by the number of bytes read.</source>
          <target state="translated">Si la operación de lectura se realiza correctamente, la posición actual dentro de la secuencia avanza según el número de bytes leídos.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If an exception occurs, the current position within the stream remains unchanged.</source>
          <target state="translated">Si se produce una excepción, no cambie la posición actual dentro de la secuencia.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`Read`</ph> method will return zero only if the end of the stream is reached.</source>
          <target state="translated">El <ph id="ph1">`Read`</ph> método devolverá cero sólo si se alcanza el final de la secuencia.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>In all other cases, <ph id="ph1">`Read`</ph> always reads at least one byte from the stream before returning.</source>
          <target state="translated">En todos los demás casos, <ph id="ph1">`Read`</ph> siempre lee al menos un byte de la secuencia antes de devolver.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>By definition, if no data is available from the stream upon a call to <ph id="ph1">`Read`</ph>, the <ph id="ph2">`Read`</ph> method returns zero (the end of the stream is reached automatically).</source>
          <target state="translated">Por definición, si no hay datos disponibles en la secuencia tras una llamada a <ph id="ph1">`Read`</ph>, el <ph id="ph2">`Read`</ph> método devuelva cero (el final de la secuencia se alcanza de forma automática).</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</source>
          <target state="translated">Una implementación es gratuita devolver menos bytes de los solicitados incluso si no se ha alcanzado el final de la secuencia.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> for reading primitive data types.</source>
          <target state="translated">Utilice <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> para leer los tipos de datos primitivos.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If the byte array specified in the <ph id="ph1">`buffer`</ph> parameter is the underlying buffer returned by the <ph id="ph2">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> method, the array contents are overwritten, and no exception is thrown.</source>
          <target state="translated">Si la matriz de bytes especificado en el <ph id="ph1">`buffer`</ph> parámetro es el búfer subyacente que devuelve el <ph id="ph2">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> método, se sobrescribe el contenido de la matriz y se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> subtracted from the buffer length is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph>, restado de la longitud de búfer, es menor que <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The current stream instance is closed.</source>
          <target state="translated">La instancia de la secuencia actual está cerrada.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write the data into.</source>
          <target state="translated">Búfer en el que se escriben los datos.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin writing data from the stream.</source>
          <target state="translated">Desplazamiento de bytes de <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> donde se van a empezar a escribir datos de la secuencia.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">Número máximo de bytes que se pueden leer.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Token para supervisar solicitudes de cancelación.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The default value is <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</source>
          <target state="translated">Lee de forma asincrónica una secuencia de bytes en la secuencia actual, se hace avanzar la posición dentro de la secuencia el número de bytes leídos y controla las solicitudes de cancelación.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous read operation.</source>
          <target state="translated">Tarea que representa la operación de lectura asincrónica.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The value of the <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> parameter contains the total number of bytes read into the buffer.</source>
          <target state="translated">El valor del parámetro <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> contiene el número total de bytes leídos en el búfer.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</source>
          <target state="translated">El valor del resultado puede ser menor que el número de bytes solicitados si el número de bytes disponibles actualmente es menor que el número solicitado o puede ser 0 (cero) si se ha llegado al final de la secuencia.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">Si la operación se cancela antes de que finalice, la tarea devuelta contiene la <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> valor para el <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>You can create a cancellation token by creating an instance of the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> class and passing the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> property as the <ph id="ph3">`cancellationToken`</ph> parameter.</source>
          <target state="translated">Puede crear un token de cancelación mediante la creación de una instancia de la <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> clase y pasar la <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> propiedad como el <ph id="ph3">`cancellationToken`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated">La suma de <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es mayor que la longitud del búfer.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream does not support reading.</source>
          <target state="translated">La secuencia no admite lectura.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">Se ha eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream is currently in use by a previous read operation.</source>
          <target state="translated">Una operación de lectura anterior está usando actualmente la secuencia.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadByte">
          <source>Reads a byte from the current stream.</source>
          <target state="translated">Lee un byte de la secuencia actual.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadByte">
          <source>The byte cast to a <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>, or -1 if the end of the stream has been reached.</source>
          <target state="translated">El byte convertido en un <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> o -1 si se llega al final de la secuencia.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadByte">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.ReadByte%2A&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.ReadByte%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadByte">
          <source>If the read operation is successful, the current position within the stream is advanced by one byte.</source>
          <target state="translated">Si la operación de lectura se realiza correctamente, se adelanta la posición actual dentro de la secuencia en un byte.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadByte">
          <source>If an exception occurs, the current position within the stream is unchanged.</source>
          <target state="translated">Si se produce una excepción, no se modifica la posición actual dentro de la secuencia.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ReadByte">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ReadByte">
          <source>The current stream instance is closed.</source>
          <target state="translated">La instancia de la secuencia actual está cerrada.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The new position within the stream.</source>
          <target state="translated">Nueva posición dentro de la secuencia.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>This is relative to the <bpt id="p1">&lt;c&gt;</bpt>loc<ept id="p1">&lt;/c&gt;</ept> parameter, and can be positive or negative.</source>
          <target state="translated">Está relacionada con el parámetro <bpt id="p1">&lt;c&gt;</bpt>loc<ept id="p1">&lt;/c&gt;</ept> y puede ser positiva o negativa.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>A value of type <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>, which acts as the seek reference point.</source>
          <target state="translated">Valor de tipo <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>, que actúa como el punto de referencia de las operaciones de búsqueda.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Sets the position within the current stream to the specified value.</source>
          <target state="translated">Establece la posición dentro de la secuencia actual en el valor especificado.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The new position within the stream, calculated by combining the initial reference point and the offset.</source>
          <target state="translated">Nueva posición dentro de la secuencia, calculada mediante la combinación del punto de referencia inicial y del desplazamiento.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Seeking to any location beyond the length of the stream is supported.</source>
          <target state="translated">Se admite la búsqueda en cualquier ubicación más allá de la longitud de la secuencia.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Do not use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> method to determine the new position in the stream if the <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph> was initialized with a non-zero offset.</source>
          <target state="translated">No utilice la <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> método para determinar la nueva posición en la secuencia, si la <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph> se inicializó con un desplazamiento distinto de cero.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>If you do, <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> will return an inaccurate value.</source>
          <target state="translated">Si lo hace, <ph id="ph1">&lt;xref:System.IO.MemoryStream.Seek%2A&gt;</ph> devolverá un valor inexacto.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Instead, use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.Position%2A&gt;</ph> property to get the new position of the stream.</source>
          <target state="translated">En su lugar, use la <ph id="ph1">&lt;xref:System.IO.MemoryStream.Position%2A&gt;</ph> propiedad que se va a obtener la nueva posición de la secuencia.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Seeking is attempted before the beginning of the stream.</source>
          <target state="translated">La búsqueda se intenta antes del comienzo de la secuencia.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> es mayor que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>There is an invalid <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>.</source>
          <target state="translated">Hay un <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph> no válido.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> caused an arithmetic overflow.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> produjo un desbordamiento aritmético.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The current stream instance is closed.</source>
          <target state="translated">La instancia de la secuencia actual está cerrada.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>The value at which to set the length.</source>
          <target state="translated">Valor en el que establecer la longitud.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>Sets the length of the current stream to the specified value.</source>
          <target state="translated">Establece la longitud de la secuencia actual en el valor especificado.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.SetLength%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>If the specified value is less than the current length of the stream, the stream is truncated.</source>
          <target state="translated">Si el valor especificado es menor que la longitud actual de la secuencia, se trunca la secuencia.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>If after the truncation the current position within the stream is past the end of the stream, the <ph id="ph1">&lt;xref:System.IO.MemoryStream.ReadByte%2A&gt;</ph> method returns -1, the <ph id="ph2">&lt;xref:System.IO.MemoryStream.Read%2A&gt;</ph> method reads zero bytes into the provided byte array, and <ph id="ph3">&lt;xref:System.IO.MemoryStream.Write%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.IO.MemoryStream.WriteByte%2A&gt;</ph> methods append specified bytes at the end of the stream, increasing its length.</source>
          <target state="translated">Si el truncamiento la posición actual dentro de la secuencia está más allá del final de la secuencia, el <ph id="ph1">&lt;xref:System.IO.MemoryStream.ReadByte%2A&gt;</ph> método devuelve -1, el <ph id="ph2">&lt;xref:System.IO.MemoryStream.Read%2A&gt;</ph> método lee cero bytes en la matriz de bytes proporcionada, y <ph id="ph3">&lt;xref:System.IO.MemoryStream.Write%2A&gt;</ph> y <ph id="ph4">&lt;xref:System.IO.MemoryStream.WriteByte%2A&gt;</ph> métodos anexarán bytes especificados al final de la secuencia, aumentar su longitud.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>If the specified value is larger than the current capacity and the stream is resizable, the capacity is increased, and the current position within the stream is unchanged.</source>
          <target state="translated">Si el valor especificado es mayor que la capacidad actual y la secuencia es de tamaño variable, se aumenta la capacidad y la posición actual dentro de la secuencia se ha modificado.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>If the length is increased, the contents of the stream between the old and the new length are initialized to zeros.</source>
          <target state="translated">Si se aumenta la longitud, el contenido de la secuencia entre la antigua y la nueva longitud se inicializa a los ceros.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>A <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> instance must support writing for this method to work.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> instancia debe admitir la escritura para este método funcione.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> property to determine whether the current instance supports writing.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.IO.MemoryStream.CanWrite%2A&gt;</ph> propiedad para determinar si la instancia actual admite escritura.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>For additional information, see <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</source>
          <target state="translated">Para obtener información adicional, vea <ph id="ph1">&lt;xref:System.IO.Stream.CanWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>The current stream is not resizable and <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is larger than the current capacity.</source>
          <target state="translated">La secuencia actual no es de tamaño variable y <ph id="ph1">&lt;paramref name="value" /&gt;</ph> es mayor que la capacidad actual.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source>The current stream does not support writing.</source>
          <target state="translated">La secuencia actual no admite escritura.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.SetLength(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is negative or is greater than the maximum length of the <ph id="ph2">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph>, where the maximum length is(<ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> - origin), and origin is the index into the underlying buffer at which the stream starts.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> es negativo o mayor que la longitud máxima de <ph id="ph2">&lt;see cref="T:System.IO.MemoryStream" /&gt;</ph>, donde la longitud máxima es (<ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>-origen) y el origen es el índice del búfer subyacente donde comienza la secuencia.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ToArray">
          <source>Writes the stream contents to a byte array, regardless of the <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.Position" /&gt;</ph> property.</source>
          <target state="translated">Escribe el contenido de la secuencia en una matriz de bytes, independientemente de la propiedad <ph id="ph1">&lt;see cref="P:System.IO.MemoryStream.Position" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.ToArray">
          <source>A new byte array.</source>
          <target state="translated">Nueva matriz de bytes.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>This method omits unused bytes in <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> from the array.</source>
          <target state="translated">Este método omite los bytes en <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> de la matriz.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>To get the entire buffer, use the <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> method.</source>
          <target state="translated">Para obtener el búfer completo, utilice el <ph id="ph1">&lt;xref:System.IO.MemoryStream.GetBuffer%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>This method returns a copy of the contents of the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> as a byte array.</source>
          <target state="translated">Este método devuelve una copia del contenido de la <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> como una matriz de bytes.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>If the current instance was constructed on a provided byte array, a copy of the section of the array to which this instance has access is returned.</source>
          <target state="translated">Si la instancia actual se construyó en una matriz de bytes proporcionada, se devuelve una copia de la sección de la matriz a la que esta instancia tiene acceso.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>See the <ph id="ph1">&lt;xref:System.IO.MemoryStream.%23ctor%2A&gt;</ph> constructor for details.</source>
          <target state="translated">Consulte la <ph id="ph1">&lt;xref:System.IO.MemoryStream.%23ctor%2A&gt;</ph> constructor para obtener más información.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.ToArray">
          <source>This method works when the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> is closed.</source>
          <target state="translated">Este método funciona cuando la <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> está cerrado.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)">
          <source>The byte array segment from which this stream was created.</source>
          <target state="translated">El segmento de matriz de bytes desde el que se creó esta secuencia.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)">
          <source>Returns the array of unsigned bytes from which this stream was created.</source>
          <target state="translated">Devuelve la matriz de bytes sin signo a partir de la cual se creó esta secuencia.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)">
          <source>The return value indicates whether the conversion succeeded.</source>
          <target state="translated">El valor devuelto indica si la conversión se realizó correctamente.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the conversion was successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la conversión se realiza correctamente; en caso contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The buffer to write data from.</source>
          <target state="translated">Búfer del que se van a escribir datos.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin copying bytes to the current stream.</source>
          <target state="translated">Desplazamiento de bytes de base cero de <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> en donde se van a empezar a copiar bytes en la secuencia actual.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Número máximo de bytes que se pueden escribir.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Writes a block of bytes to the current stream using data read from a buffer.</source>
          <target state="translated">Escribe un bloque de bytes en la secuencia actual usando los datos leídos en un búfer.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`offset`</ph> parameter gives the offset of the first byte in <ph id="ph2">`buffer`</ph> to write from, and the <ph id="ph3">`count`</ph> parameter gives the number of bytes to write.</source>
          <target state="translated">El <ph id="ph1">`offset`</ph> parámetro indica el desplazamiento del primer byte de <ph id="ph2">`buffer`</ph> desde el que escribir y <ph id="ph3">`count`</ph> parámetro proporciona el número de bytes que se va a escribir.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>If the write operation is successful, the current position within the stream is advanced by the number of bytes written.</source>
          <target state="translated">Si la operación de escritura se realiza correctamente, la posición actual dentro de la secuencia se avanza por el número de bytes escritos.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>If an exception occurs, the current position within the stream is unchanged.</source>
          <target state="translated">Si se produce una excepción, no se modifica la posición actual dentro de la secuencia.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Except for a <ph id="ph1">`MemoryStream`</ph> constructed with a byte[] parameter, write operations at the end of a <ph id="ph2">`MemoryStream`</ph> expand the <ph id="ph3">`MemoryStream`</ph>.</source>
          <target state="translated">Excepto para un <ph id="ph1">`MemoryStream`</ph> construido con un parámetro byte [], escribir operaciones al final de un <ph id="ph2">`MemoryStream`</ph> expandir la <ph id="ph3">`MemoryStream`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The stream does not support writing.</source>
          <target state="translated">La secuencia no admite escritura.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>For additional information see <ph id="ph1">&lt;see cref="P:System.IO.Stream.CanWrite" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="P:System.IO.Stream.CanWrite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The current position is closer than <ph id="ph1">&lt;paramref name="count" /&gt;</ph> bytes to the end of the stream, and the capacity cannot be modified.</source>
          <target state="translated">La posición actual se encuentra más cerca que <ph id="ph1">&lt;paramref name="count" /&gt;</ph> bytes al final de la secuencia, y la capacidad no puede modificar.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> subtracted from the buffer length is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph>, restado de la longitud de búfer, es menor que <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> are negative.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>An I/O error occurs.</source>
          <target state="translated">Error de E/S.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The current stream instance is closed.</source>
          <target state="translated">La instancia de la secuencia actual está cerrada.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write data from.</source>
          <target state="translated">Búfer del que se van a escribir datos.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> from which to begin copying bytes to the stream.</source>
          <target state="translated">Desplazamiento de bytes de base cero de <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> desde donde se van a empezar a copiar bytes en la secuencia.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Número máximo de bytes que se pueden escribir.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Token para supervisar solicitudes de cancelación.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The default value is <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</source>
          <target state="translated">Escribe de forma asincrónica una secuencia de bytes en la secuencia actual, se hace avanzar la posición actual dentro de la secuencia por el número de bytes escritos y controla las solicitudes de cancelación.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous write operation.</source>
          <target state="translated">Tarea que representa la operación de escritura asincrónica.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If the operation is canceled before it completes, the returned task contains the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> value for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">Si la operación se cancela antes de que finalice, la tarea devuelta contiene la <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> valor para el <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>You can create a cancellation token by creating an instance of the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> class and passing the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> property as the <ph id="ph3">`cancellationToken`</ph> parameter.</source>
          <target state="translated">Puede crear un token de cancelación mediante la creación de una instancia de la <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> clase y pasar la <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> propiedad como el <ph id="ph3">`cancellationToken`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated">La suma de <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es mayor que la longitud del búfer.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream does not support writing.</source>
          <target state="translated">La secuencia no admite escritura.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">Se ha eliminado la secuencia.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream is currently in use by a previous write operation.</source>
          <target state="translated">La secuencia está actualmente en uso por una operación de escritura anterior.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>The byte to write.</source>
          <target state="translated">Byte que se va a escribir.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>Writes a byte to the current stream at the current position.</source>
          <target state="translated">Escribe un byte en la posición actual de la secuencia actual.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph>.</source>
          <target state="translated">Este método invalida <ph id="ph1">&lt;xref:System.IO.Stream.WriteByte%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>Except for a <ph id="ph1">`MemoryStream`</ph> constructed with a byte[] parameter, write operations at the end of a <ph id="ph2">`MemoryStream`</ph> expand the <ph id="ph3">`MemoryStream`</ph>.</source>
          <target state="translated">Excepto para un <ph id="ph1">`MemoryStream`</ph> construido con un parámetro byte [], escribir operaciones al final de un <ph id="ph2">`MemoryStream`</ph> expandir la <ph id="ph3">`MemoryStream`</ph>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> class.</source>
          <target state="translated">Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <ph id="ph1">&lt;xref:System.IO.MemoryStream&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>The stream does not support writing.</source>
          <target state="translated">La secuencia no admite escritura.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>For additional information see <ph id="ph1">&lt;see cref="P:System.IO.Stream.CanWrite" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="P:System.IO.Stream.CanWrite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>The current position is at the end of the stream, and the capacity cannot be modified.</source>
          <target state="translated">La posición actual se encuentra al final de la secuencia y la capacidad no se puede modificar.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteByte(System.Byte)">
          <source>The current stream is closed.</source>
          <target state="translated">Se cierra la secuencia actual.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)">
          <source>The stream to write this memory stream to.</source>
          <target state="translated">Secuencia en la que se va a escribir esta secuencia de memoria.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)">
          <source>Writes the entire contents of this memory stream to another stream.</source>
          <target state="translated">Escribe el contenido completo de esta secuencia de memoria en otra secuencia.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)">
          <source>When the current stream is open, this method is equivalent to calling <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A?displayProperty=nameWithType&gt;</ph> on the underlying buffer of this stream.</source>
          <target state="translated">Una vez abierta la secuencia actual, este método es equivalente a llamar a <ph id="ph1">&lt;xref:System.IO.Stream.Write%2A?displayProperty=nameWithType&gt;</ph> en el búfer subyacente de esta secuencia.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)">
          <source>The current or target stream is closed.</source>
          <target state="translated">La secuencia actual o de destino está cerrada.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>