<Type Name="StringReader" FullName="System.IO.StringReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7b372a0f82b383e5dfe2e2746f416d1a0e18d2f8" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39846549" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class StringReader : System.IO.TextReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StringReader extends System.IO.TextReader" />
  <TypeSignature Language="DocId" Value="T:System.IO.StringReader" />
  <TypeSignature Language="VB.NET" Value="Public Class StringReader&#xA;Inherits TextReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringReader : System::IO::TextReader" />
  <TypeSignature Language="F#" Value="type StringReader = class&#xA;    inherit TextReader" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementa <see cref="T:System.IO.TextReader" /> que lee en una cadena.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StringReader> le permite leer una cadena de forma sincrónica o asincrónica. Puede leer un carácter a la vez con el <xref:System.IO.StringReader.Read%2A> o el <xref:System.IO.StringReader.ReadAsync%2A> método, una línea en un momento mediante el <xref:System.IO.StringReader.ReadLine%2A> o <xref:System.IO.StringReader.ReadLineAsync%2A> método y una cadena completa con el <xref:System.IO.StringReader.ReadToEnd%2A> o el <xref:System.IO.StringReader.ReadToEndAsync%2A> método.  
  
[!INCLUDE[note_unnecessary_dispose](~/includes/note-unnecessary-dispose.md)]
  
 En la tabla siguiente se muestra ejemplos de otras tareas de E/S típicas o relacionadas.  
  
|Para...|Vea el ejemplo de este tema...|  
|-------------------|--------------------------------------|  
|Crear un archivo de texto|[Cómo: Escribir texto en un archivo](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Escribir en un archivo de texto.|[Cómo: Escribir texto en un archivo](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Leer de un archivo de texto.|[Cómo: Leer texto de un archivo](~/docs/standard/io/how-to-read-text-from-a-file.md)|  
|Anexar texto a un archivo.|[Cómo: Abrir y anexar a un archivo de registro](~/docs/standard/io/how-to-open-and-append-to-a-log-file.md)<br /><br /> <xref:System.IO.File.AppendText%2A?displayProperty=nameWithType><br /><br /> <xref:System.IO.FileInfo.AppendText%2A?displayProperty=nameWithType>|  
|Obtiene el tamaño de un archivo.|<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>|  
|Obtener los atributos de un archivo.|<xref:System.IO.File.GetAttributes%2A?displayProperty=nameWithType>|  
|Establezca los atributos de un archivo.|<xref:System.IO.File.SetAttributes%2A?displayProperty=nameWithType>|  
|Determinar si existe un archivo.|<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>|  
|Leer de un archivo binario.|[Cómo: Leer y escribir en un archivo de datos recién creado](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
|Escribir en un archivo binario.|[Cómo: Leer y escribir en un archivo de datos recién creado](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo leer una cadena completa de forma asincrónica.  
  
 [!code-csharp[System.IO.StringReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stringreader/cs/example2.cs#2)]
 [!code-vb[System.IO.StringReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stringreader/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.TextReader" />
    <altmember cref="T:System.IO.StringWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringReader (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringReader(System::String ^ s);" />
      <MemberSignature Language="F#" Value="new System.IO.StringReader : string -&gt; System.IO.StringReader" Usage="new System.IO.StringReader s" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Cadena en la que <see cref="T:System.IO.StringReader" /> debe inicializarse.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.StringReader" /> que lee en la cadena especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra ejemplos de otras tareas de E/S típicas o relacionadas.  
  
|Para...|Vea el ejemplo de este tema...|  
|-------------------|--------------------------------------|  
|Crear un archivo de texto|[Cómo: Escribir texto en un archivo](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Escribir en un archivo de texto.|[Cómo: Escribir texto en un archivo](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Leer de un archivo de texto.|[Cómo: Leer texto de un archivo](~/docs/standard/io/how-to-read-text-from-a-file.md)|  
|Anexar texto a un archivo.|[Cómo: Abrir y anexar a un archivo de registro](~/docs/standard/io/how-to-open-and-append-to-a-log-file.md)<br /><br /> <xref:System.IO.File.AppendText%2A?displayProperty=nameWithType><br /><br /> <xref:System.IO.FileInfo.AppendText%2A?displayProperty=nameWithType>|  
|Obtiene el tamaño de un archivo.|<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>|  
|Obtener los atributos de un archivo.|<xref:System.IO.File.GetAttributes%2A?displayProperty=nameWithType>|  
|Establezca los atributos de un archivo.|<xref:System.IO.File.SetAttributes%2A?displayProperty=nameWithType>|  
|Determinar si existe un archivo.|<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>|  
|Leer de un archivo binario.|[Cómo: Leer y escribir en un archivo de datos recién creado](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
|Escribir en un archivo binario.|[Cómo: Leer y escribir en un archivo de datos recién creado](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.IO.StringReader> clase.  
  
 [!code-cpp[System.IO.StringReaderWriter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StringReaderWriter/CPP/stringrw.cpp#2)]
 [!code-csharp[System.IO.StringReaderWriter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StringReaderWriter/CS/stringrw.cs#2)]
 [!code-vb[System.IO.StringReaderWriter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StringReaderWriter/VB/stringrw.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="s" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="stringReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra el objeto <see cref="T:System.IO.StringReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener un ejemplo de creación de un archivo y escribir texto en un archivo, consulte [Cómo: escribir texto en un archivo](~/docs/standard/io/how-to-write-text-to-a-file.md). Para obtener un ejemplo de cómo leer texto desde un archivo, consulte [Cómo: leer texto desde un archivo](~/docs/standard/io/how-to-read-text-from-a-file.md). Para obtener un ejemplo de cómo leer y escribir en un archivo binario, vea [Cómo: leer y escribir en un recién creado archivo de datos](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md).  
  
 Este método invalida el <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> método.  
  
 Esta implementación de `Close` llamadas la <xref:System.IO.StringReader.Dispose%2A> método pasando un `true` valor.  
  
 Vaciar la secuencia no hará que vacíe su codificador subyacente a menos que se llame explícitamente a `Close`. Establecer <xref:System.IO.StreamWriter.AutoFlush%2A> a `true` significa que los datos del búfer se vaciará en el flujo, pero no se vaciará el estado del codificador. Esto permite al codificador mantener su estado (caracteres parciales) para que puede codificar correctamente el siguiente bloque de caracteres. Esta situación afecta a UTF8 y UTF7 donde ciertos caracteres solo se pueden codificar después de que el codificador reciba el carácter o caracteres adyacentes.  
  
 Después de una llamada a `Close`, otros métodos podrían generar una excepción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="stringReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.IO.StringReader" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.IO.StringReader> hace referencia. Este método invoca al método `Dispose` de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.StringReader.Dispose(System.Boolean)" /> puede llamarse varias veces por otros objetos. Cuando se reemplaza <see cref="M:System.IO.StringReader.Dispose(System.Boolean)" />, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see cref="M:System.IO.StringReader.Dispose(System.Boolean)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public override int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Peek () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Peek();" />
      <MemberSignature Language="F#" Value="override this.Peek : unit -&gt; int" Usage="stringReader.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el siguiente carácter disponible pero no lo consume.</summary>
        <returns>Un entero que representa el siguiente carácter que se va a leer, o -1 si no hay más caracteres disponibles o si la secuencia no admite la operación de búsqueda.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.StringReader.Peek%2A> método devuelve un valor entero con el fin de determinar si se ha producido el final del archivo o de otro error. Esto permite que un usuario compruebe primero si el valor devuelto es -1 antes de convertirlo a un <xref:System.Char> tipo.  
  
 Este método invalida el <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType> método.  
  
 La posición actual de la `StringReader` esta operación no se modifica.  
  
 En la tabla siguiente se muestra ejemplos de otras tareas de E/S típicas o relacionadas.  
  
|Para...|Vea el ejemplo de este tema...|  
|-------------------|--------------------------------------|  
|Crear un archivo de texto|[Cómo: Escribir texto en un archivo](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Escribir en un archivo de texto.|[Cómo: Escribir texto en un archivo](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Leer de un archivo de texto.|[Cómo: Leer texto de un archivo](~/docs/standard/io/how-to-read-text-from-a-file.md)|  
|Obtiene el tamaño de un archivo.|<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El sistema de lectura actual está cerrado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lee el siguiente carácter o el siguiente juego de caracteres de la cadena de entrada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; int" Usage="stringReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el siguiente carácter de la cadena de entrada y hace avanzar la posición de los caracteres en un carácter.</summary>
        <returns>Siguiente carácter de la cadena subyacente, o -1 si no hay más caracteres disponibles.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida el <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType> método.  
  
 En la tabla siguiente se muestra ejemplos de otras tareas de E/S típicas o relacionadas.  
  
|Para...|Vea el ejemplo de este tema...|  
|-------------------|--------------------------------------|  
|Crear un archivo de texto|[Cómo: Escribir texto en un archivo](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Escribir en un archivo de texto.|[Cómo: Escribir texto en un archivo](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Leer de un archivo de texto.|[Cómo: Leer texto de un archivo](~/docs/standard/io/how-to-read-text-from-a-file.md)|  
|Anexar texto a un archivo.|[Cómo: Abrir y anexar a un archivo de registro](~/docs/standard/io/how-to-open-and-append-to-a-log-file.md)<br /><br /> <xref:System.IO.File.AppendText%2A?displayProperty=nameWithType><br /><br /> <xref:System.IO.FileInfo.AppendText%2A?displayProperty=nameWithType>|  
|Obtiene el tamaño de un archivo.|<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>|  
|Obtener los atributos de un archivo.|<xref:System.IO.File.GetAttributes%2A?displayProperty=nameWithType>|  
|Establezca los atributos de un archivo.|<xref:System.IO.File.SetAttributes%2A?displayProperty=nameWithType>|  
|Determinar si existe un archivo.|<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>|  
|Leer de un archivo binario.|[Cómo: Leer y escribir en un archivo de datos recién creado](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
|Escribir en un archivo binario.|[Cómo: Leer y escribir en un archivo de datos recién creado](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.IO.StringReader> clase.  
  
 [!code-cpp[System.IO.StringReaderWriter#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StringReaderWriter/CPP/stringrw.cpp#3)]
 [!code-csharp[System.IO.StringReaderWriter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StringReaderWriter/CS/stringrw.cs#3)]
 [!code-vb[System.IO.StringReaderWriter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StringReaderWriter/VB/stringrw.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El sistema de lectura actual está cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;char&gt; -&gt; int" Usage="stringReader.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : char[] * int * int -&gt; int" Usage="stringReader.Read (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Cuando este método finaliza, contiene la matriz de caracteres especificada con los valores comprendidos entre <c>index</c> e (<c>index</c> + <c>count</c> - 1) reemplazada por los caracteres leídos del origen actual.</param>
        <param name="index">Índice inicial del búfer.</param>
        <param name="count">Número de caracteres que se va a leer.</param>
        <summary>Lee un bloque de caracteres de la cadena de entrada y hace avanzar la posición de los caracteres en <paramref name="count" />.</summary>
        <returns>Número total de caracteres leídos en el búfer. Puede ser menor que el número de caracteres solicitado si dicho número de caracteres no está disponible, o puede ser cero si se alcanza el final de la cadena subyacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 El método leerá hasta `count` caracteres desde la <xref:System.IO.StringReader> en el `buffer` matriz de caracteres a partir de posición `index`. Devuelve el número real de caracteres de lectura, o cero si se alcanzó el final de la cadena y no se lee ningún carácter.  
  
 En la tabla siguiente se muestra ejemplos de otras tareas de E/S típicas o relacionadas.  
  
|Para...|Vea el ejemplo de este tema...|  
|-------------------|--------------------------------------|  
|Crear un archivo de texto|[Cómo: Escribir texto en un archivo](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Escribir en un archivo de texto.|[Cómo: Escribir texto en un archivo](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Leer de un archivo de texto.|[Cómo: Leer texto de un archivo](~/docs/standard/io/how-to-read-text-from-a-file.md)|  
|Anexar texto a un archivo.|[Cómo: Abrir y anexar a un archivo de registro](~/docs/standard/io/how-to-open-and-append-to-a-log-file.md)<br /><br /> <xref:System.IO.File.AppendText%2A?displayProperty=nameWithType><br /><br /> <xref:System.IO.FileInfo.AppendText%2A?displayProperty=nameWithType>|  
|Obtiene el tamaño de un archivo.|<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>|  
|Obtener los atributos de un archivo.|<xref:System.IO.File.GetAttributes%2A?displayProperty=nameWithType>|  
|Establezca los atributos de un archivo.|<xref:System.IO.File.SetAttributes%2A?displayProperty=nameWithType>|  
|Determinar si existe un archivo.|<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>|  
|Leer de un archivo binario.|[Cómo: Leer y escribir en un archivo de datos recién creado](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
|Escribir en un archivo binario.|[Cómo: Leer y escribir en un archivo de datos recién creado](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La longitud del búfer menos <paramref name="index" /> es menor que <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">El sistema de lectura actual está cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="stringReader.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stringReader.ReadAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Cuando este método finaliza, contiene la matriz de caracteres especificada con los valores comprendidos entre <c>index</c> e (<c>index</c> + <c>count</c> - 1) reemplazada por los caracteres leídos del origen actual.</param>
        <param name="index">La posición de <c>buffer</c> en la que se va a iniciar la escritura.</param>
        <param name="count">Número máximo de caracteres que se van a leer. Si el final de la cadena se alcanza antes de escribir el número de caracteres especificado en el búfer, el método vuelve.</param>
        <summary>Lee de forma asincrónica un número máximo de caracteres especificado en la cadena actual y escribe los datos en un búfer, comenzando en el índice especificado.</summary>
        <returns>Tarea que representa la operación de lectura asincrónica. El valor del parámetro <paramref name="TResult" /> contiene el número total de bytes leídos en el búfer. El valor del resultado puede ser menor que el número de bytes solicitados si el número de bytes disponibles actualmente es menor que el número solicitado o puede ser 0 (cero) si se ha llegado al final de la cadena.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tarea completa después el número de caracteres especificados por el `count` parámetro se leen o se alcanza el final de la cadena.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo leer la primera vez 23 caracteres de una cadena de forma asincrónica.  
  
 [!code-csharp[System.IO.StringReader#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stringreader/cs/example1.cs#1)]
 [!code-vb[System.IO.StringReader#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stringreader/vb/example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.ArgumentException">La suma de <paramref name="index" /> y <paramref name="count" /> es mayor que la longitud del búfer.</exception>
        <exception cref="T:System.ObjectDisposedException">El lector de cadenas se ha desechado.</exception>
        <exception cref="T:System.InvalidOperationException">Una operación de lectura anterior está usando actualmente el lector.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadBlock(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : Span&lt;char&gt; -&gt; int" Usage="stringReader.ReadBlock buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadBlockAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadBlockAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadBlockAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="stringReader.ReadBlockAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlockAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadBlockAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stringReader.ReadBlockAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Cuando este método finaliza, contiene la matriz de caracteres especificada con los valores comprendidos entre <c>index</c> e (<c>index</c> + <c>count</c> - 1) reemplazada por los caracteres leídos del origen actual.</param>
        <param name="index">La posición de <c>buffer</c> en la que se va a iniciar la escritura.</param>
        <param name="count">Número máximo de caracteres que se van a leer. Si el final de la cadena se alcanza antes de escribir el número de caracteres especificado en el búfer, el método vuelve.</param>
        <summary>Lee de forma asincrónica un número máximo de caracteres especificado en la cadena actual y escribe los datos en un búfer, comenzando en el índice especificado.</summary>
        <returns>Tarea que representa la operación de lectura asincrónica. El valor del parámetro <paramref name="TResult" /> contiene el número total de bytes leídos en el búfer. El valor del resultado puede ser menor que el número de bytes solicitados si el número de bytes disponibles actualmente es menor que el número solicitado o puede ser 0 (cero) si se ha llegado al final de la cadena.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tarea no completa hasta que el número de caracteres especificados por el `count` parámetro se leen o se alcanzó el final de la cadena.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.ArgumentException">La suma de <paramref name="index" /> y <paramref name="count" /> es mayor que la longitud del búfer.</exception>
        <exception cref="T:System.ObjectDisposedException">El lector de cadenas se ha desechado.</exception>
        <exception cref="T:System.InvalidOperationException">Una operación de lectura anterior está usando actualmente el lector.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public override string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="override this.ReadLine : unit -&gt; string" Usage="stringReader.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee una línea de caracteres de la cadena actual y devuelve los datos como una cadena.</summary>
        <returns>Línea siguiente de la cadena actual, o <see langword="null" /> si se alcanza el final de la cadena.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida el <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType> método.  
  
 Una línea se define como fuente de una secuencia de caracteres seguida de una línea ("\n"), un retorno de carro "(\r) o un retorno de carro seguido inmediatamente por una línea de avance ("\r\n"). La cadena devuelta no contiene la terminación de retorno de carro o avance de línea. El valor devuelto es `null` si se ha alcanzado el final de la cadena.  
  
 Si el método actual produce una <xref:System.OutOfMemoryException>, avanza la posición del lector en la cadena subyacente por el número de caracteres que el método fue capaz de leer, pero los caracteres ya leídos en el interno <xref:System.IO.StringReader.ReadLine%2A> búfer se descartan. Porque no se puede cambiar la posición del lector en la cadena, los caracteres leídos ya son irrecuperables y puede tener acceso a solo reinicializando la <xref:System.IO.StringReader>. Para evitar esta situación, utilice el <xref:System.IO.StringReader.Read%2A> método y el almacén de los caracteres de lectura en un búfer preasignado.  
  
 En la tabla siguiente se muestra ejemplos de otras tareas de E/S típicas o relacionadas.  
  
|Para...|Vea el ejemplo de este tema...|  
|-------------------|--------------------------------------|  
|Crear un archivo de texto|[Cómo: Escribir texto en un archivo](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Escribir en un archivo de texto.|[Cómo: Escribir texto en un archivo](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Leer de un archivo de texto.|[Cómo: Leer texto de un archivo](~/docs/standard/io/how-to-read-text-from-a-file.md)|  
|Anexar texto a un archivo.|[Cómo: Abrir y anexar a un archivo de registro](~/docs/standard/io/how-to-open-and-append-to-a-log-file.md)<br /><br /> <xref:System.IO.File.AppendText%2A?displayProperty=nameWithType><br /><br /> <xref:System.IO.FileInfo.AppendText%2A?displayProperty=nameWithType>|  
|Obtiene el tamaño de un archivo.|<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>|  
|Obtener los atributos de un archivo.|<xref:System.IO.File.GetAttributes%2A?displayProperty=nameWithType>|  
|Establezca los atributos de un archivo.|<xref:System.IO.File.SetAttributes%2A?displayProperty=nameWithType>|  
|Determinar si existe un archivo.|<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>|  
|Leer de un archivo binario.|[Cómo: Leer y escribir en un archivo de datos recién creado](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
|Escribir en un archivo binario.|[Cómo: Leer y escribir en un archivo de datos recién creado](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.IO.StringReader> clase.  
  
 [!code-cpp[System.IO.StringReaderWriter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StringReaderWriter/CPP/stringrw.cpp#2)]
 [!code-csharp[System.IO.StringReaderWriter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StringReaderWriter/CS/stringrw.cs#2)]
 [!code-vb[System.IO.StringReaderWriter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StringReaderWriter/VB/stringrw.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El sistema de lectura actual está cerrado.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay memoria suficiente para asignar un búfer para la cadena devuelta.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLineAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadLineAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadLineAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="stringReader.ReadLineAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee de forma asincrónica una línea de caracteres de la cadena actual y devuelve los datos como una cadena.</summary>
        <returns>Tarea que representa la operación de lectura asincrónica. El valor del parámetro <paramref name="TResult" /> contiene la línea siguiente del lector de cadenas, o es <see langword="null" /> si se han leído todos los caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra cómo leer de forma asincrónica una línea de una cadena al mismo tiempo.  
  
 [!code-csharp[System.IO.StringReader#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stringreader/cs/example3.cs#3)]
 [!code-vb[System.IO.StringReader#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stringreader/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de caracteres de la siguiente línea es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El lector de cadenas se ha desechado.</exception>
        <exception cref="T:System.InvalidOperationException">Una operación de lectura anterior está usando actualmente el lector.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public override string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="override this.ReadToEnd : unit -&gt; string" Usage="stringReader.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee todos los caracteres desde la posición actual hasta el final de la cadena y los devuelve como una cadena única.</summary>
        <returns>Contenido desde la posición actual hasta el final de la cadena subyacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida el <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType> método.  
  
 Si el método actual produce una <xref:System.OutOfMemoryException>, avanza la posición del lector en la cadena subyacente por el número de caracteres que el método fue capaz de leer, pero los caracteres ya leídos en el interno <xref:System.IO.StringReader.ReadToEnd%2A> búfer se descartan. Porque no se puede cambiar la posición del lector en la cadena, los caracteres leídos ya son irrecuperables y puede tener acceso a solo reinicializando la <xref:System.IO.StringReader>. Para evitar esta situación, utilice el <xref:System.IO.StringReader.Read%2A> método y el almacén de los caracteres de lectura en un búfer preasignado.  
  
 En la tabla siguiente se muestra ejemplos de otras tareas de E/S típicas o relacionadas.  
  
|Para...|Vea el ejemplo de este tema...|  
|-------------------|--------------------------------------|  
|Crear un archivo de texto|[Cómo: Escribir texto en un archivo](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Escribir en un archivo de texto.|[Cómo: Escribir texto en un archivo](~/docs/standard/io/how-to-write-text-to-a-file.md)|  
|Leer de un archivo de texto.|[Cómo: Leer texto de un archivo](~/docs/standard/io/how-to-read-text-from-a-file.md)|  
|Anexar texto a un archivo.|[Cómo: Abrir y anexar a un archivo de registro](~/docs/standard/io/how-to-open-and-append-to-a-log-file.md)<br /><br /> <xref:System.IO.File.AppendText%2A?displayProperty=nameWithType><br /><br /> <xref:System.IO.FileInfo.AppendText%2A?displayProperty=nameWithType>|  
|Obtiene el tamaño de un archivo.|<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>|  
|Obtener los atributos de un archivo.|<xref:System.IO.File.GetAttributes%2A?displayProperty=nameWithType>|  
|Establezca los atributos de un archivo.|<xref:System.IO.File.SetAttributes%2A?displayProperty=nameWithType>|  
|Determinar si existe un archivo.|<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>|  
|Leer de un archivo binario.|[Cómo: Leer y escribir en un archivo de datos recién creado](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
|Escribir en un archivo binario.|[Cómo: Leer y escribir en un archivo de datos recién creado](~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md)|  
  
   
  
## Examples  
 Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.IO.TextReader> clase.  
  
 [!code-cpp[System.IO.TextReaderWriter#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.TextReaderWriter/CPP/textrw.cpp#5)]
 [!code-csharp[System.IO.TextReaderWriter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.TextReaderWriter/CS/textrw.cs#5)]
 [!code-vb[System.IO.TextReaderWriter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.TextReaderWriter/VB/textrw.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">No hay memoria suficiente para asignar un búfer para la cadena devuelta.</exception>
        <exception cref="T:System.ObjectDisposedException">El sistema de lectura actual está cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StringReader.ReadToEndAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEndAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadToEndAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadToEndAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="stringReader.ReadToEndAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee de forma asincrónica todos los caracteres desde la posición actual hasta el final de la cadena y los devuelve como una cadena única.</summary>
        <returns>Tarea que representa la operación de lectura asincrónica. El valor del parámetro <paramref name="TResult" /> contiene una cadena con los caracteres desde la posición actual hasta el final de la cadena.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra cómo leer una cadena completa de forma asincrónica.  
  
 [!code-csharp[System.IO.StringReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stringreader/cs/example2.cs#2)]
 [!code-vb[System.IO.StringReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stringreader/vb/example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de caracteres es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El lector de cadenas se ha desechado.</exception>
        <exception cref="T:System.InvalidOperationException">Una operación de lectura anterior está usando actualmente el lector.</exception>
      </Docs>
    </Member>
  </Members>
</Type>