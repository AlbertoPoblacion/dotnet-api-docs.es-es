<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a474b39e321ea84a98c73e1946fa4241dbf6722f" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48740083" /></Metadata><TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.IO.IODescription("FileSystemWatcherDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Escucha las notificaciones de cambio del sistema de archivos y genera eventos cuando cambia un directorio o un archivo de un directorio.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.IO.FileSystemWatcher> para ver los cambios en un directorio especificado. Puede ver los cambios en los archivos y subdirectorios del directorio especificado. Puede crear un componente para ver los archivos en un equipo local, una unidad de red o un equipo remoto.  
  
 Para ver los cambios en todos los archivos, establezca el <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad en una cadena vacía ("") o usar caracteres comodín ("*.\*"). Para inspeccionar un archivo específico, establezca el <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad en el nombre de archivo. Por ejemplo, para ver los cambios en el archivo MyDoc.txt, establezca el <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad en "MyDoc.txt". También puede ver los cambios en un determinado tipo de archivo. Por ejemplo, para ver los cambios en los archivos de texto, establezca el <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad en "\*.txt".  
  
 Hay varios tipos de cambios que puede inspeccionar en un directorio o archivo. Por ejemplo, puede ver los cambios en `Attributes`, `LastWrite` fecha y hora, o la `Size` de archivos o directorios. Esto se hace estableciendo el <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> propiedad en uno de los <xref:System.IO.NotifyFilters> valores. Para obtener más información sobre el tipo de cambios que puede ver, consulte <xref:System.IO.NotifyFilters>.  
  
 Puede ver el cambio de nombre, eliminación o la creación de archivos o directorios. Por ejemplo, para inspeccionar el cambio de nombre de archivos de texto, establezca el <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad en "*.txt" y llame a la <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> método con un <xref:System.IO.WatcherChangeTypes.Renamed> especificado para el parámetro.  
  
 El sistema operativo de Windows notifica al componente de cambios de archivo en un búfer creado por el <xref:System.IO.FileSystemWatcher>. Si hay muchos cambios en poco tiempo, el búfer puede desbordarse. Esto hace que el componente a perder la pista de los cambios en el directorio y solo proporcionará la notificación general. Aumentar el tamaño del búfer con el <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedad es costosa, como si procediera de memoria no paginada que no puede intercambiarse en el disco, por lo que mantener el búfer como pequeñas pero grande suficiente para que no se pierda cualquier archivo de eventos de cambio. Para evitar un desbordamiento del búfer, utilice el <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> y <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> las notificaciones de cambios de propiedades para que pueda filtrar no deseados.  
  
 Para obtener una lista de valores de propiedad iniciales de una instancia de <xref:System.IO.FileSystemWatcher>, consulte el <xref:System.IO.FileSystemWatcher.%23ctor%2A> constructor.  
  
 Tenga en cuenta lo siguiente cuando se usa el <xref:System.IO.FileSystemWatcher> clase.  
  
-   No se omiten los archivos ocultos.  
  
-   En algunos sistemas, <xref:System.IO.FileSystemWatcher> informa de los cambios a los archivos con el formato de nombre corto de 8.3 archivo. Por ejemplo, un cambio en "longfilename.LongExtension", éste podría aparecer como "LongFil ~. LON".  
  
-   Esta clase contiene una petición de vínculo y una petición de herencia en el nivel de clase que se aplica a todos los miembros. Un <xref:System.Security.SecurityException> se produce cuando el llamador inmediato o la clase derivada no tiene permiso de plena confianza. Para obtener más información acerca de las peticiones de seguridad, consulte [peticiones de vínculo](~/docs/framework/misc/link-demands.md).  
  
-   El tamaño máximo que puede establecer para el <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedad para la supervisión de un directorio a través de la red es 64 KB.  
  
> [!NOTE]
>  Ejecutando <xref:System.IO.FileSystemWatcher> no se admite en Windows 98.  
  
## <a name="copying-and-moving-folders"></a>Copiar y mover carpetas  
 El sistema operativo y <xref:System.IO.FileSystemWatcher> objeto interpretar una acción de cortar y pegar o una acción de movimiento como una acción de cambio de nombre de una carpeta y su contenido. Si corta y pega una carpeta con archivos en una carpeta que se está inspeccionando, el <xref:System.IO.FileSystemWatcher> objeto informa solamente la carpeta como nuevo, pero no su contenido, ya que básicamente son solo cambia.  
  
 Para recibir una notificación que el contenido de carpetas se han movido o copiado en una carpeta controlada, proporcionar <xref:System.IO.FileSystemWatcher.OnChanged%2A> y <xref:System.IO.FileSystemWatcher.OnRenamed%2A> métodos de controlador de eventos como se sugiere en la tabla siguiente.  
  
|Controlador de eventos|Eventos controlados|Lleva a cabo|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|Notificar los cambios en los atributos de archivo, los archivos creados y archivos eliminados.|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|Enumerar las rutas de antiguas y nuevas de carpetas y archivos cuyo nombre ha cambiado, expandiendo de forma recursiva, si es necesario.|  
  
## <a name="events-and-buffer-sizes"></a>Eventos y los tamaños de búfer  
 Tenga en cuenta que varios factores pueden afectar a los eventos de cambio de sistema de archivos que se generan, como se describe en la siguiente:  
  
-   Las operaciones comunes del sistema de archivos podrían generar más de un evento. Por ejemplo, cuando se mueve un archivo de un directorio a otro, varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> y algunos <xref:System.IO.FileSystemWatcher.OnCreated%2A> y <xref:System.IO.FileSystemWatcher.OnDeleted%2A> eventos que puedan generarse. Mover que un archivo es una operación compleja que consta de varias operaciones sencillas, por lo tanto, se provocan varios eventos. De forma similar, algunas aplicaciones (por ejemplo, software antivirus) pueden provocar eventos del sistema de archivos adicionales que se detectan mediante <xref:System.IO.FileSystemWatcher>.  
  
-   El <xref:System.IO.FileSystemWatcher> puede inspeccionar discos siempre que no se cambia o se quitan. El <xref:System.IO.FileSystemWatcher> no genera eventos para CDs y DVDs, porque no se pueden cambiar las propiedades y las marcas de tiempo. Equipos remotos deben tener una de las plataformas necesarias instaladas para que el componente funcione correctamente.  
  
-   Si hay varios <xref:System.IO.FileSystemWatcher> objetos están viendo la misma ruta UNC en Windows XP antes del Service Pack 1 o Windows 2000 SP2 o versiones anterior, sólo uno de los objetos, se producirá un evento. En las máquinas que ejecutan Windows XP SP1 y versiones más recientes, Windows 2000 SP3 o posterior o Windows Server 2003, todos los <xref:System.IO.FileSystemWatcher> objetos generará los eventos adecuados.  
  
 Tenga en cuenta que un <xref:System.IO.FileSystemWatcher> puede perder un evento cuando se supera el tamaño del búfer. Para evitar la pérdida de eventos, siga estas instrucciones:  
  
-   Aumentar el tamaño del búfer estableciendo el <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedad.  
  
-   Evite inspeccionar archivos con nombres de archivo largos, dado un nombre de archivo largo contribuye a llenar el búfer. Considere la posibilidad de cambiar el nombre de estos archivos con nombres más cortos.  
  
-   Mantenga su código lo más corta posible de control de eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.FileSystemWatcher> para inspeccionar el directorio especificado en tiempo de ejecución. El componente se establece para ver los cambios en `LastWrite` y `LastAccess` de tiempo, la creación, eliminación, o cambiar el nombre de los archivos de texto en el directorio. Si se cambia, se crea o se elimina un archivo, se imprime la ruta de acceso al archivo en la consola. Cuando se cambia el nombre de un archivo, imprimen las rutas de acceso antiguos y nuevos en la consola.  
  
 Use la <xref:System.Diagnostics> y <xref:System.IO> espacios de nombres para este ejemplo.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">para derivar de la <see cref="T:System.Diagnostics.ProcessStartInfo" /> clase. Valor de petición: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; Con el nombre de los conjuntos de permisos: <see langword="FullTrust" />.</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Using-a-FileSystemWatcher-4bc97af4">Uso de un componente de FileSystemWatcher en un formulario de Windows</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileSystemWatcher" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se puede inspeccionar un equipo remoto que no tiene Windows NT o Windows 2000. No se puede inspeccionar un equipo remoto de Windows NT 4.0 desde un equipo de Windows NT 4.0.  
  
 La siguiente tabla muestra los valores de propiedad iniciales de una instancia de <xref:System.IO.FileSystemWatcher>.  
  
|Propiedad.|Valor inicial|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|combinación OR bit a bit de `LastWrite`, `FileName`, y `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*. \*"(Inspecciona todos los archivos.)|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|una cadena vacía ("")|  
  
> [!NOTE]
>  El componente no inspeccionará el directorio especificado hasta que la <xref:System.IO.FileSystemWatcher.Path%2A> está establecido, y <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> es `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.FileSystemWatcher> objeto que se va a inspeccionar el directorio especificado en tiempo de ejecución. El <xref:System.IO.FileSystemWatcher> inspecciona cambios en el objeto `LastWrite` y `LastAccess` horas y para la creación, eliminación o cambio de nombre de texto de archivos en el directorio. Si se cambia, se crea o se elimina un archivo, se muestra la ruta de acceso al archivo en la consola. Cuando se cambia el nombre de un archivo, las rutas de acceso antiguos y nuevos se muestran en la consola.  
  
 Este ejemplo se usa el <xref:System.Diagnostics> y <xref:System.IO> espacios de nombres.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">El directorio que se va a supervisar, en notación de Convención de nomenclatura universal (Universal Naming Convention, UNC) o estándar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileSystemWatcher" />, dado el directorio especificado que se va a supervisar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  El componente no inspeccionará el directorio especificado hasta que la <xref:System.IO.FileSystemWatcher.Path%2A> está establecido, y <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> es `true`.  
  
 El componente puede inspeccionar archivos en su equipo, una unidad de red o un equipo remoto.  
  
 No se puede inspeccionar un equipo remoto que no tiene Windows NT o Windows 2000. No se puede inspeccionar un equipo remoto de Windows NT 4.0 desde un equipo de Windows NT 4.0. El <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad se establece de forma predeterminada para ver todos los archivos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="path" /> es una cadena vacía ("").  
  
O bien 
La ruta de acceso especificada mediante el parámetro <paramref name="path" /> no existe.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> es demasiado largo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">El directorio que se va a supervisar, en notación de Convención de nomenclatura universal (Universal Naming Convention, UNC) o estándar.</param>
        <param name="filter">El tipo de archivos que se van a inspeccionar. Por ejemplo, "*.txt" inspecciona cambios en todos los archivos de texto.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileSystemWatcher" />, dado el directorio especificado y el tipo de archivos que se van a supervisar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  El componente no inspeccionará el directorio especificado hasta que la <xref:System.IO.FileSystemWatcher.Path%2A> está establecido, y <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> es `true`.  
  
 El componente puede inspeccionar archivos en su equipo, una unidad de red o un equipo remoto.  
  
 No se puede inspeccionar un equipo remoto que no tiene Windows NT o Windows 2000. No se puede inspeccionar un equipo remoto de Windows NT 4.0 desde un equipo de Windows NT 4.0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.  
  
O bien 
El parámetro <paramref name="filter" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="path" /> es una cadena vacía ("").  
  
O bien 
La ruta de acceso especificada mediante el parámetro <paramref name="path" /> no existe.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> es demasiado largo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comienza la inicialización de un objeto <see cref="T:System.IO.FileSystemWatcher" /> empleado en un formulario o utilizado por otro componente. La inicialización se produce en tiempo de ejecución.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] entorno usa este método para iniciar la inicialización de un componente de diseño empleado en un formulario o utilizado por otro componente. El <xref:System.IO.FileSystemWatcher.EndInit%2A> método termina la inicialización. Mediante el <xref:System.IO.FileSystemWatcher.BeginInit%2A> y <xref:System.IO.FileSystemWatcher.EndInit%2A> métodos impide que el control que se va a usar antes de inicializarse completamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Changed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia un archivo o un directorio en la ruta de acceso <see cref="P:System.IO.FileSystemWatcher.Path" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileSystemWatcher.Changed> evento se genera cuando se realizan cambios en el tamaño, atributos del sistema, la última escritura hora, hora del último acceso o los permisos de seguridad de un archivo o directorio en el directorio que se está supervisando.  
  
> [!NOTE]
>  Las operaciones comunes del sistema de archivos podrían generar más de un evento. Por ejemplo, cuando se mueve un archivo de un directorio a otro, varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> y algunos <xref:System.IO.FileSystemWatcher.OnCreated%2A> y <xref:System.IO.FileSystemWatcher.OnDeleted%2A> eventos que puedan generarse. Mover que un archivo es una operación compleja que consta de varias operaciones sencillas, por lo tanto, se provocan varios eventos. De forma similar, algunas aplicaciones (por ejemplo, software antivirus) pueden provocar eventos del sistema de archivos adicionales que se detectan mediante <xref:System.IO.FileSystemWatcher>.  
  
 Use <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> para restringir el número de notificaciones que se genera cuando se controla este evento.  
  
> [!NOTE]
>  El <xref:System.IO.FileSystemWatcher.Changed> evento se desencadena de forma inesperada cuando un archivo se cambia el nombre, pero no se produce cuando se cambia el nombre de un directorio. Para ver el cambio de nombre, utilice el <xref:System.IO.FileSystemWatcher.Renamed> eventos.  
  
> [!NOTE]
>  El orden en que el <xref:System.IO.FileSystemWatcher.Changed> evento se desencadena en relación con los demás <xref:System.IO.FileSystemWatcher> eventos pueden cambiar cuando el <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propiedad no es `null`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.FileSystemWatcher.Changed> eventos para mostrar la ruta de acceso a la consola cuando se cambia el archivo inspeccionado.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Created")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se crea un archivo o un directorio en la ruta de acceso <see cref="P:System.IO.FileSystemWatcher.Path" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunas acciones comunes, como copiar o mover un archivo o directorio, no corresponden directamente a un evento, pero estas repeticiones hacen que se generen eventos. Al copiar un archivo o directorio, el sistema genera un <xref:System.IO.FileSystemWatcher.Created> eventos en el directorio a la que se copió el archivo, si se está inspeccionando ese directorio. Si el directorio desde el que se copió estuviera inspeccionando otra instancia de <xref:System.IO.FileSystemWatcher>, no se provocaría ningún evento. Por ejemplo, crea dos instancias de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 está establecido para inspeccionar "C:\My Documents" y FileSystemWatcher2 está establecido para inspeccionar "C:\Your Documents". Si copia un archivo de "Mis documentos" en "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> , se generará el evento FileSystemWatcher2, pero se genera ningún evento para FileSystemWatcher1. A diferencia de copiar, mover un archivo o directorio se generan dos eventos. En el ejemplo anterior, si mueve un archivo desde "My Documents" hasta "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> evento podría generarse FileSystemWatcher2 y un <xref:System.IO.FileSystemWatcher.Deleted> evento podría generarse FileSystemWatcher1.  
  
> [!NOTE]
>  Las operaciones comunes del sistema de archivos podrían generar más de un evento. Por ejemplo, cuando se mueve un archivo de un directorio a otro, varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> y algunos <xref:System.IO.FileSystemWatcher.OnCreated%2A> y <xref:System.IO.FileSystemWatcher.OnDeleted%2A> eventos que puedan generarse. Mover que un archivo es una operación compleja que consta de varias operaciones sencillas, por lo tanto, se provocan varios eventos. De forma similar, algunas aplicaciones (por ejemplo, software antivirus) pueden provocar eventos del sistema de archivos adicionales que se detectan mediante <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  El orden en que el <xref:System.IO.FileSystemWatcher.Created> evento se desencadena en relación con los demás <xref:System.IO.FileSystemWatcher> eventos pueden cambiar cuando el <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propiedad no es `null`.  
  
 El <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento se desencadena en cuanto se crea un archivo. Si se va un archivo de copia o se transfiere a un directorio inspeccionado, la <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento se genera inmediatamente, seguido de uno o varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.FileSystemWatcher.Created> eventos para mostrar la ruta de acceso a la consola cuando se crea el archivo de seguimiento.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Deleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se elimina un archivo o un directorio en la ruta de acceso <see cref="P:System.IO.FileSystemWatcher.Path" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunas acciones comunes, como copiar o mover un archivo o directorio, no corresponden directamente a un evento, pero estas repeticiones hacen que se generen eventos. Al copiar un archivo o directorio, el sistema genera un <xref:System.IO.FileSystemWatcher.Created> eventos en el directorio a la que se copió el archivo, si se está inspeccionando ese directorio. Si el directorio desde el que se copió estuviera inspeccionando otra instancia de <xref:System.IO.FileSystemWatcher>, no se provocaría ningún evento. Por ejemplo, crea dos instancias de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 está establecido para inspeccionar "C:\My Documents" y FileSystemWatcher2 está establecido para inspeccionar "C:\Your Documents". Si copia un archivo de "Mis documentos" en "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> , se generará el evento FileSystemWatcher2, pero se genera ningún evento para FileSystemWatcher1. A diferencia de copiar, mover un archivo o directorio se generan dos eventos. En el ejemplo anterior, si mueve un archivo desde "My Documents" hasta "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> evento podría generarse FileSystemWatcher2 y un <xref:System.IO.FileSystemWatcher.Deleted> evento podría generarse FileSystemWatcher1.  
  
> [!NOTE]
>  Las operaciones comunes del sistema de archivos podrían generar más de un evento. Por ejemplo, cuando se mueve un archivo de un directorio a otro, varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> y algunos <xref:System.IO.FileSystemWatcher.OnCreated%2A> y <xref:System.IO.FileSystemWatcher.OnDeleted%2A> eventos que puedan generarse. Mover que un archivo es una operación compleja que consta de varias operaciones sencillas, por lo tanto, se provocan varios eventos. De forma similar, algunas aplicaciones (por ejemplo, software antivirus) pueden provocar eventos del sistema de archivos adicionales que se detectan mediante <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  El orden en que el <xref:System.IO.FileSystemWatcher.Deleted> evento se desencadena en relación con los demás <xref:System.IO.FileSystemWatcher> eventos pueden cambiar cuando el <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propiedad no es `null`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.FileSystemWatcher.Deleted> eventos para mostrar la ruta de acceso a la consola cuando se elimine el archivo de seguimiento.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.IO.FileSystemWatcher" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama por el público <xref:System.ComponentModel.Component.Dispose%2A> método y el <xref:System.Object.Finalize%2A> método. <xref:System.ComponentModel.Component.Dispose%2A> invoca el protegido <xref:System.IO.FileSystemWatcher.Dispose%2A> método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca <xref:System.IO.FileSystemWatcher.Dispose%2A> con `disposing` establecido en `false`.  
  
 Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.IO.Compression.DeflateStream> hace referencia. Este método invoca al método <xref:System.ComponentModel.Component.Dispose%2A> de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> puede recibir varias llamadas de otros objetos. Cuando se reemplaza <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see cref="M:System.ComponentModel.Component.Dispose" />. Para obtener más información sobre cómo implementar <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obtener más información acerca de <see cref="M:System.ComponentModel.Component.Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Enabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el componente está habilitado.</summary>
        <value>Es <see langword="true" /> si el componente está habilitado; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />. Si se utiliza el componente en un diseñador de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)], el valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El componente no generará eventos a menos que establezca <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> a `true`.  
  
> [!NOTE]
>  El componente no inspeccionará el directorio especificado hasta que la <xref:System.IO.FileSystemWatcher.Path%2A> se estableció la propiedad y <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> es `true`.  
  
 El <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> método permite que los controladores de eventos que se invocará para responder a cambios en el archivo incluso si esta propiedad se establece en `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.FileSystemWatcher> para inspeccionar el directorio especificado en tiempo de ejecución. El componente se establece para ver los cambios en `LastWrite` y `LastAccess` de tiempo, la creación, eliminación, o cambiar el nombre de los archivos de texto en el directorio. Si se cambia, se crea o se elimina un archivo, se imprime la ruta de acceso al archivo en la consola. Cuando se cambia el nombre de un archivo, imprimen las rutas de acceso antiguos y nuevos en la consola.  
  
 Use la <xref:System.Diagnostics> y <xref:System.IO> espacios de nombres para este ejemplo.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se eliminó el objeto <see cref="T:System.IO.FileSystemWatcher" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Microsoft Windows NT o posterior.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el directorio especificado en <see cref="P:System.IO.FileSystemWatcher.Path" />.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.IO.FileSystemWatcher.Path" /> no se ha establecido o no es válida.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina la inicialización de un objeto <see cref="T:System.IO.FileSystemWatcher" /> empleado en un formulario o utilizado por otro componente. La inicialización se produce en tiempo de ejecución.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] entorno usa este método para finalizar la inicialización de un componente de diseño utilizado en un formulario o utilizado por otro componente. El <xref:System.IO.FileSystemWatcher.BeginInit%2A> método comienza la inicialización. Mediante el <xref:System.IO.FileSystemWatcher.BeginInit%2A> y <xref:System.IO.FileSystemWatcher.EndInit%2A> métodos impide que el control que se va a usar antes de inicializarse completamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la instancia de <see cref="T:System.IO.FileSystemWatcher" /> no puede continuar supervisando los cambios o cuando el búfer interno se desborda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena cada vez que algo impide la <xref:System.IO.FileSystemWatcher> objeto de supervisión de los cambios. Por ejemplo, si el objeto supervisa los cambios en un directorio remoto y se pierde la conexión a ese directorio, el <xref:System.IO.FileSystemWatcher.Error> provoca el evento.  
  
 El sistema le notifica los cambios de archivo y almacena esos cambios en un búfer que el componente crea y pasa a las API. Si hay muchos cambios en poco tiempo, el búfer puede desbordarse. Esto hace que el componente a perder la pista de los cambios en el directorio y solo proporcionará la notificación general. Aumentar el tamaño del búfer es caro, porque procede de no paginado memoria que no puede intercambiarse en el disco, por lo que mantener el búfer tan pequeño como sea posible. Para evitar un desbordamiento del búfer, utilice el <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.Filter%2A>, y <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> las notificaciones de cambios de propiedades para filtrar no deseados.  
  
> [!NOTE]
>  Las operaciones comunes del sistema de archivos podrían generar más de un evento. Por ejemplo, cuando se mueve un archivo de un directorio a otro, varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> y algunos <xref:System.IO.FileSystemWatcher.OnCreated%2A> y <xref:System.IO.FileSystemWatcher.OnDeleted%2A> eventos que puedan generarse. Mover que un archivo es una operación compleja que consta de varias operaciones sencillas, por lo tanto, se provocan varios eventos. De forma similar, algunas aplicaciones (por ejemplo, software antivirus) pueden provocar eventos del sistema de archivos adicionales que se detectan mediante <xref:System.IO.FileSystemWatcher>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la cadena de filtro utilizada para determinar qué archivos se supervisan en un directorio.</summary>
        <value>La cadena de filtro. El valor predeterminado es "*. \*"(Inspecciona todos los archivos).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para inspeccionar los cambios en todos los archivos, establezca el <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad en una cadena vacía (""). Para inspeccionar un archivo específico, establezca el <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad en el nombre de archivo. Por ejemplo, para ver los cambios en el archivo MyDoc.txt, establezca el <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad en "MyDoc.txt". También puede ver los cambios en un determinado tipo de archivo. Por ejemplo, para ver los cambios en los archivos de texto, establezca el <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad como "*.txt". Uso de varios filtros, como "\*.txt&#124;\*.doc" no se admite.  
  
 El <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad se puede cambiar después el <xref:System.IO.FileSystemWatcher> objeto haya empezado a recibir eventos.  
  
 Para obtener más información acerca del filtrado de notificaciones no deseadas, vea el <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, y <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedades.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> acepta caracteres comodín para los archivos coincidentes, como se muestra en los ejemplos siguientes.  
  
|Cadena de filtro|Supervisa los siguientes archivos|  
|-------------------|---------------------------------|  
|*.\*|Todos los archivos (valor predeterminado). Una cadena vacía ("") también inspecciona todos los archivos.|  
|*.txt|Todos los archivos con la extensión "txt".|  
|*recipe.doc|Todos los archivos que terminan en "receta" con una extensión "doc".|  
|Win*.Xml|Todos los archivos que comienzan por "win" con la extensión "xml".|  
|Ventas * 200?. xls|Coincide con lo siguiente:<br /><br /> Julio ventas 2001.xls Ago 2002.xls marzo 2004.xls<br /><br /> pero no coincide con:<br /><br /> Ventas Nov 1999.xls|  
|MyReport.Doc|Inspecciona sólo MyReport.doc|  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.FileSystemWatcher> para inspeccionar el directorio especificado en tiempo de ejecución. El componente se establece para ver los cambios en `LastWrite` y `LastAccess` de tiempo, la creación, eliminación, o cambiar el nombre de los archivos de texto en el directorio. Si se cambia, se crea o se elimina un archivo, se imprime la ruta de acceso al archivo en la consola. Cuando se cambia el nombre de un archivo, imprimen las rutas de acceso antiguos y nuevos en la consola.  
  
 Use la <xref:System.Diagnostics> y <xref:System.IO> espacios de nombres para este ejemplo.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_IncludeSubdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se deben supervisar los subdirectorios de la ruta de acceso especificada.</summary>
        <value>Es <see langword="true" /> si desea supervisar subdirectorios; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> a `true` cuando desee ver notificaciones de cambio de archivos y directorios dentro del directorio especificado en el <xref:System.IO.FileSystemWatcher.Path%2A> propiedad y sus subdirectorios. Establecer el <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> propiedad `false` ayuda a reduce el número de notificaciones enviadas al búfer interno. Para obtener más información sobre cómo filtrar notificaciones no deseadas, vea el <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> y <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedades.  
  
 Cuando `true`, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> es recursiva por todo el subárbol, no solo los directorios secundarios inmediatos. Devuelve la ruta de acceso relativa a un archivo o directorio dentro del subárbol de la <xref:System.IO.FileSystemEventArgs.Name%2A> propiedad de <xref:System.IO.FileSystemEventArgs> y el <xref:System.IO.RenamedEventArgs.OldName%2A> propiedad de <xref:System.IO.RenamedEventArgs>, en función de los cambios que está inspeccionando. Puede obtener la ruta de acceso completa de la <xref:System.IO.FileSystemEventArgs.FullPath%2A> propiedad de <xref:System.IO.FileSystemEventArgs> y el <xref:System.IO.RenamedEventArgs.OldFullPath%2A> propiedad de <xref:System.IO.RenamedEventArgs>, en función de los cambios que está inspeccionando.  
  
 Si se crea un directorio en el subárbol del directorio que está inspeccionando, y <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> es `true`, automáticamente se observarán ese directorio.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño (en bytes) del búfer interno.</summary>
        <value>Tamaño del búfer interno en bytes. El valor predeterminado es 8192 (8 KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede establecer el búfer de 4 KB o superior, pero no debe superar los 64 KB. Si se intenta establecer el <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedad a inferior a 4096 bytes, el valor se descarta y el <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedad está establecida en 4096 bytes. Para obtener el mejor rendimiento, utilice un múltiplo de 4 KB en los equipos basados en Intel.  
  
 El sistema notifica al componente de los cambios del archivo y almacena esos cambios en un búfer que el componente crea y pasa a las API. Cada evento puede utilizar hasta 16 bytes de memoria, sin incluir el nombre de archivo. Si hay muchos cambios en poco tiempo, el búfer puede desbordarse. Esto hace que el componente a perder la pista de los cambios en el directorio y solo proporcionará la notificación general. Aumentar el tamaño del búfer puede impedir que los eventos de cambio de la falta de sistema de archivos. Sin embargo, aumentar el tamaño del búfer es costoso, porque procede de la memoria no paginada que no puede intercambiarse en el disco, por lo que mantener el búfer tan pequeña como sea posible. Para evitar un desbordamiento del búfer, utilice el <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> y <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> las notificaciones de cambios de propiedades para filtrar no deseados.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_ChangedFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tipo de cambios que se van a inspeccionar.</summary>
        <value>Uno de los valores de <see cref="T:System.IO.NotifyFilters" />. El valor predeterminado es la combinación OR bit a bit de <see langword="LastWrite" />, <see langword="FileName" /> y <see langword="DirectoryName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede combinar los miembros de la <xref:System.IO.NotifyFilters> enumeración para inspeccionar los más de un tipo de cambio a la vez. Por ejemplo, puede inspeccionar los cambios de tamaño de un archivo y los cambios en el `LastWrite` tiempo. Esto provoca un evento cada vez que hay un cambio de tamaño de archivo o carpeta, o un cambio en el `LastWrite` tiempo del archivo o carpeta.  
  
 Se trata de una manera de filtrar las notificaciones no deseadas. Para obtener más información sobre cómo filtrar notificaciones no deseadas, vea el <xref:System.IO.FileSystemWatcher.Filter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, y <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedades.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.FileSystemWatcher> para inspeccionar el directorio especificado en tiempo de ejecución. El componente se establece para ver los cambios en `LastWrite` y `LastAccess` de tiempo, la creación, eliminación, o cambiar el nombre de los archivos de texto en el directorio. Si se cambia, se crea o se elimina un archivo, se imprime la ruta de acceso al archivo en la consola. Cuando se cambia el nombre de un archivo, imprimen las rutas de acceso antiguos y nuevos en la consola.  
  
 Use la <xref:System.Diagnostics> y <xref:System.IO> espacios de nombres para este ejemplo.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor no es una combinación OR bit a bit de los valores <see cref="T:System.IO.NotifyFilters" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El valor que se está estableciendo no es válido.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.IO.FileSystemEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.IO.FileSystemWatcher.Changed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> se llama cuando se realizan cambios en el tamaño, los atributos del sistema, hora de última escritura, hora del último acceso o permisos de seguridad de un archivo o directorio en el directorio que se está supervisando.  
  
 Use la <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> propiedad para restringir el número de eventos produce cuando el <xref:System.IO.FileSystemWatcher.Changed> controla el evento.  
  
 El <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento se desencadena en cuanto se crea un archivo. Si se va un archivo de copia o se transfiere a un directorio inspeccionado, la <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento se genera inmediatamente, seguido de uno o varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> eventos.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> método.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.IO.FileSystemEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.IO.FileSystemWatcher.Created" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> se llama cuando se crea un archivo o directorio en el directorio que se está supervisando.  
  
 Algunas acciones comunes, como copiar o mover un archivo o directorio, no corresponden directamente a un evento, pero estas repeticiones hacen que se generen eventos. Al copiar un archivo o directorio, el sistema genera un <xref:System.IO.FileSystemWatcher.Created> eventos en el directorio a la que se copió el archivo, si se está inspeccionando ese directorio. Si el directorio desde el que se copió estuviera inspeccionando otra instancia de <xref:System.IO.FileSystemWatcher>, no se provocaría ningún evento. Por ejemplo, crea dos instancias de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 está establecido para inspeccionar "C:\My Documents" y FileSystemWatcher2 está establecido para inspeccionar "C:\Your Documents". Si copia un archivo desde "Mis documentos" y péguela en "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> evento se genera en FileSystemWatcher2, pero se genera ningún evento para FileSystemWatcher1. A diferencia de copiar, mover un archivo o directorio genera dos eventos. En el ejemplo anterior, si mueve un archivo desde "My Documents" hasta "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> evento podría generarse en FileSystemWatcher2 y un <xref:System.IO.FileSystemWatcher.Deleted> evento podría generarse en FileSystemWatcher1.  
  
 El <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento se desencadena en cuanto se crea un archivo. Si se va un archivo de copia o se transfiere a un directorio inspeccionado, la <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento se genera inmediatamente, seguido de uno o varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> eventos.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> método.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.IO.FileSystemEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.IO.FileSystemWatcher.Deleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> se llama cuando se elimina un archivo o directorio dentro del directorio que se está supervisando.  
  
 Algunas acciones comunes, como copiar o mover un archivo o directorio, no corresponden directamente a un evento, pero estas repeticiones hacen que se generen eventos. Al copiar un archivo o directorio, el sistema genera un <xref:System.IO.FileSystemWatcher.Created> eventos en el directorio a la que se copió el archivo, si se está inspeccionando ese directorio. Si el directorio desde el que se copió estuviera inspeccionando otra instancia de <xref:System.IO.FileSystemWatcher>, no se provocaría ningún evento. Por ejemplo, crea dos instancias de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 está establecido para inspeccionar "C:\My Documents" y FileSystemWatcher2 está establecido para inspeccionar "C:\Your Documents". Si copia un archivo de "Mis documentos" en "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> , se generará el evento FileSystemWatcher2, pero se genera ningún evento para FileSystemWatcher1. A diferencia de copiar, mover un archivo o directorio genera dos eventos. En el ejemplo anterior, si mueve un archivo desde "My Documents" hasta "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> evento podría generarse FileSystemWatcher2 y un <xref:System.IO.FileSystemWatcher.Deleted> evento podría generarse FileSystemWatcher1.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> método.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.IO.ErrorEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.IO.FileSystemWatcher.Error" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> se llama cuando se produce un error.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> método.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.IO.RenamedEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.IO.FileSystemWatcher.Renamed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> se llama cuando se cambia el nombre de un archivo o directorio dentro del directorio que se está supervisando. Su <xref:System.IO.RenamedEventArgs> argumento contiene información sobre la operación de cambio de nombre, como el tipo de cambio, la ruta de acceso antiguo y nuevo y los nombres antiguos y nuevos. Tenga en cuenta que su <xref:System.IO.FileSystemEventArgs.Name> propiedad puede ser null para cambiar el nombre de los eventos si el <xref:System.IO.FileSystemWatcher> no obtener coinciden con los eventos de los nombres antiguos y nuevos desde el sistema operativo. 
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> método.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la ruta de acceso del directorio que se va a inspeccionar.</summary>
        <value>La ruta de acceso que se va a supervisar. El valor predeterminado es una cadena vacía ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de una ruta de acceso completa a un directorio. Si el <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> propiedad es `true`, este directorio es la raíz en el que el sistema supervisa los cambios; en caso contrario, es el único directorio inspeccionado. Para inspeccionar un archivo específico, establezca la <xref:System.IO.FileSystemWatcher.Path%2A> propiedad en el directorio adecuado completo y el <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad en el nombre de archivo.  
  
 El <xref:System.IO.FileSystemWatcher.Path%2A> propiedad es compatible con las rutas de acceso de convención de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  Esta propiedad debe establecerse antes de que el componente puede ver los cambios.  
  
 Cuando se cambia el nombre de un directorio, el <xref:System.IO.FileSystemWatcher> asocia de nuevo automáticamente al elemento cuyo nombre ha cambiado. Por ejemplo, si establece la <xref:System.IO.FileSystemWatcher.Path%2A> propiedad en "C:\My Documents" y, a continuación, cambie manualmente el nombre del directorio a "C:\Your Documents", el componente sigue escuchando para las notificaciones de cambio en el directorio cuyo nombre ha cambiado. Sin embargo, cuando se solicita la <xref:System.IO.FileSystemWatcher.Path%2A> propiedad, contiene la ruta de acceso anterior. Esto sucede porque el componente determina qué directorio inspecciona según el identificador, en lugar del nombre del directorio. Cambiar el nombre no afecta al identificador. Por lo tanto, si se destruye el componente y, a continuación, vuelva a crearlo sin actualizar el <xref:System.IO.FileSystemWatcher.Path%2A> propiedad, la aplicación generará un error porque el directorio ya no existe.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.FileSystemWatcher> para inspeccionar el directorio especificado en tiempo de ejecución. El componente se establece para ver los cambios en `LastWrite` y `LastAccess` de tiempo, la creación, eliminación, o cambiar el nombre de los archivos de texto en el directorio. Si se cambia, se crea o se elimina un archivo, se imprime la ruta de acceso al archivo en la consola. Cuando se cambia el nombre de un archivo, imprimen las rutas de acceso antiguos y nuevos en la consola.  
  
 Use la <xref:System.Diagnostics> y <xref:System.IO> espacios de nombres para este ejemplo.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso especificada no existe o no se encuentra.  
  
O bien 
La ruta de acceso especificada contiene caracteres comodín.  
  
O bien 
La ruta de acceso especificada contiene caracteres de ruta de acceso no válidos.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Renamed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se cambia de nombre un archivo o un directorio de la ruta de acceso <see cref="P:System.IO.FileSystemWatcher.Path" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Renamed` evento es un <xref:System.IO.RenamedEventHandler> delegado que tiene la firma siguiente:

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 El <xref:System.IO.RenamedEventArgs> objeto proporciona información sobre la operación de cambio de nombre, como el tipo de cambio de nombre (el <xref:System.IO.FileSystemEventArgs.ChangeType> propiedad), los nombres antiguos y nuevos y la ruta de acceso antiguo y nuevo. Tenga en cuenta que el <xref:System.IO.FileSystemEventArgs.Name> propiedad puede ser null para cambiar el nombre de los eventos si el <xref:System.IO.FileSystemWatcher> no obtener coinciden con los eventos de los nombres antiguos y nuevos desde el sistema operativo.

 Cambiar el nombre del directorio que está inspeccionando no generará una notificación. Solo se generan notificaciones para las entradas dentro del directorio que está viendo.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.FileSystemWatcher.Renamed> eventos para mostrar la ruta de acceso a la consola cuando se cambia el nombre el archivo de seguimiento.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una interfaz <see cref="T:System.ComponentModel.ISite" /> para el objeto <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <value>Estructura <see cref="T:System.ComponentModel.ISite" /> para la colección <see cref="T:System.IO.FileSystemWatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sitios de enlazan un <xref:System.ComponentModel.Component> a un <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> y habilitar la comunicación entre ellos, así como proporcionar una forma para el contenedor administrar sus componentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_SynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto utilizado para serializar de las llamadas del controlador de eventos emitidas como consecuencia de un cambio de directorio.</summary>
        <value>Objeto <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> que representa el objeto utilizado para calcular las referencias de las llamadas del controlador de eventos emitidas como consecuencia de un cambio de directorio. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> es `null`, métodos que controlan la <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, y <xref:System.IO.FileSystemWatcher.Renamed> eventos se llaman en un subproceso del grupo de subprocesos del sistema. Para obtener más información sobre los grupos de subprocesos del sistema, consulte <xref:System.Threading.ThreadPool>.  
  
 Cuando el <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, y <xref:System.IO.FileSystemWatcher.Renamed> controla los eventos son un componente de Windows Forms visual, como un <xref:System.Windows.Forms.Button>, acceso al componente en el grupo de subprocesos del sistema no funcionen o se puede producir una excepción. Evitar esta situación estableciendo <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> a un componente de Windows Forms, lo que hace que los métodos que controlan la <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, y <xref:System.IO.FileSystemWatcher.Renamed> eventos que se llamará en el mismo subproceso en el que se creó el componente.  
  
 Si el <xref:System.IO.FileSystemWatcher> se utiliza dentro de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] en un diseñador de Windows Forms, <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> establece automáticamente en el control que contiene el <xref:System.IO.FileSystemWatcher>. Por ejemplo, si coloca un <xref:System.IO.FileSystemWatcher> en un diseñador de Form1 (que hereda de <xref:System.Windows.Forms.Form>) la <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propiedad de <xref:System.IO.FileSystemWatcher> se establece en la instancia de Form1.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Método sincrónico que devuelve una estructura que contiene información específica acerca del cambio que se ha producido.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">Objeto <see cref="T:System.IO.WatcherChangeTypes" /> que se va a inspeccionar.</param>
        <summary>Un método sincrónico que devuelve una estructura que contiene información específica acerca del cambio que se ha producido, dado el tipo de cambio que desea supervisar.</summary>
        <returns>Un objeto <see cref="T:System.IO.WaitForChangedResult" /> que contiene información específica acerca del cambio que se ha producido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método espera indefinidamente hasta que el primer cambio se produce y, a continuación, se devuelve. Esto es lo mismo que usar <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> con el `timeout` parámetro establecido en -1.  
  
> [!NOTE]
>  Este método permite que un controlador de eventos que se invocará para responder al archivo si incluso de los cambios del <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> propiedad está establecida en `false`.  
  
 En algunos sistemas, <xref:System.IO.FileSystemWatcher> informa de los cambios a los archivos con el formato de nombre corto de 8.3 archivo. Por ejemplo, un cambio en "longfilename.LongExtension", éste podría aparecer como "LongFi ~. LON".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">Objeto <see cref="T:System.IO.WatcherChangeTypes" /> que se va a inspeccionar.</param>
        <param name="timeout">El tiempo (en milisegundos) que se va a esperar antes de que se agote el tiempo de espera.</param>
        <summary>Método sincrónico que devuelve una estructura que contiene información específica acerca del cambio que se ha producido, dado el tipo de cambio que desea supervisar y el tiempo (en milisegundos) que se va a esperar antes de que se agote el tiempo de espera.</summary>
        <returns>Un objeto <see cref="T:System.IO.WaitForChangedResult" /> que contiene información específica acerca del cambio que se ha producido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método espera hasta que se produce un cambio o se ha agotado. Un valor de -1 para el `timeout` parámetro significa que se esperará indefinidamente.  
  
> [!NOTE]
>  Este método permite que un controlador de eventos que se invocará para responder al archivo si incluso de los cambios del <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> propiedad está establecida en `false`.  
  
 En algunos sistemas, <xref:System.IO.FileSystemWatcher> informa de los cambios a los archivos con el formato de nombre corto de 8.3 archivo. Por ejemplo, un cambio en "longfilename.LongExtension", éste podría aparecer como "LongFi ~. LON".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>