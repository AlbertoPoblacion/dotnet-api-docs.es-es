<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f524b1e2438cea1c3c824aa9514a36244ccff373" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30420559" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Escucha las notificaciones de cambio del sistema de archivos y genera eventos cuando cambia un directorio o un archivo de un directorio.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.IO.FileSystemWatcher> para inspeccionar los cambios en un directorio especificado. También puede ver los cambios en archivos y subdirectorios del directorio especificado. Puede crear un componente para inspeccionar archivos en un equipo local, una unidad de red o un equipo remoto.  
  
 Para inspeccionar los cambios en todos los archivos, establezca la <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad en una cadena vacía ("") o usar caracteres comodín ("*.\*"). Para inspeccionar un archivo específico, establezca la <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad con el nombre de archivo. Por ejemplo, para ver los cambios en el archivo MyDoc.txt, establezca el <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad en "MyDoc.txt". También puede ver los cambios en un determinado tipo de archivo. Por ejemplo, para inspeccionar cambios en archivos de texto, establezca la <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad a "\*.txt".  
  
 Hay varios tipos de cambios que puede inspeccionar en un directorio o archivo. Por ejemplo, puede observar los cambios en `Attributes`, `LastWrite` fecha y hora, o la `Size` de archivos o directorios. Esto se hace estableciendo el <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> propiedad en uno de los <xref:System.IO.NotifyFilters> valores. Para obtener más información sobre el tipo de cambios que puede ver, consulte <xref:System.IO.NotifyFilters>.  
  
 Puede observar el cambio de nombre, eliminación o la creación de archivos o directorios. Por ejemplo, para inspeccionar el cambio de nombre de archivos de texto, establezca la <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad en "*.txt" y llame a la <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> método con un <xref:System.IO.WatcherChangeTypes.Renamed> especificado para su parámetro.  
  
 El sistema operativo Windows notifica al componente los cambios de archivo en un búfer creado por el <xref:System.IO.FileSystemWatcher>. Si hay muchos cambios en poco tiempo, el búfer puede desbordarse. Esto hace que el componente a perder el seguimiento de cambios en el directorio y sólo puede proporcionar una notificación general. Aumentar el tamaño del búfer con el <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedad es costosa, ya que procede de memoria no paginada que no se puede intercambiar en el disco, por lo que mantener el búfer como pequeño aún grande lo suficiente como para no perder cualquier archivo de eventos de cambio. Para evitar un desbordamiento de búfer, utilice el <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> y <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> las notificaciones de cambio de propiedades, por lo que se puede filtrar no deseados.  
  
 Para obtener una lista de valores de propiedad iniciales para una instancia de <xref:System.IO.FileSystemWatcher>, consulte el <xref:System.IO.FileSystemWatcher.%23ctor%2A> constructor.  
  
 Tenga en cuenta lo siguiente cuando se usa el <xref:System.IO.FileSystemWatcher> clase.  
  
-   Los archivos ocultos no se omiten.  
  
-   En algunos sistemas, <xref:System.IO.FileSystemWatcher> informa de los cambios a los archivos con el formato de nombre corto de 8.3 archivo. Por ejemplo, un cambio en "longfilename.LongExtension", éste podría aparecer como "LongFil ~. LON".  
  
-   Esta clase contiene una petición de vínculo y una petición de herencia en el nivel de clase que se aplica a todos los miembros. Un <xref:System.Security.SecurityException> se produce cuando el llamador inmediato o la clase derivada no tiene permiso de plena confianza. Para obtener más información acerca de las peticiones de seguridad, consulte [peticiones de vínculo](~/docs/framework/misc/link-demands.md).  
  
-   El tamaño máximo que puede establecer para el <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedad para supervisar un directorio a través de la red es 64 KB.  
  
> [!NOTE]
>  Ejecuta <xref:System.IO.FileSystemWatcher> no se admite en Windows 98.  
  
## <a name="copying-and-moving-folders"></a>Copiar y mover carpetas  
 El sistema operativo y <xref:System.IO.FileSystemWatcher> objeto interpretar una acción de cortar y pegar o una acción para mover como una acción de cambio de nombre de una carpeta y su contenido. Si cortar y pegar una carpeta con archivos en una carpeta que se está inspeccionada, el <xref:System.IO.FileSystemWatcher> objeto informa solo la carpeta como nueva, pero no su contenido, ya que básicamente son solo cambia.  
  
 Para recibir una notificación que el contenido de carpetas se han movido o copiado en una carpeta controlada, proporcionar <xref:System.IO.FileSystemWatcher.OnChanged%2A> y <xref:System.IO.FileSystemWatcher.OnRenamed%2A> métodos de controlador de eventos tal como se sugiere en la tabla siguiente.  
  
|Controlador de eventos|Eventos administrados|Lleva a cabo|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|Notificar los cambios en los atributos de archivo, los archivos creados y archivos eliminados.|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|Enumerar las rutas de antiguas y nuevas de los archivos cuyo nombre ha cambiado y carpetas, expandiendo de forma recursiva si es necesario.|  
  
## <a name="events-and-buffer-sizes"></a>Eventos y tamaños de búfer  
 Tenga en cuenta que varios factores pueden afectar a los eventos de cambio de sistema de archivos que se generan, como se describe en la siguiente:  
  
-   Las operaciones comunes de sistema de archivos podrían generar más de un evento. Por ejemplo, cuando se mueve un archivo de un directorio a otro, varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> y algunos <xref:System.IO.FileSystemWatcher.OnCreated%2A> y <xref:System.IO.FileSystemWatcher.OnDeleted%2A> es posible que se generen eventos. Mover que un archivo es una operación compleja que consta de varias operaciones sencillas, por lo tanto, cuando se genera varios eventos. De forma similar, algunas aplicaciones (por ejemplo, software antivirus) pueden provocar eventos del sistema de archivo adicionales que se detectan mediante <xref:System.IO.FileSystemWatcher>.  
  
-   La <xref:System.IO.FileSystemWatcher> puede inspeccionar discos siempre y cuando no se cambia o se quitan. El <xref:System.IO.FileSystemWatcher> no genera eventos para CDs y DVDs, porque no se pueden cambiar las propiedades y marcas de tiempo. Equipos remotos deben tener una de las plataformas necesarias instaladas para que el componente funcione correctamente.  
  
-   Si hay varios <xref:System.IO.FileSystemWatcher> hay objetos inspeccionando la misma ruta de acceso UNC en Windows XP antes del Service Pack 1 o Service Pack 2 de Windows 2000 o versiones anterior, sólo uno de los objetos, se producirá un evento. En equipos que ejecutan Windows XP SP1 y versiones más recientes, Windows 2000 SP3 o posterior o Windows Server 2003, todos los <xref:System.IO.FileSystemWatcher> objetos generará los eventos adecuados.  
  
 Tenga en cuenta que un <xref:System.IO.FileSystemWatcher> puede perder un evento cuando se supera el tamaño de búfer. Para evitar eventos que faltan, siga estas instrucciones:  
  
-   Aumentar el tamaño del búfer estableciendo la <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedad.  
  
-   Evite inspeccionar archivos con nombres de archivo largos, dado que un nombre de archivo largo inciden en el búfer se llene. Considere la posibilidad de cambiar el nombre de estos archivos con nombres más cortos.  
  
-   Mantener el código lo más corta posible de control de eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.FileSystemWatcher> para inspeccionar el directorio especificado en tiempo de ejecución. El componente se establece para inspeccionar los cambios en `LastWrite` y `LastAccess` de tiempo, la creación, eliminación, o cambiar el nombre de archivos de texto en el directorio. Si se cambia, se crea o se elimina un archivo, la ruta de acceso al archivo se imprime en la consola. Cuando se cambia el nombre de un archivo, las rutas de acceso antiguos y nuevos imprimen en la consola.  
  
 Use la <xref:System.Diagnostics> y <xref:System.IO> espacios de nombres para este ejemplo.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">para derivar de la <see cref="T:System.Diagnostics.ProcessStartInfo" /> clase. Valor de la petición: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; Conjuntos con nombre de permiso: <see langword="FullTrust" />.</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileSystemWatcher" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se puede inspeccionar un equipo remoto que no tiene Windows NT o Windows 2000. No se puede inspeccionar un equipo remoto de Windows NT 4.0 desde un equipo de Windows NT 4.0.  
  
 La siguiente tabla muestra los valores de propiedad iniciales para una instancia de <xref:System.IO.FileSystemWatcher>.  
  
|Propiedad.|Valor inicial|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|combinación OR bit a bit de `LastWrite`, `FileName`, y `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*. \*"(Inspecciona todos los archivos.)|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|Una cadena vacía ("")|  
  
> [!NOTE]
>  El componente no inspeccionará el directorio especificado hasta que la <xref:System.IO.FileSystemWatcher.Path%2A> está establecida, y <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> es `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.FileSystemWatcher> objeto que se va a inspeccionar el directorio especificado en tiempo de ejecución. El <xref:System.IO.FileSystemWatcher> objeto inspecciona los cambios en `LastWrite` y `LastAccess` horas así como la creación, eliminación o cambio de nombre de texto de archivos en el directorio. Si se cambia, se crea o se elimina un archivo, la ruta de acceso al archivo se muestra en la consola. Cuando se cambia el nombre de un archivo, las rutas de acceso antiguos y nuevos se muestran en la consola.  
  
 Este ejemplo se utiliza la <xref:System.Diagnostics> y <xref:System.IO> los espacios de nombres.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">El directorio que se va a supervisar, en notación de Convención de nomenclatura universal (Universal Naming Convention, UNC) o estándar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileSystemWatcher" />, dado el directorio especificado que se va a supervisar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  El componente no inspeccionará el directorio especificado hasta que la <xref:System.IO.FileSystemWatcher.Path%2A> está establecida, y <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> es `true`.  
  
 El componente puede inspeccionar archivos en el equipo, una unidad de red o un equipo remoto.  
  
 No se puede inspeccionar un equipo remoto que no tiene Windows NT o Windows 2000. No se puede inspeccionar un equipo remoto de Windows NT 4.0 desde un equipo de Windows NT 4.0. El <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad se establece de forma predeterminada para inspeccionar todos los archivos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="path" /> es una cadena vacía ("").  
  
 O bien  
  
 La ruta de acceso especificada mediante el parámetro <paramref name="path" /> no existe.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> es demasiado largo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">El directorio que se va a supervisar, en notación de Convención de nomenclatura universal (Universal Naming Convention, UNC) o estándar.</param>
        <param name="filter">El tipo de archivos que se van a inspeccionar. Por ejemplo, "*.txt" inspecciona cambios en todos los archivos de texto.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.FileSystemWatcher" />, dado el directorio especificado y el tipo de archivos que se van a supervisar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  El componente no inspeccionará el directorio especificado hasta que la <xref:System.IO.FileSystemWatcher.Path%2A> está establecida, y <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> es `true`.  
  
 El componente puede inspeccionar archivos en el equipo, una unidad de red o un equipo remoto.  
  
 No se puede inspeccionar un equipo remoto que no tiene Windows NT o Windows 2000. No se puede inspeccionar un equipo remoto de Windows NT 4.0 desde un equipo de Windows NT 4.0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.  
  
 O bien  
  
 El parámetro <paramref name="filter" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="path" /> es una cadena vacía ("").  
  
 O bien  
  
 La ruta de acceso especificada mediante el parámetro <paramref name="path" /> no existe.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> es demasiado largo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">De plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comienza la inicialización de un objeto <see cref="T:System.IO.FileSystemWatcher" /> empleado en un formulario o utilizado por otro componente. La inicialización se produce en tiempo de ejecución.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] diseño entorno usa este método para comenzar la inicialización de un componente utilizado en un formulario o por otro componente. El <xref:System.IO.FileSystemWatcher.EndInit%2A> método termina la inicialización. Mediante el <xref:System.IO.FileSystemWatcher.BeginInit%2A> y <xref:System.IO.FileSystemWatcher.EndInit%2A> métodos impide que el control que se va a usar antes de que esté totalmente inicializado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia un archivo o un directorio en la ruta de acceso <see cref="P:System.IO.FileSystemWatcher.Path" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.FileSystemWatcher.Changed> evento se desencadena cuando se realizan cambios en el tamaño, atributos del sistema, la última escritura hora, hora del último acceso o los permisos de seguridad de un archivo o directorio en el directorio que se está supervisando.  
  
> [!NOTE]
>  Las operaciones comunes de sistema de archivos podrían generar más de un evento. Por ejemplo, cuando se mueve un archivo de un directorio a otro, varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> y algunos <xref:System.IO.FileSystemWatcher.OnCreated%2A> y <xref:System.IO.FileSystemWatcher.OnDeleted%2A> es posible que se generen eventos. Mover que un archivo es una operación compleja que consta de varias operaciones sencillas, por lo tanto, cuando se genera varios eventos. De forma similar, algunas aplicaciones (por ejemplo, software antivirus) pueden provocar eventos del sistema de archivo adicionales que se detectan mediante <xref:System.IO.FileSystemWatcher>.  
  
 Use <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> para restringir el número de notificaciones generadas cuando se controla este evento.  
  
> [!NOTE]
>  El <xref:System.IO.FileSystemWatcher.Changed> evento se desencadena de forma inesperada cuando un archivo se cambia el nombre, pero no se produce cuando se cambia el nombre de un directorio. Para inspeccionar el cambio de nombre, utilice el <xref:System.IO.FileSystemWatcher.Renamed> eventos.  
  
> [!NOTE]
>  El orden en que el <xref:System.IO.FileSystemWatcher.Changed> evento se desencadena en relación con la otra <xref:System.IO.FileSystemWatcher> eventos pueden cambiar cuando el <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propiedad no es `null`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.FileSystemWatcher.Changed> eventos para mostrar la ruta de acceso de archivo en la consola cuando se cambia el archivo inspeccionado.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se crea un archivo o un directorio en la ruta de acceso <see cref="P:System.IO.FileSystemWatcher.Path" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunas repeticiones habituales, como copiar o mover un archivo o directorio, no se corresponden directamente a un evento, pero estas repeticiones hacen que se generen eventos. Al copiar un archivo o directorio, el sistema genera un <xref:System.IO.FileSystemWatcher.Created> eventos en el directorio a la que se copió el archivo, si se está inspeccionando ese directorio. Si el directorio desde el que se copió lo estuviera inspeccionando otra instancia de <xref:System.IO.FileSystemWatcher>, no se provocaría ningún evento. Por ejemplo, cree dos instancias de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 está establecido para inspeccionar "C:\My Documents" y FileSystemWatcher2 está establecido para inspeccionar "C:\Your Documents". Si copia un archivo de "Mis documentos" en "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> se generará el evento FileSystemWatcher2, pero se genera ningún evento para FileSystemWatcher1. A diferencia de copiar, mover un archivo o directorio se generan dos eventos. En el ejemplo anterior, si mueve un archivo desde "My Documents" hasta "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> se provocaría el evento FileSystemWatcher2 y un <xref:System.IO.FileSystemWatcher.Deleted> se provocaría el evento FileSystemWatcher1.  
  
> [!NOTE]
>  Las operaciones comunes de sistema de archivos podrían generar más de un evento. Por ejemplo, cuando se mueve un archivo de un directorio a otro, varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> y algunos <xref:System.IO.FileSystemWatcher.OnCreated%2A> y <xref:System.IO.FileSystemWatcher.OnDeleted%2A> es posible que se generen eventos. Mover que un archivo es una operación compleja que consta de varias operaciones sencillas, por lo tanto, cuando se genera varios eventos. De forma similar, algunas aplicaciones (por ejemplo, software antivirus) pueden provocar eventos del sistema de archivo adicionales que se detectan mediante <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  El orden en que el <xref:System.IO.FileSystemWatcher.Created> evento se desencadena en relación con la otra <xref:System.IO.FileSystemWatcher> eventos pueden cambiar cuando el <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propiedad no es `null`.  
  
 El <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento se desencadena en cuanto se crea un archivo. Si un archivo se va a copiar o se transfiere a un directorio inspeccionado, la <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento se activará inmediatamente, seguido de uno o varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.FileSystemWatcher.Created> eventos para mostrar la ruta de acceso de archivo en la consola cuando se crea el archivo inspeccionado.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se elimina un archivo o un directorio en la ruta de acceso <see cref="P:System.IO.FileSystemWatcher.Path" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunas repeticiones habituales, como copiar o mover un archivo o directorio, no se corresponden directamente a un evento, pero estas repeticiones hacen que se generen eventos. Al copiar un archivo o directorio, el sistema genera un <xref:System.IO.FileSystemWatcher.Created> eventos en el directorio a la que se copió el archivo, si se está inspeccionando ese directorio. Si el directorio desde el que se copió lo estuviera inspeccionando otra instancia de <xref:System.IO.FileSystemWatcher>, no se provocaría ningún evento. Por ejemplo, cree dos instancias de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 está establecido para inspeccionar "C:\My Documents" y FileSystemWatcher2 está establecido para inspeccionar "C:\Your Documents". Si copia un archivo de "Mis documentos" en "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> se generará el evento FileSystemWatcher2, pero se genera ningún evento para FileSystemWatcher1. A diferencia de copiar, mover un archivo o directorio se generan dos eventos. En el ejemplo anterior, si mueve un archivo desde "My Documents" hasta "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> se provocaría el evento FileSystemWatcher2 y un <xref:System.IO.FileSystemWatcher.Deleted> se provocaría el evento FileSystemWatcher1.  
  
> [!NOTE]
>  Las operaciones comunes de sistema de archivos podrían generar más de un evento. Por ejemplo, cuando se mueve un archivo de un directorio a otro, varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> y algunos <xref:System.IO.FileSystemWatcher.OnCreated%2A> y <xref:System.IO.FileSystemWatcher.OnDeleted%2A> es posible que se generen eventos. Mover que un archivo es una operación compleja que consta de varias operaciones sencillas, por lo tanto, cuando se genera varios eventos. De forma similar, algunas aplicaciones (por ejemplo, software antivirus) pueden provocar eventos del sistema de archivo adicionales que se detectan mediante <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  El orden en que el <xref:System.IO.FileSystemWatcher.Deleted> evento se desencadena en relación con la otra <xref:System.IO.FileSystemWatcher> eventos pueden cambiar cuando el <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propiedad no es `null`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.FileSystemWatcher.Deleted> eventos para mostrar la ruta de acceso a la consola cada vez que se elimina el archivo inspeccionado.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.IO.FileSystemWatcher" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama a este método público <xref:System.ComponentModel.Component.Dispose%2A> método y <xref:System.Object.Finalize%2A> método. <xref:System.ComponentModel.Component.Dispose%2A> se invoca el protegido <xref:System.IO.FileSystemWatcher.Dispose%2A> método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca <xref:System.IO.FileSystemWatcher.Dispose%2A> con `disposing` establecido en `false`.  
  
 Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.IO.Compression.DeflateStream> hace referencia. Este método invoca al método <xref:System.ComponentModel.Component.Dispose%2A> de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> puede recibir varias llamadas de otros objetos. Al reemplazar <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see cref="M:System.ComponentModel.Component.Dispose" />. Para obtener más información sobre cómo implementar <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />, consulte [implementa un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obtener más información acerca de <see cref="M:System.ComponentModel.Component.Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el componente está habilitado.</summary>
        <value>
          Es <see langword="true" /> si el componente está habilitado; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />. Si se utiliza el componente en un diseñador de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)], el valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El componente no provocará eventos a menos que establezca <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> a `true`.  
  
> [!NOTE]
>  El componente no inspeccionará el directorio especificado hasta que la <xref:System.IO.FileSystemWatcher.Path%2A> se ha establecido la propiedad y <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> es `true`.  
  
 El <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> método permite a los controladores de eventos que se debe invocar para responder a los cambios de archivo, incluso si esta propiedad se establece en `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.FileSystemWatcher> para inspeccionar el directorio especificado en tiempo de ejecución. El componente se establece para inspeccionar los cambios en `LastWrite` y `LastAccess` de tiempo, la creación, eliminación, o cambiar el nombre de archivos de texto en el directorio. Si se cambia, se crea o se elimina un archivo, la ruta de acceso al archivo se imprime en la consola. Cuando se cambia el nombre de un archivo, las rutas de acceso antiguos y nuevos imprimen en la consola.  
  
 Use la <xref:System.Diagnostics> y <xref:System.IO> espacios de nombres para este ejemplo.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se eliminó el objeto <see cref="T:System.IO.FileSystemWatcher" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo actual no es Microsoft Windows NT o posterior.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el directorio especificado en <see cref="P:System.IO.FileSystemWatcher.Path" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.IO.FileSystemWatcher.Path" /> no se ha establecido o no es válida.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina la inicialización de un objeto <see cref="T:System.IO.FileSystemWatcher" /> empleado en un formulario o utilizado por otro componente. La inicialización se produce en tiempo de ejecución.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] diseño entorno usa este método para finalizar la inicialización de un componente utilizado en un formulario o por otro componente. El <xref:System.IO.FileSystemWatcher.BeginInit%2A> método comienza la inicialización. Mediante el <xref:System.IO.FileSystemWatcher.BeginInit%2A> y <xref:System.IO.FileSystemWatcher.EndInit%2A> métodos impide que el control que se va a usar antes de que esté totalmente inicializado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la instancia de <see cref="T:System.IO.FileSystemWatcher" /> no puede continuar supervisando los cambios o cuando el búfer interno se desborda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena cuando algo impide que la <xref:System.IO.FileSystemWatcher> objeto de supervisión de los cambios. Por ejemplo, si el objeto es supervisar los cambios en un directorio remoto y se pierde la conexión a ese directorio, la <xref:System.IO.FileSystemWatcher.Error> evento se desencadena.  
  
 El sistema le informa de los cambios de archivo y almacena esos cambios en un búfer que el componente crea y pasa a la API. Si hay muchos cambios en poco tiempo, el búfer puede desbordarse. Esto hace que el componente a perder el seguimiento de cambios en el directorio y sólo puede proporcionar una notificación general. Aumentar el tamaño del búfer es costoso, porque se trata de no paginado de memoria que no es posible intercambiar en el disco, por lo que tenga el búfer tan pequeño como sea posible. Para evitar un desbordamiento de búfer, utilice el <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.Filter%2A>, y <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> las notificaciones de cambio de propiedades para filtrar no deseados.  
  
> [!NOTE]
>  Las operaciones comunes de sistema de archivos podrían generar más de un evento. Por ejemplo, cuando se mueve un archivo de un directorio a otro, varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> y algunos <xref:System.IO.FileSystemWatcher.OnCreated%2A> y <xref:System.IO.FileSystemWatcher.OnDeleted%2A> es posible que se generen eventos. Mover que un archivo es una operación compleja que consta de varias operaciones sencillas, por lo tanto, cuando se genera varios eventos. De forma similar, algunas aplicaciones (por ejemplo, software antivirus) pueden provocar eventos del sistema de archivo adicionales que se detectan mediante <xref:System.IO.FileSystemWatcher>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la cadena de filtro utilizada para determinar qué archivos se supervisan en un directorio.</summary>
        <value>La cadena de filtro. El valor predeterminado es "*. \*"(Inspecciona todos los archivos.)</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para inspeccionar cambios en todos los archivos, establezca la <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad en una cadena vacía (""). Para inspeccionar un archivo específico, establezca la <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad con el nombre de archivo. Por ejemplo, para ver los cambios en el archivo MyDoc.txt, establezca el <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad en "MyDoc.txt". También puede ver los cambios en un determinado tipo de archivo. Por ejemplo, para ver si hay cambios en los archivos de texto, establezca la <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad como "*.txt". Uso de varios filtros, como "\*.txt&#124;\*.doc" no se admite.  
  
 El <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad se puede cambiar después de la <xref:System.IO.FileSystemWatcher> objeto haya empezado a recibir eventos.  
  
 Para obtener más información acerca de cómo filtrar notificaciones no deseadas, vea el <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, y <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedades.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> acepta caracteres comodín para encontrar archivos coincidentes, tal como se muestra en los ejemplos siguientes.  
  
|Cadena de filtro|Supervisa los siguientes archivos|  
|-------------------|---------------------------------|  
|*.\*|Todos los archivos (valor predeterminado). Una cadena vacía ("") también inspecciona todos los archivos.|  
|*.txt|Todos los archivos con la extensión "txt".|  
|*recipe.doc|Todos los archivos que terminan en "receta" con una extensión "doc".|  
|win*.xml|Todos los archivos que comienzan por "win" con una extensión "xml".|  
|Ventas * 200?. xls|Coincide con lo siguiente:<br /><br /> Julio de ventas 2001.xls agosto 2002.xls marzo 2004.xls<br /><br /> pero no coincide con:<br /><br /> 1999.xls de ventas de noviembre|  
|MyReport.Doc|Inspecciona sólo MyReport.doc|  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.FileSystemWatcher> para inspeccionar el directorio especificado en tiempo de ejecución. El componente se establece para inspeccionar los cambios en `LastWrite` y `LastAccess` de tiempo, la creación, eliminación, o cambiar el nombre de archivos de texto en el directorio. Si se cambia, se crea o se elimina un archivo, la ruta de acceso al archivo se imprime en la consola. Cuando se cambia el nombre de un archivo, las rutas de acceso antiguos y nuevos imprimen en la consola.  
  
 Use la <xref:System.Diagnostics> y <xref:System.IO> espacios de nombres para este ejemplo.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se deben supervisar los subdirectorios de la ruta de acceso especificada.</summary>
        <value>
          Es <see langword="true" /> si desea supervisar subdirectorios; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> a `true` cuando desee ver notificaciones de cambio de archivos y directorios contenidos dentro del directorio especificado a través de la <xref:System.IO.FileSystemWatcher.Path%2A> propiedad y sus subdirectorios. Establecer el <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> propiedad `false` ayuda a reduce el número de notificaciones enviadas al búfer interno. Para obtener más información sobre cómo filtrar notificaciones no deseadas, vea el <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> y <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedades.  
  
 Cuando `true`, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> es recursiva por todo el subárbol, no solamente en los directorios secundarios inmediatos. Devuelve la ruta de acceso relativa a un archivo o directorio dentro del subárbol de la <xref:System.IO.FileSystemEventArgs.Name%2A> propiedad de <xref:System.IO.FileSystemEventArgs> y <xref:System.IO.RenamedEventArgs.OldName%2A> propiedad de <xref:System.IO.RenamedEventArgs>, en función de los cambios que está inspeccionando. Puede obtener la ruta de acceso completa de la <xref:System.IO.FileSystemEventArgs.FullPath%2A> propiedad de <xref:System.IO.FileSystemEventArgs> y <xref:System.IO.RenamedEventArgs.OldFullPath%2A> propiedad de <xref:System.IO.RenamedEventArgs>, en función de los cambios que esté inspeccionando.  
  
 Si se crea un directorio en el subárbol del directorio que está inspeccionando, y <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> es `true`, automáticamente se observarán ese directorio.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño (en bytes) del búfer interno.</summary>
        <value>Tamaño del búfer interno en bytes. El valor predeterminado es 8192 (8 KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede establecer el búfer de 4 KB o superior, pero no debe superar los 64 KB. Si se intenta establecer el <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedad a inferior a 4096 bytes, el valor se descarta y el <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedad está establecida en 4096 bytes. Para obtener el mejor rendimiento, use un múltiplo de 4 KB en equipos basados en Intel.  
  
 El sistema notifica al componente de cambios del archivo y almacena esos cambios en un búfer que el componente crea y pasa a las API. Cada evento puede utilizar hasta 16 bytes de memoria, sin incluir el nombre de archivo. Si hay muchos cambios en poco tiempo, el búfer puede desbordarse. Esto hace que el componente a perder el seguimiento de cambios en el directorio y sólo puede proporcionar una notificación general. Aumentar el tamaño del búfer puede evitar que los eventos de cambio de la falta de sistema de archivos. Sin embargo, si aumenta el tamaño de búfer es caro, porque se trata de la memoria no paginada que no se puede intercambiar en el disco, por lo que mantener el búfer tan pequeño como sea posible. Para evitar un desbordamiento de búfer, utilice el <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> y <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> las notificaciones de cambio de propiedades para filtrar no deseados.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tipo de cambios que se van a inspeccionar.</summary>
        <value>Uno de los valores de <see cref="T:System.IO.NotifyFilters" />. El valor predeterminado es la combinación OR bit a bit de <see langword="LastWrite" />, <see langword="FileName" /> y <see langword="DirectoryName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede combinar los miembros de la <xref:System.IO.NotifyFilters> enumeración para inspeccionar más de un tipo de cambio a la vez. Por ejemplo, puede observar los cambios en el tamaño de un archivo y cambios en las `LastWrite` tiempo. Esto provoca un evento cada vez que hay un cambio de tamaño de archivo o una carpeta o un cambio en el `LastWrite` tiempo del archivo o carpeta.  
  
 Se trata de una manera de filtrar notificaciones no deseadas. Para obtener más información sobre cómo filtrar notificaciones no deseadas, vea el <xref:System.IO.FileSystemWatcher.Filter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, y <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> propiedades.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.FileSystemWatcher> para inspeccionar el directorio especificado en tiempo de ejecución. El componente se establece para inspeccionar los cambios en `LastWrite` y `LastAccess` de tiempo, la creación, eliminación, o cambiar el nombre de archivos de texto en el directorio. Si se cambia, se crea o se elimina un archivo, la ruta de acceso al archivo se imprime en la consola. Cuando se cambia el nombre de un archivo, las rutas de acceso antiguos y nuevos imprimen en la consola.  
  
 Use la <xref:System.Diagnostics> y <xref:System.IO> espacios de nombres para este ejemplo.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor no es una combinación OR bit a bit de los valores <see cref="T:System.IO.NotifyFilters" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">El valor que se está estableciendo no es válido.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.IO.FileSystemEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.IO.FileSystemWatcher.Changed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> se llama cuando se realizan cambios en el tamaño, los atributos del sistema, última hora de escritura, hora del último acceso o permisos de seguridad de un archivo o directorio en el directorio que se está supervisando.  
  
 Use la <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> propiedad para restringir el número de eventos genera cuando el <xref:System.IO.FileSystemWatcher.Changed> evento está controlado.  
  
 El <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento se desencadena en cuanto se crea un archivo. Si un archivo se va a copiar o se transfiere a un directorio inspeccionado, la <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento se activará inmediatamente, seguido de uno o varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> eventos.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> método.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.IO.FileSystemEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.IO.FileSystemWatcher.Created" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> se llama cuando se crea un archivo o directorio en el directorio que se está supervisando.  
  
 Algunas repeticiones habituales, como copiar o mover un archivo o directorio, no se corresponden directamente a un evento, pero estas repeticiones hacen que se generen eventos. Al copiar un archivo o directorio, el sistema genera un <xref:System.IO.FileSystemWatcher.Created> eventos en el directorio a la que se copió el archivo, si se está inspeccionando ese directorio. Si el directorio desde el que se copió lo estuviera inspeccionando otra instancia de <xref:System.IO.FileSystemWatcher>, no se provocaría ningún evento. Por ejemplo, cree dos instancias de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 está establecido para inspeccionar "C:\My Documents" y FileSystemWatcher2 está establecido para inspeccionar "C:\Your Documents". Si se copia un archivo desde "Mis documentos" y se pega en "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> evento se activará en FileSystemWatcher2, pero se genera ningún evento para FileSystemWatcher1. A diferencia de copiar, mover un archivo o directorio genera dos eventos. En el ejemplo anterior, si mueve un archivo desde "My Documents" hasta "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> se provocaría el evento en FileSystemWatcher2 y un <xref:System.IO.FileSystemWatcher.Deleted> se provocaría el evento en FileSystemWatcher1.  
  
 El <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento se desencadena en cuanto se crea un archivo. Si un archivo se va a copiar o se transfiere a un directorio inspeccionado, la <xref:System.IO.FileSystemWatcher.OnCreated%2A> evento se activará inmediatamente, seguido de uno o varios <xref:System.IO.FileSystemWatcher.OnChanged%2A> eventos.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> método.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.IO.FileSystemEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.IO.FileSystemWatcher.Deleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> se llama cuando se elimina un archivo o directorio en el directorio que se está supervisando.  
  
 Algunas repeticiones habituales, como copiar o mover un archivo o directorio, no se corresponden directamente a un evento, pero estas repeticiones hacen que se generen eventos. Al copiar un archivo o directorio, el sistema genera un <xref:System.IO.FileSystemWatcher.Created> eventos en el directorio a la que se copió el archivo, si se está inspeccionando ese directorio. Si el directorio desde el que se copió lo estuviera inspeccionando otra instancia de <xref:System.IO.FileSystemWatcher>, no se provocaría ningún evento. Por ejemplo, cree dos instancias de <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 está establecido para inspeccionar "C:\My Documents" y FileSystemWatcher2 está establecido para inspeccionar "C:\Your Documents". Si copia un archivo de "Mis documentos" en "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> se generará el evento FileSystemWatcher2, pero se genera ningún evento para FileSystemWatcher1. A diferencia de copiar, mover un archivo o directorio genera dos eventos. En el ejemplo anterior, si mueve un archivo desde "My Documents" hasta "Your Documents", un <xref:System.IO.FileSystemWatcher.Created> se provocaría el evento FileSystemWatcher2 y un <xref:System.IO.FileSystemWatcher.Deleted> se provocaría el evento FileSystemWatcher1.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> método.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.IO.ErrorEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.IO.FileSystemWatcher.Error" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> se llama cuando se produce un error.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> método.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.IO.RenamedEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.IO.FileSystemWatcher.Renamed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> se llama cuando se cambia el nombre de un archivo o directorio en el directorio que se está supervisando. Su <xref:System.IO.RenamedEventArgs> argumento contiene información sobre la operación de cambio de nombre, como el tipo de cambio, la ruta de acceso antiguo y nuevo y el nombre antiguo y nuevo. Tenga en cuenta que su <xref:System.IO.FileSystemEventArgs.Name> propiedad puede ser null para cambiar el nombre de eventos si el <xref:System.IO.FileSystemWatcher> no obtener encontrar coincidencias con nombre antiguos y nuevos eventos del sistema operativo. 
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> método.</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la ruta de acceso del directorio que se va a inspeccionar.</summary>
        <value>La ruta de acceso que se va a supervisar. El valor predeterminado es una cadena vacía ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de una ruta de acceso completa a un directorio. Si el <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> propiedad es `true`, este directorio es la raíz en el que el sistema inspecciona los cambios; en caso contrario, es el único directorio inspeccionado. Para inspeccionar un archivo específico, establezca la <xref:System.IO.FileSystemWatcher.Path%2A> propiedad en el directorio completo, correcto y el <xref:System.IO.FileSystemWatcher.Filter%2A> propiedad con el nombre de archivo.  
  
 El <xref:System.IO.FileSystemWatcher.Path%2A> propiedad es compatible con las rutas de acceso de convención de nomenclatura universal (UNC, Universal Naming Convention).  
  
> [!NOTE]
>  Esta propiedad debe establecerse antes de que el componente puede ver los cambios.  
  
 Cuando se cambia el nombre de un directorio, el <xref:System.IO.FileSystemWatcher> asocia de nuevo automáticamente al elemento cuyo nombre ha cambiado. Por ejemplo, si establece la <xref:System.IO.FileSystemWatcher.Path%2A> propiedad en "C:\My Documents" y, a continuación, cambie manualmente el nombre del directorio a "C:\Your Documents", el componente continúa escuchando notificaciones de cambio en el directorio cuyo nombre ha cambiado. Sin embargo, cuando se le solicite el <xref:System.IO.FileSystemWatcher.Path%2A> propiedad, contiene la ruta de acceso anterior. Esto sucede porque el componente determina qué directorio inspecciona según el identificador, en lugar de con el nombre del directorio. Cambiar el nombre no afecta al identificador. Por lo tanto, si se destruye el componente y, a continuación, volver a crear sin actualizar la <xref:System.IO.FileSystemWatcher.Path%2A> propiedad, se producirá un error en la aplicación porque el directorio ya no existe.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.IO.FileSystemWatcher> para inspeccionar el directorio especificado en tiempo de ejecución. El componente se establece para inspeccionar los cambios en `LastWrite` y `LastAccess` de tiempo, la creación, eliminación, o cambiar el nombre de archivos de texto en el directorio. Si se cambia, se crea o se elimina un archivo, la ruta de acceso al archivo se imprime en la consola. Cuando se cambia el nombre de un archivo, las rutas de acceso antiguos y nuevos imprimen en la consola.  
  
 Use la <xref:System.Diagnostics> y <xref:System.IO> espacios de nombres para este ejemplo.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso especificada no existe o no se encuentra.  
  
 O bien  
  
 La ruta de acceso especificada contiene caracteres comodín.  
  
 O bien  
  
 La ruta de acceso especificada contiene caracteres de ruta de acceso no válidos.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se cambia de nombre un archivo o un directorio de la ruta de acceso <see cref="P:System.IO.FileSystemWatcher.Path" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Renamed` evento es un <xref:System.IO.RenamedEventHandler> delegado que tiene la siguiente firma:

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 El <xref:System.IO.RenamedEventArgs> proporciona información sobre la operación de cambio de nombre, como el tipo de cambiar el nombre de objeto (el <xref:System.IO.FileSystemEventArgs.ChangeType> propiedad), el nombre antiguo y nuevo y la ruta de acceso antiguo y nuevo. Tenga en cuenta que la <xref:System.IO.FileSystemEventArgs.Name> propiedad puede ser null para cambiar el nombre de eventos si el <xref:System.IO.FileSystemWatcher> no obtener encontrar coincidencias con nombre antiguos y nuevos eventos del sistema operativo.

 Cambiar el nombre del directorio que está inspeccionando no generará una notificación. Solo se producen notificaciones para las entradas en el directorio que está inspeccionando.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.FileSystemWatcher.Renamed> eventos para mostrar la ruta de acceso de archivo en la consola cuando se cambia el nombre del archivo inspeccionado.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una interfaz <see cref="T:System.ComponentModel.ISite" /> para el objeto <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <value>Estructura <see cref="T:System.ComponentModel.ISite" /> para la colección <see cref="T:System.IO.FileSystemWatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sitios de enlazan un <xref:System.ComponentModel.Component> a una <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> y habilitar la comunicación entre ellos, así como proporcionar una manera para que el contenedor administrar sus componentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto utilizado para serializar de las llamadas del controlador de eventos emitidas como consecuencia de un cambio de directorio.</summary>
        <value>Objeto <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> que representa el objeto utilizado para calcular las referencias de las llamadas del controlador de eventos emitidas como consecuencia de un cambio de directorio. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> es `null`, métodos que controlan la <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, y <xref:System.IO.FileSystemWatcher.Renamed> eventos se llaman en un subproceso del grupo de subprocesos del sistema. Para obtener más información sobre grupos de subprocesos del sistema, consulte <xref:System.Threading.ThreadPool>.  
  
 Cuando el <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, y <xref:System.IO.FileSystemWatcher.Renamed> eventos se controlan mediante un componente visual de formularios Windows Forms, como un <xref:System.Windows.Forms.Button>, acceso al componente en el grupo de subprocesos de sistema podrían no funcionar, o puede producir una excepción. Evitarlo estableciendo <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> a un componente de Windows Forms, lo que hace que los métodos que controlan la <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, y <xref:System.IO.FileSystemWatcher.Renamed> eventos que se llame en el mismo subproceso en el que se creó el componente.  
  
 Si el <xref:System.IO.FileSystemWatcher> se utiliza dentro de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] en un diseñador de formularios Windows Forms, <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> se establece automáticamente en el control que contiene el <xref:System.IO.FileSystemWatcher>. Por ejemplo, si coloca un <xref:System.IO.FileSystemWatcher> en un diseñador de Form1 (que hereda de <xref:System.Windows.Forms.Form>) la <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> propiedad de <xref:System.IO.FileSystemWatcher> se establece en la instancia de Form1.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Método sincrónico que devuelve una estructura que contiene información específica acerca del cambio que se ha producido.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">Objeto <see cref="T:System.IO.WatcherChangeTypes" /> que se va a inspeccionar.</param>
        <summary>Un método sincrónico que devuelve una estructura que contiene información específica acerca del cambio que se ha producido, dado el tipo de cambio que desea supervisar.</summary>
        <returns>Un objeto <see cref="T:System.IO.WaitForChangedResult" /> que contiene información específica acerca del cambio que se ha producido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método espera indefinidamente hasta que el primer cambio se produce y, a continuación, se devuelve. Esto es lo mismo que usar <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> con el `timeout` parámetro establecido en -1.  
  
> [!NOTE]
>  Este método permite que un controlador de eventos que se debe invocar para responder a archivo cambios, aunque la <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> propiedad está establecida en `false`.  
  
 En algunos sistemas, <xref:System.IO.FileSystemWatcher> informa de los cambios a los archivos con el formato de nombre corto de 8.3 archivo. Por ejemplo, un cambio en "longfilename.LongExtension", éste podría aparecer como "LongFi ~. LON".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">Objeto <see cref="T:System.IO.WatcherChangeTypes" /> que se va a inspeccionar.</param>
        <param name="timeout">El tiempo (en milisegundos) que se va a esperar antes de que se agote el tiempo de espera.</param>
        <summary>Método sincrónico que devuelve una estructura que contiene información específica acerca del cambio que se ha producido, dado el tipo de cambio que desea supervisar y el tiempo (en milisegundos) que se va a esperar antes de que se agote el tiempo de espera.</summary>
        <returns>Un objeto <see cref="T:System.IO.WaitForChangedResult" /> que contiene información específica acerca del cambio que se ha producido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método espera hasta que se produce un cambio o ha agotado. Un valor de -1 para el `timeout` significa esperar indefinidamente.  
  
> [!NOTE]
>  Este método permite que un controlador de eventos que se debe invocar para responder a archivo cambios, aunque la <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> propiedad está establecida en `false`.  
  
 En algunos sistemas, <xref:System.IO.FileSystemWatcher> informa de los cambios a los archivos con el formato de nombre corto de 8.3 archivo. Por ejemplo, un cambio en "longfilename.LongExtension", éste podría aparecer como "LongFi ~. LON".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>