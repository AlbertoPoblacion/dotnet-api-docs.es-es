<Type Name="Timer" FullName="System.Timers.Timer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fcc0e5e5a3656054b36a6ed93ec6732ed26646c9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36406585" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Timers.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Elapsed")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Interval")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Generates an event after a set interval, with an option to generate recurring events.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Timers.Timer> componente es un temporizador basado en servidor que genera un <xref:System.Timers.Timer.Elapsed> eventos en la aplicación después del número de milisegundos en la <xref:System.Timers.Timer.Interval%2A> ha transcurrido la propiedad. Puede configurar la <xref:System.Timers.Timer> objeto para generar el evento solo una vez o varias veces mediante la <xref:System.Timers.Timer.AutoReset%2A> propiedad. Normalmente, un <xref:System.Timers.Timer> objeto se declara en el nivel de clase para que permanezca en el ámbito siempre y cuando sea necesario. A continuación, puede controlar su <xref:System.Timers.Timer.Elapsed> eventos para proporcionar procesamiento normal. Por ejemplo, suponga que tiene un servidor crítico que se debe mantener ejecuta 24 horas al día, 7 días a la semana. Puede crear un servicio que utiliza un <xref:System.Timers.Timer> objeto para comprobar periódicamente el servidor y asegúrese de que el sistema está en funcionamiento. Si el sistema no responde, el servicio podría intentar reiniciar el servidor o para notificar a un administrador.  
  
> [!IMPORTANT]
> La <xref:System.Timers.Timer> clase no está disponible para todas las implementaciones de .NET y las versiones, como 1.6 estándar de .NET y las versiones inferiores.
> En estos casos, puede usar el <xref:System.Threading.Timer?displayProperty=nameWithType> clase en su lugar.
  
 Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo, debe eliminar del mismo directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él indirectamente, use una construcción de lenguaje como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
 Basada en el servidor <xref:System.Timers.Timer?displayProperty=nameWithType> clase está diseñada para su uso con subprocesos de trabajo en un entorno multiproceso. Temporizadores de servidor pueden desplazarse entre subprocesos para controlar presionado <xref:System.Timers.Timer.Elapsed> eventos, lo que produce más precisión que los temporizadores de Windows en generar el evento de tiempo.  
  
 El <xref:System.Timers.Timer?displayProperty=nameWithType> componente genera el <xref:System.Timers.Timer.Elapsed> eventos, en función del valor (en milisegundos) de la <xref:System.Timers.Timer.Interval%2A> propiedad. Puede controlar este evento para realizar el procesamiento que es necesario. Por ejemplo, suponga que tiene una aplicación de ventas en línea que envía continuamente pedidos de ventas a una base de datos. El servicio que compila las instrucciones de envío funciona en un lote de pedidos, en lugar de procesar cada pedido individualmente. Puede usar un <xref:System.Timers.Timer> para iniciar la cada 30 minutos de procesamiento por lotes.  
  
> [!IMPORTANT]
>  La clase System.Timers.Timer tiene la misma resolución que el reloj del sistema. Esto significa que la <xref:System.Timers.Timer.Elapsed> evento se desencadenará a un intervalo definido por la resolución del reloj del sistema si el <xref:System.Timers.Timer.Interval%2A> propiedad es menor que la resolución del reloj del sistema. Para obtener más información, vea la propiedad <xref:System.Timers.Timer.Interval%2A>.  
  
 Cuando <xref:System.Timers.Timer.AutoReset%2A> está establecido en `false`, <xref:System.Timers.Timer?displayProperty=nameWithType> objeto genera el <xref:System.Timers.Timer.Elapsed> eventos una sola vez, después de la primera <xref:System.Timers.Timer.Interval%2A> ha transcurrido. Para mantener la <xref:System.Timers.Timer.Elapsed> eventos periódicamente en el intervalo definido por el <xref:System.Timers.Timer.Interval%2A>, establezca <xref:System.Timers.Timer.AutoReset%2A> a `true`, que es el valor predeterminado.  
  
 El <xref:System.Timers.Timer> componente detecta y suprime todas las excepciones producidas por controladores de eventos para el <xref:System.Timers.Timer.Elapsed> eventos. Este comportamiento está sujeta a cambios en futuras versiones de .NET Framework. Sin embargo, tenga en cuenta que esto no es así para controladores de eventos que se ejecutan de forma asincrónica e incluyen la `await` operador (en C#) o `Await` (operador) (en Visual Basic). Las excepciones iniciadas en estos controladores de eventos se propagan hacia el subproceso que realiza la llamada, como se muestra en el ejemplo siguiente. Para obtener más información sobre las excepciones iniciadas en métodos asincrónicos, vea [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 Si el <xref:System.Timers.Timer.SynchronizingObject%2A> propiedad es `null`, <xref:System.Timers.Timer.Elapsed> evento se desencadena en un <xref:System.Threading.ThreadPool> subproceso. Si el procesamiento de la <xref:System.Timers.Timer.Elapsed> evento dura más de <xref:System.Timers.Timer.Interval%2A>, el evento se puede generar de nuevo en otro <xref:System.Threading.ThreadPool> subproceso. En esta situación, el controlador de eventos debe ser de reentrada.  
  
> [!NOTE]
>  El método de control de eventos puede ejecutarse en un subproceso al mismo tiempo que otro subproceso llama a la <xref:System.Timers.Timer.Stop%2A> método o establece la <xref:System.Timers.Timer.Enabled%2A> propiedad `false`. Esto podría dar lugar a la <xref:System.Timers.Timer.Elapsed> evento que se provoca cuando se detiene el temporizador. El código de ejemplo para el <xref:System.Timers.Timer.Stop%2A> método muestra una manera de evitar esta condición de carrera.  
  
 Aunque <xref:System.Timers.Timer.SynchronizingObject%2A> no es `null`, <xref:System.Timers.Timer.Elapsed> eventos pueden producirse después de la <xref:System.Timers.Timer.Dispose%2A> o <xref:System.Timers.Timer.Stop%2A> ha llamado al método o después la <xref:System.Timers.Timer.Enabled%2A> propiedad se ha establecido en `false`, porque la señal para generar el <xref:System.Timers.Timer.Elapsed> eventos siempre está en cola para su ejecución en un subproceso del grupo. Una manera de resolver esta condición de carrera es establecer una marca que indica el controlador de eventos para el <xref:System.Timers.Timer.Elapsed> evento omita algunos eventos posteriores.  
  
 Si usa el <xref:System.Timers.Timer?displayProperty=nameWithType> clase con un elemento de la interfaz de usuario, como un formulario o control, sin colocar el temporizador en ese elemento de la interfaz de usuario, asignar el formulario o control que contiene el <xref:System.Timers.Timer> a la <xref:System.Timers.Timer.SynchronizingObject%2A> propiedad, por lo que el evento es calcular las referencias en el subproceso de interfaz de usuario.  
  
 Para obtener una lista de valores de propiedad predeterminados para una instancia de <xref:System.Timers.Timer>, consulte el <xref:System.Timers.Timer.%23ctor%2A> constructor.  
  
> [!TIP]
>  Tenga en cuenta que .NET incluye cuatro clases denominadas `Timer`, cada una de la que ofrece una funcionalidad diferente:  
>   
> - <xref:System.Timers.Timer?displayProperty=nameWithType> (este tema): se desencadena un evento a intervalos regulares. La clase está diseñada para usarla como basada en un servidor o componente del servicio en un entorno multiproceso; no tiene ninguna interfaz de usuario y no es visible en tiempo de ejecución.  
> - <xref:System.Threading.Timer?displayProperty=nameWithType>: ejecuta un método de devolución de llamada solo en un subproceso del grupo a intervalos regulares. Se define el método de devolución de llamada cuando el temporizador se crea una instancia y no se puede cambiar. Al igual que el <xref:System.Timers.Timer?displayProperty=nameWithType> (clase), esta clase está pensada para su uso como un componente basado en servidor o el servicio en un entorno multiproceso; no tiene ninguna interfaz de usuario y no es visible en tiempo de ejecución.  
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (Solo en .NET framework): un componente de Windows Forms que se desencadena un evento a intervalos regulares. El componente no tiene ninguna interfaz de usuario y está diseñado para su uso en un entorno de un único subproceso.  
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (Solo en .NET framework): un componente ASP.NET que realiza postback de página web asincrónicos o sincrónicos a intervalos regulares.  

## Examples  
 El ejemplo siguiente crea un `System.Timers.Timer` objeto que se activa su <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento cada dos segundos (2.000 milisegundos), configura un controlador de eventos para el evento e inicia el temporizador. El controlador de eventos muestra el valor de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propiedad cada vez que se genera.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Cualquier público <see langword="static" /> miembros de este tipo son seguros para subprocesos. No se garantiza que los miembros de instancias sean seguros para la ejecución de subprocesos.</threadsafe>
    <altmember cref="P:System.Timers.Timer.AutoReset" />
    <altmember cref="P:System.Timers.Timer.Interval" />
    <altmember cref="E:System.Timers.Timer.Elapsed" />
    <altmember cref="M:System.Timers.Timer.#ctor" />
    <altmember cref="T:System.Threading.Timer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Timers.Timer" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Timers.Timer" /> class, and sets all the properties to their initial values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La siguiente tabla muestra los valores de propiedad iniciales para una instancia de <xref:System.Timers.Timer>.  
  
|Property|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Timers.Timer.AutoReset%2A>|`true`|  
|<xref:System.Timers.Timer.Enabled%2A>|`false`|  
|<xref:System.Timers.Timer.Interval%2A>|100 milisegundos|  
|<xref:System.Timers.Timer.SynchronizingObject%2A>|Referencia nula (`Nothing` en Visual Basic).|  
  
   
  
## Examples  
 El ejemplo siguiente crea un <xref:System.Timers.Timer> objeto que se activa su <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento cada dos segundos (2000 milisegundos), configura un controlador de eventos para el evento e inicia el temporizador. El controlador de eventos muestra el valor de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propiedad cada vez que se genera.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (double interval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (interval As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(double interval);" />
      <MemberSignature Language="F#" Value="new System.Timers.Timer : double -&gt; System.Timers.Timer" Usage="new System.Timers.Timer interval" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="interval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="interval">The time, in milliseconds, between events. The value must be greater than zero and less than or equal to <see cref="F:System.Int32.MaxValue" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Timers.Timer" /> class, and sets the <see cref="P:System.Timers.Timer.Interval" /> property to the specified number of milliseconds.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor establece la <xref:System.Timers.Timer.Interval%2A> propiedad de la nueva instancia de temporizador, pero no habilita el temporizador.  
  
   
  
## Examples  
 El ejemplo siguiente crea un <xref:System.Timers.Timer> objeto que se activa su <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento cada dos segundos (2000 milisegundos), configura un controlador de eventos para el evento e inicia el temporizador. El controlador de eventos muestra el valor de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propiedad cada vez que se genera.  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value of the <paramref name="interval" /> parameter is less than or equal to zero, or greater than <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="AutoReset">
      <MemberSignature Language="C#" Value="public bool AutoReset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoReset" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.AutoReset" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoReset As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoReset { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoReset : bool with get, set" Usage="System.Timers.Timer.AutoReset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer will be restarted when it is enabled.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a Boolean indicating whether the <see cref="T:System.Timers.Timer" /> should raise the <see cref="E:System.Timers.Timer.Elapsed" /> event only once (<see langword="false" />) or repeatedly (<see langword="true" />).</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Timers.Timer" /> debe generar el evento <see cref="E:System.Timers.Timer.Elapsed" /> cada vez que transcurre el intervalo; es <see langword="false" /> si debe generar el evento <see cref="E:System.Timers.Timer.Elapsed" /> solo una vez, cuando el intervalo transcurre por primera vez. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Timers.Timer> ya está habilitado cuando el <xref:System.Timers.Timer.Start%2A> se llama al método, el intervalo se restablece. Si <xref:System.Timers.Timer.AutoReset%2A> es `false`, el <xref:System.Timers.Timer.Start%2A> debe llamar al método para iniciar el recuento de nuevo.  
  
 Restablecer el intervalo afecta cuando el <xref:System.Timers.Timer.Elapsed> evento se desencadena. Por ejemplo, si establece el intervalo en 5 segundos y, a continuación, establezca el <xref:System.Timers.Timer.Enabled%2A> propiedad `true`, el recuento se inicia en el momento <xref:System.Timers.Timer.Enabled%2A> se establece. Si restablece el intervalo en 10 segundos cuando el recuento es de 3 segundos, el <xref:System.Timers.Timer.Elapsed> evento se desencadena por primera vez 13 segundos después de la <xref:System.Timers.Timer.Enabled%2A> propiedad se estableció en `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Timers.Timer> cuyo <xref:System.Timers.Timer.Elapsed> evento se desencadena tras 1,5 segundos. Su controlador de eventos, a continuación, muestra "¡Hello World!" en la consola.  
  
 [!code-cpp[Classic Timer.Timer1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer.Timer1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CS/source.cs#1)]
 [!code-vb[Classic Timer.Timer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="timer.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins the run-time initialization of a <see cref="T:System.Timers.Timer" /> that is used on a form or by another component.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] diseño entorno usa este método para comenzar la inicialización de un componente que se utiliza en un formulario o por otro componente. El <xref:System.Timers.Timer.EndInit%2A> método termina la inicialización. Mediante el <xref:System.Timers.Timer.BeginInit%2A> y <xref:System.Timers.Timer.EndInit%2A> métodos impide que el control que se va a usar antes de que esté totalmente inicializado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.EndInit" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="timer.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases the resources used by the <see cref="T:System.Timers.Timer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Timers.Timer.Close%2A> método llama a su vez el `Dispose` método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="timer.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases all resources used by the current <see cref="T:System.Timers.Timer" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public event System.Timers.ElapsedEventHandler Elapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Timers.ElapsedEventHandler Elapsed" />
      <MemberSignature Language="DocId" Value="E:System.Timers.Timer.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Elapsed As ElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Timers::ElapsedEventHandler ^ Elapsed;" />
      <MemberSignature Language="F#" Value="member this.Elapsed : System.Timers.ElapsedEventHandler " Usage="member this.Elapsed : System.Timers.ElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Occurs when the Interval has elapsed.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Timers.ElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the interval elapses.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Timers.Timer.Elapsed> evento se desencadena si el <xref:System.Timers.Timer.Enabled%2A> propiedad es `true` y el intervalo de tiempo (en milisegundos) definido por el <xref:System.Timers.Timer.Interval%2A> transcurra de propiedad. Si el <xref:System.Timers.Timer.AutoReset%2A> propiedad es `true`, el evento se produce repetidamente en un intervalo definido por el <xref:System.Timers.Timer.Interval%2A> propiedad; en caso contrario, se genera el evento solo una vez, la primera vez el <xref:System.Timers.Timer.Interval%2A> valor transcurra.  
  
 Si <xref:System.Timers.Timer.Interval%2A> se establece después de la <xref:System.Timers.Timer> ha iniciado, se restablece el recuento. Por ejemplo, si establece el intervalo en 5 segundos y, a continuación, establecer <xref:System.Timers.Timer.Enabled%2A> a `true`, el recuento se inicia en el momento <xref:System.Timers.Timer.Enabled%2A> se establece. Si restablece el intervalo en 10 segundos cuando el recuento es 3 segundos, el <xref:System.Timers.Timer.Elapsed> evento se desencadena por primera vez 13 segundos después de <xref:System.Timers.Timer.Enabled%2A> se estableció en `true`.  
  
 Si el <xref:System.Timers.Timer.SynchronizingObject%2A> propiedad es `null`, <xref:System.Timers.Timer.Elapsed> evento se desencadena en un <xref:System.Threading.ThreadPool> subproceso. Si el procesamiento de la <xref:System.Timers.Timer.Elapsed> evento dura más de <xref:System.Timers.Timer.Interval%2A>, el evento se puede generar de nuevo en otro <xref:System.Threading.ThreadPool> subproceso. En esta situación, el controlador de eventos debe ser de reentrada.  
  
> [!NOTE]
>  El método de control de eventos puede ejecutarse en un subproceso al mismo tiempo que otro subproceso llama a la <xref:System.Timers.Timer.Stop%2A> método o establece la <xref:System.Timers.Timer.Enabled%2A> propiedad `false`. Esto podría dar lugar a la <xref:System.Timers.Timer.Elapsed> evento que se provoca cuando se detiene el temporizador. El código de ejemplo para el <xref:System.Timers.Timer.Stop%2A> método muestra una manera de evitar esta condición de carrera.  
  
 Aunque <xref:System.Timers.Timer.SynchronizingObject%2A> no es `null`, <xref:System.Timers.Timer.Elapsed> eventos pueden producirse después de la <xref:System.Timers.Timer.Dispose%2A> o <xref:System.Timers.Timer.Stop%2A> ha llamado al método o después la <xref:System.Timers.Timer.Enabled%2A> propiedad se ha establecido en `false`, porque la señal para generar el <xref:System.Timers.Timer.Elapsed> eventos siempre está en cola para su ejecución en un subproceso del grupo. Una manera de resolver esta condición de carrera es establecer una marca que indica el controlador de eventos para el <xref:System.Timers.Timer.Elapsed> evento omita algunos eventos posteriores.  
  
 El <xref:System.Timers.Timer> componente detecta y suprime todas las excepciones producidas por controladores de eventos para el <xref:System.Timers.Timer.Elapsed> eventos. Este comportamiento está sujeta a cambios en futuras versiones de .NET Framework.  
  
   
  
## Examples  
 El ejemplo siguiente crea un <xref:System.Timers.Timer> objeto que se activa su <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento cada dos segundos (2000 milisegundos), configura un controlador de eventos para el evento e inicia el temporizador. El controlador de eventos muestra el valor de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propiedad cada vez que se genera.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
        <altmember cref="T:System.Timers.ElapsedEventArgs" />
        <altmember cref="T:System.Timers.ElapsedEventHandler" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Timers.Timer.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer is enabled to fire events at a defined interval.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the <see cref="T:System.Timers.Timer" /> should raise the <see cref="E:System.Timers.Timer.Elapsed" /> event.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Timers.Timer" /> debe generar el evento <see cref="E:System.Timers.Timer.Elapsed" />; en caso contrario, es <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer <xref:System.Timers.Timer.Enabled%2A> a `true` es igual que llamar a <xref:System.Timers.Timer.Start%2A>, durante la instalación <xref:System.Timers.Timer.Enabled%2A> a `false` es igual que llamar a <xref:System.Timers.Timer.Stop%2A>.  
  
> [!NOTE]
>  La señal para generar el <xref:System.Timers.Timer.Elapsed> eventos siempre está en cola para su ejecución en un <xref:System.Threading.ThreadPool> subproceso. Esto podría dar lugar a la <xref:System.Timers.Timer.Elapsed> evento que se provoca después de la <xref:System.Timers.Timer.Enabled%2A> propiedad está establecida en `false`. El ejemplo de código para el <xref:System.Timers.Timer.Stop%2A> método muestra una manera de evitar esta condición de carrera.  
  
 Si <xref:System.Timers.Timer.Enabled%2A> está establecido en `true` y <xref:System.Timers.Timer.AutoReset%2A> está establecido en `false`, el <xref:System.Timers.Timer> provoca la <xref:System.Timers.Timer.Elapsed> eventos una sola vez, la primera vez que el intervalo transcurre.  
  
 Si el intervalo se establece después de la <xref:System.Timers.Timer> ha iniciado, se restablece el recuento. Por ejemplo, si establece el intervalo en 5 segundos y, a continuación, establezca el <xref:System.Timers.Timer.Enabled%2A> propiedad `true`, el recuento se inicia en el momento <xref:System.Timers.Timer.Enabled%2A> se establece. Si restablece el intervalo en 10 segundos cuando el recuento es 3 segundos, el <xref:System.Timers.Timer.Elapsed> evento se desencadena por primera vez 13 segundos después de <xref:System.Timers.Timer.Enabled%2A> se estableció en `true`.  
  
> [!NOTE]
>  Algunos diseñadores visuales, como los de Microsoft Visual Studio, establezca el <xref:System.Timers.Timer.Enabled%2A> propiedad `true` al insertar un nuevo <xref:System.Timers.Timer>.  
  
   
  
## Examples  
 El ejemplo siguiente crea un <xref:System.Timers.Timer> objeto que se activa su <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento cada dos segundos (2000 milisegundos), configura un controlador de eventos para el evento e inicia el temporizador. El controlador de eventos muestra el valor de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propiedad cada vez que se genera.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">This property cannot be set because the timer has been disposed.</exception>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Timers.Timer.Interval" /> property was set to a value greater than <see cref="F:System.Int32.MaxValue" /> before the timer was enabled.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="timer.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ends the run-time initialization of a <see cref="T:System.Timers.Timer" /> that is used on a form or by another component.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] diseño entorno usa este método para finalizar la inicialización de un componente que se utiliza en un formulario o por otro componente. El <xref:System.Timers.Timer.BeginInit%2A> método comienza la inicialización. Mediante el <xref:System.Timers.Timer.BeginInit%2A> y <xref:System.Timers.Timer.EndInit%2A> métodos impide que el control que se va a usar antes de que esté totalmente inicializado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Timers.Timer.BeginInit" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public double Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Interval { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Interval : double with get, set" Usage="System.Timers.Timer.Interval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(100)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("The number of milliseconds between timer events.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the interval, expressed in milliseconds, at which to raise the <see cref="E:System.Timers.Timer.Elapsed" /> event.</summary>
        <value>Tiempo, en milisegundos, entre eventos <see cref="E:System.Timers.Timer.Elapsed" />. Este valor debe ser mayor que cero y menor o igual que <see cref="F:System.Int32.MaxValue" />. El valor predeterminado es de 100 milisegundos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa el <xref:System.Timers.Timer.Interval%2A> propiedad para determinar la frecuencia con la que el <xref:System.Timers.Timer.Elapsed> desencadena el evento. Dado que la <xref:System.Timers.Timer> clase depende del reloj del sistema, tiene la misma resolución que el reloj del sistema. Esto significa que la <xref:System.Timers.Timer.Elapsed> evento se desencadenará a un intervalo definido por la resolución del reloj del sistema si el <xref:System.Timers.Timer.Interval%2A> propiedad es menor que la resolución del reloj del sistema. El ejemplo siguiente se establece la <xref:System.Timers.Timer.Interval%2A> propiedad de 5 milisegundos. Cuando se ejecuta en un [!INCLUDE[win7](~/includes/win7-md.md)] sistema cuyo reloj del sistema tiene una resolución de aproximadamente 15 milisegundos, que se desencadene el evento aproximadamente cada 15 milisegundos en lugar de cada 5 milisegundos.  
  
 [!code-csharp[System.Timers.Timer.Interval#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/interval2.cs#1)]
 [!code-vb[System.Timers.Timer.Interval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/interval2.vb#1)]  
  
 Puede usar el código siguiente para determinar la resolución del reloj del sistema en el sistema actual:  
  
 [!code-csharp[System.Timers.Timer.Interval#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/resolution1.cs#2)]
 [!code-vb[System.Timers.Timer.Interval#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/resolution1.vb#2)]  
  
 Si la aplicación requiere una resolución mayor que la ofrecida por la <xref:System.Timers.Timer> clase o el reloj del sistema, utilice los temporizadores de multimedia de alta resolución, consulte [Cómo: utilizar el temporizador de alta resolución](http://msdn.microsoft.com/library/aa964692.aspx).  
  
 Si el intervalo se establece después de la <xref:System.Timers.Timer> ha iniciado, se restablece el recuento. Por ejemplo, si establece el intervalo en 5 segundos y, a continuación, establezca el <xref:System.Timers.Timer.Enabled%2A> propiedad `true`, el recuento se inicia en el momento <xref:System.Timers.Timer.Enabled%2A> se establece. Si restablece el intervalo en 10 segundos cuando el recuento es 3 segundos, el <xref:System.Timers.Timer.Elapsed> evento se desencadena por primera vez 13 segundos después de <xref:System.Timers.Timer.Enabled%2A> se estableció en `true`.  
  
 Si <xref:System.Timers.Timer.Enabled%2A> está establecido en `true` y <xref:System.Timers.Timer.AutoReset%2A> está establecido en `false`, el <xref:System.Timers.Timer> provoca la <xref:System.Timers.Timer.Elapsed> eventos una sola vez, la primera vez que el intervalo transcurre. <xref:System.Timers.Timer.Enabled%2A> a continuación, se establece en `false`.  
  
> [!NOTE]
>  Si <xref:System.Timers.Timer.Enabled%2A> y <xref:System.Timers.Timer.AutoReset%2A> están establecidos en `false`, y se habilitó anteriormente el temporizador, establecer el <xref:System.Timers.Timer.Interval%2A> propiedad causa el <xref:System.Timers.Timer.Elapsed> evento una vez, como si el <xref:System.Timers.Timer.Enabled%2A> propiedad hubiera establecido en `true`. Para establecer el intervalo sin que se produzca el evento, puede establecer temporalmente el <xref:System.Timers.Timer.Enabled%2A> propiedad a `true`, establezca el <xref:System.Timers.Timer.Interval%2A> propiedad en el intervalo de tiempo que desee y, a continuación, se establece inmediatamente la <xref:System.Timers.Timer.Enabled%2A> propiedad volver a `false`.  
  
   
  
## Examples  
 El ejemplo siguiente crea un <xref:System.Timers.Timer> objeto que se activa su <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento cada dos segundos (2000 milisegundos), configura un controlador de eventos para el evento e inicia el temporizador. El controlador de eventos muestra el valor de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propiedad cada vez que se genera.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The interval is less than or equal to zero.  -or-  The interval is greater than <see cref="F:System.Int32.MaxValue" />, and the timer is currently enabled. (If the timer is not currently enabled, no exception is thrown until it becomes enabled.)</exception>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Timers.Timer.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the site that binds the <see cref="T:System.Timers.Timer" /> to its container in design mode.</summary>
        <value>Interfaz <see cref="T:System.ComponentModel.ISite" /> que representa el sitio que enlaza el objeto <see cref="T:System.Timers.Timer" /> a su contenedor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sitios de enlazan un <xref:System.ComponentModel.Component> a una <xref:System.ComponentModel.Container> y habilitar la comunicación entre ellos, así como proporcionar una manera para que el contenedor administrar sus componentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="timer.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts raising the <see cref="E:System.Timers.Timer.Elapsed" /> event by setting <see cref="P:System.Timers.Timer.Enabled" /> to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Timers.Timer.Start%2A> se llama y <xref:System.Timers.Timer.AutoReset%2A> está establecido en `false`, el <xref:System.Timers.Timer> provoca la <xref:System.Timers.Timer.Elapsed> eventos una sola vez, la primera vez que el intervalo transcurre. Si <xref:System.Timers.Timer.Start%2A> se llama y <xref:System.Timers.Timer.AutoReset%2A> es `true`, <xref:System.Timers.Timer> provoca la <xref:System.Timers.Timer.Elapsed> hora del evento del primer transcurrido el intervalo y continúa generar el evento en el intervalo especificado.  
  
 También puede iniciar la temporización estableciendo <xref:System.Timers.Timer.Enabled%2A> a `true`.  
  
> [!NOTE]
>  Si <xref:System.Timers.Timer.AutoReset%2A> es `false`, el <xref:System.Timers.Timer.Start%2A> debe llamar al método para iniciar el recuento de nuevo.  
  
 Una llamada a la <xref:System.Timers.Timer.Start%2A> método cuando está habilitado el temporizador no tiene ningún efecto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The <see cref="T:System.Timers.Timer" /> is created with an interval equal to or greater than <see cref="F:System.Int32.MaxValue" /> + 1, or set to an interval less than zero.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="timer.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stops raising the <see cref="E:System.Timers.Timer.Elapsed" /> event by setting <see cref="P:System.Timers.Timer.Enabled" /> to <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Detener la temporización, también se puede establecer <xref:System.Timers.Timer.Enabled%2A> a `false`.  
  
> [!NOTE]
>  La señal para generar el <xref:System.Timers.Timer.Elapsed> eventos siempre está en cola para su ejecución en un <xref:System.Threading.ThreadPool> subprocesos, por lo que el método de control de eventos puede ejecutarse en un subproceso al mismo tiempo que una llamada a la <xref:System.Timers.Timer.Stop%2A> método se ejecuta en otro subproceso. Esto podría dar lugar a la <xref:System.Timers.Timer.Elapsed> evento que se provoca después de la <xref:System.Timers.Timer.Stop%2A> se llama al método. El ejemplo de código en la sección siguiente muestra una manera de evitar esta condición de carrera.  
  
   
  
## Examples  
 El ejemplo siguiente crea un `System.Timers.Timer` objeto que se activa su <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> evento cada dos segundos (2.000 milisegundos), configura un controlador de eventos para el evento e inicia el temporizador. El controlador de eventos muestra el valor de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propiedad cada vez que se genera. Cuando el usuario presiona la tecla ENTRAR, la aplicación llama a la <xref:System.Timers.Timer.Stop%2A> método antes de terminar la aplicación.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 En el ejemplo de código siguiente se muestra una manera de evitar que el subproceso que llama el <xref:System.Timers.Timer.Stop%2A> método impide continuar hasta que se ejecuta actualmente <xref:System.Timers.Timer.Elapsed> extremos de evento y también para evitar que dos <xref:System.Timers.Timer.Elapsed> eventos de ejecutar el controlador de eventos en el mismo tiempo (a menudo denominado reentrada).  
  
 El ejemplo ejecuta a 100 ejecuciones de prueba. Cada vez que se ejecuta la prueba, se inicia el temporizador con un intervalo de 150 milisegundos. El controlador de eventos usa el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para simular una tarea que aleatoriamente varía en longitud de 50 a 200 milisegundos. El método de prueba también inicia un subproceso de control que espera un segundo y, a continuación, detiene el temporizador. Si se controla un evento cuando el subproceso de control detiene el temporizador, el subproceso de control debe esperar hasta que finalice el evento antes de continuar.  
  
 El <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> sobrecarga del método se utiliza para evitar la reentrada y para impedir que el subproceso de control continúe hasta que finaliza un evento en ejecución. El controlador de eventos usa el <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> método para establecer un control de la variable en 1, pero solo si el valor es cero actualmente. Se trata de una operación atómica. Si el valor devuelto es cero, la variable de control se ha establecido en 1 y el controlador de eventos continúa. Si el valor devuelto es distinto de cero, el evento se descarta para evitar la reentrada. (Si fuese necesario ejecutar todos los eventos, el <xref:System.Threading.Monitor> clase sería una mejor manera de sincronizar los eventos.) Cuando el controlador de eventos finaliza, Establece la variable de control vuelve a cero. En el ejemplo se registra el número total de eventos ejecutados que se descartaron debido a la reentrada y que se ha producido después de la <xref:System.Timers.Timer.Stop%2A> método se llamó.  
  
 El subproceso de control utiliza la <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> método para establecer el control de variable en -1 (menos uno), pero solo si el valor es cero actualmente. Si la operación atómica devuelve distinto de cero, un evento se está ejecutando actualmente. El subproceso de control espera y lo intenta de nuevo. En el ejemplo se registra el número de veces que el subproceso de control tuvieron que esperar a que finalice un evento.  
  
 [!code-csharp[Timer.Stop#1](~/samples/snippets/csharp/VS_Snippets_CLR/Timer.Stop/CS/source.cs#1)]
 [!code-vb[Timer.Stop#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Timer.Stop/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Timers.Timer.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("The object used to marshal the event handler calls issued when an interval has elapsed.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the object used to marshal event-handler calls that are issued when an interval has elapsed.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> que representa el objeto que se usa para calcular las referencias de las llamadas del controlador de eventos que se emiten al transcurrir un intervalo. De manera predeterminada, es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Timers.Timer.SynchronizingObject%2A> es `null`, el método que controla el <xref:System.Timers.Timer.Elapsed> se denomina eventos en un subproceso del grupo de subprocesos del sistema. Para obtener más información acerca de los grupos de subprocesos del sistema, consulte <xref:System.Threading.ThreadPool>.  
  
 Cuando el <xref:System.Timers.Timer.Elapsed> evento está controlado por un componente visual de formularios Windows Forms, como un botón, acceso al componente a través del grupo de subprocesos del sistema podría resultado una excepción o simplemente podría no funcionar. Evitar este efecto estableciendo <xref:System.Timers.Timer.SynchronizingObject%2A> a un componente de Windows Forms, lo que hace que el método que controla el <xref:System.Timers.Timer.Elapsed> evento al que se llama en el mismo subproceso donde se creó el componente.  
  
> [!NOTE]
>  Incluso si la <xref:System.Timers.Timer.SynchronizingObject%2A> propiedad no es `null`, <xref:System.Timers.Timer.Elapsed> eventos pueden producirse después de la <xref:System.Timers.Timer.Dispose%2A> o <xref:System.Timers.Timer.Stop%2A> ha llamado al método o después la <xref:System.Timers.Timer.Enabled%2A> propiedad se ha establecido en `false`, porque la señal para generar el <xref:System.Timers.Timer.Elapsed> eventos siempre está en cola para su ejecución en un subproceso del grupo. Una manera de resolver esta condición de carrera es establecer una marca que indica el controlador de eventos para el <xref:System.Timers.Timer.Elapsed> evento omita algunos eventos posteriores.  
  
 Si el <xref:System.Timers.Timer> se utiliza dentro de Visual Studio en un diseñador de formularios Windows Forms, <xref:System.Timers.Timer.SynchronizingObject%2A> se establece automáticamente en el control que contiene el <xref:System.Timers.Timer>. Por ejemplo, si coloca un <xref:System.Timers.Timer> en un diseñador para `Form1` (que hereda de <xref:System.Windows.Forms.Form>), el <xref:System.Timers.Timer.SynchronizingObject%2A> propiedad de <xref:System.Timers.Timer> se establece en la instancia de `Form1`.  
  
   
  
## Examples  
 El ejemplo siguiente es una aplicación de formularios Windows Forms que actúa como un editor de archivos de texto muy simple. Cuando no se ha guardado el texto en el cuadro de texto, la aplicación pide al usuario a intervalos de un minuto si desea guardar el contenido del cuadro de texto.  Para ello, el <xref:System.Timers.Timer.Interval%2A> propiedad está establecida en un minuto (60.000 milisegundos) y el <xref:System.Timers.Timer.SynchronizingObject%2A> propiedad está establecida en el <xref:System.Windows.Forms.Form> objeto.  
  
 [!code-csharp[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/cs/Form1.cs#1)]
 [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/vb/Form1.vb#1)]  
  
 En el ejemplo se requiere que agregue los siguientes controles al formulario:  
  
-   A <xref:System.Windows.Forms.TextBox> control denominado `TextBox1` (su nombre predeterminado).  
  
-   A <xref:System.Windows.Forms.Button> control denominado `Button1` (su nombre predeterminado).  
  
-   A <xref:System.Windows.Forms.SaveFileDialog> control denominado `SaveSaveFileDialog1` (su nombre predeterminado).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
        <altmember cref="T:System.Threading.ThreadPool" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
  </Members>
</Type>