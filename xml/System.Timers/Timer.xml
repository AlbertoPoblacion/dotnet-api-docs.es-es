<Type Name="Timer" FullName="System.Timers.Timer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d9b8ff2e88998ea911ef3de2729af2df406ec0ee" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58702536" /></Metadata><TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Timers.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-3.0;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Elapsed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-3.0;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultProperty("Interval")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Genera un evento después de un intervalo establecido, con la opción de generar eventos recurrentes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Timers.Timer> componente es un temporizador basado en servidor que genera un <xref:System.Timers.Timer.Elapsed> eventos en la aplicación después del número de milisegundos en el <xref:System.Timers.Timer.Interval%2A> ha transcurrido la propiedad. Puede configurar el <xref:System.Timers.Timer> objeto para generar el evento mediante una sola vez o varias veces el <xref:System.Timers.Timer.AutoReset%2A> propiedad. Normalmente, un <xref:System.Timers.Timer> objeto se declara en el nivel de clase para que permanezca en el ámbito siempre y cuando sea necesario. A continuación, puede controlar su <xref:System.Timers.Timer.Elapsed> eventos para proporcionar procesamiento normal. Por ejemplo, suponga que tiene un servidor crítico que se debe mantener ejecuta 24 horas al día, 7 días a la semana. Puede crear un servicio que utiliza un <xref:System.Timers.Timer> objeto para comprobar periódicamente el servidor y asegúrese de que el sistema está en funcionamiento. Si el sistema no responde, el servicio podría intentar reiniciar el servidor o notificar a un administrador.  
  
> [!IMPORTANT]
> La <xref:System.Timers.Timer> clase no está disponible para todas las implementaciones de .NET y versiones, como .NET Standard 1.6 y versiones inferiores.
> En estos casos, puede usar el <xref:System.Threading.Timer?displayProperty=nameWithType> clase en su lugar.
  
 Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo, debe deshacerse de él directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él, indirectamente, usar una construcción de lenguaje, como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
 Basado en el servidor <xref:System.Timers.Timer?displayProperty=nameWithType> clase está diseñada para su uso con subprocesos de trabajo en un entorno multiproceso. Temporizadores de servidor pueden moverse entre los subprocesos para controlar el elevado <xref:System.Timers.Timer.Elapsed> eventos, lo que más precisión que los temporizadores de Windows en generar el evento en tiempo.  
  
 El <xref:System.Timers.Timer?displayProperty=nameWithType> componente genera el <xref:System.Timers.Timer.Elapsed> eventos, en función del valor (en milisegundos) de la <xref:System.Timers.Timer.Interval%2A> propiedad. Puede controlar este evento para realizar el procesamiento que necesita. Por ejemplo, suponga que tiene una aplicación de ventas en línea que envía continuamente los pedidos de ventas a una base de datos. El servicio que compila las instrucciones de envío funciona en un lote de pedidos en lugar de procesar cada pedido individualmente. Puede usar un <xref:System.Timers.Timer> para iniciar la cada 30 minutos de procesamiento por lotes.  
  
> [!IMPORTANT]
>  La clase System.Timers.Timer tiene la misma resolución que el reloj del sistema. Esto significa que el <xref:System.Timers.Timer.Elapsed> desencadenará el evento en un intervalo definido por la resolución del reloj del sistema si el <xref:System.Timers.Timer.Interval%2A> propiedad es menor que la resolución del reloj del sistema. Para obtener más información, vea la propiedad <xref:System.Timers.Timer.Interval%2A>.  
  
 Cuando <xref:System.Timers.Timer.AutoReset%2A> está establecido en `false`, un <xref:System.Timers.Timer?displayProperty=nameWithType> objeto genera el <xref:System.Timers.Timer.Elapsed> evento una sola vez, después del primer <xref:System.Timers.Timer.Interval%2A> ha transcurrido. Para seguir provocando la <xref:System.Timers.Timer.Elapsed> eventos periódicamente en el intervalo definido por el <xref:System.Timers.Timer.Interval%2A>, establezca <xref:System.Timers.Timer.AutoReset%2A> a `true`, que es el valor predeterminado.  
  
 El <xref:System.Timers.Timer> componente detecta y suprime todas las excepciones producidas por controladores de eventos para el <xref:System.Timers.Timer.Elapsed> eventos. Este comportamiento está sujeta a cambios en futuras versiones de .NET Framework. Sin embargo, tenga en cuenta que esto no es así de controladores de eventos que se ejecutan de forma asincrónica e incluyen la `await` operador (en C#) o el `Await` operador (en Visual Basic). Las excepciones producidas en estos controladores de eventos se propagan hacia el subproceso que realiza la llamada, como se muestra en el ejemplo siguiente. Para obtener más información sobre las excepciones producidas en los métodos asincrónicos, vea [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 Si el <xref:System.Timers.Timer.SynchronizingObject%2A> propiedad es `null`, <xref:System.Timers.Timer.Elapsed> evento se genera en un <xref:System.Threading.ThreadPool> subproceso. Si el procesamiento de la <xref:System.Timers.Timer.Elapsed> evento dura más de <xref:System.Timers.Timer.Interval%2A>, es posible que provoca el evento nuevo en otro <xref:System.Threading.ThreadPool> subproceso. En esta situación, el controlador de eventos debe ser reentrante.  
  
> [!NOTE]
>  El método de control de eventos puede ejecutarse en un subproceso al mismo tiempo que otro subproceso llama a la <xref:System.Timers.Timer.Stop%2A> método o establece el <xref:System.Timers.Timer.Enabled%2A> propiedad a `false`. Esto podría dar lugar a la <xref:System.Timers.Timer.Elapsed> evento que se provoca cuando se haya detenido el temporizador. El código de ejemplo para el <xref:System.Timers.Timer.Stop%2A> método muestra una forma de evitar esta condición de carrera.  
  
 Incluso si <xref:System.Timers.Timer.SynchronizingObject%2A> no es `null`, <xref:System.Timers.Timer.Elapsed> los eventos pueden producirse después de la <xref:System.Timers.Timer.Dispose%2A> o <xref:System.Timers.Timer.Stop%2A> ha llamado al método o después del <xref:System.Timers.Timer.Enabled%2A> se ha establecido la propiedad en `false`, ya que la señal para generar el <xref:System.Timers.Timer.Elapsed> evento siempre se pone en cola para su ejecución en un subproceso ThreadPool. Una manera de resolver esta condición de carrera es establecer una marca que indica el controlador de eventos para el <xref:System.Timers.Timer.Elapsed> evento omita algunos eventos posteriores.  
  
 Si usa el <xref:System.Timers.Timer?displayProperty=nameWithType> clase con un elemento de interfaz de usuario, como un formulario o control, sin colocar el temporizador en ese elemento de interfaz de usuario, asignar el formulario o control que contiene el <xref:System.Timers.Timer> a la <xref:System.Timers.Timer.SynchronizingObject%2A> propiedad, por lo que es el evento calcular las referencias para el subproceso de interfaz de usuario.  
  
 Para obtener una lista de valores de propiedad predeterminados para una instancia de <xref:System.Timers.Timer>, consulte el <xref:System.Timers.Timer.%23ctor%2A> constructor.  
  
> [!TIP]
>  Tenga en cuenta que .NET incluye cuatro clases denominadas `Timer`, cada uno de los que ofrece una funcionalidad diferente:  
>   
> - <xref:System.Timers.Timer?displayProperty=nameWithType> (este tema): desencadena un evento a intervalos regulares. La clase está diseñada para usarla como basada en un servidor o componente del servicio en un entorno multiproceso; no tiene ninguna interfaz de usuario y no está visible en tiempo de ejecución.  
> - <xref:System.Threading.Timer?displayProperty=nameWithType>: un método de devolución de llamada solo se ejecuta en un subproceso de grupo a intervalos regulares. Se define el método de devolución de llamada cuando el temporizador se crea una instancia y no se puede cambiar. Al igual que el <xref:System.Timers.Timer?displayProperty=nameWithType> (clase), esta clase está pensada para su uso como un componente basado en servidor o servicio en un entorno multiproceso; no tiene ninguna interfaz de usuario y no está visible en tiempo de ejecución.  
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (Solo en .NET framework): un componente de Windows Forms que se activa un evento a intervalos regulares. El componente no tiene interfaz de usuario y está diseñado para su uso en un entorno de un único subproceso.  
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (Solo en .NET framework): un componente de ASP.NET que realiza el postback de página web asincrónicas o sincrónicas a intervalos regulares.  

## Examples  
 El ejemplo siguiente crea un `System.Timers.Timer` objeto que se activa su <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventos cada dos segundos (2.000 milisegundos), configura un controlador de eventos para el evento e inicia el temporizador. El controlador de eventos muestra el valor de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propiedad cada vez que se provoca.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos los miembros públicos <see langword="static" /> miembros de este tipo son seguros para subprocesos. No se garantiza que los miembros de instancias sean seguros para la ejecución de subprocesos.</threadsafe>
    <altmember cref="P:System.Timers.Timer.AutoReset" />
    <altmember cref="P:System.Timers.Timer.Interval" />
    <altmember cref="E:System.Timers.Timer.Elapsed" />
    <altmember cref="M:System.Timers.Timer.#ctor" />
    <altmember cref="T:System.Threading.Timer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Timers.Timer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Timers.Timer" /> y establece todas las propiedades en sus valores iniciales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La siguiente tabla muestra los valores de propiedad iniciales de una instancia de <xref:System.Timers.Timer>.  
  
|Propiedad.|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Timers.Timer.AutoReset%2A>|`true`|  
|<xref:System.Timers.Timer.Enabled%2A>|`false`|  
|<xref:System.Timers.Timer.Interval%2A>|100 milisegundos|  
|<xref:System.Timers.Timer.SynchronizingObject%2A>|Referencia nula (`Nothing` en Visual Basic).|  
  
   
  
## Examples  
 El ejemplo siguiente crea un <xref:System.Timers.Timer> objeto que se activa su <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventos cada dos segundos (2.000 milisegundos), configura un controlador de eventos para el evento e inicia el temporizador. El controlador de eventos muestra el valor de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propiedad cada vez que se provoca.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (double interval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (interval As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(double interval);" />
      <MemberSignature Language="F#" Value="new System.Timers.Timer : double -&gt; System.Timers.Timer" Usage="new System.Timers.Timer interval" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="interval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="interval">Tiempo, en milisegundos, entre eventos. Este valor debe ser mayor que cero y menor o igual que <see cref="F:System.Int32.MaxValue" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Timers.Timer" /> y establece la propiedad <see cref="P:System.Timers.Timer.Interval" /> en el número de milisegundos especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor establece la <xref:System.Timers.Timer.Interval%2A> propiedad de la nueva instancia de temporizador, pero no habilita el temporizador.  
  
   
  
## Examples  
 El ejemplo siguiente crea un <xref:System.Timers.Timer> objeto que se activa su <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventos cada dos segundos (2.000 milisegundos), configura un controlador de eventos para el evento e inicia el temporizador. El controlador de eventos muestra el valor de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propiedad cada vez que se provoca.  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor del parámetro <paramref name="interval" /> es menor o igual a cero, o mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="AutoReset">
      <MemberSignature Language="C#" Value="public bool AutoReset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoReset" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.AutoReset" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoReset As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoReset { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoReset : bool with get, set" Usage="System.Timers.Timer.AutoReset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer will be restarted when it is enabled.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Timers.TimersDescription("TimerAutoReset")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor booleano que indica si <see cref="T:System.Timers.Timer" /> debe generar el evento <see cref="E:System.Timers.Timer.Elapsed" /> solo una vez (<see langword="false" />) o repetidamente (<see langword="true" />).</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Timers.Timer" /> debe generar el evento <see cref="E:System.Timers.Timer.Elapsed" /> cada vez que transcurre el intervalo; es <see langword="false" /> si debe generar el evento <see cref="E:System.Timers.Timer.Elapsed" /> solo una vez, cuando el intervalo transcurre por primera vez. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Timers.Timer> ya está habilitado cuando la <xref:System.Timers.Timer.Start%2A> se llama al método, el intervalo se restablece. Si <xref:System.Timers.Timer.AutoReset%2A> es `false`, el <xref:System.Timers.Timer.Start%2A> debe llamar al método para iniciar el recuento de nuevo.  
  
 Restablecer el intervalo afecta cuando el <xref:System.Timers.Timer.Elapsed> provoca el evento. Por ejemplo, si establece el intervalo en 5 segundos y, a continuación, Establece el <xref:System.Timers.Timer.Enabled%2A> propiedad `true`, el recuento se inicia en el momento <xref:System.Timers.Timer.Enabled%2A> está establecido. Si restablece el intervalo en 10 segundos cuando el recuento es 3 segundos, el <xref:System.Timers.Timer.Elapsed> evento se desencadena por primera vez 13 segundos después de la <xref:System.Timers.Timer.Enabled%2A> propiedad se estableció en `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Timers.Timer> cuyo <xref:System.Timers.Timer.Elapsed> evento se desencadena después de 1,5 segundos. Su controlador de eventos, a continuación, muestra "Hello World!" en la consola.  
  
 [!code-cpp[Classic Timer.Timer1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer.Timer1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CS/source.cs#1)]
 [!code-vb[Classic Timer.Timer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="timer.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comienza la inicialización en tiempo de ejecución de un objeto <see cref="T:System.Timers.Timer" /> que se usa en un formulario o que lo usa otro componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] entorno usa este método para iniciar la inicialización de un componente que se usa en un formulario u otro componente de diseño. El <xref:System.Timers.Timer.EndInit%2A> método termina la inicialización. Mediante el <xref:System.Timers.Timer.BeginInit%2A> y <xref:System.Timers.Timer.EndInit%2A> métodos impide que el control que se va a usar antes de inicializarse completamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.EndInit" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="timer.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos que usa <see cref="T:System.Timers.Timer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Timers.Timer.Close%2A> método a su vez llama a la `Dispose` método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="timer.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera todos los recursos que usa la clase <see cref="T:System.Timers.Timer" /> actual.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public event System.Timers.ElapsedEventHandler Elapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Timers.ElapsedEventHandler Elapsed" />
      <MemberSignature Language="DocId" Value="E:System.Timers.Timer.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Elapsed As ElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Timers::ElapsedEventHandler ^ Elapsed;" />
      <MemberSignature Language="F#" Value="member this.Elapsed : System.Timers.ElapsedEventHandler " Usage="member this.Elapsed : System.Timers.ElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Occurs when the Interval has elapsed.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Timers.TimersDescription("TimerIntervalElapsed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Timers.ElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando transcurre el intervalo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Timers.Timer.Elapsed> evento se desencadena si el <xref:System.Timers.Timer.Enabled%2A> propiedad es `true` y el intervalo de tiempo (en milisegundos) definido por el <xref:System.Timers.Timer.Interval%2A> propiedad transcurre. Si el <xref:System.Timers.Timer.AutoReset%2A> propiedad es `true`, se genera el evento varias veces en un intervalo definido por el <xref:System.Timers.Timer.Interval%2A> propiedad; en caso contrario, se genera el evento una sola vez, la primera vez el <xref:System.Timers.Timer.Interval%2A> valor transcurre.  
  
 Si <xref:System.Timers.Timer.Interval%2A> se establece después de la <xref:System.Timers.Timer> ha iniciado, se restablece el recuento. Por ejemplo, si establece el intervalo en 5 segundos y, a continuación, establece <xref:System.Timers.Timer.Enabled%2A> a `true`, el recuento se inicia en el momento <xref:System.Timers.Timer.Enabled%2A> está establecido. Si restablece el intervalo en 10 segundos cuando el recuento sea 3 segundos, el <xref:System.Timers.Timer.Elapsed> evento se desencadena por primera vez 13 segundos después <xref:System.Timers.Timer.Enabled%2A> se estableció en `true`.  
  
 Si el <xref:System.Timers.Timer.SynchronizingObject%2A> propiedad es `null`, <xref:System.Timers.Timer.Elapsed> evento se genera en un <xref:System.Threading.ThreadPool> subproceso. Si el procesamiento de la <xref:System.Timers.Timer.Elapsed> evento dura más de <xref:System.Timers.Timer.Interval%2A>, es posible que provoca el evento nuevo en otro <xref:System.Threading.ThreadPool> subproceso. En esta situación, el controlador de eventos debe ser reentrante.  
  
> [!NOTE]
>  El método de control de eventos puede ejecutarse en un subproceso al mismo tiempo que otro subproceso llama a la <xref:System.Timers.Timer.Stop%2A> método o establece el <xref:System.Timers.Timer.Enabled%2A> propiedad a `false`. Esto podría dar lugar a la <xref:System.Timers.Timer.Elapsed> evento que se provoca cuando se haya detenido el temporizador. El código de ejemplo para el <xref:System.Timers.Timer.Stop%2A> método muestra una forma de evitar esta condición de carrera.  
  
 Incluso si <xref:System.Timers.Timer.SynchronizingObject%2A> no es `null`, <xref:System.Timers.Timer.Elapsed> los eventos pueden producirse después de la <xref:System.Timers.Timer.Dispose%2A> o <xref:System.Timers.Timer.Stop%2A> ha llamado al método o después del <xref:System.Timers.Timer.Enabled%2A> se ha establecido la propiedad en `false`, ya que la señal para generar el <xref:System.Timers.Timer.Elapsed> evento siempre se pone en cola para su ejecución en un subproceso ThreadPool. Una manera de resolver esta condición de carrera es establecer una marca que indica el controlador de eventos para el <xref:System.Timers.Timer.Elapsed> evento omita algunos eventos posteriores.  
  
 El <xref:System.Timers.Timer> componente detecta y suprime todas las excepciones producidas por controladores de eventos para el <xref:System.Timers.Timer.Elapsed> eventos. Este comportamiento está sujeta a cambios en futuras versiones de .NET Framework.  
  
   
  
## Examples  
 El ejemplo siguiente crea un <xref:System.Timers.Timer> objeto que se activa su <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventos cada dos segundos (2.000 milisegundos), configura un controlador de eventos para el evento e inicia el temporizador. El controlador de eventos muestra el valor de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propiedad cada vez que se provoca.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
        <altmember cref="T:System.Timers.ElapsedEventArgs" />
        <altmember cref="T:System.Timers.ElapsedEventHandler" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Timers.Timer.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer is enabled to fire events at a defined interval.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Timers.TimersDescription("TimerEnabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si <see cref="T:System.Timers.Timer" /> debe generar el evento <see cref="E:System.Timers.Timer.Elapsed" />.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Timers.Timer" /> debe generar el evento <see cref="E:System.Timers.Timer.Elapsed" />; en caso contrario, es <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer <xref:System.Timers.Timer.Enabled%2A> a `true` es igual que llamar a <xref:System.Timers.Timer.Start%2A>, durante la instalación <xref:System.Timers.Timer.Enabled%2A> a `false` es igual que llamar a <xref:System.Timers.Timer.Stop%2A>.  
  
> [!NOTE]
>  La señal para generar el <xref:System.Timers.Timer.Elapsed> eventos siempre está en cola para su ejecución en un <xref:System.Threading.ThreadPool> subproceso. Esto podría dar lugar a la <xref:System.Timers.Timer.Elapsed> eventos provocados después la <xref:System.Timers.Timer.Enabled%2A> propiedad está establecida en `false`. El ejemplo de código para el <xref:System.Timers.Timer.Stop%2A> método muestra una forma de solucionar esta condición de carrera.  
  
 Si <xref:System.Timers.Timer.Enabled%2A> está establecido en `true` y <xref:System.Timers.Timer.AutoReset%2A> está establecido en `false`, el <xref:System.Timers.Timer> provoca la <xref:System.Timers.Timer.Elapsed> eventos solo una vez, la primera vez que el intervalo transcurre.  
  
 Si el intervalo se establece después de la <xref:System.Timers.Timer> ha iniciado, se restablece el recuento. Por ejemplo, si establece el intervalo en 5 segundos y, a continuación, Establece el <xref:System.Timers.Timer.Enabled%2A> propiedad `true`, el recuento se inicia en el momento <xref:System.Timers.Timer.Enabled%2A> está establecido. Si restablece el intervalo en 10 segundos cuando el recuento sea 3 segundos, el <xref:System.Timers.Timer.Elapsed> evento se desencadena por primera vez 13 segundos después <xref:System.Timers.Timer.Enabled%2A> se estableció en `true`.  
  
> [!NOTE]
>  Algunos diseñadores visuales, como las de Microsoft Visual Studio, establezca el <xref:System.Timers.Timer.Enabled%2A> propiedad `true` al insertar un nuevo <xref:System.Timers.Timer>.  
  
   
  
## Examples  
 El ejemplo siguiente crea un <xref:System.Timers.Timer> objeto que se activa su <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventos cada dos segundos (2.000 milisegundos), configura un controlador de eventos para el evento e inicia el temporizador. El controlador de eventos muestra el valor de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propiedad cada vez que se provoca.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">No se puede establecer esta propiedad porque se ha desechado el temporizador.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Timers.Timer.Interval" /> se estableció en un valor mayor que <see cref="F:System.Int32.MaxValue" /> antes de que el temporizador estuviera habilitado.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="timer.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Finaliza la inicialización en tiempo de ejecución de un objeto <see cref="T:System.Timers.Timer" /> que se usa en un formulario o que lo usa otro componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] entorno usa este método para finalizar la inicialización de un componente que se usa en un formulario u otro componente de diseño. El <xref:System.Timers.Timer.BeginInit%2A> método comienza la inicialización. Mediante el <xref:System.Timers.Timer.BeginInit%2A> y <xref:System.Timers.Timer.EndInit%2A> métodos impide que el control que se va a usar antes de inicializarse completamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Timers.Timer.BeginInit" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public double Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Interval { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Interval : double with get, set" Usage="System.Timers.Timer.Interval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(100)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("The number of milliseconds between timer events.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Timers.TimersDescription("TimerInterval")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el intervalo, expresado en milisegundos, en el que se generará el evento <see cref="E:System.Timers.Timer.Elapsed" />.</summary>
        <value>Tiempo, en milisegundos, entre eventos <see cref="E:System.Timers.Timer.Elapsed" />. Este valor debe ser mayor que cero y menor o igual que <see cref="F:System.Int32.MaxValue" />. El valor predeterminado es de 100 milisegundos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa el <xref:System.Timers.Timer.Interval%2A> propiedad para determinar la frecuencia con la que el <xref:System.Timers.Timer.Elapsed> desencadena el evento. Dado que la <xref:System.Timers.Timer> clase depende del reloj del sistema, tiene la misma resolución que el reloj del sistema. Esto significa que el <xref:System.Timers.Timer.Elapsed> desencadenará el evento en un intervalo definido por la resolución del reloj del sistema si el <xref:System.Timers.Timer.Interval%2A> propiedad es menor que la resolución del reloj del sistema. El ejemplo siguiente se establece la <xref:System.Timers.Timer.Interval%2A> propiedad 5 milisegundos. Cuando se ejecuta en un [!INCLUDE[win7](~/includes/win7-md.md)] sistema cuyo reloj del sistema tiene una resolución de aproximadamente 15 milisegundos, el evento se desencadena aproximadamente cada 15 milisegundos en lugar de cada 5 milisegundos.  
  
 [!code-csharp[System.Timers.Timer.Interval#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/interval2.cs#1)]
 [!code-vb[System.Timers.Timer.Interval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/interval2.vb#1)]  
  
 Puede usar el código siguiente para determinar la resolución del reloj del sistema en el sistema actual:  
  
 [!code-csharp[System.Timers.Timer.Interval#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/resolution1.cs#2)]
 [!code-vb[System.Timers.Timer.Interval#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/resolution1.vb#2)]  
  
 Si la aplicación requiere una resolución mayor que la ofrecida por la <xref:System.Timers.Timer> clase o el reloj del sistema, utilice los temporizadores multimedios de alta resolución; vea [Cómo: Utilice el temporizador de alta resolución](https://msdn.microsoft.com/library/aa964692.aspx).  
  
 Si el intervalo se establece después de la <xref:System.Timers.Timer> ha iniciado, se restablece el recuento. Por ejemplo, si establece el intervalo en 5 segundos y, a continuación, Establece el <xref:System.Timers.Timer.Enabled%2A> propiedad `true`, el recuento se inicia en el momento <xref:System.Timers.Timer.Enabled%2A> está establecido. Si restablece el intervalo en 10 segundos cuando el recuento sea 3 segundos, el <xref:System.Timers.Timer.Elapsed> evento se desencadena por primera vez 13 segundos después <xref:System.Timers.Timer.Enabled%2A> se estableció en `true`.  
  
 Si <xref:System.Timers.Timer.Enabled%2A> está establecido en `true` y <xref:System.Timers.Timer.AutoReset%2A> está establecido en `false`, el <xref:System.Timers.Timer> provoca la <xref:System.Timers.Timer.Elapsed> eventos solo una vez, la primera vez que el intervalo transcurre. <xref:System.Timers.Timer.Enabled%2A> a continuación, se establece en `false`.  
  
> [!NOTE]
>  Si <xref:System.Timers.Timer.Enabled%2A> y <xref:System.Timers.Timer.AutoReset%2A> están establecidos en `false`, y se habilitó anteriormente el temporizador, establecer el <xref:System.Timers.Timer.Interval%2A> propiedad causa el <xref:System.Timers.Timer.Elapsed> evento una vez, como si el <xref:System.Timers.Timer.Enabled%2A> propiedad se ha establecido en `true`. Para establecer el intervalo sin provocar el evento, puede establecer temporalmente el <xref:System.Timers.Timer.Enabled%2A> propiedad a `true`, establezca el <xref:System.Timers.Timer.Interval%2A> propiedad en el intervalo de tiempo que desee y, a continuación, se establece inmediatamente el <xref:System.Timers.Timer.Enabled%2A> propiedad nuevo a `false`.  
  
   
  
## Examples  
 El ejemplo siguiente crea un <xref:System.Timers.Timer> objeto que se activa su <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventos cada dos segundos (2.000 milisegundos), configura un controlador de eventos para el evento e inicia el temporizador. El controlador de eventos muestra el valor de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propiedad cada vez que se provoca.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El intervalo es menor o igual que cero.  
  
O bien 
El intervalo es mayor que <see cref="F:System.Int32.MaxValue" /> y el temporizador está habilitado actualmente. (Si el temporizador no está habilitado actualmente, no se produce ninguna excepción hasta que se habilita.)</exception>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Timers.Timer.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el sitio que enlaza el objeto <see cref="T:System.Timers.Timer" /> a su contenedor en modo de diseño.</summary>
        <value>Interfaz <see cref="T:System.ComponentModel.ISite" /> que representa el sitio que enlaza el objeto <see cref="T:System.Timers.Timer" /> a su contenedor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sitios de enlazan un <xref:System.ComponentModel.Component> a un <xref:System.ComponentModel.Container> y habilitar la comunicación entre ellos, así como proporcionar una forma para el contenedor administrar sus componentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="timer.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Empieza a generar el evento <see cref="E:System.Timers.Timer.Elapsed" /> al establecer <see cref="P:System.Timers.Timer.Enabled" /> en <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Timers.Timer.Start%2A> se llama y <xref:System.Timers.Timer.AutoReset%2A> está establecido en `false`, el <xref:System.Timers.Timer> provoca la <xref:System.Timers.Timer.Elapsed> eventos solo una vez, la primera vez que el intervalo transcurre. Si <xref:System.Timers.Timer.Start%2A> se llama y <xref:System.Timers.Timer.AutoReset%2A> es `true`, <xref:System.Timers.Timer> provoca la <xref:System.Timers.Timer.Elapsed> hora del evento de la primera transcurrido el intervalo y continúa generar el evento en el intervalo especificado.  
  
 También puede iniciar el control de tiempo estableciendo <xref:System.Timers.Timer.Enabled%2A> a `true`.  
  
> [!NOTE]
>  Si <xref:System.Timers.Timer.AutoReset%2A> es `false`, el <xref:System.Timers.Timer.Start%2A> debe llamar al método para iniciar el recuento de nuevo.  
  
 Una llamada a la <xref:System.Timers.Timer.Start%2A> método cuando el temporizador está habilitado no tiene ningún efecto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="T:System.Timers.Timer" /> se crea con un intervalo igual o superior a <see cref="F:System.Int32.MaxValue" /> + 1 o se establece en un intervalo inferior a cero.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="timer.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deja de generar el evento <see cref="E:System.Timers.Timer.Elapsed" /> al establecer <see cref="P:System.Timers.Timer.Enabled" /> en <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 También puede detener la temporización estableciendo <xref:System.Timers.Timer.Enabled%2A> a `false`.  
  
> [!NOTE]
>  La señal para generar el <xref:System.Timers.Timer.Elapsed> eventos siempre está en cola para su ejecución en un <xref:System.Threading.ThreadPool> subprocesos, por lo que el método de control de eventos puede ejecutarse en un subproceso al mismo tiempo que una llamada a la <xref:System.Timers.Timer.Stop%2A> método se ejecuta en otro subproceso. Esto podría dar lugar a la <xref:System.Timers.Timer.Elapsed> eventos provocados después el <xref:System.Timers.Timer.Stop%2A> se llama al método. El ejemplo de código en la sección siguiente muestra una manera de evitar esta condición de carrera.  
  
   
  
## Examples  
 El ejemplo siguiente crea un `System.Timers.Timer` objeto que se activa su <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> eventos cada dos segundos (2.000 milisegundos), configura un controlador de eventos para el evento e inicia el temporizador. El controlador de eventos muestra el valor de la <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> propiedad cada vez que se provoca. Cuando el usuario presiona la tecla ENTRAR, la aplicación llama a la <xref:System.Timers.Timer.Stop%2A> método antes de finalizar la aplicación.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 En el ejemplo de código siguiente se muestra una forma de evitar que el subproceso que llama el <xref:System.Timers.Timer.Stop%2A> método continúe hasta que se está ejecutando <xref:System.Timers.Timer.Elapsed> extremos de evento y también para evitar que dos <xref:System.Timers.Timer.Elapsed> eventos de ejecutar el controlador de eventos al mismo tiempo tiempo (a menudo denominado reentrada).  
  
 El ejemplo ejecuta 100 Series de pruebas. Cada vez que se ejecuta la prueba, se inicia el temporizador con un intervalo de 150 milisegundos. El controlador de eventos usa el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para simular una tarea que varía de forma aleatoria en la longitud de 50 a 200 milisegundos. El método de prueba también inicia un subproceso de control que espera un segundo y, a continuación, detiene el temporizador. Si se controla un evento cuando el subproceso de control detiene el temporizador, el subproceso de control debe esperar hasta que finalice el evento antes de continuar.  
  
 El <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> sobrecarga del método se utiliza para evitar la reentrada y para impedir que el subproceso de control continúe hasta que finalice un evento en ejecución. El controlador de eventos usa el <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> método para establecer un control de variable en 1, pero solo si el valor es cero actualmente. Se trata de una operación atómica. Si el valor devuelto es cero, la variable de control se ha establecido en 1 y el controlador de eventos continúa. Si el valor devuelto es distinto de cero, se descarta el evento para evitar la reentrada. (Si fuese necesario ejecutar todos los eventos, el <xref:System.Threading.Monitor> clase sería una mejor manera de sincronizar los eventos.) Cuando finaliza el controlador de eventos, Establece la variable de control vuelve a cero. En el ejemplo se registra el número total de eventos ejecutados que se descartaron debido a la reentrada y que se produjeron después de la <xref:System.Timers.Timer.Stop%2A> se llamó al método.  
  
 El subproceso de control utiliza el <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> método para establecer el control de la variable en -1 (menos uno), pero solo si el valor es cero actualmente. Si la operación atómica devuelve distinto de cero, se está ejecutando actualmente un evento. El subproceso de control espera y vuelve a intentarlo. En el ejemplo se registra el número de veces que el subproceso de control se tuvieron que esperar a que finalice un evento.  
  
 [!code-csharp[Timer.Stop#1](~/samples/snippets/csharp/VS_Snippets_CLR/Timer.Stop/CS/source.cs#1)]
 [!code-vb[Timer.Stop#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Timer.Stop/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Timers.Timer.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("The object used to marshal the event handler calls issued when an interval has elapsed.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Timers.TimersDescription("TimerSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto que se utiliza para calcular las referencias de las llamadas del controlador de eventos que se emiten al transcurrir un intervalo.</summary>
        <value><see cref="T:System.ComponentModel.ISynchronizeInvoke" /> que representa el objeto que se usa para calcular las referencias de las llamadas del controlador de eventos que se emiten al transcurrir un intervalo. De manera predeterminada, es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Timers.Timer.SynchronizingObject%2A> es `null`, el método que controla el <xref:System.Timers.Timer.Elapsed> se llama al evento en un subproceso del grupo de subprocesos del sistema. Para obtener más información sobre los grupos de subprocesos del sistema, consulte <xref:System.Threading.ThreadPool>.  
  
 Cuando el <xref:System.Timers.Timer.Elapsed> evento está controlado por un componente de Windows Forms visual, como un botón, acceso al componente a través del grupo de subprocesos del sistema podría resultado una excepción o simplemente no funcionen. Evitar este efecto estableciendo <xref:System.Timers.Timer.SynchronizingObject%2A> a un componente de Windows Forms, lo que hace que el método que controla el <xref:System.Timers.Timer.Elapsed> evento al que se llama en el mismo subproceso donde se creó el componente.  
  
> [!NOTE]
>  Incluso si la <xref:System.Timers.Timer.SynchronizingObject%2A> propiedad no es `null`, <xref:System.Timers.Timer.Elapsed> los eventos pueden producirse después de la <xref:System.Timers.Timer.Dispose%2A> o <xref:System.Timers.Timer.Stop%2A> ha llamado al método o después del <xref:System.Timers.Timer.Enabled%2A> se ha establecido la propiedad en `false`, ya que la señal para generar el <xref:System.Timers.Timer.Elapsed> evento siempre se pone en cola para su ejecución en un subproceso ThreadPool. Una manera de resolver esta condición de carrera es establecer una marca que indica el controlador de eventos para el <xref:System.Timers.Timer.Elapsed> evento omita algunos eventos posteriores.  
  
 Si el <xref:System.Timers.Timer> se usa dentro de Visual Studio en un diseñador de Windows Forms, <xref:System.Timers.Timer.SynchronizingObject%2A> se establece automáticamente en el control que contiene el <xref:System.Timers.Timer>. Por ejemplo, si coloca un <xref:System.Timers.Timer> en un diseñador para `Form1` (que hereda de <xref:System.Windows.Forms.Form>), el <xref:System.Timers.Timer.SynchronizingObject%2A> propiedad de <xref:System.Timers.Timer> se establece en la instancia de `Form1`.  
  
   
  
## Examples  
 El ejemplo siguiente es una aplicación de Windows Forms que actúa como un editor de archivos de texto muy sencillo. Cuando no se ha guardado el texto en el cuadro de texto, la aplicación pide al usuario a intervalos de un minuto si desea guardar el contenido del cuadro de texto.  Para ello, el <xref:System.Timers.Timer.Interval%2A> propiedad está establecida en un minuto (60.000 milisegundos) y el <xref:System.Timers.Timer.SynchronizingObject%2A> propiedad está establecida en el <xref:System.Windows.Forms.Form> objeto.  
  
 [!code-csharp[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/cs/Form1.cs#1)]
 [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/vb/Form1.vb#1)]  
  
 El ejemplo requiere que agregue los siguientes controles al formulario:  
  
-   Un <xref:System.Windows.Forms.TextBox> control denominado `TextBox1` (su nombre predeterminado).  
  
-   Un <xref:System.Windows.Forms.Button> control denominado `Button1` (su nombre predeterminado).  
  
-   Un <xref:System.Windows.Forms.SaveFileDialog> control denominado `SaveSaveFileDialog1` (su nombre predeterminado).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
        <altmember cref="T:System.Threading.ThreadPool" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
  </Members>
</Type>