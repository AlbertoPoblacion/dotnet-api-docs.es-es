<Type Name="MethodDataCollection" FullName="System.Management.MethodDataCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ed8ee777fa6d565f2b2a6288bb8fabbab3d268bf" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30460389" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MethodDataCollection : System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MethodDataCollection extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Management.MethodDataCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class MethodDataCollection&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodDataCollection : System::Collections::ICollection" />
  <AssemblyInfo>
    <AssemblyName>System.Management</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa el conjunto de métodos disponibles en la colección.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra información sobre la **Win32_Process.Create** método mediante el <xref:System.Management.MethodData> clase. Para obtener más información sobre la **Win32_Process** de clases, vea la documentación de Instrumental de administración de Windows en MSDN Library en http://msdn.microsoft.com/library.  
  
 [!code-csharp[wminet_MethodDataCollection#1](~/samples/snippets/csharp/VS_Snippets_WindowsServer/wminet_MethodDataCollection/cs/MethodDataCollection.cs#1)]
 [!code-vb[wminet_MethodDataCollection#1](~/samples/snippets/visualbasic/VS_Snippets_WindowsServer/wminet_MethodDataCollection/vb/MethodDataCollection.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega un objeto <see cref="T:System.Management.MethodData" /> a <see cref="T:System.Management.MethodDataCollection" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (string methodName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(string methodName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.MethodDataCollection.Add(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (methodName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::String ^ methodName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="methodName">Nombre del método que se va a agregar.</param>
        <summary>Agrega un objeto <see cref="T:System.Management.MethodData" /> a la colección <see cref="T:System.Management.MethodDataCollection" />. Esta sobrecarga agregará a la colección un método nuevo sin parámetros.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Agregar <xref:System.Management.MethodData> objetos a la <xref:System.Management.MethodDataCollection> solo puede realizarse cuando la clase no tiene instancias. Cualquier otro caso se producirá una excepción.  
  
## <a name="net-framework-security"></a>Seguridad de .NET Framework  
 Plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro. Para obtener más información, consulte [utilizar bibliotecas de código de confianza parcial](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual void Add (string methodName, System.Management.ManagementBaseObject inParameters, System.Management.ManagementBaseObject outParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(string methodName, class System.Management.ManagementBaseObject inParameters, class System.Management.ManagementBaseObject outParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.MethodDataCollection.Add(System.String,System.Management.ManagementBaseObject,System.Management.ManagementBaseObject)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Add (methodName As String, inParameters As ManagementBaseObject, outParameters As ManagementBaseObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::String ^ methodName, System::Management::ManagementBaseObject ^ inParameters, System::Management::ManagementBaseObject ^ outParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="inParameters" Type="System.Management.ManagementBaseObject" />
        <Parameter Name="outParameters" Type="System.Management.ManagementBaseObject" />
      </Parameters>
      <Docs>
        <param name="methodName">Nombre del método que se va a agregar.</param>
        <param name="inParameters">
          <see cref="T:System.Management.ManagementBaseObject" /> que contiene los parámetros de entrada del método.</param>
        <param name="outParameters">
          <see cref="T:System.Management.ManagementBaseObject" /> que contiene los parámetros de salida del método.</param>
        <summary>Agrega un objeto <see cref="T:System.Management.MethodData" /> a la colección <see cref="T:System.Management.MethodDataCollection" />. Esta sobrecarga agregará a la colección un método nuevo con los objetos de parámetro especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Agregar <xref:System.Management.MethodData> objetos a la <xref:System.Management.MethodDataCollection> solo puede realizarse cuando la clase no tiene instancias. Cualquier otro caso se producirá una excepción.  
  
## <a name="net-framework-security"></a>Seguridad de .NET Framework  
 Plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro. Para obtener más información, consulte [utilizar bibliotecas de código de confianza parcial](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia el objeto <see cref="T:System.Management.MethodDataCollection" /> en una matriz.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.MethodDataCollection.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matriz en la que se va a copiar la colección.</param>
        <param name="index">Índice por el que se va a comenzar.</param>
        <summary>Copia <see cref="T:System.Management.MethodDataCollection" /> en una matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="net-framework-security"></a>Seguridad de .NET Framework  
 Plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro. Para obtener más información, consulte [utilizar bibliotecas de código de confianza parcial](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Management.MethodData[] methodArray, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Management.MethodData[] methodArray, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.MethodDataCollection.CopyTo(System.Management.MethodData[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (methodArray As MethodData(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Management::MethodData ^&gt; ^ methodArray, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodArray" Type="System.Management.MethodData[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="methodArray">Matriz de destino en la que se va a copiar los objetos <see cref="T:System.Management.MethodData" />.</param>
        <param name="index">Índice de la matriz de destino por el que va a comenzar la copia.</param>
        <summary>Copia <see cref="T:System.Management.MethodDataCollection" /> en una matriz <see cref="T:System.Management.MethodData" /> especializada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="net-framework-security"></a>Seguridad de .NET Framework  
 Plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro. Para obtener más información, consulte [utilizar bibliotecas de código de confianza parcial](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Management.MethodDataCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de objetos de la colección <see cref="T:System.Management.MethodDataCollection" />.</summary>
        <value>Devuelve un valor <see cref="T:System.Int32" /> que representa el número de objetos de la colección.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="property-value"></a>Valor de propiedad  
 El número de objetos en el <xref:System.Management.MethodDataCollection>.  
  
## <a name="net-framework-security"></a>Seguridad de .NET Framework  
 Plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro. Para obtener más información, consulte [utilizar bibliotecas de código de confianza parcial](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.Count" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Management.MethodDataCollection.MethodDataEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Management.MethodDataCollection/MethodDataEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.MethodDataCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As MethodDataCollection.MethodDataEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Management::MethodDataCollection::MethodDataEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.MethodDataCollection+MethodDataEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador para la colección <see cref="T:System.Management.MethodDataCollection" />.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> que enumera la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada llamada a este método devuelve un nuevo enumerador de la colección. Se pueden obtener varios enumeradores para la misma colección de métodos. Sin embargo, cada enumerador toma una instantánea de la colección, por lo que no se reflejan los cambios realizados en la colección después de que se obtuvo el enumerador.  
  
 Solo puede recorrer en iteración (como en Visual Basic .NET `For Each` instrucción o C# `For` instrucción) a través de un enumerador de solo avance y solo una vez. Por lo que no se podrá rebobinar el enumerador, se libera la memoria que contiene las instancias de WMI. Por lo tanto, la <xref:System.Management.MethodDataCollection.Count%2A> no se puede usar el método puesto que requiere un retroceso del enumerador.  
  
 Los enumeradores de sólo avance generalmente son mucho más rápidos y utilizan menos memoria que los enumeradores convencionales, pero no permiten las llamadas a <xref:System.Management.MethodDataCollection.MethodDataEnumerator.Reset%2A>.  
  
 Si un enumerador es susceptible de retroceso, los objetos de la colección se mantendrán disponibles para varias enumeraciones.  
  
## <a name="net-framework-security"></a>Seguridad de .NET Framework  
 Plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro. Para obtener más información, consulte [utilizar bibliotecas de código de confianza parcial](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Management.MethodDataCollection.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto  está sincronizado.</summary>
        <value>Devuelve un valor <see cref="T:System.Boolean" /> que indica si el objeto está sincronizado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="property-value"></a>Valor de propiedad  
 `true` Si el objeto está sincronizado; en caso contrario, `false`.  
  
## <a name="net-framework-security"></a>Seguridad de .NET Framework  
 Plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro. Para obtener más información, consulte [utilizar bibliotecas de código de confianza parcial](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual System.Management.MethodData this[string methodName] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Management.MethodData Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Management.MethodDataCollection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(methodName As String) As MethodData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Management::MethodData ^ default[System::String ^] { System::Management::MethodData ^ get(System::String ^ methodName); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Management.MethodData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="methodName">Nombre del método solicitado.</param>
        <summary>Obtiene el <see cref="T:System.Management.MethodData" /> especificado de <see cref="T:System.Management.MethodDataCollection" />.</summary>
        <value>Devuelve <see cref="T:System.Management.MethodData" /> que contiene los datos de un método especificado de la colección.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="property-value"></a>Valor de propiedad  
 Un <xref:System.Management.MethodData> que contiene toda la información sobre el método especificado.  
  
## <a name="net-framework-security"></a>Seguridad de .NET Framework  
 Plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro. Para obtener más información, consulte [utilizar bibliotecas de código de confianza parcial](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (string methodName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(string methodName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.MethodDataCollection.Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (methodName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::String ^ methodName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="methodName">Nombre del método que se va a quitar de la colección.</param>
        <summary>Quita un objeto <see cref="T:System.Management.MethodData" /> de la colección <see cref="T:System.Management.MethodDataCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quitar <xref:System.Management.MethodData> objetos desde el <xref:System.Management.MethodDataCollection> solo puede realizarse cuando la clase no tiene instancias. Cualquier otro caso se producirá una excepción.  
  
## <a name="net-framework-security"></a>Seguridad de .NET Framework  
 Plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro. Para obtener más información, consulte [utilizar bibliotecas de código de confianza parcial](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Management.MethodDataCollection.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto que se utilizará para la sincronización.</summary>
        <value>Devuelve un valor <see cref="T:System.Object" /> que representa el objeto que se va a utilizar para la sincronización.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="property-value"></a>Valor de propiedad  
 El objeto que se usará para la sincronización.  
  
## <a name="net-framework-security"></a>Seguridad de .NET Framework  
 Plena confianza para el llamador inmediato. Un código de confianza parcial no puede utilizar este miembro. Para obtener más información, consulte [utilizar bibliotecas de código de confianza parcial](~/docs/framework/misc/using-libraries-from-partially-trusted-code.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Management.MethodDataCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Management</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Collections.IEnumerator" /> que recorre en iteración el objeto <see cref="T:System.Management.MethodDataCollection" />.</summary>
        <returns>Estructura <see cref="T:System.Collections.IEnumerator" /> para la colección <see cref="T:System.Management.MethodDataCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 La instrucción `foreach` del lenguaje C# (`for each` en Visual Basic) oculta la complejidad de los enumeradores.  Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. <xref:System.Collections.IEnumerator.Reset%2A> también devuelve el enumerador a esta posición. En esta posición, al llamar a <xref:System.Collections.IEnumerator.Current%2A> produce una excepción. Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A> o a <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.IEnumerator.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Mientras el enumerador permanezca en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, si se llama <xref:System.Collections.IEnumerator.Current%2A> produce una excepción. Para volver a establecer el valor de <xref:System.Collections.IEnumerator.Current%2A> en el primer elemento de la colección, se puede llamar primero a <xref:System.Collections.IEnumerator.Reset%2A> y después a <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumerador es válido mientras la colección no cambie. Si se realizan cambios en la colección, como agregar, modificar, o eliminar elementos, el enumerador queda permanentemente invalidado y la siguiente llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> produce una <xref:System.InvalidOperationException>. Si la colección se modifica entre <xref:System.Collections.IEnumerator.MoveNext%2A> y <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> devuelve el elemento que está establecido, aunque el enumerador ya haya quedado invalidado.  
  
 La enumeración en una colección no es un procedimiento seguro para subprocesos ya que el enumerador carece de acceso exclusivo. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>