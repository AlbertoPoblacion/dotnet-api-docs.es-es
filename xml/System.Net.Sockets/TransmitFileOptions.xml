<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TransmitFileOptions.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac57b5a0fa4a075e8c683de9144df832ae697f025f8.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7b5a0fa4a075e8c683de9144df832ae697f025f8</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> enumeration defines values used in file transfer requests.</source>
          <target state="translated">La enumeración <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> define valores utilizados en solicitudes de transferencia de archivos.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> The flags Disconnect and ReuseSocket return the socket to a disconnected, reusable state after the file has been transmitted.</source>
          <target state="translated"><bpt id="p1">**</bpt>Tenga en cuenta<ept id="p1">**</ept> las marcas de desconexión y ReuseSocket devuelven el socket a desconectado, reutilizable de estado después de que se ha transmitido el archivo.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source>These flags should not be used on a socket where quality of service (QOS) has been requested, because the service provider might immediately delete any quality of service associated with the socket before the file transfer has completed.</source>
          <target state="translated">Estas marcas no deben usarse en un socket donde se ha solicitado la calidad de servicio (QOS), porque el proveedor de servicios podría eliminar inmediatamente cualquier calidad del servicio asociada al socket antes de que se ha completado la transferencia de archivos.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source>The best approach for a QOS-enabled socket is to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> when the file transfer has completed, rather than relying on these flags.</source>
          <target state="translated">El mejor método para un socket habilitado para QOS es llamar a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> cuando haya finalizado la transferencia de archivos, en lugar de confiar en estos indicadores.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source>The following example demonstrates the use of <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions.ReuseSocket&gt;</ph> in a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions.ReuseSocket&gt;</ph> en una llamada a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source>The file "test.txt" is located in the root directory of the local machine.</source>
          <target state="translated">El archivo "test.txt" se encuentra en el directorio raíz de la máquina local.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source>In this example, a prebuffer and postbuffer of data are created and sent to the remote host with the file.</source>
          <target state="translated">En este ejemplo, un búfer y enviamos de datos se crean y envían al host remoto con el archivo.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.TransmitFileOptions">
          <source>To use the system's default thread, UseDefaultWorkerThread is specified.</source>
          <target state="translated">Para usar predeterminada del subproceso del sistema, se especifica UseDefaultWorkerThread.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.Disconnect">
          <source>Start a transport-level disconnect after all the file data has been queued for transmission.</source>
          <target state="translated">Inicia una desconexión de nivel de transporte después de que todos los datos de archivos se han colocado en la cola para la transmisión.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.Disconnect">
          <source>When used with <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.ReuseSocket" /&gt;</ph>, these flags return the socket to a disconnected, reusable state after the file has been transmitted.</source>
          <target state="translated">Cuando se utiliza con <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.ReuseSocket" /&gt;</ph>, estos marcadores devuelven el socket a un estado desconectado y reutilizable después de que se ha transmitido el archivo.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.ReuseSocket">
          <source>The socket handle may be reused when the request completes.</source>
          <target state="translated">Se puede reutilizar el identificador del socket cuando la solicitud finaliza.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.ReuseSocket">
          <source>This flag is valid only if <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.Disconnect" /&gt;</ph> is also specified.</source>
          <target state="translated">Este marcador sólo es válido si también se especifica <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.Disconnect" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.ReuseSocket">
          <source>When used with <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.Disconnect" /&gt;</ph>, these flags return the socket to a disconnected, reusable state after the file has been transmitted.</source>
          <target state="translated">Cuando se utiliza con <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.Disconnect" /&gt;</ph>, estos marcadores devuelven el socket a un estado desconectado y reutilizable después de que se ha transmitido el archivo.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread">
          <source>Use the default thread to process long file transfer requests.</source>
          <target state="translated">Utilice el subproceso predeterminado para procesar las solicitudes de transferencia de archivos largas.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.UseKernelApc">
          <source>Use kernel asynchronous procedure calls (APCs) instead of worker threads to process long file transfer requests.</source>
          <target state="translated">Utilice llamadas a procedimientos asincrónicos (APC) del kernel, en lugar de subprocesos de trabajo, para procesar las solicitudes largas de transferencia de archivos.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.UseKernelApc">
          <source>Long requests are defined as requests that require more than a single read from the file or a cache; the request therefore depends on the size of the file and the specified length of the send packet.</source>
          <target state="translated">Las solicitudes largas se definen como solicitudes que requieren más de una lectura del archivo o de una caché; la solicitud depende, por tanto, del tamaño del archivo y de la longitud especificada del paquete de envío.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.UseSystemThread">
          <source>Use system threads to process long file transfer requests.</source>
          <target state="translated">Utilice el subproceso del sistema para procesar las solicitudes largas de transferencia de archivos.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.WriteBehind">
          <source>Complete the file transfer request immediately, without pending.</source>
          <target state="translated">Finaliza la solicitud de la transferencia de archivos de forma inmediata y completa.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.WriteBehind">
          <source>If this flag is specified and the file transfer succeeds, the data has been accepted by the system but not necessarily acknowledged by the remote end.</source>
          <target state="translated">Si se especifica este marcador y la transferencia de archivos se realiza, el sistema ha aceptado los datos pero no han sido necesariamente confirmados por el fin remoto.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="F:System.Net.Sockets.TransmitFileOptions.WriteBehind">
          <source>Do not use this flag with the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.Disconnect" /&gt;</ph> and <ph id="ph2">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.ReuseSocket" /&gt;</ph> flags.</source>
          <target state="translated">No utilice este marcador con marcadores <ph id="ph1">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.Disconnect" /&gt;</ph> y <ph id="ph2">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.ReuseSocket" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>