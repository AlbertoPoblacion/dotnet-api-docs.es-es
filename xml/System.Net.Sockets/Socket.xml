<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6808af7c97188ea08a3159ec1991b02538d2e81c" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58702278" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implementa la interfaz de sockets Berkeley.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Net.Sockets.Socket> clase proporciona un amplio conjunto de métodos y propiedades para las comunicaciones de red. El <xref:System.Net.Sockets.Socket> clase le permite realizar ambos sincrónica y transferencias de datos asincrónicas mediante cualquiera de los protocolos de comunicación que se enumeran en la <xref:System.Net.Sockets.ProtocolType> enumeración.  
  
 La <xref:System.Net.Sockets.Socket> clase sigue el patrón de nomenclatura de .NET Framework para los métodos asincrónicos. Por ejemplo, sincrónico <xref:System.Net.Sockets.Socket.Receive%2A> método corresponde a la asincrónica <xref:System.Net.Sockets.Socket.BeginReceive%2A> y <xref:System.Net.Sockets.Socket.EndReceive%2A> métodos.  
  
 Si la aplicación requiere sólo un subproceso durante la ejecución, utilice los métodos siguientes, que están diseñados para el modo de funcionamiento sincrónico.  
  
-   Si usa un protocolo orientado a conexiones como TCP, el servidor puede escuchar las conexiones mediante el <xref:System.Net.Sockets.Socket.Listen%2A> método. El <xref:System.Net.Sockets.Socket.Accept%2A> método procesa las solicitudes de cualquier conexión entrante y devuelve un <xref:System.Net.Sockets.Socket> que puede usar para intercambiar datos con el host remoto. Use este valor devuelto <xref:System.Net.Sockets.Socket> para llamar a la <xref:System.Net.Sockets.Socket.Send%2A> o <xref:System.Net.Sockets.Socket.Receive%2A> método. Llame a la <xref:System.Net.Sockets.Socket.Bind%2A> método antes de llamar a la <xref:System.Net.Sockets.Socket.Listen%2A> método si desea especificar el número de puerto y la dirección IP local. Use un número de puerto de cero si desea que el proveedor de servicios subyacente para asignar un puerto libre para usted. Si desea conectarse a un host de escucha, llame a la <xref:System.Net.Sockets.Socket.Connect%2A> método. Para comunicar datos, llame a la <xref:System.Net.Sockets.Socket.Send%2A> o <xref:System.Net.Sockets.Socket.Receive%2A> método.  
  
-   Si usa un protocolo sin conexión, como UDP, no es necesario escuchar las conexiones en absoluto. Llame a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método para aceptar los datagramas entrantes. Use el <xref:System.Net.Sockets.Socket.SendTo%2A> método para enviar datagramas a un host remoto.  
  
 Para procesar las comunicaciones que usan subprocesos independientes durante la ejecución, use los métodos siguientes, que están diseñados para el modo de operación asincrónica.  
  
-   Si usa un protocolo orientado a conexiones como TCP, use el <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, y <xref:System.Net.Sockets.Socket.EndConnect%2A> métodos para establecer conexión con un host de escucha. Use la <xref:System.Net.Sockets.Socket.BeginSend%2A> y <xref:System.Net.Sockets.Socket.EndSend%2A> o <xref:System.Net.Sockets.Socket.BeginReceive%2A> y <xref:System.Net.Sockets.Socket.EndReceive%2A> métodos para comunicarse de forma asincrónica los datos. Se pueden procesar solicitudes de conexión entrantes mediante <xref:System.Net.Sockets.Socket.BeginAccept%2A> y <xref:System.Net.Sockets.Socket.EndAccept%2A>.  
  
-   Si usa un protocolo sin conexión, como UDP, puede usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> y <xref:System.Net.Sockets.Socket.EndSendTo%2A> para enviar datagramas, y <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> y <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> para recibir datagramas.  
  
 Si realiza varias operaciones asincrónicas en un socket, no necesariamente se completan en el orden en el que se inician.  
  
 Cuando haya terminado de enviar y recibir datos, use el <xref:System.Net.Sockets.Socket.Shutdown%2A> método para deshabilitar el <xref:System.Net.Sockets.Socket>. Después de llamar a <xref:System.Net.Sockets.Socket.Shutdown%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método para liberar todos los recursos asociados con la <xref:System.Net.Sockets.Socket>.  
  
 El <xref:System.Net.Sockets.Socket> clase le permite configurar su <xref:System.Net.Sockets.Socket> utilizando el <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método. Recuperar estos valores mediante el <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.  
  
> [!NOTE]
>  Si está escribiendo una aplicación relativamente sencilla y no requieren el máximo rendimiento, considere el uso de <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, y <xref:System.Net.Sockets.UdpClient>. Estas clases proporcionan una interfaz sencilla y más fácil de usar para <xref:System.Net.Sockets.Socket> las comunicaciones.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra cómo el <xref:System.Net.Sockets.Socket> clase puede utilizarse para enviar datos a un servidor HTTP y recibir la respuesta. En este ejemplo se bloquea hasta que se recibe la página completa.  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Para establecer una conexión saliente o Aceptar una solicitud entrante.</permission>
    <threadsafe>Las instancias de esta clase son seguros para subprocesos.</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md">Programación para redes en .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md">Procedimientos recomendados para las clases System.Net</related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md">Administración de la memoria caché para aplicaciones de red</related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md">Protocolo de Internet versión 6</related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md">Ejemplos de programación de red</related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md">Traza de la red en .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md">Seguridad en la programación para redes</related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md">Mejoras de rendimiento de socket en la versión 3.5</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="socketInformation">Información sobre el socket devuelta por <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.Socket" /> utilizando el valor devuelto por <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se llama a la <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor varias veces con la misma matriz de bytes que el argumento para cada llamada, creará varios administrados <xref:System.Net.Sockets.Socket>s con el mismo socket subyacente. Esta práctica es recomendable.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType">Uno de los valores de <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Uno de los valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.Net.Sockets.Socket" /> usando el tipo de socket y el protocolo que se especifiquen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `socketType` parámetro especifica el tipo de la <xref:System.Net.Sockets.Socket> clase y el `protocolType` parámetro especifica el protocolo utilizado por <xref:System.Net.Sockets.Socket>. Los dos parámetros no son independientes. A menudo el <xref:System.Net.Sockets.Socket> tipo está implícito en el protocolo. Si la combinación de <xref:System.Net.Sockets.Socket> tipo y tipo de protocolo resultados en un no válido <xref:System.Net.Sockets.Socket>, el constructor produce una <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Si el constructor produce una <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">La combinación de <paramref name="socketType" /> y <paramref name="protocolType" /> da como resultado un socket no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">Uno de los valores de <see cref="T:System.Net.Sockets.AddressFamily" />.</param>
        <param name="socketType">Uno de los valores de <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Uno de los valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.Net.Sockets.Socket" /> con la familia de direcciones, el tipo de socket y el protocolo que se especifiquen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `addressFamily` parámetro especifica el esquema de direcciones que el <xref:System.Net.Sockets.Socket> clase utiliza, el `socketType` parámetro especifica el tipo de la <xref:System.Net.Sockets.Socket> (clase) y el `protocolType` parámetro especifica el protocolo utilizado por <xref:System.Net.Sockets.Socket>. Los tres parámetros no son independientes. Algunas familias de direcciones restringen qué protocolos se pueden usar con ellos y, a menudo el <xref:System.Net.Sockets.Socket> tipo está implícito en el protocolo. Si la combinación de la familia de direcciones, <xref:System.Net.Sockets.Socket> tipo y escriba los resultados no es válido de protocolo <xref:System.Net.Sockets.Socket>, el constructor produce una <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Si el constructor produce una <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear una instancia de la <xref:System.Net.Sockets.Socket> clase.  
  
 [!code-cpp[Socket_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">La combinación de <paramref name="addressFamily" />, <paramref name="socketType" /> y <paramref name="protocolType" /> tiene como resultado un socket no válido.</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuevo objeto <see cref="T:System.Net.Sockets.Socket" /> para una conexión recién establecida.</summary>
        <returns>Objeto <see cref="T:System.Net.Sockets.Socket" /> para una conexión recién establecida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> sincrónicamente extrae la primera solicitud de conexión pendiente de la cola de solicitudes de conexión del socket de escucha y, a continuación, crea y devuelve un nuevo <xref:System.Net.Sockets.Socket>. No se puede usar este valor devuelto <xref:System.Net.Sockets.Socket> para aceptar conexiones adicionales de la cola de conexiones. Sin embargo, puede llamar a la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> devuelto del método de <xref:System.Net.Sockets.Socket> para identificar el número de puerto y la dirección de red del host remoto.  
  
 En modo de bloqueo, <xref:System.Net.Sockets.Socket.Accept%2A> bloquea hasta que se pone en cola un intento de conexión entrante. Una vez que se acepte una conexión, el original <xref:System.Net.Sockets.Socket> continúa la puesta en cola solicitudes de conexión entrantes hasta que cierre se.  
  
 Si se llama a este método mediante sin bloqueo <xref:System.Net.Sockets.Socket>y sin conexión se ponen en cola las solicitudes, <xref:System.Net.Sockets.Socket.Accept%2A> produce una <xref:System.Net.Sockets.SocketException>. Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Antes de llamar a la <xref:System.Net.Sockets.Socket.Accept%2A> método, primero debe llamar a la <xref:System.Net.Sockets.Socket.Listen%2A> método para escuchar y poner en cola las solicitudes de conexión entrantes.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente acepta una sencilla <xref:System.Net.Sockets.Socket> conexión.  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">El socket receptor no realiza escuchas de conexiones. Debe llamar a <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> y a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de llamar a <see cref="M:System.Net.Sockets.Socket.Accept" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</param>
        <summary>Comienza una operación asincrónica para aceptar un intento de conexión entrante.</summary>
        <returns>Devuelve <see langword="true" /> si la operación de E/S está pendiente. Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.  
  
 Devuelve <see langword="false" /> si la operación de E/S se ha completado de forma sincrónica. El evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pueden usar protocolos orientados a conexiones la <xref:System.Net.Sockets.Socket.AcceptAsync%2A> intentos de método para procesar conexiones entrantes de forma asincrónica. Aceptar conexiones de forma asincrónica ofrece la capacidad de enviar y recibir datos en un subproceso de ejecución independiente. Antes de llamar a la <xref:System.Net.Sockets.Socket.AcceptAsync%2A> método, debe llamar a la <xref:System.Net.Sockets.Socket.Listen%2A> método para escuchar y poner en cola las solicitudes de conexión entrantes.  
  
 Para recibir una notificación de finalización, debe crear un método de devolución de llamada que implementa el delegado EventHandler\<SocketAsyncEventArgs > delegar y enlazarlo a la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> eventos.  
  
 Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 El llamador puede especificar opcionalmente una existente <xref:System.Net.Sockets.Socket> que se usará para la conexión entrante especificando el <xref:System.Net.Sockets.Socket> para usar con el <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propiedad.  
  
 Si el <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propiedad es null, un nuevo <xref:System.Net.Sockets.Socket> se construye con el mismo <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, y <xref:System.Net.Sockets.Socket.ProtocolType%2A> como actual <xref:System.Net.Sockets.Socket> y establecer como el <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propiedad.  
  
 El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.AcceptAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada. Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.  
  
 Opcionalmente, se puede proporcionar un búfer para recibir el bloque inicial de datos en el socket después de la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método se ejecuta correctamente. En este caso, el <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propiedad debe establecerse en el búfer que contiene los datos para recibir y el <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propiedad debe establecerse en el número máximo de bytes de datos para el búfer de recepción. Estas propiedades se pueden establecer mediante el <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> método. Parte del búfer pasado se usarán internamente para su uso por la llamada de Winsock AcceptEx subyacente. Esto significa que la cantidad de datos devueltos siempre será menor que el valor de la <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propiedad en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instancia proporcionada. La cantidad de búfer utilizado internamente varía en función de la familia de direcciones del socket. El tamaño de búfer mínimo necesario es 288 bytes. Si se especifica un tamaño de búfer mayor, el <xref:System.Net.Sockets.Socket> esperan algunos datos adicionales que no sean los datos de direcciones recibidos por la llamada de Winsock AcceptEx y esperará hasta que se reciben estos datos innecesarios. Si se produce un tiempo de espera, se restablece la conexión. Por lo que si se esperan que los datos adicionales de una cantidad específica, el tamaño del búfer debe establecerse en el tamaño de búfer mínimo más esta cantidad.  
  
 El método de devolución de llamada de finalización debe examinar el <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> propiedad para determinar si el <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operación fue correcta.  
  
 El <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento puede producirse en algunos casos, cuando no se ha aceptado ninguna conexión y hacer que el <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> propiedad se establece en <xref:System.Net.Sockets.SocketError.ConnectionReset>. Esto puede ocurrir como resultado de la exploración de puertos mediante un examen de tipo semiabierto SYN (SYN -> SYN-ACK-> secuencia RST). Las aplicaciones que usan el <xref:System.Net.Sockets.Socket.AcceptAsync%2A> método debe estar preparado para controlar esta condición.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un argumento no es válido. Esta excepción produce si el búfer proporcionado no es suficientemente grande. El búfer debe ser de al menos 2 bytes * (sizeof(SOCKADDR_STORAGE + 16).  
  
Esta excepción también se produce si se especifican varios búferes; es decir, si la propiedad <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> no es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Un argumento está fuera de intervalo. La excepción produce si <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> es menor que 0.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha solicitado una operación no válida. Esta excepción se produce si el <see cref="T:System.Net.Sockets.Socket" /> de aceptación no realiza escuchas para las conexiones o el socket aceptado está enlazado.  
  
Debe llamar al método <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> y <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de llamar al método <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />.  
  
Esta excepción también se produce si el socket ya está conectado o si ya hay una operación de socket en curso con el parámetro <paramref name="e" /> especificado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.NotSupportedException">Se requiere Windows XP o posteriores para este método.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la familia de direcciones de <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Uno de los valores de <see cref="T:System.Net.Sockets.AddressFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.AddressFamily> especifica el esquema de direcciones que una instancia de la <xref:System.Net.Sockets.Socket> puede utilizar la clase. Esta propiedad es de solo lectura y se establece cuando el <xref:System.Net.Sockets.Socket> se crea.  
  
   
  
## Examples  
 El siguiente código de ejemplo se muestra el <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, y <xref:System.Net.Sockets.ProtocolType> en la consola.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cantidad de datos que se han recibido de la red y están disponibles para leer.</summary>
        <value>Número de bytes de datos recibidos de la red y disponibles para su lectura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si está utilizando sin bloqueo <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> es una buena forma de determinar si se pone en cola datos para la lectura, antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>. Los datos disponibles están que la cantidad total de datos en cola en el búfer de red para su lectura. Si no hay datos se pone en cola en el búfer de red, <xref:System.Net.Sockets.Socket.Available%2A> devuelve 0.  
  
 Si el host remoto se apaga o cierra la conexión, <xref:System.Net.Sockets.Socket.Available%2A> puede producir un <xref:System.Net.Sockets.SocketException>. Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se compara los resultados de llamar a IOControl con FIONREAD y la propiedad disponible.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza una operación asincrónica para aceptar un intento de conexión entrante.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objeto que contiene la información de estado para esta solicitud.</param>
        <summary>Comienza una operación asincrónica para aceptar un intento de conexión entrante.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a la creación asincrónica de <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pueden usar protocolos orientados a conexiones la <xref:System.Net.Sockets.Socket.BeginAccept%2A> intentos de método para procesar conexiones entrantes de forma asincrónica. Aceptar conexiones de forma asincrónica ofrece la capacidad de enviar y recibir datos en un subproceso de ejecución independiente. Antes de llamar a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, debe llamar a la <xref:System.Net.Sockets.Socket.Listen%2A> método para escuchar y poner en cola las solicitudes de conexión entrantes.  
  
 Debe crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. Para ello, como mínimo, debe pasar a la escucha <xref:System.Net.Sockets.Socket> objeto <xref:System.Net.Sockets.Socket.BeginAccept%2A> a través de la `state` parámetro. Si la devolución de llamada, necesita más información, puede crear una clase pequeña para contener el <xref:System.Net.Sockets.Socket> y otra información necesaria. Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método a través de la `state` parámetro.  
  
 El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndAccept%2A> método. Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, el sistema normalmente usa un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloquea en <xref:System.Net.Sockets.Socket.EndAccept%2A> hasta que se recupere una conexión pendiente. <xref:System.Net.Sockets.Socket.EndAccept%2A> Devuelve un nuevo <xref:System.Net.Sockets.Socket> objeto que puede usar para enviar y recibir datos con el host remoto. No se puede usar este valor devuelto <xref:System.Net.Sockets.Socket> para aceptar conexiones adicionales de la cola de conexiones. Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Llame al método Set en un <xref:System.Threading.ManualResetEvent> en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original.  
  
 El sistema también puede usar el subproceso de llamada para invocar el método de devolución de llamada. En este caso, el <xref:System.IAsyncResult.CompletedSynchronously%2A> propiedad en el valor devuelto <xref:System.IAsyncResult> se establecerá para indicar que el <xref:System.Net.Sockets.Socket.BeginAccept%2A> método se completó de forma sincrónica.  
  
 Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Para cancelar una llamada pendiente la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, cierre el <xref:System.Net.Sockets.Socket>. Cuando el <xref:System.Net.Sockets.Socket.Close%2A> se llama al método mientras una operación asincrónica está en curso, la devolución de llamada proporcionada para el <xref:System.Net.Sockets.Socket.BeginAccept%2A> se llama al método.  Una llamada posterior a la <xref:System.Net.Sockets.Socket.EndAccept%2A> método producirá una <xref:System.ObjectDisposedException> para indicar que se ha cancelado la operación.  
  
> [!NOTE]
>  Puede usar el <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propiedad devuelto del <xref:System.Net.Sockets.Socket> para identificar el número de puerto y la dirección de red del host remoto.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se intenta recibir una conexión entrante de forma asincrónica.  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.NotSupportedException">Se requiere Windows NT para este método.</exception>
        <exception cref="T:System.InvalidOperationException">El socket receptor no realiza escuchas de conexiones. Debe llamar a <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> y a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de llamar a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
O bien 
El socket aceptado se encuentra enlazado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> es menor que 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Ejemplo de sockets de cliente asincrónicos</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Ejemplo de sockets de servidor asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="receiveSize">Número de bytes que se han de aceptar del remitente.</param>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objeto que contiene la información de estado para esta solicitud.</param>
        <summary>Comienza una operación asincrónica para aceptar un intento de conexión entrante y recibe el primer bloque de datos enviado por la aplicación cliente.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a la creación asincrónica de <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pueden usar protocolos orientados a conexiones la <xref:System.Net.Sockets.Socket.BeginAccept%2A> intentos de método para procesar conexiones entrantes de forma asincrónica. Aceptar conexiones de forma asincrónica permite enviar y recibir datos en un subproceso de ejecución independiente. Esta sobrecarga permite especificar el número de bytes que se acepte en la transferencia inicial en el `receiveSize` parámetro.  
  
 Antes de llamar a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, debe llamar a la <xref:System.Net.Sockets.Socket.Listen%2A> método para escuchar y poner en cola las solicitudes de conexión entrantes.  
  
 Debe crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. Para ello, como mínimo, debe pasar a la escucha <xref:System.Net.Sockets.Socket> objeto <xref:System.Net.Sockets.Socket.BeginAccept%2A> a través de la `state` parámetro. Si la devolución de llamada, necesita más información, puede crear una clase pequeña para contener el <xref:System.Net.Sockets.Socket> y otra información necesaria. Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método a través de la `state` parámetro.  
  
 El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndAccept%2A> método. Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, el sistema normalmente usa un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloquea en <xref:System.Net.Sockets.Socket.EndAccept%2A> hasta que se recupere una conexión pendiente.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Devuelve un nuevo <xref:System.Net.Sockets.Socket> que puede usar para enviar y recibir datos con el host remoto. No se puede usar este valor devuelto <xref:System.Net.Sockets.Socket> para aceptar conexiones adicionales de la cola de conexiones. Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Llame al método Set en un <xref:System.Threading.ManualResetEvent> en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original.  
  
 El sistema también puede usar el subproceso de llamada para invocar el método de devolución de llamada. En este caso, el <xref:System.IAsyncResult.CompletedSynchronously%2A> propiedad en el valor devuelto <xref:System.IAsyncResult> se establecerá para indicar que el <xref:System.Net.Sockets.Socket.BeginAccept%2A> método se completó de forma sincrónica.  
  
 Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Para cancelar una llamada pendiente la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, cierre el <xref:System.Net.Sockets.Socket>.  Cuando el <xref:System.Net.Sockets.Socket.Close%2A> se llama al método mientras una operación asincrónica está en curso, la devolución de llamada proporcionada para el <xref:System.Net.Sockets.Socket.BeginAccept%2A> se llama al método.  Una llamada posterior a la <xref:System.Net.Sockets.Socket.EndAccept%2A> método producirá una <xref:System.ObjectDisposedException> para indicar que se ha cancelado la operación.  
  
> [!NOTE]
>  Puede llamar a usar el <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propiedad devuelto del <xref:System.Net.Sockets.Socket> objeto para identificar el número de puerto y la dirección de red del host remoto.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se abre un socket y acepta una conexión asincrónica. En este ejemplo, el socket acepta los 10 bytes iniciales de datos. El número de bytes recibidos y los datos se muestran en la consola por el delegado de devolución de llamada. Consulte <xref:System.Net.Sockets.Socket.BeginReceive%2A> para obtener una descripción de cómo se reciben los datos restantes.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.NotSupportedException">Se requiere Windows NT para este método.</exception>
        <exception cref="T:System.InvalidOperationException">El socket receptor no realiza escuchas de conexiones. Debe llamar a <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> y a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de llamar a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
O bien 
El socket aceptado se encuentra enlazado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> es menor que 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Ejemplo de sockets de cliente asincrónicos</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Ejemplo de sockets de servidor asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">Objeto <see cref="T:System.Net.Sockets.Socket" /> aceptado. Este valor puede ser <see langword="null" />.</param>
        <param name="receiveSize">Número máximo de bytes que se va a recibir.</param>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objeto que contiene la información de estado para esta solicitud.</param>
        <summary>Comienza una operación asincrónica para aceptar un intento de conexión entrante desde un socket específico y recibe el primer bloque de datos enviado por la aplicación cliente.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que hace referencia a la creación asincrónica del objeto <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pueden usar protocolos orientados a conexiones la <xref:System.Net.Sockets.Socket.BeginAccept%2A> intentos de método para procesar conexiones entrantes de forma asincrónica. Aceptar conexiones de forma asincrónica ofrece la capacidad de enviar y recibir datos en un subproceso de ejecución independiente. Esta sobrecarga permite especificar el socket aceptado en el `acceptSocket` parámetro. Si este parámetro es `null`, se crea el socket aceptado por el <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. Puede especificar el número de bytes que se acepte en la transferencia inicial en el `receiveSize` parámetro.  
  
 Antes de llamar a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, debe llamar a la <xref:System.Net.Sockets.Socket.Listen%2A> método para escuchar y poner en cola las solicitudes de conexión entrantes.  
  
 Debe crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. Para ello, como mínimo, debe pasar a la escucha <xref:System.Net.Sockets.Socket> objeto <xref:System.Net.Sockets.Socket.BeginAccept%2A> a través de la `state` parámetro. Si la devolución de llamada, necesita más información, puede crear una clase pequeña para contener el <xref:System.Net.Sockets.Socket> y otra información necesaria. Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método a través de la `state` parámetro.  
  
 El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndAccept%2A> método. Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, el sistema normalmente usa un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloquea en <xref:System.Net.Sockets.Socket.EndAccept%2A> hasta que se recupere una conexión pendiente.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Devuelve un nuevo <xref:System.Net.Sockets.Socket> objeto que puede usar para enviar y recibir datos con el host remoto. No se puede usar este valor devuelto <xref:System.Net.Sockets.Socket> para aceptar conexiones adicionales de la cola de conexiones. Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Llame al método Set en un <xref:System.Threading.ManualResetEvent> en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original.  
  
 El sistema también puede usar el subproceso de llamada para invocar el método de devolución de llamada. En este caso, el <xref:System.IAsyncResult.CompletedSynchronously%2A> propiedad en el valor devuelto <xref:System.IAsyncResult> se establecerá para indicar que el <xref:System.Net.Sockets.Socket.BeginAccept%2A> método se completó de forma sincrónica.  
  
 Para obtener más información sobre cómo escribir métodos de devolución de llamada, vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Para cancelar una llamada pendiente la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, cierre el <xref:System.Net.Sockets.Socket>. Cuando el <xref:System.Net.Sockets.Socket.Close%2A> se llama al método mientras una operación asincrónica está en curso, la devolución de llamada proporcionada para el <xref:System.Net.Sockets.Socket.BeginAccept%2A> se llama al método.  Una llamada posterior a la <xref:System.Net.Sockets.Socket.EndAccept%2A> método producirá una <xref:System.ObjectDisposedException> para indicar que se ha cancelado la operación.  
  
> [!NOTE]
>  Puede usar el <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propiedad devuelto del <xref:System.Net.Sockets.Socket> objeto para identificar el número de puerto y la dirección de red del host remoto.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se abre un socket y acepta una conexión asincrónica. En este ejemplo, el socket acepta los 10 bytes de datos iniciales y la `acceptSocket` parámetro es `null`, que fuerza la <xref:System.Net.Sockets.Socket.BeginAccept%2A> método para crear el socket aceptado. El número de bytes recibidos y los datos se muestran en la consola por el delegado de devolución de llamada. Consulte <xref:System.Net.Sockets.Socket.BeginReceive%2A> para obtener una descripción de cómo se reciben los datos restantes.  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.NotSupportedException">Se requiere Windows NT para este método.</exception>
        <exception cref="T:System.InvalidOperationException">El socket receptor no realiza escuchas de conexiones. Debe llamar a <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> y a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de llamar a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
O bien 
El socket aceptado se encuentra enlazado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> es menor que 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Ejemplo de sockets de cliente asincrónicos</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Ejemplo de sockets de servidor asincrónicos</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicia una solicitud asincrónica para una conexión a host remoto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> que representa el host remoto.</param>
        <param name="end_point"><see cref="T:System.Net.EndPoint" /> que representa el host remoto.</param>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objeto que contiene la información de estado para esta solicitud.</param>
        <summary>Inicia una solicitud asincrónica para una conexión a host remoto.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a la conexión asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si usa un protocolo orientado a conexiones, el <xref:System.Net.Sockets.Socket.BeginConnect%2A> método inicia una solicitud asincrónica para una conexión a la `remoteEP` parámetro. Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establece un host remoto predeterminado. Conectar o establecer el host remoto predeterminado de forma asincrónica ofrece la capacidad de enviar y recibir datos en un subproceso de ejecución independiente.  
  
 Puede crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método. Como mínimo, debe pasar el <xref:System.Net.Sockets.Socket> a <xref:System.Net.Sockets.Socket.BeginConnect%2A> a través de la `state` parámetro. Si la devolución de llamada, necesita más información, puede crear una clase pequeña para contener el <xref:System.Net.Sockets.Socket>y otra información necesaria. Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método a través de la `state` parámetro.  
  
 El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndConnect%2A> método. Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginConnect%2A>, el sistema usará un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloqueará en <xref:System.Net.Sockets.Socket.EndConnect%2A> hasta que el <xref:System.Net.Sockets.Socket> se conecta correctamente o produce una excepción. Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A>. Llame al método Set en un <xref:System.Threading.ManualResetEvent> en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original. Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Si usa un protocolo sin conexión, como UDP, no es necesario llamar a <xref:System.Net.Sockets.Socket.BeginConnect%2A> antes de enviar y recibir datos. Puede usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> y <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> para comunicarse con un host remoto. Si se llama <xref:System.Net.Sockets.Socket.BeginConnect%2A>, se descartarán todos los datagramas que llegan desde una dirección que no sea el valor predeterminado especificado. Si desea establecer el host remoto predeterminado para una dirección de difusión, primero debe llamar a <xref:System.Net.Sockets.Socket.SetSocketOption%2A> y establezca la difusión en `true`. Si no es posible, <xref:System.Net.Sockets.Socket.BeginConnect%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
 Si utiliza un protocolo orientado a conexiones y no llame a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar a <xref:System.Net.Sockets.Socket.BeginConnect%2A>, el proveedor de servicios subyacente asignará el número de puerto y la dirección de red local más adecuado. Si usa un protocolo sin conexión, el proveedor de servicios no asignará un número de puerto y la dirección de red local hasta que llame a la <xref:System.Net.Sockets.Socket.BeginSend%2A> o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. Si desea cambiar el host remoto predeterminado, llame a la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método nuevo con el punto de conexión deseado.  
  
 Para cancelar una llamada pendiente la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, cierre el <xref:System.Net.Sockets.Socket>. Cuando el <xref:System.Net.Sockets.Socket.Close%2A> se llama al método mientras una operación asincrónica está en curso, la devolución de llamada proporcionada para el <xref:System.Net.Sockets.Socket.BeginConnect%2A> se llama al método.  Una llamada posterior a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método producirá una <xref:System.ObjectDisposedException> para indicar que se ha cancelado la operación.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Si este socket se ha desconectado previamente, a continuación, <xref:System.Net.Sockets.Socket.BeginConnect%2A> debe llamarse en un subproceso que no terminará hasta que se complete la operación. Esta es una limitación del proveedor subyacente.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
   
  
## Examples  
 El ejemplo de código siguiente inicia un intento de conexión asincrónica.  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o ya hay una operación asincrónica en curso.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Calcular las referencias de un delegado como un método de devolución de llamada</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Ejemplo de sockets de cliente asincrónicos</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Ejemplo de sockets de servidor asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><see cref="T:System.Net.IPAddress" /> del host remoto.</param>
        <param name="port">Número de puerto del host remoto.</param>
        <param name="requestCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación de conexión se complete.</param>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación de conexión se complete.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación de conexión. Este objeto se pasa al delegado de <paramref name="requestCallback" /> cuando la operación se completa.</param>
        <summary>Inicia una solicitud asincrónica para una conexión a host remoto. El host se especifica mediante una <see cref="T:System.Net.IPAddress" /> y un número de puerto.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a la conexión asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrónico <xref:System.Net.Sockets.Socket.BeginConnect%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método. Normalmente, se invoca el método por el `requestCallback` delegar.  
  
 Este método no se bloquea hasta que se complete la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.Socket.Connect%2A> sobrecargas del método o <xref:System.Net.Sockets.Socket.EndConnect%2A>.  
  
 Para cancelar una llamada pendiente la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, cierre el <xref:System.Net.Sockets.Socket>. Cuando el <xref:System.Net.Sockets.Socket.Close%2A> se llama al método mientras una operación asincrónica está en curso, la devolución de llamada proporcionada para el <xref:System.Net.Sockets.Socket.BeginConnect%2A> se llama al método.  Una llamada posterior a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método producirá una <xref:System.ObjectDisposedException> para indicar que se ha cancelado la operación.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Si este socket se ha desconectado previamente, a continuación, <xref:System.Net.Sockets.Socket.BeginConnect%2A> debe llamarse en un subproceso que no terminará hasta que se complete la operación. Esta es una limitación del proveedor subyacente. También la <xref:System.Net.EndPoint> que es usado debe ser diferente.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
   
  
## Examples  
 El ejemplo de código siguiente inicia un intento de conexión asincrónica.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.NotSupportedException">El <see cref="T:System.Net.Sockets.Socket" /> no está en la familia de sockets.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de puerto no es válido.</exception>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="address" /> es cero.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o ya hay una operación asincrónica en curso.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Calcular las referencias de un delegado como un método de devolución de llamada</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Ejemplo de sockets de cliente asincrónicos</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Ejemplo de sockets de servidor asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses">Al menos una <see cref="T:System.Net.IPAddress" />, que designa el host remoto.</param>
        <param name="port">Número de puerto del host remoto.</param>
        <param name="requestCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación de conexión se complete.</param>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación de conexión se complete.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación de conexión. Este objeto se pasa al delegado de <paramref name="requestCallback" /> cuando la operación se completa.</param>
        <summary>Inicia una solicitud asincrónica para una conexión a host remoto. El host se especifica mediante una matriz <see cref="T:System.Net.IPAddress" /> y un número de puerto.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a las conexiones asincrónicas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrónico <xref:System.Net.Sockets.Socket.BeginConnect%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método. Normalmente, se invoca el método por el `requestCallback` delegar.  
  
 Este método no se bloquea hasta que se complete la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.Socket.Connect%2A> sobrecargas del método.  
  
 Para cancelar una llamada pendiente la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, cierre el <xref:System.Net.Sockets.Socket>. Cuando el <xref:System.Net.Sockets.Socket.Close%2A> se llama al método mientras una operación asincrónica está en curso, la devolución de llamada proporcionada para el <xref:System.Net.Sockets.Socket.BeginConnect%2A> se llama al método.  Una llamada posterior a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método producirá una <xref:System.ObjectDisposedException> para indicar que se ha cancelado la operación.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Si este socket se ha desconectado previamente, a continuación, <xref:System.Net.Sockets.Socket.BeginConnect%2A> debe llamarse en un subproceso que no terminará hasta que se complete la operación. Esta es una limitación del proveedor subyacente. También la <xref:System.Net.EndPoint> que es usado debe ser diferente.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
   
  
## Examples  
 El ejemplo de código siguiente inicia un intento de conexión asincrónica.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.NotSupportedException">Este método es válido para sockets que usan <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de puerto no es válido.</exception>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="address" /> es cero.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o ya hay una operación asincrónica en curso.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Calcular las referencias de un delegado como un método de devolución de llamada</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Ejemplo de sockets de cliente asincrónicos</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Ejemplo de sockets de servidor asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host">Nombre del host remoto.</param>
        <param name="port">Número de puerto del host remoto.</param>
        <param name="requestCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación de conexión se complete.</param>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación de conexión se complete.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación de conexión. Este objeto se pasa al delegado de <paramref name="requestCallback" /> cuando la operación se completa.</param>
        <summary>Inicia una solicitud asincrónica para una conexión a host remoto. El host se especifica mediante un nombre de host y un número de puerto.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a la conexión asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrónico <xref:System.Net.Sockets.Socket.BeginConnect%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método. Normalmente, se invoca el método por el `requestCallback` delegar.  
  
 Este método no se bloquea hasta que se complete la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.Socket.Connect%2A> sobrecargas del método.  
  
 Para cancelar una llamada pendiente la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, cierre el <xref:System.Net.Sockets.Socket>. Cuando el <xref:System.Net.Sockets.Socket.Close%2A> se llama al método mientras una operación asincrónica está en curso, la devolución de llamada proporcionada para el <xref:System.Net.Sockets.Socket.BeginConnect%2A> se llama al método.  Una llamada posterior a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método producirá una <xref:System.ObjectDisposedException> para indicar que se ha cancelado la operación.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Si este socket se ha desconectado previamente, a continuación, <xref:System.Net.Sockets.Socket.BeginConnect%2A> debe llamarse en un subproceso que no terminará hasta que se complete la operación. Esta es una limitación del proveedor subyacente. También la <xref:System.Net.EndPoint> que es usado debe ser diferente.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
   
  
## Examples  
 El ejemplo de código siguiente inicia un intento de conexión asincrónica.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se cerró el <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.NotSupportedException">Este método es válido para sockets de las familias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de puerto no es válido.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> o ya hay una operación asincrónica en curso.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Calcular las referencias de un delegado como un método de devolución de llamada</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Ejemplo de sockets de cliente asincrónicos</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Ejemplo de sockets de servidor asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><see langword="true" /> si se puede reutilizar el socket una vez cerrada la conexión; de lo contrario, <see langword="false" />.</param>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objeto que contiene la información de estado para esta solicitud.</param>
        <summary>Comienza una solicitud asincrónica para la desconexión de un extremo remoto.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que hace referencia a la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si utiliza un protocolo orientado a conexiones, puede llamar a la <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> método para solicitar una desconexión de un extremo remoto. Si `reuseSocket` es `true`, se puede reutilizar el socket.  
  
 El <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> método usa un subproceso independiente para invocar el método de devolución de llamada especificadas. El <xref:System.Net.Sockets.Socket.EndDisconnect%2A> método se bloquea hasta que la desconexión pendiente completada. Para obtener más información sobre cómo escribir métodos de devolución de llamada, vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException> excepción, use el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un socket para la comunicación asincrónica y envía datos a un host remoto. Cuando los datos se ha enviado, <xref:System.Net.Sockets.Socket.Shutdown%2A> se llama para detener el envío y recepción de actividad. A continuación, <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> se llama para iniciar una solicitud de desconexión. Cuando se completa la solicitud, el <xref:System.Net.Sockets.Socket.Connected%2A> es consultar la propiedad para comprobar si el socket está desconectado.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El sistema operativo es Windows 2000 o una versión anterior, y este método requiere Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza a recibir asincrónicamente los datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación se complete.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación de recepción. Este objeto se pasa al delegado de <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> cuando la operación se completa.</param>
        <summary>Comienza a recibir asincrónicamente los datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a la lectura asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrónico <xref:System.Net.Sockets.Socket.BeginReceive%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.Socket.EndReceive%2A> método. Normalmente, se invoca el método por el `callback` delegar.  
  
 Este método no se bloquea hasta que se complete la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas del método.  
  
 Para cancelar una pendiente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina. Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.  
  
> [!NOTE]
>  `state` es una instancia de una clase definida por el usuario.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Calcular las referencias de un delegado como un método de devolución de llamada</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Ejemplo de sockets de cliente asincrónicos</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Ejemplo de sockets de servidor asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</param>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación se complete.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación de recepción. Este objeto se pasa al delegado de <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> cuando la operación se completa.</param>
        <summary>Comienza a recibir asincrónicamente los datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a la lectura asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrónico <xref:System.Net.Sockets.Socket.BeginReceive%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.Socket.EndReceive%2A> método. Normalmente, se invoca el método por el `callback` delegar.  
  
 Este método no se bloquea hasta que se complete la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas del método.  
  
 Para cancelar una pendiente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina. Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.  
  
> [!NOTE]
>  `state` es una instancia de una clase definida por el usuario.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Calcular las referencias de un delegado como un método de devolución de llamada</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Ejemplo de sockets de cliente asincrónicos</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Ejemplo de sockets de servidor asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</param>
        <param name="offset">Posición de base cero del parámetro <paramref name="buffer" /> donde se almacenarán los datos recibidos.</param>
        <param name="size">Número de bytes que se va a recibir.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación se complete.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación de recepción. Este objeto se pasa al delegado de <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> cuando la operación se completa.</param>
        <summary>Comienza a recibir asincrónicamente los datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a la lectura asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrónico <xref:System.Net.Sockets.Socket.BeginReceive%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.Socket.EndReceive%2A> método. Normalmente, se invoca el método por el `callback` delegar.  
  
 Este método no se bloquea hasta que se complete la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas del método.  
  
 Para cancelar una pendiente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina. Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.  
  
> [!NOTE]
>  `state` es una instancia de una clase definida por el usuario.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
   
  
## Examples  
 En el siguiente ejemplo se comienza a recibir asincrónicamente los datos desde un conectado <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> es menor que 0.  
  
O bien 
 <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.  
  
O bien 
 <paramref name="size" /> es menor que 0.  
  
O bien 
 <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Calcular las referencias de un delegado como un método de devolución de llamada</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Ejemplo de sockets de cliente asincrónicos</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Ejemplo de sockets de servidor asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</param>
        <param name="offset">Ubicación de <paramref name="buffer" /> en la que se almacenarán los datos recibidos.</param>
        <param name="size">Número de bytes que se va a recibir.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="flags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</param>
        <param name="error">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</param>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación se complete.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación de recepción. Este objeto se pasa al delegado de <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> cuando la operación se completa.</param>
        <summary>Comienza a recibir asincrónicamente los datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a la lectura asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrónico <xref:System.Net.Sockets.Socket.BeginReceive%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.Socket.EndReceive%2A> método. Normalmente, se invoca el método por el `callback` delegar.  
  
 Este método no se bloquea hasta que se complete la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas del método.  
  
 Para cancelar una pendiente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina. Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.  
  
> [!NOTE]
>  `state` es una instancia de una clase definida por el usuario.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> es menor que 0.  
  
O bien 
 <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.  
  
O bien 
 <paramref name="size" /> es menor que 0.  
  
O bien 
 <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Calcular las referencias de un delegado como un método de devolución de llamada</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Ejemplo de sockets de cliente asincrónicos</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Ejemplo de sockets de servidor asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</param>
        <param name="offset">Posición de base cero del parámetro <paramref name="buffer" /> donde se almacenarán los datos.</param>
        <param name="size">Número de bytes que se va a recibir.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> que representa el origen de los datos.</param>
        <param name="remote_end"><see cref="T:System.Net.EndPoint" /> que representa el origen de los datos.</param>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objeto que contiene la información de estado para esta solicitud.</param>
        <summary>Comienza a recibir asincrónicamente los datos de un dispositivo de red especificado.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a la lectura asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método comienza a leer de forma asincrónica datagramas sin conexión desde un host remoto. Una llamada a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método le permite recibir datos en un subproceso de ejecución independiente.  
  
 Puede crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método. Para ello, como mínimo, el `state` parámetro debe contener conectado o default <xref:System.Net.Sockets.Socket> utilizado para la comunicación. Si la devolución de llamada, necesita más información, puede crear una clase pequeña para contener el <xref:System.Net.Sockets.Socket> y otra información necesaria. Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método a través de la `state` parámetro.  
  
 El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método. Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, el sistema usará un subproceso independiente para ejecutar el método de devolución de llamada especificado y bloqueará en <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> hasta que el <xref:System.Net.Sockets.Socket> lee datos o produce una excepción. Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Llame al método Set en un ManualResetEvent en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original. Para obtener más información sobre cómo escribir métodos de devolución de llamada, vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Antes de llamar a <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, debe enlazar explícitamente el <xref:System.Net.Sockets.Socket> a un punto de conexión local con el <xref:System.Net.Sockets.Socket.Bind%2A> método, o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
 Este método lee los datos en el `buffer` parámetro y el host remoto desde el que se envían los datos de punto de conexión de capturas. Para obtener información sobre cómo recuperar este punto de conexión, consulte <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Este método es muy útil si va a recibir asincrónicamente los datagramas sin conexión de un host desconocido o varios hosts. En estos casos, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> leerá el primer datagrama en cola recibido en el búfer de red local. Si el datagrama recibido es mayor que el tamaño de `buffer`, el <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método rellenará `buffer` con tanta información del mensaje como sea posible y throw un <xref:System.Net.Sockets.SocketException>. Si usa un protocolo no confiable, el exceso de datos se perderá. Si usa un protocolo confiable, el exceso de datos se conservarán por el proveedor de servicios y se puede recuperar llamando el <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método con un búfer suficientemente grande.  
  
 Para garantizar que siempre se devuelve el punto de conexión del host remoto, una aplicación debe enlazar explícitamente el <xref:System.Net.Sockets.Socket> a un punto de conexión local con el <xref:System.Net.Sockets.Socket.Bind%2A> método y, después, llame el <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método con el `optionLevel` parámetro establecido en <xref:System.Net.Sockets.SocketOptionLevel.IP>o <xref:System.Net.Sockets.SocketOptionLevel.IPv6> según corresponda, el `optionName` parámetro establecido en <xref:System.Net.Sockets.SocketOptionName.PacketInformation>y el `optionValue` parámetro para habilitar esta opción antes de llamar a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método. En caso contrario, es posible que el punto de conexión del host remoto no se devolverá cuando el remitente ha enviado un número de datagramas antes de que el receptor haya llamado el <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.  
  
 Aunque <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> está pensado para protocolos sin conexión, puede usar un protocolo orientado a conexiones. Si decide hacerlo, primero debe establecer o una conexión de host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> método o Aceptar una solicitud de conexión entrantes mediante una llamada a la <xref:System.Net.Sockets.Socket.Accept%2A> o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. Si se llama a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método antes de establecer o Aceptar una conexión, obtendrá un <xref:System.Net.Sockets.SocketException>. También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método. En cualquiera de estos casos, el <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método pasará por alto el `remoteEP` parámetro y solo recibirá datos conectado o host remoto predeterminado.  
  
 Con los sockets orientados a conexiones, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> leerá tantos datos como está disponible hasta el número de bytes especificado por el `size` parámetro.  
  
 Para cancelar una pendiente <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
   
  
## Examples  
 El ejemplo de código siguiente recibe datagramas sin conexión desde un host remoto de forma asincrónica.  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.  
  
O bien 
 <paramref name="remoteEP" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> es menor que 0.  
  
O bien 
 <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.  
  
O bien 
 <paramref name="size" /> es menor que 0.  
  
O bien 
 <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Calcular las referencias de un delegado como un método de devolución de llamada</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</param>
        <param name="offset">Posición de base cero del parámetro <paramref name="buffer" /> donde se almacenarán los datos.</param>
        <param name="size">Número de bytes que se va a recibir.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> que representa el origen de los datos.</param>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objeto que contiene la información de estado para esta solicitud.</param>
        <summary>Empieza a recibir de forma asincrónica el número especificado de bytes de datos en la ubicación indicada del búfer de datos, mediante el marcador <see cref="T:System.Net.Sockets.SocketFlags" /> especificado, y almacena el punto de conexión y la información sobre paquetes.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a la lectura asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operación de recepción asincrónica debe realizarse mediante una llamada a la <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar.  
  
 Este método no se bloquea hasta que se complete la operación. Para bloquear hasta que se complete la operación, utilice el <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método.  
  
 Para cancelar una pendiente <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Este método lee los datos en el `buffer` parámetro y el host remoto desde el que se envían los datos de punto de conexión de capturas, así como información sobre el paquete recibido. Para obtener información sobre cómo recuperar este punto de conexión, consulte <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Este método es muy útil si va a recibir asincrónicamente los datagramas sin conexión de un host desconocido o varios hosts.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.  
  
O bien 
 <paramref name="remoteEP" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> es menor que 0.  
  
O bien 
 <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.  
  
O bien 
 <paramref name="size" /> es menor que 0.  
  
O bien 
 <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.NotSupportedException">El sistema operativo es Windows 2000 o una versión anterior, y este método requiere Windows XP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envía datos asincrónicamente a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se enviarán.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objeto que contiene la información de estado para esta solicitud.</param>
        <summary>Envía datos asincrónicamente a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia al envío asincrónico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia una operación de envío asincrónico para el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. <xref:System.Net.Sockets.Socket.BeginSend%2A> se iniciará una excepción si no se llama primero <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Una llamada a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método le permite enviar datos en un subproceso de ejecución independiente.  
  
 Puede crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método. Para ello, como mínimo, el `state` parámetro debe contener conectado o default <xref:System.Net.Sockets.Socket> utilizado para la comunicación. Si la devolución de llamada, necesita más información, puede crear una pequeña clase o estructura que contenga el <xref:System.Net.Sockets.Socket> y otra información necesaria. Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método a través de la `state` parámetro.  
  
 El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndSend%2A> método. Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginSend%2A>, el sistema usará un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloqueará en <xref:System.Net.Sockets.Socket.EndSend%2A> hasta que el <xref:System.Net.Sockets.Socket> envía el número de bytes solicitado o una excepción. Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use el <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método. Llame al método Set en un ManualResetEvent en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original. Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Si bien pensado para protocolos orientados a conexiones, <xref:System.Net.Sockets.Socket.BeginSend%2A> también funciona para los protocolos sin conexión, siempre que se llama primero a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para establecer un host remoto predeterminado. Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. No pasa nada por usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>. También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.BeginSend%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Protocolos sin conexión, también debe ser seguro de que el tamaño del búfer no supera el tamaño máximo de paquetes del proveedor de servicios subyacente. Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.BeginSend%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
 Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina. Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.  
  
> [!NOTE]
>  `state` es una instancia de una clase definida por el usuario.  
  
> [!NOTE]
>  La finalización correcta de un envío no indica que los datos se ha entregado correctamente. Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> está vacía.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket. Vea la sección de comentarios que figura más abajo.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Calcular las referencias de un delegado como un método de devolución de llamada</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Ejemplo de sockets de cliente asincrónicos</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Ejemplo de sockets de servidor asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se enviarán.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</param>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objeto que contiene la información de estado para esta solicitud.</param>
        <summary>Envía datos asincrónicamente a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia al envío asincrónico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia una operación de envío asincrónico para el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. <xref:System.Net.Sockets.Socket.BeginSend%2A> se iniciará una excepción si no se llama primero <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Una llamada a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método le permite enviar datos en un subproceso de ejecución independiente.  
  
 Puede crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método. Para ello, como mínimo, el `state` parámetro debe contener conectado o default <xref:System.Net.Sockets.Socket> utilizado para la comunicación. Si la devolución de llamada, necesita más información, puede crear una pequeña clase o estructura que contenga el <xref:System.Net.Sockets.Socket> y otra información necesaria. Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método a través de la `state` parámetro.  
  
 El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndSend%2A> método. Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginSend%2A>, el sistema usará un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloqueará en <xref:System.Net.Sockets.Socket.EndSend%2A> hasta que el <xref:System.Net.Sockets.Socket> envía el número de bytes solicitado o una excepción. Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use el <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método. Llame al método Set en un <xref:System.Threading.ManualResetEvent> en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original. Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Si bien pensado para protocolos orientados a conexiones, <xref:System.Net.Sockets.Socket.BeginSend%2A> también funciona para los protocolos sin conexión, siempre que se llama primero a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para establecer un host remoto predeterminado. Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. No pasa nada por usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>. También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.BeginSend%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Protocolos sin conexión, también debe ser seguro de que el tamaño del búfer no supera el tamaño máximo de paquetes del proveedor de servicios subyacente. Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.BeginSend%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
 Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina. Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.  
  
> [!NOTE]
>  `state` es una instancia de una clase definida por el usuario.  
  
> [!NOTE]
>  La finalización correcta de un envío no indica que los datos se ha entregado correctamente. Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> está vacía.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket. Vea la sección de comentarios que figura más abajo.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Calcular las referencias de un delegado como un método de devolución de llamada</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Ejemplo de sockets de cliente asincrónicos</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Ejemplo de sockets de servidor asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se enviarán.</param>
        <param name="offset">Posición de base cero del parámetro <paramref name="buffer" /> donde se empezará a enviar los datos.</param>
        <param name="size">Número de bytes para enviar.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</param>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objeto que contiene la información de estado para esta solicitud.</param>
        <summary>Envía datos asincrónicamente a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia al envío asincrónico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia una operación de envío asincrónico para el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. <xref:System.Net.Sockets.Socket.BeginSend%2A> se iniciará una excepción si no se llama primero <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Una llamada a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método le permite enviar datos en un subproceso de ejecución independiente.  
  
 Puede crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método. Para ello, como mínimo, el `state` parámetro debe contener conectado o default <xref:System.Net.Sockets.Socket> utilizado para la comunicación. Si la devolución de llamada, necesita más información, puede crear una pequeña clase o estructura que contenga el <xref:System.Net.Sockets.Socket> y otra información necesaria. Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método a través de la `state` parámetro.  
  
 El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndSend%2A> método. Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginSend%2A>, el sistema usará un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloqueará en <xref:System.Net.Sockets.Socket.EndSend%2A> hasta que el <xref:System.Net.Sockets.Socket> envía el número de bytes solicitado o una excepción. Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use el <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método. Llame al método Set en un ManualResetEvent en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original. Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Si bien pensado para protocolos orientados a conexiones, <xref:System.Net.Sockets.Socket.BeginSend%2A> también funciona para los protocolos sin conexión, siempre que se llama primero a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para establecer un host remoto predeterminado. Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. No pasa nada por usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>. También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.BeginSend%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Protocolos sin conexión, también debe ser seguro de que el tamaño del búfer no supera el tamaño máximo de paquetes del proveedor de servicios subyacente. Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.BeginSend%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
 Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina. Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.  
  
> [!NOTE]
>  `state` es una instancia de una clase definida por el usuario.  
  
> [!NOTE]
>  La finalización correcta de un envío no indica que los datos se ha entregado correctamente. Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket. Vea la sección de comentarios que figura más abajo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> es menor que 0.  
  
O bien 
 <paramref name="offset" /> es menor que la longitud de <paramref name="buffer" />.  
  
O bien 
 <paramref name="size" /> es menor que 0.  
  
O bien 
 <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Calcular las referencias de un delegado como un método de devolución de llamada</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Ejemplo de sockets de cliente asincrónicos</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Ejemplo de sockets de servidor asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se enviarán.</param>
        <param name="offset">Posición de base cero del parámetro <paramref name="buffer" /> donde se empezará a enviar los datos.</param>
        <param name="size">Número de bytes para enviar.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objeto que contiene la información de estado para esta solicitud.</param>
        <summary>Envía datos asincrónicamente a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia al envío asincrónico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia una operación de envío asincrónico para el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. <xref:System.Net.Sockets.Socket.BeginSend%2A> se iniciará una excepción si no se llama primero <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Una llamada a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método le permite enviar datos en un subproceso de ejecución independiente.  
  
 Puede crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método. Para ello, como mínimo, el `state` parámetro debe contener conectado o default <xref:System.Net.Sockets.Socket> utilizado para la comunicación. Si la devolución de llamada, necesita más información, puede crear una pequeña clase o estructura que contenga el <xref:System.Net.Sockets.Socket> y otra información necesaria. Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método a través de la `state` parámetro.  
  
 El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndSend%2A> método. Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginSend%2A>, el sistema usará un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloqueará en <xref:System.Net.Sockets.Socket.EndSend%2A> hasta que el <xref:System.Net.Sockets.Socket> envía el número de bytes solicitado o una excepción. Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use el <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método. Llame al método Set en un ManualResetEvent en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original. Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Si bien pensado para protocolos orientados a conexiones, <xref:System.Net.Sockets.Socket.BeginSend%2A> también funciona para los protocolos sin conexión, siempre que se llama primero a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para establecer un host remoto predeterminado. Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. No pasa nada por usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>. También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.BeginSend%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Protocolos sin conexión, también debe ser seguro de que el tamaño del búfer no supera el tamaño máximo de paquetes del proveedor de servicios subyacente. Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.BeginSend%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
 Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina. Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.  
  
> [!NOTE]
>  `state` es una instancia de una clase definida por el usuario.  
  
> [!NOTE]
>  La finalización correcta de un envío no indica que los datos se ha entregado correctamente. Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
   
  
## Examples  
 El siguiente ejemplo de código comienza a enviar datos a un host remoto de forma asincrónica.  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket. Vea la sección de comentarios que figura más abajo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> es menor que 0.  
  
O bien 
 <paramref name="offset" /> es menor que la longitud de <paramref name="buffer" />.  
  
O bien 
 <paramref name="size" /> es menor que 0.  
  
O bien 
 <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Calcular las referencias de un delegado como un método de devolución de llamada</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Ejemplo de sockets de cliente asincrónicos</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Ejemplo de sockets de servidor asincrónicos</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envía, de forma asincrónica, un archivo a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Cadena con la ruta de acceso y el nombre del archivo que se ha de enviar. Este parámetro puede ser <see langword="null" />.</param>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objeto que contiene la información de estado para esta solicitud.</param>
        <summary>Envía el archivo <paramref name="fileName" /> a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado mediante el marcador <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que representa el envío asincrónico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga envía el archivo `fileName` al socket conectado. Si `fileName` está en el directorio local, puede identificarse con solo el nombre del archivo; en caso contrario, se deben especificar la ruta de acceso completa y el nombre del archivo. Los caracteres comodín (".. \\\myfile.txt ") y nombres de recurso compartido UNC ("\\\\\\\shared directory\\\myfile.txt ") son compatibles. Si el archivo no se encuentra, la excepción <xref:System.IO.FileNotFoundException> se produce.  
  
 Este método usa la `TransmitFile` encuentra la función de la API de Windows Sockets 2. Para obtener más información sobre la `TransmitFile` función y sus marcas, vea el [Windows Sockets](/windows/desktop/WinSock/) documentación.  
  
 El <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método inicia una operación de envío asincrónico para el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> métodos. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> produce una excepción si no se llama primero <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Una llamada a la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método le permite enviar un archivo en un subproceso de ejecución independiente.  
  
 Para completar la operación, puede crear un método de devolución de llamada invocada por el <xref:System.AsyncCallback> parámetro del delegado. Para ello, como mínimo, el `state` parámetro debe contener el <xref:System.Net.Sockets.Socket> objeto utilizado para la comunicación. Si la devolución de llamada, necesita más información, puede crear una clase o estructura que contenga el <xref:System.Net.Sockets.Socket> y otra información necesaria. Pasar una instancia de este objeto personalizado a la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método a través de la `state` parámetro.  
  
 El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndSendFile%2A> método. Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, el sistema utiliza un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloquea en <xref:System.Net.Sockets.Socket.EndSendFile%2A> hasta que el <xref:System.Net.Sockets.Socket> envía todo el archivo o una excepción. Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Si bien pensado para protocolos orientados a conexiones, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> también funciona para los protocolos sin conexión, siempre que se llama primero a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para establecer un host remoto predeterminado. Protocolos sin conexión, debe asegurarse de que el tamaño del archivo no supera el tamaño máximo de paquetes del proveedor de servicios subyacente. Si es así, no se envía el datagrama y <xref:System.Net.Sockets.Socket.BeginSendFile%2A> produce una <xref:System.Net.Sockets.SocketException> excepción.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException> excepción, use el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea y se conecta a un socket para la comunicación asincrónica. En primer lugar, el archivo "text.txt" se envía de forma asincrónica al host remoto. Las llamadas de delegado de la devolución de llamada <xref:System.Net.Sockets.Socket.EndSendFile%2A> para completar la transmisión.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.NotSupportedException">El socket no está conectado a un host remoto.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo <paramref name="fileName" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket. Vea la sección de comentarios que figura más abajo.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Cadena con la ruta de acceso y el nombre del archivo que se ha de enviar. Este parámetro puede ser <see langword="null" />.</param>
        <param name="preBuffer">Una matriz <see cref="T:System.Byte" /> que contiene los datos que se van a enviar antes de enviar el archivo. Este parámetro puede ser <see langword="null" />.</param>
        <param name="postBuffer">Una matriz <see cref="T:System.Byte" /> que contiene los datos que se van a enviar después de enviar el archivo. Este parámetro puede ser <see langword="null" />.</param>
        <param name="flags">Combinación bit a bit de valores <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</param>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" /> al que invocar una vez completada la operación. Este parámetro puede ser <see langword="null" />.</param>
        <param name="state">Objeto definido por el usuario con información de estado para esta solicitud. Este parámetro puede ser <see langword="null" />.</param>
        <summary>Envía, de forma asincrónica, un archivo y búferes de datos a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga requiere el nombre del archivo que desea enviar y una combinación bit a bit de <xref:System.Net.Sockets.TransmitFileOptions> valores. El `preBuffer` parámetro contiene todos los datos debe preceder el archivo. `postBuffer` contiene los datos que desea que siga el archivo. Si `fileName` está en el directorio local, puede identificarse con solo el nombre del archivo; en caso contrario, se deben especificar la ruta de acceso completa y el nombre del archivo. Los caracteres comodín (".. \\\myfile.txt ") y nombres de recurso compartido UNC ("\\\\\\\shared directory\\\myfile.txt ") son compatibles. Si el archivo no se encuentra, la excepción <xref:System.IO.FileNotFoundException> se produce.  
  
 El `flags` parámetro proporciona el proveedor de servicios de Windows Sockets con información adicional sobre la transferencia de archivos. Para obtener más información sobre cómo usar este parámetro, vea <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Este método usa la `TransmitFile` encuentra la función de la API de Windows Sockets 2. Para obtener más información sobre la `TransmitFile` función y sus marcas, vea el [Windows Sockets](/windows/desktop/WinSock/) documentación.  
  
 El <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método inicia una operación de envío asincrónico para el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> métodos. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> produce una excepción si no se llama primero <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Una llamada a la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método le permite enviar un archivo dentro de un subproceso de ejecución independiente.  
  
 Para completar la operación, puede crear un método de devolución de llamada invocada por el <xref:System.AsyncCallback> parámetro del delegado. Para ello, como mínimo, el `state` parámetro debe contener el <xref:System.Net.Sockets.Socket> objeto utilizado para la comunicación. Si la devolución de llamada, necesita más información, puede crear una clase o estructura que contenga el <xref:System.Net.Sockets.Socket> y otra información necesaria. Pasar una instancia de este objeto personalizado a la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método a través de la `state` parámetro.  
  
 El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndSendFile%2A> método. Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, el sistema utiliza un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloquea en <xref:System.Net.Sockets.Socket.EndSendFile%2A> hasta que el <xref:System.Net.Sockets.Socket> envía todo el archivo o una excepción. Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Si bien pensado para protocolos orientados a conexiones, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> también funciona para los protocolos sin conexión, siempre que se llama primero a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para establecer un host remoto predeterminado. Protocolos sin conexión, también debe asegurarse de que el tamaño del archivo no supera el tamaño máximo de paquetes del proveedor de servicios subyacente. Si es así, no se envía el datagrama y <xref:System.Net.Sockets.Socket.BeginSendFile%2A> produce una <xref:System.Net.Sockets.SocketException> excepción.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException> excepción, use el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea y se conecta a un socket para la comunicación asincrónica y comienza a enviar el archivo "text.txt" asincrónicamente al host remoto. En este ejemplo, un `preBuffer` y un `postBuffer` de datos se crea para enviar con el archivo y el valor predeterminado <xref:System.Net.Sockets.TransmitFileOptions> se usa el valor. Las llamadas de delegado de la devolución de llamada <xref:System.Net.Sockets.Socket.EndSendFile%2A> para completar la transmisión.  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket. Vea la sección de comentarios que figura más abajo.</exception>
        <exception cref="T:System.NotSupportedException">El sistema operativo no es Windows NT o una versión posterior.  
  
O bien 
El socket no está conectado a un host remoto.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo <paramref name="fileName" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se enviarán.</param>
        <param name="offset">Posición de base cero en el parámetro <paramref name="buffer" /> donde comienza el envío de datos.</param>
        <param name="size">Número de bytes para enviar.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> que representa el dispositivo remoto.</param>
        <param name="remote_end"><see cref="T:System.Net.EndPoint" /> que representa el dispositivo remoto.</param>
        <param name="callback">Delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Objeto que contiene la información de estado para esta solicitud.</param>
        <summary>Envía datos de forma asincrónica a un host remoto concreto.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia al envío asincrónico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método inicia una operación de envío asincrónico al host remoto especificado en el `remoteEP` parámetro. Una llamada a la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método le permite enviar datos en un subproceso de ejecución independiente. Si bien pensado para protocolos sin conexión, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> funciona con los protocolos sin conexión y orientados a conexiones.  
  
 Puede crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> y pasar su nombre a la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método. Para ello, como mínimo, el `state` parámetro debe contener conectado o default <xref:System.Net.Sockets.Socket> utilizado para la comunicación. Si la devolución de llamada, necesita más información, puede crear una clase pequeña para contener el <xref:System.Net.Sockets.Socket>y otra información necesaria. Pasar una instancia de esta clase a la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método a través de la `state` parámetro.  
  
 El método de devolución de llamada debe invocar el <xref:System.Net.Sockets.Socket.EndSendTo%2A> método. Cuando la aplicación llama <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, el sistema usará un subproceso independiente para ejecutar el método de devolución de llamada especificado y se bloqueará en <xref:System.Net.Sockets.Socket.EndSendTo%2A> hasta que el <xref:System.Net.Sockets.Socket> envía el número de bytes solicitado o una excepción. Si desea que el subproceso original se bloquee después de llamar a la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método, use el <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método. Llame al método Set en un ManualResetEvent en el método de devolución de llamada cuando desee seguir ejecutando el subproceso original. Para obtener más información sobre cómo escribir métodos de devolución de llamada vea [serialización de un delegado como un método de devolución de llamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Si utiliza un protocolo orientado a conexiones, primero debe llamar a la <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, o <xref:System.Net.Sockets.Socket.BeginSendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>. <xref:System.Net.Sockets.Socket.BeginSendTo%2A> pasará por alto el `remoteEP` parámetro y envía los datos a la <xref:System.Net.EndPoint> establecidos en el <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.  
  
 Si usa un protocolo sin conexión, no es necesario establecer un host remoto predeterminado mediante el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>. Solo deberá hacer esto si va a llamar a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método. Si se llama a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>, el `remoteEP` parámetro reemplazará el host remoto predeterminado especificado para que sólo la operación de envío. También no es necesario llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método. En este caso, el proveedor de servicios subyacente asignará al número de puerto y la dirección de red local más adecuado. Use un número de puerto de cero si desea que el proveedor de servicios subyacente para seleccionar un puerto libre. Si tiene que identificar el número de puerto y dirección de red local asignado, puede usar el <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propiedad después de la <xref:System.Net.Sockets.Socket.EndSendTo%2A> método se completa correctamente.  
  
 Si desea enviar datos a una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. -También debe asegurarse de que el tamaño del búfer no supera el tamaño máximo de paquetes del proveedor de servicios subyacente. Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.EndSendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
 Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El contexto de ejecución (el contexto de seguridad, el usuario suplantado y el contexto de llamada) se almacena en caché asincrónica <xref:System.Net.Sockets.Socket> métodos. Después del primer uso de un contexto determinado (un determinado asincrónico <xref:System.Net.Sockets.Socket> método, un determinado <xref:System.Net.Sockets.Socket> instancia y una devolución de llamada específica), los usos posteriores de ese contexto verán una mejora del rendimiento.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se envía de forma asincrónica datos al host remoto especificado.  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.  
  
O bien 
 <paramref name="remoteEP" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> es menor que 0.  
  
O bien 
 <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.  
  
O bien 
 <paramref name="size" /> es menor que 0.  
  
O bien 
 <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Calcular las referencias de un delegado como un método de devolución de llamada</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><see cref="T:System.Net.EndPoint" /> local que se va a asociar a <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Asocia un objeto <see cref="T:System.Net.Sockets.Socket" /> a un extremo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice el <xref:System.Net.Sockets.Socket.Bind%2A> método si tiene que utilizar un extremo local específico. Debe llamar a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar el <xref:System.Net.Sockets.Socket.Listen%2A> método. No es necesario llamar a <xref:System.Net.Sockets.Socket.Bind%2A> antes de usar el <xref:System.Net.Sockets.Socket.Connect%2A> método a menos que necesite utilizar un extremo local específico. Puede usar el <xref:System.Net.Sockets.Socket.Bind%2A> método en protocolos sin conexión y orientados a conexiones.  
  
 Antes de llamar a <xref:System.Net.Sockets.Socket.Bind%2A>, primero debe crear la variable local <xref:System.Net.IPEndPoint> desde que se va a comunicar los datos. Si no te importa qué dirección local se asigna, puede crear un <xref:System.Net.IPEndPoint> utilizando <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> como el parámetro de dirección y el servicio subyacente proveedor asignará la dirección de red más adecuada. Esto puede ayudar a simplificar la aplicación si tiene varias interfaces de red. Si no te importa qué puerto local se utiliza, puede crear un <xref:System.Net.IPEndPoint> con 0 para el número de puerto. En este caso, el proveedor de servicios asignará a un número de puerto disponible entre 1024 y 5000.  
  
 Si utiliza el enfoque anterior, puede detectar qué número de puerto y la dirección de red local se asignó mediante una llamada a la <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> no devolverá la dirección de red asignada localmente hasta después de haber realizado una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.EndConnect%2A> método. Si usa un protocolo sin conexión, no tendrá acceso a esta información hasta que se ha realizado un envío o recepción.  
  
 Si un socket UDP desea recibir información de la interfaz en los paquetes recibidos, el <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método debe llamarse explícitamente con la opción de socket establecida en <xref:System.Net.Sockets.SocketOptionName.PacketInformation> inmediatamente después de llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método.  
  
> [!NOTE]
>  Si tiene previsto recibir datagramas de multidifusión, debe llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método con un número de puerto de multidifusión.  
  
> [!NOTE]
>  Debe llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método si desea recibir datagramas sin conexión utilizando la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException> al llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método, use el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente código de ejemplo se enlaza un <xref:System.Net.Sockets.Socket> con el extremo local especificado.  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceptar conexiones desde el host definido por <paramref name="localEP" />. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si <see cref="T:System.Net.Sockets.Socket" /> está en modo de bloqueo.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> se bloquea; de lo contrario, es <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.Blocking%2A> propiedad indica si un <xref:System.Net.Sockets.Socket> está en modo de bloqueo.  
  
 Si está en modo de bloqueo, y llamar a un método que no se completa inmediatamente, la aplicación bloqueará la ejecución hasta que se complete la operación solicitada. Si desea que la ejecución continúe aunque la operación solicitada no está completa, cambie el <xref:System.Net.Sockets.Socket.Blocking%2A> propiedad `false`. El <xref:System.Net.Sockets.Socket.Blocking%2A> propiedad no tiene ningún efecto sobre los métodos asincrónicos. Si son enviar y recibir datos de forma asincrónica y desea bloquear la ejecución, use el <xref:System.Threading.ManualResetEvent> clase.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para solicitar la conexión al host remoto llamando a uno de los métodos <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />.</param>
        <summary>Cancela una solicitud asincrónica de una conexión a un host remoto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> método cancela una solicitud asincrónica de una conexión al host remoto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="e" /> y <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no puede ser null.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cierra la conexión <see cref="T:System.Net.Sockets.Socket" /> y libera todos los recursos asociados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra la conexión <see cref="T:System.Net.Sockets.Socket" /> y libera todos los recursos asociados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.Close%2A> método cierra la conexión del host remoto y las versiones todos los recursos administrados y asociados con el <xref:System.Net.Sockets.Socket>. Al cerrarse, el <xref:System.Net.Sockets.Socket.Connected%2A> propiedad está establecida en `false`.  
  
 Para protocolos orientados a conexiones, se recomienda que llame <xref:System.Net.Sockets.Socket.Shutdown%2A> antes de llamar a la <xref:System.Net.Sockets.Socket.Close%2A> método. Esto garantiza que todos los datos se envía y recibe en el socket conectado antes de cerrarse.  
  
 Si necesita llamar a <xref:System.Net.Sockets.Socket.Close%2A> sin llamar primero a <xref:System.Net.Sockets.Socket.Shutdown%2A>, puede asegurarse de que los datos en cola para transmisión de salida que se enviará al establecer el <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opción `false` y especificando un intervalo de tiempo de espera distinto de cero. <xref:System.Net.Sockets.Socket.Close%2A> a continuación, se bloqueará hasta que estos datos se envían o hasta que expire el tiempo de espera especificado. Si establece <xref:System.Net.Sockets.SocketOptionName.DontLinger> a `false` y especifique un intervalo de cero tiempo de espera, <xref:System.Net.Sockets.Socket.Close%2A> libera la conexión y descarta automáticamente los datos en cola de salida.  
  
> [!NOTE]
>  Para establecer el <xref:System.Net.Sockets.SocketOptionName.DontLinger> opción de socket `false`, cree un <xref:System.Net.Sockets.LingerOption>, establezca la propiedad habilitada en `true`y establezca el <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propiedad para el período de tiempo de espera deseado. Use esta <xref:System.Net.Sockets.LingerOption> junto con el <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket opción para llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente código en el ejemplo se cierra un <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout">Espere hasta <paramref name="timeout" /> segundos para enviar los datos restantes y, después, cierre el socket.</param>
        <summary>Cierra la conexión <see cref="T:System.Net.Sockets.Socket" /> y libera todos los recursos asociados con un tiempo de espera especificado para permitir el envío de los datos en cola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.Close%2A> método cierra la conexión del host remoto y las versiones todos los recursos administrados y asociados con el <xref:System.Net.Sockets.Socket>. Al cerrarse, el <xref:System.Net.Sockets.Socket.Connected%2A> propiedad está establecida en `false`.  
  
 Para protocolos orientados a conexiones, se recomienda que llame <xref:System.Net.Sockets.Socket.Shutdown%2A> antes de llamar a <xref:System.Net.Sockets.Socket.Close%2A>. Esto garantiza que todos los datos se envía y recibe en el socket conectado antes de cerrarse.  
  
 Si necesita llamar a <xref:System.Net.Sockets.Socket.Close%2A> sin llamar primero a <xref:System.Net.Sockets.Socket.Shutdown%2A>, puede asegurarse de que los datos en cola para transmisión de salida que se enviará al establecer el <xref:System.Net.Sockets.SocketOptionName.DontLinger> opción `false` y especificando un intervalo de tiempo de espera distinto de cero. <xref:System.Net.Sockets.Socket.Close%2A> a continuación, se bloqueará hasta que estos datos se envían o hasta que expire el tiempo de espera especificado. Si establece <xref:System.Net.Sockets.SocketOptionName.DontLinger> a `false` y especifique un intervalo de cero tiempo de espera, <xref:System.Net.Sockets.Socket.Close%2A> libera la conexión y descarta automáticamente los datos en cola de salida.  
  
> [!NOTE]
>  Para establecer el <xref:System.Net.Sockets.SocketOptionName.DontLinger> opción de socket `false`, cree un <xref:System.Net.Sockets.LingerOption>, establezca la propiedad habilitada en `true`y establezca el <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propiedad en el tiempo de espera. Use esta <xref:System.Net.Sockets.LingerOption> junto con el <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket opción para llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo cerrar una <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece una conexión a un host remoto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> que representa el dispositivo remoto.</param>
        <summary>Establece una conexión a un host remoto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si usa un protocolo orientado a conexiones como TCP, el <xref:System.Net.Sockets.Socket.Connect%2A> método sincrónicamente establece una conexión de red entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> y el extremo remoto especificado. Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.Connect%2A> establece un host remoto predeterminado. Después de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>, puede enviar datos al dispositivo remoto con el <xref:System.Net.Sockets.Socket.Send%2A> método, o recibir datos desde el dispositivo remoto con el <xref:System.Net.Sockets.Socket.Receive%2A> método.  
  
 Si usa un protocolo sin conexión, como UDP, no es necesario llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar y recibir datos. Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> y <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> comunicarse de forma sincrónica con un host remoto. Si se llama <xref:System.Net.Sockets.Socket.Connect%2A>, se descartarán todos los datagramas que llegan desde una dirección que no sea el valor predeterminado especificado. Si desea establecer el host remoto predeterminado para una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
 El <xref:System.Net.Sockets.Socket.Connect%2A> método se bloqueará, a menos que se establezcan específicamente el <xref:System.Net.Sockets.Socket.Blocking%2A> propiedad `false` antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>. Si usa un protocolo orientado a conexiones como TCP y deshabilita el bloqueo, <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException> ya que necesita tiempo para realizar la conexión. Los protocolos sin conexión no inician una excepción porque sólo establecen un host remoto predeterminado. Puede usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error. Si el error devuelve WSAEWOULDBLOCK, la conexión del host remoto haya sido iniciada por un orientado a conexión <xref:System.Net.Sockets.Socket>, pero aún no ha completado correctamente. Use la <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar cuándo la <xref:System.Net.Sockets.Socket> finalice conectarse.  
  
> [!NOTE]
>  Si utiliza un protocolo orientado a conexiones y no se llamó a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>, el proveedor de servicios subyacente asignará el número de puerto y dirección de red local. Si usa un protocolo sin conexión, el proveedor de servicios no asignará a un número de puerto y la dirección de red local hasta que complete un envío o recepción de la operación. Si desea cambiar el host remoto predeterminado, llame a <xref:System.Net.Sockets.Socket.Connect%2A> nuevo con el punto de conexión deseado.  
  
> [!NOTE]
>  Si el socket se ha desconectado previamente, no se puede usar este método para restaurar la conexión. Utilice uno de los asincrónicos <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para volver a conectar. Esta es una limitación del proveedor subyacente.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código se conecta a un punto de conexión remota y, a continuación, comprueba la conexión.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
        <permission cref="T:System.Net.SocketPermission">para conectarse al host remoto. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Dirección IP del host remoto.</param>
        <param name="port">Número de puerto del host remoto.</param>
        <summary>Establece una conexión a un host remoto. El host se especifica mediante una dirección IP y un número de puerto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si usa un protocolo orientado a conexiones como TCP, el <xref:System.Net.Sockets.Socket.Connect%2A> método sincrónicamente establece una conexión de red entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> y el extremo remoto especificado. Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.Connect%2A> establece un host remoto predeterminado. Después de llamar a <xref:System.Net.Sockets.Socket.Connect%2A> puede enviar datos al dispositivo remoto con el <xref:System.Net.Sockets.Socket.Send%2A> método, o recibir datos desde el dispositivo remoto con el <xref:System.Net.Sockets.Socket.Receive%2A> método.  
  
 Si usa un protocolo sin conexión, como UDP, no es necesario llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar y recibir datos. Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> y <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> comunicarse de forma sincrónica con un host remoto. Si se llama <xref:System.Net.Sockets.Socket.Connect%2A> se descartarán todos los datagramas que llegan desde una dirección que no sea el valor predeterminado especificado. Si desea establecer el host remoto predeterminado para una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> método se bloqueará, a menos que se establezcan específicamente el <xref:System.Net.Sockets.Socket.Blocking%2A> propiedad `false` antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>. Si usa un protocolo orientado a conexiones como TCP y deshabilita el bloqueo, <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException> ya que necesita tiempo para realizar la conexión. Los protocolos sin conexión no inician una excepción porque sólo establecen un host remoto predeterminado. Puede usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error. Si el error devuelve WSAEWOULDBLOCK, la conexión del host remoto haya sido iniciada por un orientado a conexión <xref:System.Net.Sockets.Socket>, pero aún no ha completado correctamente. Use la <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar cuándo la <xref:System.Net.Sockets.Socket> finalice conectarse.  
  
> [!NOTE]
>  Si utiliza un protocolo orientado a conexiones y no se llamó a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>, el proveedor de servicios subyacente asignará el número de puerto y dirección de red local. Si usa un protocolo sin conexión, el proveedor de servicios no asignará a un número de puerto y la dirección de red local hasta que complete un envío o recepción de la operación. Si desea cambiar el host remoto predeterminado, llame a <xref:System.Net.Sockets.Socket.Connect%2A> nuevo con el punto de conexión deseado.  
  
> [!NOTE]
>  Si el socket se ha desconectado previamente, no se puede usar este método para restaurar la conexión. Utilice uno de los asincrónicos <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para volver a conectar. Esta es una limitación del proveedor subyacente.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código se conecta a un punto de conexión remota y, a continuación, comprueba la conexión.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de puerto no es válido.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.NotSupportedException">Este método es válido para sockets de las familias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="address" /> es cero.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses">Direcciones IP del host remoto.</param>
        <param name="port">Número de puerto del host remoto.</param>
        <summary>Establece una conexión a un host remoto. El host se especifica mediante una matriz de direcciones IP y un número de puerto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza normalmente inmediatamente después de llamar a <xref:System.Net.Dns.GetHostAddresses%2A>, que puede devolver varias direcciones IP para un solo host. Si usa un protocolo orientado a conexiones como TCP, el <xref:System.Net.Sockets.Socket.Connect%2A> método sincrónicamente establece una conexión de red entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> y el extremo remoto especificado. Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.Connect%2A> establece un host remoto predeterminado. Después de llamar a <xref:System.Net.Sockets.Socket.Connect%2A> puede enviar datos al dispositivo remoto con el <xref:System.Net.Sockets.Socket.Send%2A> método, o recibir datos desde el dispositivo remoto con el <xref:System.Net.Sockets.Socket.Receive%2A> método.  
  
 Si usa un protocolo sin conexión, como UDP, no es necesario llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar y recibir datos. Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> y <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> comunicarse de forma sincrónica con un host remoto. Si se llama <xref:System.Net.Sockets.Socket.Connect%2A> se descartarán todos los datagramas que llegan desde una dirección que no sea el valor predeterminado especificado. Si desea establecer el host remoto predeterminado para una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> método se bloqueará, a menos que se establezcan específicamente el <xref:System.Net.Sockets.Socket.Blocking%2A> propiedad `false` antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>. Si usa un protocolo orientado a conexiones como TCP y deshabilita el bloqueo, <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException> ya que necesita tiempo para realizar la conexión. Los protocolos sin conexión no inician una excepción porque sólo establecen un host remoto predeterminado. Puede usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error. Si el error devuelve WSAEWOULDBLOCK, la conexión del host remoto haya sido iniciada por un orientado a conexión <xref:System.Net.Sockets.Socket>, pero aún no ha completado correctamente. Use la <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar cuándo la <xref:System.Net.Sockets.Socket> finalice conectarse.  
  
> [!NOTE]
>  Si utiliza un protocolo orientado a conexiones y no se llamó a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>, el proveedor de servicios subyacente asignará el número de puerto y dirección de red local. Si usa un protocolo sin conexión, el proveedor de servicios no asignará a un número de puerto y la dirección de red local hasta que complete un envío o recepción de la operación. Si desea cambiar el host remoto predeterminado, llame a <xref:System.Net.Sockets.Socket.Connect%2A> nuevo con el punto de conexión deseado.  
  
> [!NOTE]
>  Si el socket se ha desconectado previamente, no se puede usar este método para restaurar la conexión. Utilice uno de los asincrónicos <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para volver a conectar. Esta es una limitación del proveedor subyacente.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código se conecta a un punto de conexión remota y, a continuación, comprueba la conexión.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de puerto no es válido.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.NotSupportedException">Este método es válido para sockets de las familias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="address" /> es cero.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host">Nombre del host remoto.</param>
        <param name="port">Número de puerto del host remoto.</param>
        <summary>Establece una conexión a un host remoto. El host se especifica mediante un nombre de host y un número de puerto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si usa un protocolo orientado a conexiones como TCP, el <xref:System.Net.Sockets.Socket.Connect%2A> método sincrónicamente establece una conexión de red entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> y el host remoto especificado. Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.Connect%2A> establece un host remoto predeterminado. Después de llamar a <xref:System.Net.Sockets.Socket.Connect%2A> puede enviar datos al dispositivo remoto con el <xref:System.Net.Sockets.Socket.Send%2A> método, o recibir datos desde el dispositivo remoto con el <xref:System.Net.Sockets.Socket.Receive%2A> método.  
  
 Si usa un protocolo sin conexión, como UDP, no es necesario llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar y recibir datos. Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> y <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> comunicarse de forma sincrónica con un host remoto. Si se llama <xref:System.Net.Sockets.Socket.Connect%2A> se descartarán todos los datagramas que llegan desde una dirección que no sea el valor predeterminado especificado. Si desea establecer el host remoto predeterminado para una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, o <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> método se bloqueará, a menos que se establezcan específicamente el <xref:System.Net.Sockets.Socket.Blocking%2A> propiedad `false` antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>. Si usa un protocolo orientado a conexiones como TCP y deshabilita el bloqueo, <xref:System.Net.Sockets.Socket.Connect%2A> producirá un <xref:System.Net.Sockets.SocketException> ya que necesita tiempo para realizar la conexión. Los protocolos sin conexión no inician una excepción porque sólo establecen un host remoto predeterminado. Puede usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error. Si el error devuelve WSAEWOULDBLOCK, la conexión del host remoto haya sido iniciada por un orientado a conexión <xref:System.Net.Sockets.Socket>, pero aún no ha completado correctamente. Use la <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar cuándo la <xref:System.Net.Sockets.Socket> finalice conectarse.  
  
 Si IPv6 está habilitado y el <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> método se llama para conectarse a un host que se resuelve en ambos IPv6 y direcciones IPv4, la conexión a la dirección será de IPv6 intenta primero antes de la dirección IPv4. Esto puede tener el efecto de retrasar el tiempo para establecer la conexión si el host no está escuchando en la dirección IPv6.  
  
> [!NOTE]
>  Si utiliza un protocolo orientado a conexiones y no se llamó a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar a <xref:System.Net.Sockets.Socket.Connect%2A>, el proveedor de servicios subyacente asignará el número de puerto y dirección de red local. Si usa un protocolo sin conexión, el proveedor de servicios no asignará a un número de puerto y la dirección de red local hasta que complete un envío o recepción de la operación. Si desea cambiar el host remoto predeterminado, llame a <xref:System.Net.Sockets.Socket.Connect%2A> nuevo con el punto de conexión deseado.  
  
> [!NOTE]
>  Si el socket se ha desconectado previamente, no se puede usar este método para restaurar la conexión. Utilice uno de los asincrónicos <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para volver a conectar. Esta es una limitación del proveedor subyacente.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código se conecta a un punto de conexión remota y, a continuación, comprueba la conexión.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de puerto no es válido.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.NotSupportedException">Este método es válido para sockets de las familias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> se ha colocado en un estado de escucha mediante una llamada a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza una solicitud asincrónica para una conexión a host remoto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</param>
        <summary>Comienza una solicitud asincrónica para una conexión a host remoto.</summary>
        <returns>Devuelve <see langword="true" /> si la operación de E/S está pendiente. Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.  
  
 Devuelve <see langword="false" /> si la operación de E/S se ha completado de forma sincrónica. En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si usa un protocolo orientado a conexiones, el <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método inicia una solicitud asincrónica para una conexión al host remoto. Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establece un host remoto predeterminado.  
  
 Para recibir una notificación de finalización, debe crear un método de devolución de llamada que implementa el delegado EventHandler\<SocketAsyncEventArgs > delegar y adjuntar la devolución de llamada la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> eventos.  
  
 El llamador debe establecer el <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propiedad a la <xref:System.Net.IPEndPoint> del host remoto al que conectarse.  
  
 El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada. Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.  
  
 Si usa un protocolo sin conexión, como UDP, no es necesario llamar a <xref:System.Net.Sockets.Socket.ConnectAsync%2A> antes de enviar y recibir datos. Puede usar <xref:System.Net.Sockets.Socket.SendToAsync%2A> y <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> para comunicarse con un host remoto. Si se llama <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, se descartarán todos los datagramas que llegan desde una dirección que no sea el valor predeterminado especificado. Si desea cambiar el host remoto predeterminado, llame a la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método nuevo con el punto de conexión deseado.  
  
 Si desea establecer el host remoto predeterminado para una dirección de difusión, primero debe llamar a <xref:System.Net.Sockets.Socket.SetSocketOption%2A> y establezca la difusión en `true`. Si no se hace esto, el <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método producirá una <xref:System.Net.Sockets.SocketException>.  
  
 Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Opcionalmente, se puede proporcionar un búfer que se enviarán automáticamente en el socket después de la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método se ejecuta correctamente. En este caso, el <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propiedad debe establecerse en el búfer que contiene los datos para enviar y <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propiedad debe establecerse en el número de bytes de datos para enviar desde el búfer. Una vez establecida una conexión, se envía este búfer de datos.  
  
 Si utiliza un protocolo orientado a conexiones y no llame a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar a <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, el proveedor de servicios subyacente asignará el número de puerto y la dirección de red local más adecuado.  
  
 Si usa un protocolo sin conexión, el proveedor de servicios no asignará un número de puerto y la dirección IP de red local hasta que llame a la <xref:System.Net.Sockets.Socket.SendAsync%2A> o <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> métodos.  
  
 El <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método inicie una excepción <xref:System.NotSupportedException> si la familia de direcciones de la <xref:System.Net.Sockets.Socket> y <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> no son la misma familia de direcciones.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException> al llamar a este método, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un argumento no es válido. Esta excepción también se produce si se especifican varios búferes; es decir, si la propiedad <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> no es null.</exception>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="e" /> y <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no puede ser null.</exception>
        <exception cref="T:System.InvalidOperationException">El objeto <see cref="T:System.Net.Sockets.Socket" /> está escuchando o ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.NotSupportedException">Se requiere Windows XP o posteriores para este método. Esta excepción también se produce si el extremo local y <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no son la misma familia de direcciones.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType">Uno de los valores de <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Uno de los valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <param name="e">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</param>
        <summary>Comienza una solicitud asincrónica para una conexión a host remoto.</summary>
        <returns>Devuelve <see langword="true" /> si la operación de E/S está pendiente. Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.  
  
 Devuelve <see langword="false" /> si la operación de E/S se ha completado de forma sincrónica. En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si utiliza un protocolo orientado a conexiones, el método System.NET.Sockets.ProtocolType inicia una solicitud asincrónica de un conexión al host remoto. Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establece un host remoto predeterminado especificado por el `socketType` y `protocolType` parámetros.  
  
 Para recibir una notificación de finalización, debe crear un método de devolución de llamada que implementa el delegado EventHandler\<SocketAsyncEventArgs > delegar y adjuntar la devolución de llamada la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> eventos.  
  
 El llamador debe establecer el <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propiedad a la <xref:System.Net.IPEndPoint> del host remoto al que conectarse.  
  
 El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada. Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.  
  
 Si usa un protocolo sin conexión, como UDP, no es necesario llamar a <xref:System.Net.Sockets.Socket.ConnectAsync%2A> antes de enviar y recibir datos. Puede usar <xref:System.Net.Sockets.Socket.SendToAsync%2A> y <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> para comunicarse con un host remoto. Si se llama <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, se descartarán todos los datagramas que llegan desde una dirección que no sea el valor predeterminado especificado. Si desea cambiar el host remoto predeterminado, llame a la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método nuevo con el punto de conexión deseado.  
  
 Si desea establecer el host remoto predeterminado para una dirección de difusión, primero debe llamar a <xref:System.Net.Sockets.Socket.SetSocketOption%2A> y establezca la difusión en `true`. Si no se hace esto, el <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método producirá una <xref:System.Net.Sockets.SocketException>.  
  
 Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Opcionalmente, se puede proporcionar un búfer que se enviarán automáticamente en el socket después de la <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método se ejecuta correctamente. En este caso, el <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propiedad debe establecerse en el búfer que contiene los datos para enviar y <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propiedad debe establecerse en el número de bytes de datos para enviar desde el búfer. Una vez establecida una conexión, se envía este búfer de datos.  
  
 Si utiliza un protocolo orientado a conexiones y no llame a <xref:System.Net.Sockets.Socket.Bind%2A> antes de llamar a <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, el proveedor de servicios subyacente asignará el número de puerto y la dirección de red local más adecuado.  
  
 Si usa un protocolo sin conexión, el proveedor de servicios no asignará un número de puerto y la dirección IP de red local hasta que llame a la <xref:System.Net.Sockets.Socket.SendAsync%2A> o <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> métodos.  
  
 El <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método inicie una excepción <xref:System.NotSupportedException> si la familia de direcciones de la <xref:System.Net.Sockets.Socket> y <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> no son la misma familia de direcciones.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException> al llamar a este método, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un argumento no es válido. Esta excepción también se produce si se especifican varios búferes; es decir, si la propiedad <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> no es null.</exception>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="e" /> y <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no puede ser null.</exception>
        <exception cref="T:System.InvalidOperationException">El objeto <see cref="T:System.Net.Sockets.Socket" /> está escuchando o ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.NotSupportedException">Se requiere Windows XP o posteriores para este método. Esta excepción también se produce si el extremo local y <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no son la misma familia de direcciones.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Net.Sockets.Socket" /> se conecta con un host remoto a partir de la última operación <see cref="Overload:System.Net.Sockets.Socket.Send" /> u <see cref="Overload:System.Net.Sockets.Socket.Receive" />.</summary>
        <value>Es <see langword="true" /> si el objeto <see cref="T:System.Net.Sockets.Socket" /> estaba conectado a un recurso remoto desde la operación más reciente; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Connected` propiedad obtiene el estado de conexión de la <xref:System.Net.Sockets.Socket> a partir de la última operación de E/S. Cuando devuelve `false`, el <xref:System.Net.Sockets.Socket> nunca se conectó o ya no está conectado.  
  
 El valor de la <xref:System.Net.Sockets.Socket.Connected%2A> propiedad refleja el estado de la conexión a partir de la operación más reciente. Si necesita determinar el estado actual de la conexión, llamar a un envío de no bloqueo, cero bytes. Si la llamada se devuelve correctamente o produce un código de error WAEWOULDBLOCK (10035), el socket aún está conectado; en caso contrario, el socket ya no está conectado.  
  
 Si se llama a <xref:System.Net.Sockets.Socket.Connect%2A> en un socket de protocolo de datagramas de usuario (UDP), el <xref:System.Net.Sockets.Socket.Connected%2A> propiedad siempre devuelve `true`; sin embargo, esta acción no cambia la naturaleza sin conexión inherente de UDP.  
  
   
  
## Examples  
 El siguiente ejemplo de código se conecta a un punto de conexión remota, comprueba la <xref:System.Net.Sockets.Socket.Connected%2A> propiedad y comprueba el estado actual de la conexión.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><see langword="true" /> si se puede reutilizar el socket una vez cerrada la conexión actual; de lo contrario, <see langword="false" />.</param>
        <summary>Cierra la conexión del socket y permite reutilizarlo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si utiliza un protocolo orientado a conexiones, puede usar este método para cerrar el socket. Este método de extremos la conexión y establece el <xref:System.Net.Sockets.Socket.Connected%2A> propiedad `false`. Sin embargo, si `reuseSocket` es `true`, se puede reutilizar el socket.  
  
 Para asegurarse de que todos los datos se envía y recibe antes de cerrar el socket, debe llamar a <xref:System.Net.Sockets.Socket.Shutdown%2A> antes de llamar a la <xref:System.Net.Sockets.Socket.Disconnect%2A> método.  
  
 Si necesita llamar a <xref:System.Net.Sockets.Socket.Disconnect%2A> sin llamar primero a <xref:System.Net.Sockets.Socket.Shutdown%2A>, puede establecer el <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opción `false` y especifique un intervalo de tiempo de espera distinto de cero para asegurarse de que los datos en cola de transmisión de salida se envía. <xref:System.Net.Sockets.Socket.Disconnect%2A> a continuación, se bloquea hasta que los datos se envían o hasta que expire el tiempo de espera especificado. Si establece <xref:System.Net.Sockets.SocketOptionName.DontLinger> a `false` y especifique un intervalo de cero tiempo de espera, <xref:System.Net.Sockets.Socket.Close%2A> libera la conexión y descarta automáticamente los datos en cola de salida.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un socket para la comunicación sincrónica y se envía algunos datos a un host remoto. A continuación, llama <xref:System.Net.Sockets.Socket.Shutdown%2A>para detener el envío y recepción de actividad, y <xref:System.Net.Sockets.Socket.Disconnect%2A>para cerrar la conexión de socket.  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Este método requiere Windows 2000 o anterior, o se iniciará la excepción.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</param>
        <summary>Comienza una solicitud asincrónica para la desconexión de un extremo remoto.</summary>
        <returns>Devuelve <see langword="true" /> si la operación de E/S está pendiente. Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.  
  
 Devuelve <see langword="false" /> si la operación de E/S se ha completado de forma sincrónica. En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se usa un protocolo orientado a conexiones, una llamada a la <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> método solicita una desconexión de un extremo remoto. Si establece <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> a `true` en el `e` parámetro, se puede reutilizar el socket.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="e" /> no puede ser null.</exception>
        <exception cref="T:System.InvalidOperationException">Ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Se requiere Windows XP o posteriores para este método.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a `Dispose` cuando haya terminado de usar <xref:System.Net.Sockets.Socket>. El método `Dispose` deja el <xref:System.Net.Sockets.Socket> en un estado no utilizable. Después de llamar a `Dispose`, debe liberar todas las referencias a la <xref:System.Net.Sockets.Socket> por lo que el recolector de elementos no utilizados pueda reclamar la memoria que el <xref:System.Net.Sockets.Socket> estaba ocupando.  
  
 Para obtener más información, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Realice siempre una llamada a `Dispose` antes de liberar la última referencia al objeto <xref:System.Net.Sockets.Socket>. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.Net.Sockets.Socket> del objeto `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar los recursos administrados y no administrados; es <see langword="false" /> para liberar sólo los recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.Net.Sockets.Socket" /> y, de forma opcional, desecha los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama por el público `Dispose()` método y el <xref:System.Object.Finalize%2A> método. `Dispose()` invoca el protegido `Dispose(Boolean)` método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` con `disposing` establecido en `false`.  
  
 Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.Net.Sockets.Socket> hace referencia. Este método invoca al método `Dispose()` de cada uno de los objetos a los que se hace referencia.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> puede recibir varias llamadas de otros objetos. Al invalidar <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />. Para obtener más información sobre cómo implementar <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obtener más información acerca de <see langword="Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [reemplazar el método Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor de <see cref="T:System.Boolean" /> que especifica si <see cref="T:System.Net.Sockets.Socket" /> permite fragmentar los datagramas de protocolo Internet (IP).</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> permite la fragmentación de datagramas; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Necesario fragmentar los datagramas cuando su tamaño supera la unidad de transmisión máxima (MTU) del medio de transmisión. Pueden fragmentar los datagramas por el host de envío (todas las versiones de protocolo de Internet) o un enrutador intermedio (Protocolo de Internet versión 4 solo). Si un datagrama debe fragmentarse y el <xref:System.Net.Sockets.Socket.DontFragment%2A> opción está establecida, se descarta el datagrama y se envía un mensaje de error de protocolo de mensajes de Control de Internet (ICMP) al remitente del datagrama.  
  
 Establecer esta propiedad en un socket de protocolo de Control de transmisión (TCP) no tendrá ningún efecto.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.DontFragment%2A> propiedad.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Esta propiedad sólo se puede establecer para sockets de las familias de <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor <see cref="T:System.Boolean" /> que especifica si <see cref="T:System.Net.Sockets.Socket" /> es un socket de modo dual que se usa tanto para IPv4 como para IPv6.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> es un socket de modo dual; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">Identificador del proceso de destino donde se crea un duplicado de la referencia del socket.</param>
        <summary>Duplica la referencia del socket para el proceso de destino y cierra el socket para este proceso.</summary>
        <returns>Referencia del socket que se va a pasar al proceso de destino.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El proceso de destino debe utilizar <xref:System.Net.Sockets.Socket.%23ctor%2A> para crear la instancia de socket duplicado.  
  
 Si se llama a la <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor varias veces con la misma matriz de bytes que el argumento para cada llamada, creará varios administrados <xref:System.Net.Sockets.Socket> instancias con el mismo socket subyacente. Esta práctica es recomendable.  
  
 Si el proceso de crear el socket usa los métodos asincrónicos (<xref:System.Net.Sockets.Socket.BeginReceive%2A> o <xref:System.Net.Sockets.Socket.BeginSend%2A>), primero debe establecer el proceso de la <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> propiedad en true; de lo contrario, se enlaza el socket para el puerto de terminación del proceso de creación, lo cual puede provocar un <xref:System.ArgumentNullException> que se produzca en el proceso de destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="targetProcessID" /> no es un identificador de proceso válido. 
O bien 
Se produjo un error al duplicar la referencia del socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor de <see cref="T:System.Boolean" /> que especifica si <see cref="T:System.Net.Sockets.Socket" /> puede enviar o recibir paquetes de difusión.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> permite la difusión de paquetes; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Difusión se limita a una subred específica y debe usar el protocolo de datagramas de usuario (UDP). Protocolo de Internet versión 4, puede difundir a la subred local enviando un paquete a 255.255.255.255; o bien, puede usar la dirección de difusión dirigida, que es la parte de la red de una dirección de protocolo de Internet (IP) con todos los bits establecidos en la parte del host. Por ejemplo, si su dirección IP es 192.168.1.40 (una dirección de clase C, con una máscara de red de 255.255.255.0, la parte de la red es los tres primeros octetos y la parte del host es el último octeto), es de su dirección de difusión dirigida 192.168.1.255.  
  
 Establecer esta propiedad en un socket de protocolo de Control de transmisión (TCP) no tendrá ningún efecto.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> propiedad.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Esta opción sólo es válida para un socket de datagramas.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acepta de forma asincrónica un intento de conexión entrante.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que contiene los bytes transferidos.</param>
        <param name="asyncResult">Objeto <see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica así como cualquier dato definido por el usuario.</param>
        <summary>Acepta de forma asincrónica un intento de conexión entrante y crea un objeto <see cref="T:System.Net.Sockets.Socket" /> nuevo para controlar la comunicación con el host remoto. Este método devuelve un búfer que contiene los datos iniciales transferidos.</summary>
        <returns>Objeto <see cref="T:System.Net.Sockets.Socket" /> para controlar la comunicación con el host remoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> finaliza una llamada a <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Antes de llamar a <xref:System.Net.Sockets.Socket.BeginAccept%2A>, deberá crear un método de devolución de llamada invocada por el <xref:System.AsyncCallback> delegar. Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de la <xref:System.Net.Sockets.Socket.BeginAccept%2A> devuelve del método.  
  
 Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la `asyncResult` parámetro para obtener el <xref:System.Net.Sockets.Socket> en que se está realizando el intento de conexión. Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndAccept%2A> método para completar correctamente el intento de conexión. El `buffer` parámetro de esta sobrecarga contiene los datos que se reciben en la llamada a <xref:System.Net.Sockets.Socket.BeginAccept%2A> y `bytesTransferred` parámetro contiene el número de bytes transferidos en la llamada.  
  
 El <xref:System.Net.Sockets.Socket.EndAccept%2A> método se bloquea hasta que una conexión está pendiente en la cola de conexión entrantes. El <xref:System.Net.Sockets.Socket.EndAccept%2A> método acepta la conexión entrante y devuelve un nuevo <xref:System.Net.Sockets.Socket> que puede utilizarse para enviar y recibir datos desde el host remoto.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Net.Sockets.Socket.BeginAccept%2A> para crear y conectar un socket y aceptan los 10 bytes iniciales de datos. Las llamadas de delegado de la devolución de llamada <xref:System.Net.Sockets.Socket.EndAccept%2A> para finalizar la solicitud asincrónica. El número de bytes transmitidos y los datos se devuelven en el `buffer` y `bytesTransferred` parámetros de este método y se muestran en la consola.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Se requiere Windows NT para este método.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> está vacía.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="asyncResult" /> no se creó mediante una llamada a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó anteriormente al método <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder a <see cref="T:System.Net.Sockets.Socket" /></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica así como cualquier dato definido por el usuario.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica así como cualquier dato definido por el usuario.</param>
        <summary>Acepta asincrónicamente un intento de conexión entrante y crea un nuevo objeto <see cref="T:System.Net.Sockets.Socket" /> para controlar la comunicación con el host remoto.</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> para controlar la comunicación con el host remoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> finaliza una llamada a <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Antes de llamar a <xref:System.Net.Sockets.Socket.BeginAccept%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar. Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de la <xref:System.Net.Sockets.Socket.BeginAccept%2A> devuelve del método. Debe aceptar el `asyncResult` parámetro devuelto desde el <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.  
  
 Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la `asyncResult` parámetro para obtener el <xref:System.Net.Sockets.Socket> en que se está realizando el intento de conexión. Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndAccept%2A> método para completar correctamente el intento de conexión.  
  
 El <xref:System.Net.Sockets.Socket.EndAccept%2A> método se bloquea hasta que una conexión está pendiente en la cola de conexión entrantes. El <xref:System.Net.Sockets.Socket.EndAccept%2A> método acepta la conexión entrante y devuelve un nuevo <xref:System.Net.Sockets.Socket> que puede utilizarse para enviar y recibir datos desde el host remoto.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el siguiente ejemplo se finaliza una solicitud asincrónica y crea un nuevo <xref:System.Net.Sockets.Socket> para aceptar una solicitud de conexión entrante. Para obtener un ejemplo completo que muestra las comunicaciones asincrónicas con sockets, vea [ejemplos de código de Socket](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="asyncResult" /> no se creó mediante una llamada a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket. Vea la sección Comentarios para obtener más información.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó anteriormente al método <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</exception>
        <exception cref="T:System.NotSupportedException">Se requiere Windows NT para este método.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que contiene los bytes transferidos.</param>
        <param name="bytesTransferred">Número de bytes transferidos.</param>
        <param name="asyncResult">Objeto <see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica así como cualquier dato definido por el usuario.</param>
        <summary>Acepta de forma asincrónica un intento de conexión entrante y crea un objeto <see cref="T:System.Net.Sockets.Socket" /> nuevo para controlar la comunicación con el host remoto. Este método devuelve un búfer que contiene los datos iniciales y el número de bytes transferidos.</summary>
        <returns>Objeto <see cref="T:System.Net.Sockets.Socket" /> para controlar la comunicación con el host remoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> finaliza una llamada a <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Antes de llamar a <xref:System.Net.Sockets.Socket.BeginAccept%2A>, deberá crear un método de devolución de llamada invocada por el <xref:System.AsyncCallback> delegar. Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de la <xref:System.Net.Sockets.Socket.BeginAccept%2A> devuelve del método. Debe aceptar el `asyncResult` parámetro devuelto desde el <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.  
  
 Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la `asyncResult` parámetro para obtener el <xref:System.Net.Sockets.Socket> en que se está realizando el intento de conexión. Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndAccept%2A> método para completar correctamente el intento de conexión. El `buffer` parámetro de esta sobrecarga contiene los datos que se reciben en la llamada a <xref:System.Net.Sockets.Socket.BeginAccept%2A> y `bytesTransferred` parámetro contiene el número de bytes transferidos en la llamada.  
  
 El <xref:System.Net.Sockets.Socket.EndAccept%2A> método se bloquea hasta que una conexión está pendiente en la cola de conexión entrantes. El <xref:System.Net.Sockets.Socket.EndAccept%2A> método acepta la conexión entrante y devuelve un nuevo <xref:System.Net.Sockets.Socket> que puede utilizarse para enviar y recibir datos desde el host remoto.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Net.Sockets.Socket.BeginAccept%2A> para crear y conectar un socket y aceptan los 10 bytes iniciales de datos. Las llamadas de delegado de la devolución de llamada <xref:System.Net.Sockets.Socket.EndAccept%2A> para finalizar la solicitud asincrónica. El número de bytes transmitidos y los datos se devuelven en el `buffer` y `bytesTransferred` parámetros de este método y se muestran en la consola.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Se requiere Windows NT para este método.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> está vacía.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="asyncResult" /> no se creó mediante una llamada a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó anteriormente al método <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar obtener acceso a <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</param>
        <summary>Finaliza una solicitud de conexión asincrónica pendiente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> se inicia un método de bloqueo que se completa la solicitud de conexión asincrónica host remoto en el <xref:System.Net.Sockets.Socket.BeginConnect%2A> método.  
  
 Antes de llamar a <xref:System.Net.Sockets.Socket.BeginConnect%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar. Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginConnect%2A> devuelve. El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> devuelto por la <xref:System.Net.Sockets.Socket.BeginConnect%2A> método como parámetro.  
  
 Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> parámetro para obtener el <xref:System.Net.Sockets.Socket> en que se está realizando el intento de conexión. Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndConnect%2A> método para completar correctamente el intento de conexión.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código finaliza el intento de conexión asincrónica. Para obtener un ejemplo completo que muestra las comunicaciones asincrónicas con sockets, vea [ejemplos de código de Socket](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> fue llamado previamente para la conexión asincrónica.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Objeto <see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</param>
        <summary>Finaliza una solicitud de desconexión asincrónica pendiente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> finaliza una llamada a <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. El <xref:System.Net.Sockets.Socket.EndDisconnect%2A> método se bloquea hasta que se complete la desconexión. Para obtener información acerca de las operaciones asincrónicas, vea el tema de información general de programación asincrónica en MSDN library.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un socket para la comunicación asincrónica y envía datos a un host remoto. Cuando los datos se ha enviado, <xref:System.Net.Sockets.Socket.Shutdown%2A> se llama para detener el envío y recepción de actividad. A continuación, <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> se llama para iniciar una solicitud de desconexión. Las llamadas de delegado de la devolución de llamada <xref:System.Net.Sockets.Socket.EndDisconnect%2A> para finalizar la solicitud asincrónica. Cuando se completa la solicitud, el <xref:System.Net.Sockets.Socket.Connected%2A> es consultar la propiedad para comprobar si el socket está desconectado.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El sistema operativo es Windows 2000 o una versión anterior, y este método requiere Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> fue llamado previamente para la conexión asincrónica.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.Net.WebException">La petición de desconexión ha agotado su tiempo de espera.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Finaliza una lectura asincrónica pendiente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</param>
        <summary>Finaliza una lectura asincrónica pendiente.</summary>
        <returns>Número de bytes recibidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.EndReceive%2A> método completa la operación de lectura asincrónica iniciada el <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.  
  
 Antes de llamar a <xref:System.Net.Sockets.Socket.BeginReceive%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar. Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginReceive%2A> devuelve. El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> devuelto por la <xref:System.Net.Sockets.Socket.BeginReceive%2A> método como parámetro.  
  
 Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> para obtener el objeto de estado pasado a la <xref:System.Net.Sockets.Socket.BeginReceive%2A> método. Extraer la recepción <xref:System.Net.Sockets.Socket> de este objeto de estado. Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndReceive%2A> método para completar la operación de lectura y devolver el número de bytes leídos correctamente.  
  
 El <xref:System.Net.Sockets.Socket.EndReceive%2A> método se bloqueará hasta que haya datos disponibles. Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.EndReceive%2A> leerá el primer datagrama en cola disponible en el búfer de red entrante. Si usa un protocolo orientado a conexiones, el <xref:System.Net.Sockets.Socket.EndReceive%2A> método leerá tantos datos como está disponible hasta el número de bytes especificado por el `size` parámetro de la <xref:System.Net.Sockets.Socket.BeginReceive%2A> método. Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.EndReceive%2A> método finalizará inmediatamente y devolverá cero bytes.  
  
 Para obtener los datos recibidos, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult>y extraiga el búfer que contiene el objeto de estado resultante.  
  
 Para cancelar una pendiente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, llame a la <xref:System.Net.Sockets.Socket.Close%2A> método.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina. Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el siguiente ejemplo se finaliza una lectura asincrónica pendiente. Para obtener un ejemplo completo que muestra las comunicaciones asincrónicas con sockets, vea [ejemplos de código de Socket](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó previamente a <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> para la lectura asincrónica.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</param>
        <param name="errorCode">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</param>
        <summary>Finaliza una lectura asincrónica pendiente.</summary>
        <returns>Número de bytes recibidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.EndReceive%2A> método completa la operación de lectura asincrónica iniciada el <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.  
  
 Antes de llamar a <xref:System.Net.Sockets.Socket.BeginReceive%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar. Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginReceive%2A> devuelve. El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> devuelto por la <xref:System.Net.Sockets.Socket.BeginReceive%2A> método como parámetro.  
  
 Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> para obtener el objeto de estado pasado a la <xref:System.Net.Sockets.Socket.BeginReceive%2A> método. Extraer la recepción <xref:System.Net.Sockets.Socket> de este objeto de estado. Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndReceive%2A> método para completar la operación de lectura y devolver el número de bytes leídos correctamente.  
  
 El <xref:System.Net.Sockets.Socket.EndReceive%2A> método se bloqueará hasta que haya datos disponibles. Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.EndReceive%2A> leerá el primer datagrama en cola disponible en el búfer de red entrante. Si usa un protocolo orientado a conexiones, el <xref:System.Net.Sockets.Socket.EndReceive%2A> método leerá tantos datos como está disponible hasta el número de bytes especificado por el `size` parámetro de la <xref:System.Net.Sockets.Socket.BeginReceive%2A> método. Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.EndReceive%2A> método finalizará inmediatamente y devolverá cero bytes.  
  
 Para obtener los datos recibidos, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult>y extraiga el búfer que contiene el objeto de estado resultante.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina. Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó previamente a <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> para la lectura asincrónica.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</param>
        <param name="endPoint"><see cref="T:System.Net.EndPoint" /> de origen.</param>
        <param name="end_point"><see cref="T:System.Net.EndPoint" /> de origen.</param>
        <summary>Finaliza una lectura asincrónica pendiente desde un extremo específico.</summary>
        <returns>Si se realiza correctamente, el número de bytes recibidos. Si no se realiza correctamente, devuelve 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método completa la operación de lectura asincrónica iniciada el <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.  
  
 Antes de llamar a <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar. Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> devuelve. El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> devuelto por la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método como parámetro.  
  
 Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> para obtener el objeto de estado pasado a la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método. Extraer la recepción <xref:System.Net.Sockets.Socket> de este objeto de estado. Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método para completar la operación de lectura y devolver el número de bytes leídos correctamente.  
  
 El <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método se bloqueará hasta que haya datos disponibles. Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> leerá el primer datagrama en cola disponible en el búfer de red entrante. Si usa un protocolo orientado a conexiones, el <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método leerá tantos datos como está disponible hasta el número de bytes especificado por el `size` parámetro de la <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método. Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método finalizará inmediatamente y devolverá cero bytes. Para obtener los datos recibidos, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> objeto y extraiga el búfer que contiene el objeto de estado resultante. Para identificar el host de origen, extraiga el <xref:System.Net.EndPoint> y conviértalo a un <xref:System.Net.IPEndPoint>. Use la <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> método para obtener la dirección IP y el <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> método para obtener el número de puerto.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código finaliza una lectura asincrónica pendiente desde un determinado <xref:System.Net.EndPoint>.  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó previamente a <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> para la lectura asincrónica.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" /> para el paquete recibido.</param>
        <param name="endPoint"><see cref="T:System.Net.EndPoint" /> de origen.</param>
        <param name="ipPacketInformation"><see cref="T:System.Net.IPAddress" /> e interfaz del paquete recibido.</param>
        <summary>Finaliza una lectura asincrónica pendiente desde un extremo específico. Este método también desvela más información sobre el paquete que <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</summary>
        <returns>Si se realiza correctamente, el número de bytes recibidos. Si no se realiza correctamente, devuelve 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se ha completado la operación, este método se bloquea hasta que lo haga.  
  
 Para realizar esta operación sincrónicamente, utilice el <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método.  
  
 Examinar `ipPacketInformation` si necesita saber si el datagrama se envió mediante una unidifusión, la dirección de difusión o multidifusión.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> es <see langword="null" />  
  
O bien 
 <paramref name="endPoint" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó previamente a <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> para la lectura asincrónica.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Finaliza un envío asincrónico pendiente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica.</param>
        <summary>Finaliza un envío asincrónico pendiente.</summary>
        <returns>Si se realiza con éxito, el número de bytes enviados al objeto <see cref="T:System.Net.Sockets.Socket" />; en caso contrario, un error de <see cref="T:System.Net.Sockets.Socket" /> no válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> finaliza la operación de envío asincrónica iniciada <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Antes de llamar a <xref:System.Net.Sockets.Socket.BeginSend%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar. Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginSend%2A> devuelve. El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> devuelto por la <xref:System.Net.Sockets.Socket.BeginSend%2A> método como parámetro.  
  
 Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> parámetro para obtener el envío <xref:System.Net.Sockets.Socket>. Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndSend%2A> método para completar la operación de envío y devolver el número de bytes enviados correctamente.  
  
 Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloqueará hasta que se envíe el datagrama. Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloqueará hasta que se envió a algunos de los búferes. Si el valor devuelto desde <xref:System.Net.Sockets.Socket.EndSend%2A> indica que el búfer no se ha enviado completamente, llame a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método nuevo, modifique el búfer para almacenar los datos sin enviar.  
  
 No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.BeginSend%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina. Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.  
  
> [!NOTE]
>  La finalización correcta de un envío no indica que los datos se ha entregado correctamente. Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el siguiente ejemplo se finaliza un envío asincrónico pendiente.  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> fue llamado previamente para el envío asincrónico.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica.</param>
        <param name="errorCode">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</param>
        <summary>Finaliza un envío asincrónico pendiente.</summary>
        <returns>Si se realiza con éxito, el número de bytes enviados al objeto <see cref="T:System.Net.Sockets.Socket" />; en caso contrario, un error de <see cref="T:System.Net.Sockets.Socket" /> no válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> finaliza la operación de envío asincrónica iniciada <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Antes de llamar a <xref:System.Net.Sockets.Socket.BeginSend%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar. Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginSend%2A> devuelve. El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> devuelto por la <xref:System.Net.Sockets.Socket.BeginSend%2A> método como parámetro.  
  
 Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> parámetro para obtener el envío <xref:System.Net.Sockets.Socket>. Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndSend%2A> método para completar la operación de envío y devolver el número de bytes enviados correctamente.  
  
 Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloqueará hasta que se envíe el datagrama. Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.EndSend%2A> se bloqueará hasta que se envió a algunos de los búferes. Si el valor devuelto desde <xref:System.Net.Sockets.Socket.EndSend%2A> indica que el búfer no se ha enviado completamente, llame a la <xref:System.Net.Sockets.Socket.BeginSend%2A> método nuevo, modifique el búfer para almacenar los datos sin enviar.  
  
 No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.BeginSend%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Todas las E/S iniciada por un subproceso dado se cancela cuando ese subproceso termina. Una operación asincrónica pendiente puede producir un error si el subproceso se cierra antes de que finalice la operación.  
  
> [!NOTE]
>  La finalización correcta de un envío no indica que los datos se ha entregado correctamente. Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> fue llamado previamente para el envío asincrónico.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Objeto <see cref="T:System.IAsyncResult" /> que almacena información de estado para esta operación asincrónica.</param>
        <summary>Finaliza un envío asincrónico de archivo pendiente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> finaliza la operación de envío asincrónica iniciada <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.  
  
 Antes de llamar a <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, debe crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar. Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginSendFile%2A> devuelve. El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> objeto devuelto por la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método como parámetro.  
  
 Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> parámetro para obtener el envío <xref:System.Net.Sockets.Socket>. Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndSendFile%2A> método finalice correctamente la operación de envío.  
  
 Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloquea hasta que se envíe el datagrama. Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloquea hasta que se envía el archivo completo. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea y se conecta a un socket para la comunicación asincrónica y comienza a enviar el archivo "text.txt" asincrónicamente al host remoto. Las llamadas de delegado de la devolución de llamada <xref:System.Net.Sockets.Socket.EndSendFile%2A> para completar la transmisión.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Se requiere Windows NT para este método.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> está vacía.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó previamente a <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> para el <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> asincrónico.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket. Vea la sección de comentarios que figura más abajo.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</param>
        <param name="result"><see cref="T:System.IAsyncResult" /> que almacena información de estado así como cualquier dato definido por el usuario para esta operación asincrónica.</param>
        <summary>Finaliza un envío asincrónico pendiente en una ubicación específica.</summary>
        <returns>Si se realiza con éxito, el número de bytes enviados; en caso contrario, un error de <see cref="T:System.Net.Sockets.Socket" /> no válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> finaliza la operación de envío asincrónica iniciada <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.  
  
 Antes de llamar a <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, deberá crear un método de devolución de llamada que implementa el <xref:System.AsyncCallback> delegar. Este método de devolución de llamada se ejecuta en un subproceso independiente y es llamado por el sistema después de <xref:System.Net.Sockets.Socket.BeginReceive%2A> devuelve. El método de devolución de llamada debe aceptar el <xref:System.IAsyncResult> devuelto por la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método como parámetro.  
  
 Dentro del método de devolución de llamada, llame a la <xref:System.IAsyncResult.AsyncState%2A> método de la <xref:System.IAsyncResult> parámetro para obtener el envío <xref:System.Net.Sockets.Socket>. Después de obtener el <xref:System.Net.Sockets.Socket>, puede llamar a la <xref:System.Net.Sockets.Socket.EndSendTo%2A> método para completar la operación de envío y devolver el número de bytes enviados correctamente.  
  
 Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.EndSendTo%2A> se bloqueará hasta que se envíe el datagrama. Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.EndSendTo%2A> se bloqueará hasta que se envía el número de bytes solicitado. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el siguiente ejemplo se finaliza un envío asincrónico en una ubicación específica.  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> no se devolvió mediante una llamada al método <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> fue llamado previamente para el envío asincrónico.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor de <see cref="T:System.Boolean" /> que especifica si <see cref="T:System.Net.Sockets.Socket" /> permite sólo a un proceso el enlace a un puerto.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> permite sólo a un socket el enlace a un puerto concreto; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="true" /> para Windows Server 2003 y Windows XP Service Pack 2 y <see langword="false" /> para todas las demás versiones.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> es `false`, pueden usar varios sockets el <xref:System.Net.Sockets.Socket.Bind%2A> método para enlazar a un puerto concreto; sin embargo, solo uno de los sockets puede realizar operaciones en el tráfico de red enviado al puerto. Si más de un socket intenta usar el <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> enlazarse a un puerto determinado, a continuación, en la dirección IP específica más controlará el tráfico de red enviado a ese puerto.  
  
 Si <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> es `true`, el primer uso de la <xref:System.Net.Sockets.Socket.Bind%2A> método intenta enlazar a un puerto determinado, independientemente de la dirección de protocolo de Internet (IP), se realizará correctamente; todos los usos de la <xref:System.Net.Sockets.Socket.Bind%2A> método al que intenta enlazar a ese puerto un error hasta que se destruya el socket del enlace original.  
  
 Esta propiedad debe establecerse antes de <xref:System.Net.Sockets.Socket.Bind%2A> llamado; de lo contrario una <xref:System.InvalidOperationException> se iniciará.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> propiedad.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha llamado a <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> para este <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos utilizados por la clase <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket> clase llamadas del finalizador el <xref:System.Net.Sockets.Socket.Close%2A> método para cerrar el <xref:System.Net.Sockets.Socket> y liberar los recursos asociados con la <xref:System.Net.Sockets.Socket>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor hash para una instancia de <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Valor hash entero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
El método GetHashCode devuelve un código hash de esta instancia. Este valor puede utilizarse como clave en las tablas hash.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el valor de una opción de <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <summary>Devuelve el valor de una opción de <see cref="T:System.Net.Sockets.Socket" /> especificada en forma de objeto.</summary>
        <returns>Objeto que representa el valor de una opción. Cuando se establece el parámetro <paramref name="optionName" /> en <see cref="F:System.Net.Sockets.SocketOptionName.Linger" />, el valor devuelto es una instancia de la clase <see cref="T:System.Net.Sockets.LingerOption" />. Cuando se establece el parámetro <paramref name="optionName" /> en <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> o <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, el valor devuelto es una instancia de la clase <see cref="T:System.Net.Sockets.MulticastOption" />. Cuando <paramref name="optionName" /> está establecido en cualquier otro valor, el valor de devolución es un entero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opciones determinan el comportamiento del elemento actual <xref:System.Net.Sockets.Socket>. Utilice esta sobrecarga para obtener el <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, y <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opciones. Para el <xref:System.Net.Sockets.SocketOptionName.Linger> opción, utilice <xref:System.Net.Sockets.Socket> para el `optionLevel` parámetro. Para <xref:System.Net.Sockets.SocketOptionName.AddMembership> y <xref:System.Net.Sockets.SocketOptionName.DropMembership>, utilice <xref:System.Net.Sockets.SocketOptionLevel.IP>. Si desea establecer el valor de cualquiera de las opciones enumeradas anteriormente, use el <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente código en el ejemplo se recupera el <xref:System.Net.Sockets.LingerOption> y <xref:System.Net.Sockets.Socket.Send%2A> los valores de tiempo de espera y los muestra en la consola.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.  
  
O bien 
 <paramref name="optionName" /> se estableció en el valor <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />, que no es compatible.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Matriz de tipo <see cref="T:System.Byte" /> que va a recibir el valor de la opción.</param>
        <summary>Devuelve el valor de la opción de <see cref="T:System.Net.Sockets.Socket" /> especificada, representado como una matriz de bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opciones determinan el comportamiento del elemento actual <xref:System.Net.Sockets.Socket>. Tras la finalización correcta de este método, la matriz especificada por el `optionValue` parámetro contiene el valor del elemento especificado <xref:System.Net.Sockets.Socket> opción.  
  
 Cuando la longitud de la `optionValue` matriz es menor que el número de bytes necesarios para almacenar el valor del elemento especificado <xref:System.Net.Sockets.Socket> opción, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error. Utilice esta sobrecarga para cualquiera de los sockets que está representada por valores booleanos o enteros.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente código en el ejemplo se recupera el <xref:System.Net.Sockets.LingerOption> y <xref:System.Net.Sockets.Socket.Send%2A> los valores de tiempo de espera y los muestra en la consola.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.  
  
O bien 
En aplicaciones de .NET Compact Framework, el espacio en búfer predeterminado de Windows CE está establecido en 32768 bytes. El espacio en búfer por cada socket puede modificarse mediante una llamada a <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionLength">Longitud, en bytes, del valor devuelto previsto.</param>
        <summary>Devuelve el valor de la opción de <see cref="T:System.Net.Sockets.Socket" /> especificada en una matriz.</summary>
        <returns>Matriz de tipo <see cref="T:System.Byte" /> que contiene el valor de la opción de socket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `optionLength` parámetro establece el tamaño máximo de la matriz de bytes devuelta. Si el valor de opción requiere menos bytes, la matriz contendrá solo que número de bytes. Si el valor de opción requiere más bytes <xref:System.Net.Sockets.Socket.GetSocketOption%2A> producirá un <xref:System.Net.Sockets.SocketException>. Utilice esta sobrecarga para cualquiera de los sockets que está representada por valores booleanos o enteros.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente código en el ejemplo se recupera el <xref:System.Net.Sockets.LingerOption> y <xref:System.Net.Sockets.Socket.Send%2A> los valores de tiempo de espera y los muestra en la consola.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.  
  
O bien 
En aplicaciones de .NET Compact Framework, el espacio en búfer predeterminado de Windows CE está establecido en 32768 bytes. El espacio en búfer por cada socket puede modificarse mediante una llamada a <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador del sistema operativo de <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value><see cref="T:System.IntPtr" /> que representa el identificador del sistema operativo de <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece modos operativos de bajo nivel para <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Valor de <see cref="T:System.Int32" /> que especifica el código de control de la operación que se ha de realizar.</param>
        <param name="optionInValue">Matriz <see cref="T:System.Byte" /> que contiene los datos de entrada requeridos por la operación.</param>
        <param name="optionOutValue">Matriz <see cref="T:System.Byte" /> que contiene los datos de salida devueltos por la operación.</param>
        <summary>Establece modos operativos de bajo nivel para el <see cref="T:System.Net.Sockets.Socket" /> que utiliza códigos de control numéricos.</summary>
        <returns>Número de bytes del parámetro <paramref name="optionOutValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.IOControl%2A> método proporciona acceso al sistema operativo de bajo nivel <xref:System.Net.Sockets.Socket> subyacente de la instancia actual de la <xref:System.Net.Sockets.Socket> clase. Para obtener más información, consulte el [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) documentación.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se compara los resultados de FIONREAD y la propiedad disponible.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Se intentó modificar el modo de bloqueo sin utilizar la propiedad <see cref="P:System.Net.Sockets.Socket.Blocking" />.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para ejecutar código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Valor de <see cref="T:System.Net.Sockets.IOControlCode" /> que especifica el código de control de la operación que se ha de realizar.</param>
        <param name="optionInValue">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos de entrada requeridos por la operación.</param>
        <param name="optionOutValue">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos de salida requeridos por la operación.</param>
        <summary>Establece modos operativos de bajo nivel para el <see cref="T:System.Net.Sockets.Socket" /> que utiliza la enumeración <see cref="T:System.Net.Sockets.IOControlCode" /> para especificar códigos de control.</summary>
        <returns>Número de bytes del parámetro <paramref name="optionOutValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método proporciona acceso al sistema operativo de bajo nivel <xref:System.Net.Sockets.Socket> subyacente de la instancia actual de la <xref:System.Net.Sockets.Socket> clase. Para obtener más información, consulte el [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) documentación.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se compara los resultados de llamar a <xref:System.Net.Sockets.Socket.IOControl%2A> con <xref:System.Net.Sockets.IOControlCode.DataToRead> y <xref:System.Net.Sockets.Socket.Available%2A> propiedad.  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Se intentó modificar el modo de bloqueo sin utilizar la propiedad <see cref="P:System.Net.Sockets.Socket.Blocking" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para ejecutar código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Net.Sockets.Socket" /> se enlaza a un puerto local concreto.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> se enlaza a un puerto local; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un socket se considera que está enlazado a un puerto local si está enlazada explícitamente mediante una llamada a la <xref:System.Net.Sockets.Socket.Bind%2A> método, o implícitamente enlazado llamando a los miembros como <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, que usan un puerto local efímero (un puerto libre mayor que 1024, seleccionado por el sistema operativo.) Los servidores usan la <xref:System.Net.Sockets.Socket.Bind%2A> método para enlazar a un puerto conocido para que los clientes pueden conectarse a ellos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.IsBound%2A> propiedad.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica si <see cref="T:System.Net.Sockets.Socket" /> retrasará el cierre de un socket en un intento de envío de todos los datos pendientes.</summary>
        <value><see cref="T:System.Net.Sockets.LingerOption" /> que especifica cómo aplicar un retraso mientras se cierra un socket.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.LingerState%2A> propiedad cambia la manera <xref:System.Net.Sockets.Socket.Close%2A> método se comporta. Esta propiedad cuando set modifica las condiciones en las que se puede restablecer la conexión mediante Winsock. Restablecimientos de conexión pueden seguir apareciendo según el comportamiento del protocolo IP.  
  
 Esta propiedad controla el período de tiempo que una conexión orientado a la conexión permanecerá abierta después de llamar a <xref:System.Net.Sockets.Socket.Close%2A> cuando quedan enviarán datos.  
  
 Al llamar a métodos para enviar datos a un elemento del mismo nivel, estos datos se colocan en el búfer de red saliente. Esta propiedad se puede utilizar para asegurarse de que estos datos se envían al host remoto antes de la <xref:System.Net.Sockets.TcpClient.Close%2A> método interrumpe la conexión.  
  
 Para habilitar la permanencia de la conexión, cree un <xref:System.Net.Sockets.LingerOption> de instancia que contiene los valores deseados y establezca el <xref:System.Net.Sockets.Socket.LingerState%2A> propiedad a esta instancia.  
  
 En la tabla siguiente se describe el comportamiento de la <xref:System.Net.Sockets.Socket.Close%2A> método para los valores posibles de la <xref:System.Net.Sockets.LingerOption.Enabled%2A> propiedad y el <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propiedad almacenados en el <xref:System.Net.Sockets.Socket.LingerState%2A> propiedad.  
  
|LingerState.Enabled|LingerState.LingerTime|Comportamiento|  
|-------------------------|----------------------------|--------------|  
|`false` (deshabilitado), el valor predeterminado|No es aplicable, el tiempo de espera (valor predeterminado).|Intenta enviar los datos pendientes hasta que expire el tiempo de espera de protocolo IP de forma predeterminada.|  
|`true` (habilitado)|Un tiempo de espera distinto de cero|Intenta enviar los datos pendientes hasta que expira el tiempo de espera especificado y, si se produce un error en el intento, Winsock restablece la conexión.|  
|`true` (habilitado)|Un cero tiempo de espera.|Descarta cualquier dato pendiente. Para el socket orientado a conexión (por ejemplo, TCP), Winsock restablece la conexión.|  
  
 La pila IP calcula el tiempo de espera de protocolo IP predeterminado a utilizar basándose en el tiempo de ida y vuelta de la conexión. En la mayoría de los casos, el tiempo de espera calculado por la pila es más relevante que definidos por una aplicación. Este es el comportamiento predeterminado para un socket cuando la <xref:System.Net.Sockets.Socket.LingerState%2A> no se establece la propiedad.  
  
 Cuando el <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propiedad almacenados en el <xref:System.Net.Sockets.Socket.LingerState%2A> propiedad está establecida en mayor que el tiempo de espera de protocolo IP de forma predeterminada, el tiempo de espera de protocolo IP de forma predeterminada se todavía se aplican y reemplazan.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.LingerState%2A> propiedad.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Longitud máxima de la cola de conexiones pendientes.</param>
        <summary>Coloca un objeto <see cref="T:System.Net.Sockets.Socket" /> en un estado de escucha.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> hace que un orientado a conexión <xref:System.Net.Sockets.Socket> para realizar escuchas para los intentos de conexión entrante. El `backlog` parámetro especifica el número de conexiones entrantes que pueden poner en cola para que los acepte. Para determinar el número máximo de conexiones que puede especificar, recuperar el <xref:System.Net.Sockets.SocketOptionName.MaxConnections> valor. <xref:System.Net.Sockets.Socket.Listen%2A> no se bloquea.  
  
 Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error. Use <xref:System.Net.Sockets.Socket.Accept%2A> o <xref:System.Net.Sockets.Socket.BeginAccept%2A> para aceptar una conexión de la cola.  
  
> [!NOTE]
>  Debe llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.Listen%2A>, o <xref:System.Net.Sockets.Socket.Listen%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  El parámetro de trabajo pendiente se limita a valores diferentes dependiendo del sistema operativo. Puede especificar un valor mayor, pero el trabajo pendiente estará limitado en función del sistema operativo.  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Net.Sockets.Socket> para escuchar las conexiones entrantes.  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el extremo local.</summary>
        <value><see cref="T:System.Net.EndPoint" /> que utiliza el <see cref="T:System.Net.Sockets.Socket" /> para las comunicaciones.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> procedimientos property get un <xref:System.Net.EndPoint> que contiene el número de puerto y dirección IP local a la que su <xref:System.Net.Sockets.Socket> está enlazado. Debe convertir esta <xref:System.Net.EndPoint> a un <xref:System.Net.IPEndPoint> antes de recuperar toda la información. A continuación, puede llamar a la <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> método para recuperar la variable local <xref:System.Net.IPAddress>y el <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> método para recuperar el número de puerto local.  
  
 El <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propiedad normalmente se establece después de realizar una llamada a la <xref:System.Net.Sockets.Socket.Bind%2A> método. Si permite que el sistema asignar la dirección IP local del socket y el número de puerto, el <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> se establecerá la propiedad después de la primera operación de E/S. Para protocolos orientados a conexiones, la primera operación de E/S sería una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método. Para los protocolos sin conexión, la primera operación de E/S podría ser cualquiera de envío o recibir llamadas.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se recupera y muestra los puntos de conexión locales y remotas.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica si se entregan paquetes de multidifusión saliente a la aplicación emisora.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> recibe paquetes de multidifusión saliente; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multidifusión es un método escalable para la comunicación de varios a varios en Internet. Un proceso se suscribe a una dirección de multidifusión; a continuación, todos los paquetes enviados por un proceso suscrito son recibidos por todos los procesos suscrito a la dirección de multidifusión.  
  
 Establecer esta propiedad en un socket de protocolo de Control de transmisión (TCP) no tendrá ningún efecto.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> propiedad.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor de <see cref="T:System.Boolean" /> que especifica si la secuencia <see cref="T:System.Net.Sockets.Socket" /> está utilizando el algoritmo de Nagle.</summary>
        <value><see langword="false" /> si <see cref="T:System.Net.Sockets.Socket" /> utiliza el algoritmo de Nagle; de lo contrario, <see langword="true" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El algoritmo de Nagle está diseñado para reducir el tráfico de red haciendo que el socket almacenar en búfer paquetes pequeños y, a continuación, combinar y enviarlos en un paquete en determinadas circunstancias. Un paquete TCP se compone de 40 bytes de encabezado y los datos que se envían. Cuando se envían paquetes pequeños de datos con TCP, la sobrecarga resultante del encabezado TCP puede convertirse en una parte significativa del tráfico de red. En redes con mucha cargadas, la congestión resultantes de esta sobrecarga puede producir pérdida de datagramas y retransmisiones, así como tiempo excesivo de propagación causados por la congestión de la. El algoritmo de Nagle inhibe el envío de nuevos segmentswhen TCP nuevos datos de salida llegan al usuario si los datos previouslytransmitted en la conexión permanecen sin confirmación.  
  
 La mayoría de las aplicaciones de red debe usar el algoritmo de Nagle.  
  
 Establecer esta propiedad en un socket de protocolo de datagramas de usuario (UDP) no tendrá ningún efecto.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.NoDelay%2A> propiedad.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar obtener acceso a <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica si el sistema operativo subyacente y los adaptadores de red admiten la versión 4 del protocolo de Internet (IPv4).</summary>
        <value>Es <see langword="true" /> si el sistema operativo y los adaptadores de red admiten el protocolo IPv4; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El sistema operativo puede admitir los protocolos IPv4 e IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica si el sistema operativo subyacente y los adaptadores de red admiten la versión 6 del protocolo Internet (IPv6).</summary>
        <value><see langword="true" /> si el sistema operativo y los adaptadores de red admiten el protocolo IPv6; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El sistema operativo puede admitir los protocolos IPv4 e IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="microSeconds">Tiempo que se va a esperar una respuesta, en microsegundos.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.Net.Sockets.SelectMode" />.</param>
        <summary>Determina el estado de <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Estado del objeto <see cref="T:System.Net.Sockets.Socket" /> según el valor del modo de sondeo que se pase en el parámetro <paramref name="mode" />.  
  
 <list type="table"><listheader><term> Modo 
 </term><description> Valor devuelto 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description>Es <see langword="true" /> si se ha llamado a <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> y hay una conexión pendiente; 
O bien 
 Es <see langword="true" /> si hay datos disponibles para su lectura; 
O bien 
 Es <see langword="true" /> si se cerró, restableció o terminó la conexión; 
de lo contrario, devolverá <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description>Es <see langword="true" /> si se procesa un método <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> y la conexión se ha realizado correctamente; 
O bien 
 Es <see langword="true" /> si se pueden enviar datos; 
de lo contrario, devolverá <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description>Es <see langword="true" /> si se procesa un método <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> que no se bloquea y la conexión no se ha realizado correctamente; 
O bien 
 Es <see langword="true" /> si no se ha establecido <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> y hay datos fuera de banda disponibles; 
de lo contrario, devolverá <see langword="false" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.Poll%2A> método comprobará el estado de la <xref:System.Net.Sockets.Socket>. Especificar <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> para el `selectMode` parámetro para determinar si la <xref:System.Net.Sockets.Socket> es legible. Especificar <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> para determinar si la <xref:System.Net.Sockets.Socket> es grabable. Use <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> para detectar una condición de error. <xref:System.Net.Sockets.Socket.Poll%2A> bloqueará la ejecución hasta que el período de tiempo especificado, expresada en `microseconds`, transcurre. Establecer el `microSeconds` parámetro en un entero negativo si desea esperar una respuesta de forma indefinida. Si desea comprobar el estado de varios sockets, es preferible usar el <xref:System.Net.Sockets.Socket.Select%2A> método.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este método no puede detectar ciertos tipos de problemas de conexión, como un cable de red rota, o que el host remoto cierre brusco. Debe intentar enviar o recibir datos para detectar estos tipos de errores.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un socket, se conecta a un servidor y utiliza <xref:System.Net.Sockets.Socket.Poll%2A> para comprobar el estado del socket.  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El parámetro <paramref name="mode" /> no es un valor de <see cref="T:System.Net.Sockets.SelectMode" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket. Vea los comentarios más abajo.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo de protocolo de <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Uno de los valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.ProtocolType%2A> propiedad se establece cuando el <xref:System.Net.Sockets.Socket> se crea y especifica el protocolo utilizado por esa <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 El siguiente código de ejemplo se muestra el <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, y <xref:System.Net.Sockets.ProtocolType> en la consola.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recibe datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> enlazado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</param>
        <summary>Recibe datos de un <see cref="T:System.Net.Sockets.Socket" /> enlazado en un búfer de recepción.</summary>
        <returns>Número de bytes recibidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.Receive%2A> método lee los datos en el parámetro de búfer y devuelve el número de bytes leídos correctamente. Puede llamar a <xref:System.Net.Sockets.Socket.Receive%2A> en sockets orientados a conexiones y sin conexión.  
  
 Esta sobrecarga sólo requiere proporcionar un búfer de recepción. El desplazamiento de búfer predeterminado es 0, el tamaño predeterminado es la longitud del parámetro de búfer y el <xref:System.Net.Sockets.SocketFlags> como valor predeterminado <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>. El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método. Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.  
  
 Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles, a menos que se haya establecido un valor de tiempo de espera utilizando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>. Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>. Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura. Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.  
  
 Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, el <xref:System.Net.Sockets.Socket.Receive%2A> método leerá todos los datos estén disponibles, hasta el tamaño del búfer. Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.  
  
 Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método. Si el datagrama recibido es mayor que el tamaño de la `buffer` parámetro, `buffer` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente recibe los datos en un conectado <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceptar conexiones desde la red. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista de <see cref="T:System.ArraySegment`1" /> de tipo <see cref="T:System.Byte" /> que contiene los datos recibidos.</param>
        <summary>Recibe, en la lista de búferes de recepción, datos de un <see cref="T:System.Net.Sockets.Socket" /> enlazado.</summary>
        <returns>Número de bytes recibidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee los datos en el parámetro de búferes y devuelve el número de bytes leídos correctamente. Puede llamar en sockets orientados a conexiones y sin conexión.  
  
 Esta sobrecarga requiere que proporcione uno o varios búferes de recepción.  
  
 Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>. El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde la conexión de host remoto establecida en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método. Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.  
  
 Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles, a menos que se haya establecido un valor de tiempo de espera utilizando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>. Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>. Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura. Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.  
  
 Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, el <xref:System.Net.Sockets.Socket.Receive%2A> método leerá todos los datos estén disponibles, hasta el tamaño del búfer. Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.  
  
 Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método. Si el datagrama recibido es mayor que el tamaño de la `buffers` parámetro, `buffers` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
 **Tenga en cuenta** este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al intentar obtener acceso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Recibe datos de un <see cref="T:System.Net.Sockets.Socket" /> enlazado en un búfer de recepción, usando el valor de <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>Número de bytes recibidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.Receive%2A> método lee los datos en el parámetro de búfer y devuelve el número de bytes leídos correctamente. Puede llamar a <xref:System.Net.Sockets.Socket.Receive%2A> en sockets orientados a conexiones y sin conexión.  
  
 Esta sobrecarga sólo requiere que proporcione un búfer de recepción y el necesario <xref:System.Net.Sockets.SocketFlags>. El desplazamiento de búfer predeterminado es 0 y el tamaño predeterminado es la longitud del parámetro de bytes.  
  
 Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>. El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método. Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.  
  
 Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles. Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>. Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura. Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.  
  
 Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, el <xref:System.Net.Sockets.Socket.Receive%2A> método leerá tantos datos como está disponible hasta el tamaño del búfer. Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.  
  
 Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método. Si el datagrama recibido es mayor que el tamaño de la `buffer` parámetro, `buffer` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se especifica un búfer de datos, y <xref:System.Net.Sockets.SocketFlags> para recibir los datos en un conectado <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceptar conexiones desde la red. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista de <see cref="T:System.ArraySegment`1" /> de tipo <see cref="T:System.Byte" /> que contiene los datos recibidos.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Recibe, en la lista de búferes de recepción, datos de un <see cref="T:System.Net.Sockets.Socket" /> enlazado, utilizando el valor de <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>Número de bytes recibidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee los datos en el `buffers` parámetro y devuelve el número de bytes leídos correctamente. Puede llamar en sockets orientados a conexiones y sin conexión.  
  
 Esta sobrecarga requiere que proporcione uno o varios búferes de recepción. El <xref:System.Net.Sockets.SocketFlags> como valor predeterminado <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>. El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde la conexión de host remoto establecida en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método. Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.  
  
 Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles, a menos que se haya establecido un valor de tiempo de espera utilizando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> llamar a produce un <xref:System.Net.Sockets.SocketException>. Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>. Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura. Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.  
  
 Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, el <xref:System.Net.Sockets.Socket.Receive%2A> método leerá todos los datos estén disponibles, hasta el tamaño del búfer. Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.  
  
 Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método. Si el datagrama recibido es mayor que el tamaño de la `buffers` parámetro, `buffers` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo recibir datos en un conectado <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> es <see langword="null" />.  
  
O bien 
 <paramref name="buffers" />.Count es cero.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al intentar obtener acceso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceptar conexiones desde la red. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</param>
        <param name="size">Número de bytes que se va a recibir.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Recibe el número especificado de bytes de datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> enlazado en un búfer de recepción, usando el valor de <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>Número de bytes recibidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.Receive%2A> método lee datos en el `buffer` parámetro y devuelve el número de bytes leídos correctamente. Puede llamar a <xref:System.Net.Sockets.Socket.Receive%2A> en sockets orientados a conexiones y sin conexión.  
  
 Esta sobrecarga sólo requiere que se proporcione un búfer de recepción, el número de bytes que desea recibir y el necesario <xref:System.Net.Sockets.SocketFlags>.  
  
 Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>. El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método. Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.  
  
 Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles, a menos que se haya establecido un valor de tiempo de espera utilizando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>. Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>. Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura. Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.  
  
 Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> método leerá todos los datos estén disponibles, hasta el número de bytes especificado por el `size` parámetro. Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.  
  
 Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método. Si el datagrama recibido es mayor que el tamaño de la `buffer` parámetro, `buffer` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 La siguiente recibe los datos se encuentran en `buffer`y especifica <xref:System.Net.Sockets.SocketFlags.None> para <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> sobrepasa el tamaño de <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceptar conexiones desde la red. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista de <see cref="T:System.ArraySegment`1" /> de tipo <see cref="T:System.Byte" /> que contiene los datos recibidos.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</param>
        <summary>Recibe, en la lista de búferes de recepción, datos de un <see cref="T:System.Net.Sockets.Socket" /> enlazado, utilizando el valor de <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>Número de bytes recibidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lee los datos en el `buffers` parámetro y devuelve el número de bytes leídos correctamente. Puede llamar en sockets orientados a conexiones y sin conexión.  
  
 Esta sobrecarga requiere que proporcione uno o varios búferes de recepción. El <xref:System.Net.Sockets.SocketFlags> como valor predeterminado <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>. El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde la conexión de host remoto establecida en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método. Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.  
  
 Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles, a menos que se haya establecido un valor de tiempo de espera utilizando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> llamar a produce un <xref:System.Net.Sockets.SocketException>. Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>. Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura. Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.  
  
 Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, el <xref:System.Net.Sockets.Socket.Receive%2A> método leerá todos los datos estén disponibles, hasta el tamaño del búfer. Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.  
  
 Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método. Si el datagrama recibido es mayor que el tamaño de la `buffers` parámetro, `buffers` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> es <see langword="null" />.  
  
O bien 
 <paramref name="buffers" />.Count es cero.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al intentar obtener acceso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceptar conexiones desde la red. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que es la ubicación de almacenamiento para los datos recibidos.</param>
        <param name="offset">Ubicación de <paramref name="buffer" /> en la que se almacenarán los datos recibidos.</param>
        <param name="size">Número de bytes que se va a recibir.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Recibe el número especificado de bytes de un objeto <see cref="T:System.Net.Sockets.Socket" /> enlazado en la posición de desplazamiento especificada del búfer de recepción, usando el valor de <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>Número de bytes recibidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.Receive%2A> método lee los datos en el parámetro de búfer y devuelve el número de bytes leídos correctamente. Puede llamar a <xref:System.Net.Sockets.Socket.Receive%2A> en sockets orientados a conexiones y sin conexión.  
  
 Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>. El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método. Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.  
  
 Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles, a menos que se haya establecido un valor de tiempo de espera utilizando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>. Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>. Error al intentar acceder al socket. Consulte la sección Comentarios más adelante. Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura. Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.  
  
 Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, el <xref:System.Net.Sockets.Socket.Receive%2A> método leerá todos los datos estén disponibles, hasta el número de bytes especificado por el parámetro de tamaño. Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.  
  
 Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método. Si el datagrama recibido es mayor que el tamaño de la `buffer` parámetro, `buffer` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se especifica un búfer de datos, un desplazamiento, un tamaño y un indicador de socket antes de recibir datos en un conectado <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> es menor que 0.  
  
O bien 
 <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.  
  
O bien 
 <paramref name="size" /> es menor que 0.  
  
O bien 
 <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> no es una combinación válida de valores.  
  
O bien 
La propiedad <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> no se estableció.  
  
O bien 
Se produce un error de sistema operativo al acceder a <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceptar conexiones desde la red. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</param>
        <param name="offset">Posición en el parámetro <paramref name="buffer" /> para almacenar los datos recibidos.</param>
        <param name="size">Número de bytes que se va a recibir.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</param>
        <summary>Recibe datos de un <see cref="T:System.Net.Sockets.Socket" /> enlazado en un búfer de recepción, usando el valor de <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>Número de bytes recibidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.Receive%2A> método lee los datos en el parámetro de búfer y devuelve el número de bytes leídos correctamente. Puede llamar a <xref:System.Net.Sockets.Socket.Receive%2A> en sockets orientados a conexiones y sin conexión.  
  
 Si utiliza un protocolo orientado a conexiones, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> para establecer conexión con un host remoto, o <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante antes de llamar a <xref:System.Net.Sockets.Socket.Receive%2A>. El <xref:System.Net.Sockets.Socket.Receive%2A> método sólo leerá los datos que llegan desde el host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método. Si usa un protocolo sin conexión, también puede usar el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> le permitirá recibir datos procedentes de cualquier host.  
  
 Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.Receive%2A> método se bloqueará hasta que haya datos disponibles, a menos que se haya establecido un valor de tiempo de espera utilizando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>. Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>. Error al intentar acceder al socket. Consulte la sección Comentarios más adelante. Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura. Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.  
  
 Si usas un orientado a conexión <xref:System.Net.Sockets.Socket>, el <xref:System.Net.Sockets.Socket.Receive%2A> método leerá todos los datos estén disponibles, hasta el número de bytes especificado por el parámetro de tamaño. Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.Receive%2A> método finalizará inmediatamente y devolverá cero bytes.  
  
 Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> leerá el primer datagrama en cola de la dirección de destino especificada en el <xref:System.Net.Sockets.Socket.Connect%2A> método. Si el datagrama recibido es mayor que el tamaño de la `buffer` parámetro, `buffer` se rellenará con la primera parte del mensaje, se pierde el exceso de datos y un <xref:System.Net.Sockets.SocketException> se produce.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> es menor que 0.  
  
O bien 
 <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.  
  
O bien 
 <paramref name="size" /> es menor que 0.  
  
O bien 
 <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> no es una combinación válida de valores.  
  
O bien 
La propiedad <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> no se ha establecido.  
  
O bien 
Se produce un error de sistema operativo al acceder a <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceptar conexiones desde la red. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</param>
        <summary>Comienza una solicitud asincrónica para recibir los datos de un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Devuelve <see langword="true" /> si la operación de E/S está pendiente. Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.  
  
 Devuelve <see langword="false" /> si la operación de E/S se ha completado de forma sincrónica. En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> método se usa en sockets conectados o sockets enlazados sin conexión y se usa para leer los datos entrantes. Debe conocer la dirección local del socket.  
  
 Para los sockets enlazados sin conexión, esta función restringe las direcciones desde el que se aceptan los mensajes recibidos. La función devuelve solo los mensajes de la dirección remota especificada en la conexión. Los mensajes de otras direcciones se descartan.  
  
 El <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propiedad en el `e` parámetro proporciona el proveedor de servicios de Windows Sockets con información adicional sobre la solicitud de lectura. Para obtener más información sobre cómo usar este parámetro, vea <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios para llamar correctamente a este método:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> o <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está establecido  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está establecido  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada. Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.  
  
 Para los sockets de estilo de la secuencia de bytes, los datos entrantes se colocan en el búfer hasta que el búfer se llena, la conexión está cerrada o se agotan los datos almacenados en búfer internamente.  
  
 Para los sockets orientados a mensajes, se coloca un mensaje entrante en el búfer hasta el tamaño total del búfer asociado con el `e` parámetro. Si el mensaje es mayor que el búfer, el búfer se rellena con la primera parte del mensaje.  
  
 Para los sockets orientados a conexiones, el <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> método puede indicar la finalización correcta del circuito virtual en uno de dos maneras en que dependen de si el socket está orientado a mensajes o secuencia de bytes. Para las secuencias de bytes, de cero bytes leídos indica el cierre correcto y que nunca se leerá ningún byte más. Para los sockets orientados a mensajes, donde un mensaje de cero bytes a menudo es permitido, un <xref:System.Net.Sockets.SocketException> con el <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> establecido en el código de error nativo de Winsock WSAEDISCON (10101) se utiliza para indicar el cierre correcto. En cualquier caso, un <xref:System.Net.Sockets.SocketException> con el <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> se establece en el nativo Winsock WSAECONNRESET (10054) del código de error indica se ha producido un cierre firme.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Un argumento no era válido. Las propiedades <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> del parámetro <paramref name="e" /> deben hacer referencia a los búferes válidos. Se puede establecer una de estas propiedades, pero no ambas al mismo tiempo.</exception>
        <exception cref="T:System.InvalidOperationException">Ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Se requiere Windows XP o posteriores para este método.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica el tamaño del búfer de recepción de <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value><see cref="T:System.Int32" /> que contiene el tamaño, en bytes, del búfer de recepción. El valor predeterminado es 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Potencialmente, un tamaño de búfer mayor reduce el número de confirmaciones vacías (paquetes TCP sin parte de datos), pero también pueden producir retrasos en el reconocimiento de las dificultades de conexión. Considere la posibilidad de aumentar el tamaño del búfer si va a transferir archivos grandes o usa un ancho de banda alto, la conexión de latencia alta (por ejemplo, un proveedor por satélite banda ancha.)  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> propiedad.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor especificado para una operación de establecimiento es menor que 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recibe un datagrama y almacena el extremo de origen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que es la ubicación de almacenamiento para los datos recibidos.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> que se pasa por referencia y que representa el servidor remoto.</param>
        <summary>Recibe un datagrama en el búfer de datos y almacena el extremo.</summary>
        <returns>Número de bytes recibidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lee datos en el `buffer` parámetro, devuelve el número de bytes leídos correctamente y captura el punto de conexión del host remoto desde el que se enviaron los datos. Este método es útil si desea recibir datagramas sin conexión de un host desconocido o varios hosts.  
  
 Esta sobrecarga sólo requiere que proporcione una instrucción receive `buffer`y un <xref:System.Net.EndPoint> que representa el host remoto. El desplazamiento de búfer predeterminado es 0. El tamaño predeterminado es la longitud de la `buffer` parámetro y el `socketFlags` como valor predeterminado <xref:System.Net.Sockets.SocketFlags.None>.  
  
> [!NOTE]
>  Antes de llamar a <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, debe enlazar explícitamente el <xref:System.Net.Sockets.Socket> a un punto de conexión local con el <xref:System.Net.Sockets.Socket.Bind%2A> método. Si no, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
 Con los protocolos sin conexión, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá el primer datagrama en cola recibido en el búfer de red local. Si el datagrama recibido es mayor que el tamaño de `buffer`, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método rellenará `buffer` con tanta información del mensaje como sea posible y throw un <xref:System.Net.Sockets.SocketException>. Si usa un protocolo no confiable, el exceso de datos se perderá. Si usa un protocolo confiable, el exceso de datos se conservarán por el proveedor de servicios y se puede recuperar llamando el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método con un búfer suficientemente grande.  
  
 Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método se bloqueará hasta que haya datos disponibles. Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>. Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura. Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.  
  
 Aunque <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> está pensado para protocolos sin conexión, puede usar un protocolo orientado a conexiones. Si decide hacerlo, primero debe establecer o una conexión de host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o acepte una instancia remota entrante hospedar conexión mediante una llamada a la <xref:System.Net.Sockets.Socket.Accept%2A> método. Si no se establece o se acepta una conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, obtendrá un <xref:System.Net.Sockets.SocketException>. También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. En cualquiera de estos casos, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método pasará por alto el `remoteEP` parámetro y solo recibirá datos conectado o host remoto predeterminado.  
  
 Con los sockets orientados a conexiones, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá tantos datos como está disponible hasta el tamaño de `buffer`. Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y devolverá cero bytes.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  El <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> debe coincidir con el <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente recibe un datagrama sin conexión de un host remoto.  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.  
  
O bien 
 <paramref name="remoteEP" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceptar conexiones desde la red. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que constituye la ubicación de almacenamiento de los datos recibidos.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> que se pasa por referencia y que representa el servidor remoto.</param>
        <summary>Recibe un datagrama en el búfer de datos usando el objeto <see cref="T:System.Net.Sockets.SocketFlags" /> especificado y almacena el extremo.</summary>
        <returns>Número de bytes recibidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lee datos en el `buffer` parámetro, devuelve el número de bytes leídos correctamente y captura el punto de conexión del host remoto desde el que se enviaron los datos. Este método es útil si desea recibir datagramas sin conexión de un host desconocido o varios hosts.  
  
 Esta sobrecarga sólo requiere que proporcione un búfer de recepción, el necesario <xref:System.Net.Sockets.SocketFlags>y un <xref:System.Net.EndPoint> que representa el host remoto. El desplazamiento predeterminado es 0 y el tamaño predeterminado es la longitud del parámetro de búfer.  
  
> [!NOTE]
>  Antes de llamar a <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, debe enlazar explícitamente el <xref:System.Net.Sockets.Socket> a un punto de conexión local con el <xref:System.Net.Sockets.Socket.Bind%2A> método. Si no, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
 Con los protocolos sin conexión, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá el primer datagrama en cola recibido en el búfer de red local. Si el datagrama recibido es mayor que el tamaño de `buffer`, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método rellenará `buffer` con tanta información del mensaje como sea posible y throw un <xref:System.Net.Sockets.SocketException>. Si usa un protocolo no confiable, el exceso de datos se perderá. Si usa un protocolo confiable, el exceso de datos se conservarán por el proveedor de servicios y se puede recuperar llamando el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método con un búfer suficientemente grande.  
  
 Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método se bloqueará hasta que haya datos disponibles. Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>. Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura. Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.  
  
 Aunque <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> está pensado para protocolos sin conexión, puede usar un protocolo orientado a conexiones. Si decide hacerlo, primero debe establecer o una conexión de host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o acepte una instancia remota entrante hospedar conexión mediante una llamada a la <xref:System.Net.Sockets.Socket.Accept%2A> método. Si no se establece o se acepta una conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, obtendrá un <xref:System.Net.Sockets.SocketException>. También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. En cualquiera de estos casos, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método pasará por alto el `remoteEP` parámetro y solo recibirá datos conectado o host remoto predeterminado.  
  
 Con los sockets orientados a conexiones, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá tantos datos como está disponible hasta el tamaño de `buffer`. Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y devolverá cero bytes.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  El <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> debe coincidir con el <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente recibe un datagrama sin conexión de un host remoto. <xref:System.Net.Sockets.SocketFlags> se pasan a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.  
  
O bien 
 <paramref name="remoteEP" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceptar conexiones desde la red. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que es la ubicación de almacenamiento para los datos recibidos.</param>
        <param name="size">Número de bytes que se va a recibir.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> que se pasa por referencia y que representa el servidor remoto.</param>
        <summary>Recibe el número especificado de bytes en el búfer de datos mediante el marcador <see cref="T:System.Net.Sockets.SocketFlags" /> especificado y almacena el extremo.</summary>
        <returns>Número de bytes recibidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lee datos en el `buffer` parámetro, devuelve el número de bytes leídos correctamente y captura el punto de conexión del host remoto desde el que se enviaron los datos. Este método es útil si desea recibir datagramas sin conexión de un host desconocido o varios hosts.  
  
 Esta sobrecarga sólo requiere que proporcione un búfer de recepción, el número de bytes que desea que reciban el necesario <xref:System.Net.Sockets.SocketFlags>y un <xref:System.Net.EndPoint> que representa el host remoto. El desplazamiento de búfer predeterminado es 0.  
  
 Con los protocolos sin conexión, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá el primer datagrama en cola recibido en el búfer de red local. Si el datagrama recibido es mayor que el tamaño de `buffer`, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método rellenará `buffer` con tanta información del mensaje como sea posible y throw un <xref:System.Net.Sockets.SocketException>. Si usa un protocolo no confiable, el exceso de datos se perderá. Si usa un protocolo confiable, el exceso de datos se conservarán por el proveedor de servicios y se puede recuperar llamando el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método con un búfer suficientemente grande.  
  
 Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método se bloqueará hasta que haya datos disponibles. Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>. Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura. Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.  
  
 Aunque <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> está pensado para protocolos sin conexión, puede usar un protocolo orientado a conexiones. Si decide hacerlo, primero debe establecer o una conexión de host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o acepte una instancia remota entrante hospedar conexión mediante una llamada a la <xref:System.Net.Sockets.Socket.Accept%2A> método. Si no se establece o se acepta una conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, obtendrá un <xref:System.Net.Sockets.SocketException>. También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. En cualquiera de estos casos, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método pasará por alto el `remoteEP` parámetro y solo recibirá datos conectado o host remoto predeterminado.  
  
 Con los sockets orientados a conexiones, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá tantos datos como está disponible hasta el número de bytes especificado por el `size` parámetro. Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y devolverá cero bytes.  
  
> [!NOTE]
>  Antes de llamar a <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, debe enlazar explícitamente el <xref:System.Net.Sockets.Socket> a un punto de conexión local con el <xref:System.Net.Sockets.Socket.Bind%2A> método. Si no, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  El <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> debe coincidir con el <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente recibe un datagrama sin conexión de un host remoto. El tamaño de búfer y <xref:System.Net.Sockets.SocketFlags> se pasan a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.  
  
O bien 
 <paramref name="remoteEP" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> es menor que 0.  
  
O bien 
 <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> no es una combinación válida de valores.  
  
O bien 
La propiedad <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> no se estableció.  
  
O bien 
Se produce un error de sistema operativo al acceder a <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceptar conexiones desde la red. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que es la ubicación de almacenamiento para los datos recibidos.</param>
        <param name="offset">Posición en el parámetro <paramref name="buffer" /> para almacenar los datos recibidos.</param>
        <param name="size">Número de bytes que se va a recibir.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> que se pasa por referencia y que representa el servidor remoto.</param>
        <summary>Recibe el número especificado de bytes de datos en la ubicación especificada del búfer de datos, mediante el <see cref="T:System.Net.Sockets.SocketFlags" /> especificado y almacena el punto de conexión.</summary>
        <returns>Número de bytes recibidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lee datos en el `buffer` parámetro, devuelve el número de bytes leídos correctamente y captura el punto de conexión del host remoto desde el que se enviaron los datos. Este método es útil si desea recibir datagramas sin conexión de un host desconocido o varios hosts.  
  
 Con los protocolos sin conexión, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá el primer datagrama en cola recibido en el búfer de red local. Si el datagrama recibido es mayor que el tamaño de `buffer`, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método rellenará `buffer` con tanta información del mensaje como sea posible y throw un <xref:System.Net.Sockets.SocketException>. Si usa un protocolo no confiable, el exceso de datos se perderá. Si usa un protocolo confiable, el exceso de datos se conservarán por el proveedor de servicios y se puede recuperar llamando el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método con un búfer suficientemente grande.  
  
 Si no hay datos disponibles para su lectura, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método se bloqueará hasta que haya datos disponibles. Si se encuentra en modo sin bloqueo y no hay ningún dato disponible en el en el búfer de pila de protocolo, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y producirá una <xref:System.Net.Sockets.SocketException>. Puede usar el <xref:System.Net.Sockets.Socket.Available%2A> propiedad para determinar si los datos están disponibles para su lectura. Cuando <xref:System.Net.Sockets.Socket.Available%2A> es distinto de cero, vuelva a intentar la operación de recepción.  
  
 Aunque <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> está pensado para protocolos sin conexión, puede usar un protocolo orientado a conexiones. Si decide hacerlo, primero debe establecer o una conexión de host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o acepte una instancia remota entrante hospedar conexión mediante una llamada a la <xref:System.Net.Sockets.Socket.Accept%2A> método. Si no se establece o se acepta una conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, obtendrá un <xref:System.Net.Sockets.SocketException>. También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. En cualquiera de estos casos, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método pasará por alto el `remoteEP` parámetro y solo recibirá datos conectado o host remoto predeterminado.  
  
 Con los sockets orientados a conexiones, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> leerá tantos datos como está disponible hasta la cantidad de bytes especificado por el `size` parámetro. Si el host remoto se apaga el <xref:System.Net.Sockets.Socket> conexión con el <xref:System.Net.Sockets.Socket.Shutdown%2A> se ha recibido el método y todos los datos disponibles, el <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método finalizará inmediatamente y devolverá cero bytes.  
  
> [!NOTE]
>  Antes de llamar a <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, debe enlazar explícitamente el <xref:System.Net.Sockets.Socket> a un punto de conexión local con el <xref:System.Net.Sockets.Socket.Bind%2A> método. Si no, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  El <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> debe coincidir con el <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente recibe un datagrama sin conexión de un host remoto. El desplazamiento, el tamaño del búfer y <xref:System.Net.Sockets.SocketFlags> se pasan a la <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.  
  
O bien 
 <paramref name="remoteEP" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> es menor que 0.  
  
O bien 
 <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.  
  
O bien 
 <paramref name="size" /> es menor que 0.  
  
O bien 
 <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro de desplazamiento.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> no es una combinación válida de valores.  
  
O bien 
La propiedad <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> no se estableció.  
  
O bien 
Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceptar conexiones desde la red. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</param>
        <summary>Comienza a recibir asincrónicamente los datos de un dispositivo de red especificado.</summary>
        <returns>Devuelve <see langword="true" /> si la operación de E/S está pendiente. Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.  
  
 Devuelve <see langword="false" /> si la operación de E/S se ha completado de forma sincrónica. En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> método se utiliza principalmente para recibir datos en un socket sin conexión. Debe conocer la dirección local del socket.  
  
 El llamador debe establecer el <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propiedad a la <xref:System.Net.IPEndPoint> del host remoto desde el que los datos son para recibirse.  
  
 El <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propiedad en el `e` parámetro proporciona el proveedor de servicios de Windows Sockets con información adicional sobre la solicitud de lectura. Para obtener más información sobre cómo usar este parámetro, vea <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios para llamar correctamente a este método:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada. Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.  
  
 Para los sockets orientados a mensajes, se coloca un mensaje entrante en el búfer hasta el tamaño total del búfer. El <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> y <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propiedades determinan dónde se colocan los datos en el búfer y la cantidad de datos.  
  
 Para los sockets de estilo de la secuencia de bytes, los datos entrantes se colocan en el búfer hasta que el búfer se llena, la conexión está cerrada o se agotan los datos almacenados en búfer internamente. El <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> y <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propiedades determinan dónde se colocan los datos en el búfer y la cantidad de datos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no puede ser null.</exception>
        <exception cref="T:System.InvalidOperationException">Ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Se requiere Windows XP o posteriores para este método.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que es la ubicación de almacenamiento para los datos recibidos.</param>
        <param name="offset">Posición en el parámetro <paramref name="buffer" /> para almacenar los datos recibidos.</param>
        <param name="size">Número de bytes que se va a recibir.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> que se pasa por referencia y que representa el servidor remoto.</param>
        <param name="ipPacketInformation"><see cref="T:System.Net.Sockets.IPPacketInformation" /> que contiene información de dirección e interfaz.</param>
        <summary>Recibe el número especificado de bytes de datos en la ubicación especificada del búfer de datos, mediante el elemento <see cref="T:System.Net.Sockets.SocketFlags" /> especificado y almacena el punto de conexión y la información del paquete.</summary>
        <returns>Número de bytes recibidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método lee datos en el `buffer` parámetro, devuelve el número de bytes leídos correctamente y captura el punto de conexión del host remoto desde el que se enviaron los datos, así como información sobre el paquete recibido.  
  
 El <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método se utiliza principalmente para recibir datos del mensaje en un socket sin conexión. Debe conocer la dirección local del socket. Este método solo se puede usar con datagrama y sockets básicos. El socket debe inicializarse con el tipo de socket establecido en <xref:System.Net.Sockets.SocketType.Dgram> o <xref:System.Net.Sockets.SocketType.Raw> antes de llamar a este método. Esto puede hacerse cuando el socket se construye utilizando <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Para los sockets orientados a mensajes, se coloca un mensaje entrante en el `buffer` parámetro hasta el tamaño total especificado en el `size` parámetro. El `offset` parámetro determina dónde en la `buffer` se colocan los datos. La cantidad de datos real se coloca en el `buffer` devuelto por la <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método.  
  
 El <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método automáticamente método establece el <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opción de socket `true` la primera vez que se llama para un determinado <xref:System.Net.Sockets.Socket>. Sin embargo, el valor devuelto <xref:System.Net.Sockets.IPPacketInformation> objeto solo será válido para los paquetes que llegan al equipo local una vez establecida la opción de socket. Si un socket se envía paquetes entre cuando se enlaza a un extremo local (explícitamente por el <xref:System.Net.Sockets.Socket.Bind%2A> método o implícitamente por uno de los <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, o <xref:System.Net.Sockets.Socket.SendToAsync%2A> métodos) y su primera llamada a la <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método, las llamadas a <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método devolverá válido <xref:System.Net.Sockets.IPPacketInformation> objetos para estos paquetes.  
  
 Para asegurarse de que todos los <xref:System.Net.Sockets.IPPacketInformation> objetos son válidos, una aplicación debe establecer el <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opción de socket `true` antes de que está enlazado a un punto de conexión local con el <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> método.  
  
 Una aplicación puede examinar la `ipPacketInformation` parámetro si es necesario saber si el datagrama se envió mediante una unidifusión, la dirección de difusión o multidifusión.  
  
> [!NOTE]
>  El <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> debe coincidir con el <xref:System.Net.Sockets.AddressFamily> de la <xref:System.Net.EndPoint> utilizados en <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.  
  
\- O bien, 
 <paramref name="remoteEP" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> es menor que 0.  
  
O bien 
 <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.  
  
O bien 
 <paramref name="size" /> es menor que 0.  
  
O bien 
 <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro de desplazamiento.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> no es una combinación válida de valores.  
  
O bien 
La propiedad <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> no se estableció.  
  
O bien 
.NET Framework se está ejecutando en procesador AMD de 64 bits.  
  
O bien 
Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.NotSupportedException">El sistema operativo es Windows 2000 o una versión anterior, y este método requiere Windows XP.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceptar conexiones desde la red. Enumeración asociada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</param>
        <summary>Comienza a recibir de forma asincrónica el número especificado de bytes de datos en la ubicación indicada del búfer de datos, mediante la propiedad <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> especificada, y almacena la información sobre el extremo y el paquete.</summary>
        <returns>Devuelve <see langword="true" /> si la operación de E/S está pendiente. Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.  
  
 Devuelve <see langword="false" /> si la operación de E/S se ha completado de forma sincrónica. En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método se utiliza principalmente para recibir datos del mensaje en un socket sin conexión. Debe conocer la dirección local del socket. Este método solo se puede usar con datagrama y sockets básicos. El socket debe inicializarse con el tipo de socket establecido en <xref:System.Net.Sockets.SocketType.Dgram> o <xref:System.Net.Sockets.SocketType.Raw> antes de llamar a este método. Esto puede hacerse cuando el socket se construye utilizando <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 El llamador debe establecer el <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propiedad a la <xref:System.Net.IPEndPoint> del host remoto desde el que los datos son para recibirse.  
  
 Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios para llamar correctamente a este método:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada. Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.  
  
 Para los sockets orientados a mensajes, se coloca un mensaje entrante en el búfer hasta el tamaño total del búfer. El <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> y <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propiedades determinan dónde se colocan los datos en el búfer y la cantidad de datos.  
  
 El <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método establece automáticamente la <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opción de socket `true` la primera vez que se llama para un determinado <xref:System.Net.Sockets.Socket>. Sin embargo, la <xref:System.Net.Sockets.IPPacketInformation> objeto solo será válido para los paquetes que llegan al equipo local una vez establecida la opción de socket. Si un socket se envía paquetes entre cuando se enlaza el socket a un punto de conexión local (explícitamente por el <xref:System.Net.Sockets.Socket.Bind%2A> método o implícitamente por uno de los <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, o <xref:System.Net.Sockets.Socket.SendToAsync%2A> métodos) y la primera llamada a la <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>método, las llamadas a <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método dará como resultado no es válido <xref:System.Net.Sockets.IPPacketInformation> objetos para estos paquetes.  
  
 Para asegurarse de que todos los <xref:System.Net.Sockets.IPPacketInformation> objetos son válidos, una aplicación debe establecer el <xref:System.Net.Sockets.SocketOptionName.PacketInformation> opción de socket`true` antes de que está enlazado a un punto de conexión local con el <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> método.  
  
 Una aplicación puede examinar los resultados <xref:System.Net.Sockets.IPPacketInformation> objetos si es necesario saber si el datagrama se envió mediante una unidifusión, la dirección de difusión o multidifusión.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no puede ser null.</exception>
        <exception cref="T:System.NotSupportedException">Se requiere Windows XP o posteriores para este método.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica el tiempo tras el que una llamada <see cref="Overload:System.Net.Sockets.Socket.Receive" /> sincrónica pasará a tiempo de espera.</summary>
        <value>El valor del tiempo de espera, en milisegundos. El valor predeterminado es 0, lo que indica un tiempo de espera infinito. Especificar -1 también indica un tiempo infinito.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta opción se aplica a sincrónico <xref:System.Net.Sockets.Socket.Receive%2A> sólo llamadas. Si se supera el tiempo de espera, el <xref:System.Net.Sockets.Socket.Receive%2A> método producirá una <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> propiedad.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor especificado para una operación Set es menor que -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el extremo remoto.</summary>
        <value><see cref="T:System.Net.EndPoint" /> con el que está comunicando el <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si usa un protocolo orientado a conexiones, el <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> procedimientos property get el <xref:System.Net.EndPoint> que contiene el número de puerto y dirección IP remoto a la que el <xref:System.Net.Sockets.Socket> está conectado. Si usa un protocolo sin conexión, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contiene la dirección IP remota de forma predeterminada y el número de puerto con el que el <xref:System.Net.Sockets.Socket> se comunicará. Debe convertir esta <xref:System.Net.EndPoint> a un <xref:System.Net.IPEndPoint> antes de recuperar toda la información. A continuación, puede llamar a la <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> método para recuperar el servidor remoto <xref:System.Net.IPAddress>y el <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> método para recuperar el número de puerto remoto.  
  
 El <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> se establece después de una llamada a <xref:System.Net.Sockets.Socket.Accept%2A> o <xref:System.Net.Sockets.Socket.Connect%2A>. Si intenta tener acceso a esta propiedad anteriormente, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se recupera y muestra los puntos de conexión locales y remotas.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="checkRead"><see cref="T:System.Collections.IList" /> de instancias <see cref="T:System.Net.Sockets.Socket" /> para comprobar la legibilidad.</param>
        <param name="checkWrite"><see cref="T:System.Collections.IList" /> de instancias <see cref="T:System.Net.Sockets.Socket" /> para comprobar la capacidad de escritura.</param>
        <param name="checkError"><see cref="T:System.Collections.IList" /> de instancias <see cref="T:System.Net.Sockets.Socket" /> para comprobar errores.</param>
        <param name="microSeconds">Valor del tiempo de espera, en microsegundos. Un valor de -1 indica un tiempo de espera infinito.</param>
        <summary>Determina el estado de uno o varios sockets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> es un método estático que determina el estado de uno o varios <xref:System.Net.Sockets.Socket> instancias. Debe colocar uno o varios sockets en un <xref:System.Collections.IList> antes de poder usar el <xref:System.Net.Sockets.Socket.Select%2A> método. Comprobar la legibilidad mediante una llamada a <xref:System.Net.Sockets.Socket.Select%2A> con el <xref:System.Collections.IList> como el `checkRead` parámetro. Para comprobar los sockets de escritura, use el `checkWrite` parámetro. Para detectar las condiciones de error, utilice `checkError`. Después de llamar a <xref:System.Net.Sockets.Socket.Select%2A>, el <xref:System.Collections.IList> se rellenará con sólo aquellos sockets que satisfacen las condiciones.  
  
 Si está en un estado de escucha, la legibilidad significa que una llamada a <xref:System.Net.Sockets.Socket.Accept%2A> se realizará correctamente sin bloquear. Si ya han aceptado la conexión, la legibilidad significa que los datos están disponibles para su lectura. En estos casos, todas las operaciones de recepción se realizará correctamente sin bloquear. La legibilidad también puede indicar si el servidor remoto <xref:System.Net.Sockets.Socket> se cerrado hacia la conexión; en ese caso una llamada a <xref:System.Net.Sockets.Socket.Receive%2A> se devolverá inmediatamente, con cero bytes devueltos.  
  
 <xref:System.Net.Sockets.Socket.Select%2A> devuelve cuando al menos uno de los sockets de interés (los sockets en el `checkRead`, `checkWrite`, y `checkError` enumera) cumpla con los criterios especificados, o el `microSeconds` parámetro se supera, lo que ocurra primero. Establecer `microSeconds` en -1 especifica un tiempo de espera infinito.  
  
 Si realiza una llamada sin bloqueo a <xref:System.Net.Sockets.Socket.Connect%2A>, escritura significa que se ha conectado correctamente. Si ya tiene una conexión establecida, escritura significa todos envíen las operaciones se realizará correctamente sin bloquear.  
  
 Si ha realizado una llamada sin bloqueo a <xref:System.Net.Sockets.Socket.Connect%2A>, el `checkerror` parámetro identifica sockets que no se han conectado correctamente.  
  
> [!NOTE]
>  Use la <xref:System.Net.Sockets.Socket.Poll%2A> método si desea determinar el estado de una sola <xref:System.Net.Sockets.Socket>.  
  
> [!NOTE]
>  Este método no puede detectar ciertos tipos de problemas de conexión, como un cable de red rota, o que el host remoto cierre brusco. Debe intentar enviar o recibir datos para detectar estos tipos de errores.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza <xref:System.Net.Sockets.Socket.Select%2A> para determinar qué sockets de escucha tienen una solicitud de conexión.  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="checkRead" /> es <see langword="null" /> o está vacío.  
  
- y - 
El parámetro <paramref name="checkWrite" /> es <see langword="null" /> o está vacío. 
- y - 
El parámetro <paramref name="checkError" /> es <see langword="null" /> o está vacío.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envía datos a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</param>
        <summary>Envía datos a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> envía datos de forma sincrónica al host remoto especificado en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método y devuelve el número de bytes enviado correctamente. <xref:System.Net.Sockets.Socket.Send%2A> puede usarse para protocolos orientados a conexiones y sin conexión.  
  
 Esta sobrecarga requiere un búfer que contiene los datos que desea enviar. El <xref:System.Net.Sockets.SocketFlags> valor predeterminado es 0, el desplazamiento de búfer predeterminado es 0 y el número de bytes que se envían los valores predeterminados para el tamaño del búfer.  
  
 Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método, o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.  
  
 Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar el <xref:System.Net.Sockets.Socket.SendTo%2A> método. Si no usa el <xref:System.Net.Sockets.Socket.SendTo%2A> método, tendrá que llamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada llamada a <xref:System.Net.Sockets.Socket.Send%2A>. Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>. También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envían todos los bytes del búfer, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>. En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía a menor que el número de bytes en el búfer. Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía los bytes del búfer. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  La finalización correcta de un envío no indica que los datos se ha entregado correctamente. Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el envío de datos en un conectado <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista de objetos <see cref="T:System.ArraySegment`1" /> de tipo <see cref="T:System.Byte" /> que contiene los datos que se han de enviar.</param>
        <summary>Envía el conjunto de búferes de la lista a un <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> puede usarse para protocolos orientados a conexiones y sin conexión.  
  
 Esta sobrecarga requiere al menos un búfer que contiene los datos que desea enviar.  
  
 Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método, o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.  
  
 Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar el <xref:System.Net.Sockets.Socket.SendTo%2A> método. Si no usa el <xref:System.Net.Sockets.Socket.SendTo%2A> método, tendrá que llamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada llamada a <xref:System.Net.Sockets.Socket.Send%2A>. Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>. También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envían todos los bytes del búfer, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>. En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía a menor que el número de bytes en el búfer. Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía los bytes del búfer. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  La finalización correcta de un envío no indica que los datos se ha entregado correctamente. Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> está vacía.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket. Vea la sección de comentarios que figura más abajo.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Envía datos a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado mediante el marcador <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> envía datos de forma sincrónica al host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método y devuelve el número de bytes enviado correctamente. El <xref:System.Net.Sockets.Socket.Send%2A> método puede utilizarse para protocolos orientados a conexiones y sin conexión.  
  
 Esta sobrecarga requiere un búfer que contiene los datos que desea enviar y una combinación bit a bit de <xref:System.Net.Sockets.SocketFlags>. El desplazamiento de búfer predeterminado es 0 y el número de bytes que se envían los valores predeterminados para el tamaño del búfer. Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` valor del parámetro, los datos que se envía no se enrutarán.  
  
 Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método, o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.  
  
 Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar el <xref:System.Net.Sockets.Socket.SendTo%2A> método. Si no usa el <xref:System.Net.Sockets.Socket.SendTo%2A> método, tendrá que llamar el <xref:System.Net.Sockets.Socket.Connect%2A> método antes de cada llamada a <xref:System.Net.Sockets.Socket.Send%2A>. Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>. También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envían todos los bytes del búfer, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>. En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía a menor que el número de bytes en el búfer. Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía el número de bytes solicitado. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
> [!NOTE]
>  Debe asegurarse de que el tamaño del búfer no supera el tamaño máximo de paquetes del proveedor de servicios subyacente. Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  La finalización correcta de un envío no indica que los datos se ha entregado correctamente. Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el envío de datos en un conectado <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista de objetos <see cref="T:System.ArraySegment`1" /> de tipo <see cref="T:System.Byte" /> que contiene los datos que se han de enviar.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Envía el conjunto de búferes de la lista a un <see cref="T:System.Net.Sockets.Socket" /> conectado, utilizando el <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga requiere al menos un búfer que contiene los datos que desea enviar. El <xref:System.Net.Sockets.SocketFlags> como valor predeterminado 0. Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketFlags` parámetro, los datos que se envía no se enrutarán.  
  
 Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método, o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.  
  
 Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar el <xref:System.Net.Sockets.Socket.SendTo%2A> método. Si no usa el <xref:System.Net.Sockets.Socket.SendTo%2A> método, tendrá que llamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada llamada a <xref:System.Net.Sockets.Socket.Send%2A>. Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>. También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envían todos los bytes del búfer, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>. En el modo sin bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía a menor que el número de bytes en el búfer. Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía los bytes del búfer. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  La finalización correcta de un envío no indica que los datos se ha entregado correctamente. Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> está vacía.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</param>
        <param name="size">Número de bytes para enviar.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Envía el número especificado de bytes de datos a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado, usando el marcador <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> envía datos de forma sincrónica al host remoto establecido en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método y devuelve el número de bytes enviado correctamente. <xref:System.Net.Sockets.Socket.Send%2A> puede usarse para protocolos orientados a conexiones y sin conexión.  
  
 Esta sobrecarga requiere un búfer que contiene los datos que desea enviar, el número de bytes que desea enviar y una combinación bit a bit de los <xref:System.Net.Sockets.SocketFlags>. Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.  
  
 Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método, o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.  
  
 Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar el <xref:System.Net.Sockets.Socket.SendTo%2A> método. Si no usa el <xref:System.Net.Sockets.Socket.SendTo%2A> método, tendrá que llamar el <xref:System.Net.Sockets.Socket.Connect%2A> método antes de cada llamada a la <xref:System.Net.Sockets.Socket.Send%2A> método. Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>. También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Con un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envía el número de bytes solicitado, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>. En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía menor que el número de bytes que se solicite. Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía el número de bytes solicitado. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
> [!NOTE]
>  Debe asegurarse de que el tamaño no supera el tamaño máximo de paquetes del proveedor de servicios subyacente. Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  La finalización correcta de un envío no indica que los datos se ha entregado correctamente. Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente envía los datos que se encuentra en el búfer y especifica <xref:System.Net.Sockets.SocketFlags.None> para <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> es menor que 0 o supera el tamaño del búfer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> no es una combinación válida de valores.  
  
O bien 
Se produce un error del sistema operativo al tener acceso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Lista de objetos <see cref="T:System.ArraySegment`1" /> de tipo <see cref="T:System.Byte" /> que contiene los datos que se han de enviar.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</param>
        <summary>Envía el conjunto de búferes de la lista a un <see cref="T:System.Net.Sockets.Socket" /> conectado, utilizando el <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga requiere al menos un búfer que contiene los datos que desea enviar. El <xref:System.Net.Sockets.SocketFlags> como valor predeterminado 0. Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketFlags` parámetro, los datos que se envía no se enrutarán.  
  
 Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método, o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.  
  
 Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar el <xref:System.Net.Sockets.Socket.SendTo%2A> método. Si no usa el <xref:System.Net.Sockets.Socket.SendTo%2A> método, tendrá que llamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada llamada a <xref:System.Net.Sockets.Socket.Send%2A>. Puede usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>. También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envían todos los bytes del búfer, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>. En el modo sin bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía a menor que el número de bytes en el búfer. Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía los bytes del búfer. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  La finalización correcta de un envío no indica que los datos se ha entregado correctamente. Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> está vacía.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</param>
        <param name="offset">Posición en el búfer de datos donde comienza el envío de datos.</param>
        <param name="size">Número de bytes para enviar.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Envía el número especificado de bytes de datos a un <see cref="T:System.Net.Sockets.Socket" /> conectado, comenzando en el desplazamiento especificado y usando el <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> envía datos de forma sincrónica al host remoto especificado en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método y devuelve el número de bytes enviado correctamente. <xref:System.Net.Sockets.Socket.Send%2A> puede usarse para protocolos orientados a conexiones y sin conexión.  
  
 En esta sobrecarga, si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.  
  
 Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.  
  
 Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar <xref:System.Net.Sockets.Socket.SendTo%2A>. Si no usas <xref:System.Net.Sockets.Socket.SendTo%2A>, tendrá que llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada llamada a <xref:System.Net.Sockets.Socket.Send%2A>. No pasa nada por usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>. También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 También debe asegurarse de que el tamaño no supera el tamaño máximo de paquetes del proveedor de servicios subyacente. Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
 Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envía el número de bytes solicitado, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>. En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía menor que el número de bytes que se solicite. Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía el número de bytes solicitado. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  La finalización correcta de un envío no indica que los datos se ha entregado correctamente. Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente especifica el búfer de datos, un desplazamiento, un tamaño, y <xref:System.Net.Sockets.SocketFlags> para enviar datos a una conectada <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> es menor que 0.  
  
O bien 
 <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.  
  
O bien 
 <paramref name="size" /> es menor que 0.  
  
O bien 
 <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> no es una combinación válida de valores.  
  
O bien 
Se produce un error de sistema operativo al acceder a <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</param>
        <param name="offset">Posición en el búfer de datos donde comienza el envío de datos.</param>
        <param name="size">Número de bytes para enviar.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Objeto <see cref="T:System.Net.Sockets.SocketError" /> que almacena el error de socket.</param>
        <summary>Envía el número especificado de bytes de datos a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado, a partir de la posición de desplazamiento especificada y usando el valor de <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>Número de bytes enviados a <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> envía datos de forma sincrónica al host remoto especificado en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método y devuelve el número de bytes enviado correctamente. <xref:System.Net.Sockets.Socket.Send%2A> puede usarse para protocolos orientados a conexiones y sin conexión.  
  
 En esta sobrecarga, si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.  
  
 Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método o <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>. Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.  
  
 Si usa un protocolo sin conexión y un plan para enviar datos a varios hosts diferentes, debe usar <xref:System.Net.Sockets.Socket.SendTo%2A>. Si no usas <xref:System.Net.Sockets.Socket.SendTo%2A>, tendrá que llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada llamada a <xref:System.Net.Sockets.Socket.Send%2A>. No pasa nada por usar <xref:System.Net.Sockets.Socket.SendTo%2A> incluso después de haber establecido un host remoto predeterminado mediante <xref:System.Net.Sockets.Socket.Connect%2A>. También puede cambiar el host remoto predeterminado antes de llamar a <xref:System.Net.Sockets.Socket.Send%2A> mediante otra llamada a <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 También debe asegurarse de que el tamaño no supera el tamaño máximo de paquetes del proveedor de servicios subyacente. Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.Send%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
 Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.Send%2A> se bloqueará hasta que se envía el número de bytes solicitado, a menos que se haya establecido un tiempo de espera mediante <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Si se ha superado el valor de tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> llamada producirá un <xref:System.Net.Sockets.SocketException>. En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.Send%2A> puede completarse correctamente incluso si envía menor que el número de bytes que se solicite. Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía el número de bytes solicitado. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.Send%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  La finalización correcta de un envío no indica que los datos se ha entregado correctamente. Si no hay espacio de búfer disponible dentro del sistema de transporte para contener los datos que se transmitan, envío bloqueará a menos que el socket se ha colocado en el modo de no bloqueo.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente especifica el búfer de datos, un desplazamiento, un tamaño, y <xref:System.Net.Sockets.SocketFlags> para enviar datos a una conectada <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> es menor que 0.  
  
O bien 
 <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.  
  
O bien 
 <paramref name="size" /> es menor que 0.  
  
O bien 
 <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> no es una combinación válida de valores.  
  
O bien 
Se produce un error de sistema operativo al acceder a <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</param>
        <summary>Envía datos de forma asincrónica a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Devuelve <see langword="true" /> si la operación de E/S está pendiente. Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.  
  
 Devuelve <see langword="false" /> si la operación de E/S se ha completado de forma sincrónica. En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.SendAsync%2A> método se utiliza para escribir los datos salientes de uno o varios búferes en un socket orientado a conexiones. Este método puede utilizarse también, sin embargo, en sockets sin conexión que han especificado un host remoto en una operación de conexión.  
  
 El <xref:System.Net.Sockets.Socket.SendAsync%2A> método inicia una operación de envío asincrónico para el host remoto establecido en el <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método.  
  
 Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios para llamar correctamente a este método:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> o <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está establecido  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Si <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está establecido  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.SendAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada. Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.  
  
 El <xref:System.Net.Sockets.Socket.SendAsync%2A> método producirá una excepción si no se llama primero <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.  
  
 Una llamada a la <xref:System.Net.Sockets.Socket.SendAsync%2A> método le permite enviar datos en un subproceso de ejecución independiente.  
  
 Para los sockets orientados a mensajes, no superar el tamaño máximo del mensaje del proveedor de servicios de Windows sockets subyacente. Si los datos están demasiado largos para pasar de forma atómica a través del proveedor de servicio subyacente, no hay datos se transmiten y el <xref:System.Net.Sockets.Socket.SendAsync%2A> método produce una <xref:System.Net.Sockets.SocketException> con el <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> establecido en el código de error de Winsock WSAEMSGSIZE (10040) nativo.  
  
 Tenga en cuenta que la finalización correcta de la <xref:System.Net.Sockets.Socket.SendAsync%2A> método no indica que los datos se ha entregado correctamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Las propiedades <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> del parámetro <paramref name="e" /> deben hacer referencia a los búferes válidos. Se puede establecer una de estas propiedades, pero no ambas al mismo tiempo.</exception>
        <exception cref="T:System.InvalidOperationException">Ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Se requiere Windows XP o posteriores para este método.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">El <see cref="T:System.Net.Sockets.Socket" /> no está conectado todavía o no se obtuvo a través de un método <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> o <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica el tamaño del búfer de envío de <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value><see cref="T:System.Int32" /> que contiene el tamaño, en bytes, del búfer de envío. El valor predeterminado es 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un tamaño de búfer mayor puede retrasar el reconocimiento de las dificultades de conexión. Considere la posibilidad de aumentar el tamaño del búfer si va a transferir archivos grandes o usa un ancho de banda alto, la conexión de latencia alta (por ejemplo, un proveedor por satélite banda ancha.)  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.SendBufferSize%2A> propiedad.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor especificado para una operación de establecimiento es menor que 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envía, de forma sincrónica, un archivo y datos opcionales a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><see cref="T:System.String" /> que contiene la ruta de acceso y el nombre del archivo que se va a enviar. Este parámetro puede ser <see langword="null" />.</param>
        <summary>Envía el archivo <paramref name="fileName" /> a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado con el marcador de transmisión <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga envía el archivo `fileName` al socket conectado. El `flags` parámetro el valor predeterminado es <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0) y el `preBuffer` y `postBuffer` parámetros de forma predeterminada `null`. Si `fileName` está en el directorio local, puede identificarse con solo el nombre del archivo; en caso contrario, se deben especificar la ruta de acceso completa y el nombre del archivo. Los caracteres comodín (".. \\\myfile.txt ") y nombres de recurso compartido UNC ("\\\\\\\shared directory\\\myfile.txt ") son compatibles. Si el archivo no se encuentra, la excepción <xref:System.IO.FileNotFoundException> se produce.  
  
 Este método usa la `TransmitFile` encuentra la función de la API de Windows Sockets 2. Para obtener más información sobre la `TransmitFile` función y sus marcas, vea el [Windows Sockets](/windows/desktop/WinSock/) documentación.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> envía un archivo de forma sincrónica al host remoto especificado en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método. <xref:System.Net.Sockets.Socket.SendFile%2A> puede usarse para ambos orientados a conexiones y protocolos sin conexión.  
  
 Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método, de lo contrario <xref:System.Net.Sockets.Socket.SendFile%2A> produce una <xref:System.Net.Sockets.SocketException> excepción. Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión al host remoto o usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.  
  
 Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.SendFile%2A> bloquea hasta que se envía el archivo. En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.SendFile%2A> puede completarse correctamente antes de que todo el archivo se ha enviado. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.SendFile%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea y se conecta a un socket y, a continuación, envía un archivo con el host remoto. El archivo "test.txt" se encuentra en el directorio raíz de la máquina local.  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El socket no está conectado a un host remoto.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">El objeto <see cref="T:System.Net.Sockets.Socket" /> no está en modo de bloqueo y no puede aceptar esta llamada sincrónica.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo <paramref name="fileName" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><see cref="T:System.String" /> que contiene la ruta de acceso y el nombre del archivo que se va a enviar. Este parámetro puede ser <see langword="null" />.</param>
        <param name="preBuffer">Una matriz <see cref="T:System.Byte" /> que contiene los datos que se van a enviar antes de enviar el archivo. Este parámetro puede ser <see langword="null" />.</param>
        <param name="postBuffer">Una matriz <see cref="T:System.Byte" /> que contiene los datos que se van a enviar después de enviar el archivo. Este parámetro puede ser <see langword="null" />.</param>
        <param name="flags">Uno o varios de los valores <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</param>
        <summary>Envía el archivo <paramref name="fileName" /> y búferes de datos a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado mediante el valor <see cref="T:System.Net.Sockets.TransmitFileOptions" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga requiere el nombre del archivo que desea enviar y una combinación bit a bit de <xref:System.Net.Sockets.TransmitFileOptions> valores. El `preBuffer` parámetro contiene todos los datos debe preceder el archivo. `postBuffer` contiene los datos que desea que siga el archivo. Si `fileName` está en el directorio de trabajo actual, puede identificarse con solo el nombre del archivo; en caso contrario, se deben especificar la ruta de acceso completa y el nombre del archivo. Los caracteres comodín (".. \\\myfile.txt ") y nombres de recurso compartido UNC ("\\\\\\\shared directory\\\myfile.txt ") son compatibles.  
  
 El `flags` parámetro proporciona el proveedor de servicios de Windows Sockets con información adicional sobre la transferencia de archivos. Para obtener más información sobre cómo usar este parámetro, vea <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Este método usa la `TransmitFile` encuentra la función de la API de Windows Sockets 2. Para obtener más información sobre la `TransmitFile` función y sus marcas, vea el [Windows Sockets](/windows/desktop/WinSock/) documentación.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> envía un archivo de forma sincrónica al host remoto especificado en el <xref:System.Net.Sockets.Socket.Connect%2A> o <xref:System.Net.Sockets.Socket.Accept%2A> método. <xref:System.Net.Sockets.Socket.SendFile%2A> puede usarse para ambos orientados a conexiones y protocolos sin conexión.  
  
 Si usa un protocolo sin conexión, debe llamar a <xref:System.Net.Sockets.Socket.Connect%2A> antes de llamar a este método; en caso contrario <xref:System.Net.Sockets.Socket.SendFile%2A> produce una <xref:System.Net.Sockets.SocketException>. Si utiliza un protocolo orientado a conexiones, debe usar <xref:System.Net.Sockets.Socket.Connect%2A> para establecer una conexión de host remoto, o use <xref:System.Net.Sockets.Socket.Accept%2A> para aceptar una conexión entrante.  
  
 Si usa un protocolo orientado a conexiones, <xref:System.Net.Sockets.Socket.SendFile%2A> bloquea hasta que se envía el archivo completo. En el modo de no bloqueo, <xref:System.Net.Sockets.Socket.SendFile%2A> puede completarse correctamente antes de que todo el archivo se ha enviado. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.SendFile%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea y se conecta a un socket. El archivo "test.txt" se encuentra en el directorio raíz de la máquina local. En este ejemplo, crearemos un búfer y tamaño de postbuffer de datos y enviarlos al host remoto con el archivo. El valor predeterminado <xref:System.Net.Sockets.TransmitFileOptions> se usan.  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El sistema operativo no es Windows NT o una versión posterior.  
  
O bien 
El socket no está conectado a un host remoto.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">El objeto <see cref="T:System.Net.Sockets.Socket" /> no está en modo de bloqueo y no puede aceptar esta llamada sincrónica.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo <paramref name="fileName" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</param>
        <summary>Envía de forma asincrónica una colección de archivos o búferes de datos en memoria a un objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Devuelve <see langword="true" /> si la operación de E/S está pendiente. Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.  
  
 Devuelve <see langword="false" /> si la operación de E/S se ha completado de forma sincrónica. En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método se usa para enviar los búferes de datos de una colección de archivos o en la memoria al host remoto. El <xref:System.Net.Sockets.Socket> ya debe estar conectado al host remoto.  
  
 Si un <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> hace referencia a un archivo en el directorio de trabajo, que se puede identificar con solo el nombre del archivo; en caso contrario, se deben especificar la ruta de acceso completa y el nombre del archivo. Se admiten caracteres comodín y nombres de recurso compartido UNC. Si no se encuentra el archivo, <xref:System.IO.FileNotFoundException> se produce.  
  
 Para recibir una notificación de finalización, debe crear un método de devolución de llamada que implementa el delegado EventHandler\<SocketAsyncEventArgs > delegar y adjuntar la devolución de llamada la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> eventos.  
  
 El <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> propiedad en el `e` parámetro proporciona el proveedor de servicios de Windows Sockets con información adicional sobre la transferencia de archivos. Para obtener más información sobre cómo usar este parámetro, vea <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios para llamar correctamente a este método:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada. Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.  
  
 Este método usa la función TransmitPackets de la API de Windows Sockets 2. Para obtener más información acerca de la función TransmitPackets y sus marcadores, vea el [Windows Sockets](/windows/desktop/WinSock/) documentación.  
  
 Si bien pensado para protocolos orientados a conexiones, el <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método funciona para los protocolos sin conexión, siempre que se llama primero a la <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método para establecer un host remoto predeterminado. Protocolos sin conexión, también debe asegurarse de que el tamaño del archivo no supera el tamaño máximo de paquetes del proveedor de servicios subyacente. Si es así, no se envía el datagrama y <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> produce una <xref:System.Net.Sockets.SocketException> excepción.  
  
 El <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> se optimiza el método según el sistema operativo en el que se utiliza. En las ediciones de Windows server, el <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método está optimizado para alto rendimiento.  
  
 En las ediciones del cliente de Windows, el <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método está optimizado para la utilización de memoria y los recursos mínima.  
  
 El uso de la <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> marca en el <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> propiedad en el `e` parámetro puede ofrecer ventajas significativas de rendimiento. Si el subproceso iniciando el <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> llamada al método es que se usa para cálculos complejos, es posible, aunque improbable, que se podrían evitar APC inicio. Tenga en cuenta que hay una diferencia entre las APC del núcleo y modo de usuario. APC de kernel se inician cuando un subproceso está en un estado de espera. APC de modo de usuario se inician cuando un subproceso está en un estado de espera de alerta  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró el archivo especificado en la propiedad <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Se requiere Windows XP o posteriores para este método. Esta excepción también se produce si <see cref="T:System.Net.Sockets.Socket" /> no está conectado a un host remoto.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se está usando un <see cref="T:System.Net.Sockets.Socket" /> sin conexión y el archivo que se está enviando supera el tamaño de paquete máximo del transporte subyacente.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica el tiempo tras el que una llamada <see cref="Overload:System.Net.Sockets.Socket.Send" /> sincrónica pasará a tiempo de espera.</summary>
        <value>El valor del tiempo de espera, en milisegundos. Si establece la propiedad con un valor comprendido entre 1 y 499, el valor cambiará a 500. El valor predeterminado es 0, lo que indica un tiempo de espera infinito. Especificar -1 también indica un tiempo infinito.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta opción se aplica a sincrónico <xref:System.Net.Sockets.Socket.Send%2A> sólo llamadas. Si se supera el tiempo de espera, el <xref:System.Net.Sockets.Socket.Send%2A> método producirá una <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.SendTimeout%2A> propiedad.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor especificado para una operación Set es menor que -1.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envía datos a un extremo específico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> que representa el destino de los datos.</param>
        <summary>Envía los datos al extremo especificado.</summary>
        <returns>Número de bytes enviados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En esta sobrecarga, el desplazamiento de búfer predeterminado es 0, el número de bytes que se envían los valores predeterminados para el tamaño de la `buffer` parámetro y el <xref:System.Net.Sockets.SocketFlags> como valor predeterminado 0.  
  
 Si usa un protocolo sin conexión, no es necesario establecer un host remoto predeterminado mediante el <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>. Solo deberá hacer esto si va a llamar a la <xref:System.Net.Sockets.Socket.Send%2A> método. Si se llama a la <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>, el `remoteEP` parámetro reemplazará el host remoto predeterminado especificado para que sólo la operación de envío. También no es necesario llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método, porque el proveedor de servicios subyacente asignará el número de puerto y la dirección de red local más adecuado. Si tiene que identificar el número de puerto y dirección de red local asignado, puede usar el <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propiedad después de la <xref:System.Net.Sockets.Socket.SendTo%2A> método se completa correctamente.  
  
 Si bien pensado para protocolos sin conexión, <xref:System.Net.Sockets.Socket.SendTo%2A> también funciona con los protocolos orientados a conexiones. Si utiliza un protocolo orientado a conexiones, primero debe establecer una conexión con el host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o Aceptar una solicitud de conexión entrantes mediante la <xref:System.Net.Sockets.Socket.Accept%2A> método. Si no se establece o se acepta una conexión de host remoto, <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>. También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.SendTo%2A> método. En cualquiera de estos casos, <xref:System.Net.Sockets.Socket.SendTo%2A> pasará por alto el `remoteEP` parámetro y solo envía datos a conectado o host remoto predeterminado.  
  
 Los sockets de bloqueo se bloquearán hasta que se envían todos los bytes del búfer. Puesto que una sin bloqueo <xref:System.Net.Sockets.Socket> se completa inmediatamente, es posible que no envíe todos los bytes en el `buffer`. Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía todos los bytes en el `buffer`. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
 Si usa un protocolo sin conexión en modo de bloqueo, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloqueará hasta que se envíe el datagrama. Si desea enviar datos a una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. También debe asegurarse de que el número de bytes enviados no supera el tamaño de paquete máximo del proveedor de servicios subyacente. Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se envía un datagrama sin conexión al host remoto especificado.  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.  
  
O bien 
 <paramref name="remoteEP" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> que representa la ubicación de destino de los datos.</param>
        <summary>Envía datos a un extremo específico mediante el marcador <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>Número de bytes enviados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En esta sobrecarga, el desplazamiento de búfer predeterminado es 0 y el número de bytes que se envían los valores predeterminados para el tamaño de la `buffer`. Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.  
  
 Si usa un protocolo sin conexión, no es necesario establecer un host remoto predeterminado mediante el <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>. Solo deberá hacer esto si va a llamar a la <xref:System.Net.Sockets.Socket.Send%2A> método. Si se llama a la <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>, el `remoteEP` parámetro reemplazará el host remoto predeterminado especificado para que sólo la operación de envío. También no es necesario llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método, porque el proveedor de servicios subyacente asignará el número de puerto y la dirección de red local más adecuado. Si tiene que identificar el número de puerto y dirección de red local asignado, puede usar el <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propiedad después de la <xref:System.Net.Sockets.Socket.SendTo%2A> método se completa correctamente.  
  
 Si bien pensado para protocolos sin conexión, <xref:System.Net.Sockets.Socket.SendTo%2A> también funciona con los protocolos orientados a conexiones. Si utiliza un protocolo orientado a conexiones, primero debe establecer una conexión con el host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o Aceptar una solicitud de conexión entrantes mediante la <xref:System.Net.Sockets.Socket.Accept%2A> método. Si no se establece o se acepta una conexión de host remoto, <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>. También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.SendTo%2A> método. En cualquiera de estos casos, <xref:System.Net.Sockets.Socket.SendTo%2A> pasará por alto el `remoteEP` parámetro y solo envía datos a conectado o host remoto predeterminado.  
  
 Los sockets de bloqueo se bloquearán hasta que el solicitado todos los bytes en el `buffer` se envían. Puesto que una sin bloqueo <xref:System.Net.Sockets.Socket> se completa inmediatamente, es posible que no envíe todos los bytes en el `buffer`. Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía todos los bytes en el `buffer`. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
 Si usa un protocolo sin conexión en modo de bloqueo, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloqueará hasta que se envíe el datagrama. Si desea enviar datos a una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. También debe asegurarse de que el número de bytes enviados no supera el tamaño de paquete máximo del proveedor de servicios subyacente. Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se envía un datagrama sin conexión al host remoto especificado. <xref:System.Net.Sockets.SocketFlags> se pasan a la <xref:System.Net.Sockets.Socket.SendTo%2A> método.  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.  
  
O bien 
 <paramref name="remoteEP" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</param>
        <param name="size">Número de bytes para enviar.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> que representa la ubicación de destino de los datos.</param>
        <summary>Envía el número especificado de bytes de datos al extremo especificado usando los <see cref="T:System.Net.Sockets.SocketFlags" /> especificados.</summary>
        <returns>Número de bytes enviados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En esta sobrecarga, el desplazamiento de búfer predeterminado es 0. Si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.  
  
 Si usa un protocolo sin conexión, no es necesario establecer un host remoto predeterminado mediante el <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>. Solo deberá hacer esto si va a llamar a la <xref:System.Net.Sockets.Socket.Send%2A> método. Si se llama a la <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>, el `remoteEP` parámetro reemplazará el host remoto predeterminado especificado para que sólo la operación de envío. También no es necesario llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método, porque el proveedor de servicios subyacente asignará el número de puerto y la dirección de red local más adecuado. Si tiene que identificar el número de puerto y dirección de red local asignado, puede usar el <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propiedad después de la <xref:System.Net.Sockets.Socket.SendTo%2A> método se completa correctamente.  
  
 Si bien pensado para protocolos sin conexión, <xref:System.Net.Sockets.Socket.SendTo%2A> también funciona con los protocolos orientados a conexiones. Si utiliza un protocolo orientado a conexiones, primero debe establecer una conexión con el host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o Aceptar una solicitud de conexión entrantes mediante la <xref:System.Net.Sockets.Socket.Accept%2A> método. Si no se establece o se acepta una conexión de host remoto, <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>. También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.SendTo%2A> método. En cualquiera de estos casos, <xref:System.Net.Sockets.Socket.SendTo%2A> pasará por alto el `remoteEP` parámetro y solo envía datos a conectado o host remoto predeterminado.  
  
 Los sockets de bloqueo se bloquearán hasta que se envía el número de bytes solicitado. Puesto que una sin bloqueo <xref:System.Net.Sockets.Socket> se completa inmediatamente, es posible que no envíe todos los bytes solicitados en una sola operación. Es responsabilidad de la aplicación para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía el número de bytes solicitado. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
 Si usa un protocolo sin conexión en modo de bloqueo, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloqueará hasta que se envíe el datagrama. Si desea enviar datos a una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. También debe asegurarse de que el número de bytes enviados no supera el tamaño de paquete máximo del proveedor de servicios subyacente. Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se envía un datagrama sin conexión al host remoto especificado. El tamaño y <xref:System.Net.Sockets.SocketFlags> se pasan a la <xref:System.Net.Sockets.Socket.SendTo%2A> método.  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.  
  
O bien 
 <paramref name="remoteEP" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="size" /> especificado sobrepasa el tamaño de <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de tipo <see cref="T:System.Byte" /> que contiene los datos que se van a enviar.</param>
        <param name="offset">Posición en el búfer de datos donde comienza el envío de datos.</param>
        <param name="size">Número de bytes para enviar.</param>
        <param name="socketFlags">Combinación bit a bit de los valores de <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" /> que representa la ubicación de destino de los datos.</param>
        <summary>Envía el número especificado de bytes de datos al extremo especificado, comenzando en la ubicación especificada del búfer y usando los <see cref="T:System.Net.Sockets.SocketFlags" /> especificados.</summary>
        <returns>Número de bytes enviados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En esta sobrecarga, si especifica la <xref:System.Net.Sockets.SocketFlags.DontRoute> marca como el `socketflags` parámetro, los datos que se envía no se enrutarán.  
  
 Si usa un protocolo sin conexión, no es necesario establecer un host remoto predeterminado mediante el <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>. Solo deberá hacer esto si va a llamar a la <xref:System.Net.Sockets.Socket.Send%2A> método. Si se llama a la <xref:System.Net.Sockets.Socket.Connect%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendTo%2A>, el `remoteEP` parámetro reemplazará el host remoto predeterminado especificado para que sólo la operación de envío. También no es necesario llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método, porque el proveedor de servicios subyacente asignará el número de puerto y la dirección de red local más adecuado. Si tiene que identificar el número de puerto y dirección de red local asignado, puede usar el <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propiedad después de la <xref:System.Net.Sockets.Socket.SendTo%2A> método se completa correctamente.  
  
 Si bien pensado para protocolos sin conexión, <xref:System.Net.Sockets.Socket.SendTo%2A> también funciona con los protocolos orientados a conexiones. Si utiliza un protocolo orientado a conexiones, primero debe establecer una conexión con el host remoto mediante una llamada a la <xref:System.Net.Sockets.Socket.Connect%2A> método o Aceptar una solicitud de conexión entrantes mediante la <xref:System.Net.Sockets.Socket.Accept%2A> método. Si no se establece o se acepta una conexión de host remoto, <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>. También puede establecer un host remoto predeterminado para un protocolo sin conexión antes de llamar a la <xref:System.Net.Sockets.Socket.SendTo%2A> método. En cualquiera de estos casos, <xref:System.Net.Sockets.Socket.SendTo%2A> pasará por alto el `remoteEP` parámetro y solo envía datos a conectado o host remoto predeterminado.  
  
 Los sockets de bloqueo se bloquearán hasta que se envía el número de bytes solicitado. Desde sin bloqueo <xref:System.Net.Sockets.Socket> se completa inmediatamente, es posible que no envíe todos los bytes solicitados en una sola operación. Es su responsabilidad de las aplicaciones para mantener el seguimiento del número de bytes enviados y vuelva a intentar la operación hasta que la aplicación envía el número de bytes solicitado. No hay ninguna garantía de que los datos que envíe aparecerán en la red inmediatamente. Para aumentar la eficacia de la red, el sistema subyacente podría retrasar la transmisión hasta que se recopila una cantidad significativa de datos salientes. La finalización correcta de la <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que el sistema subyacente disponía de suficiente espacio en búfer los datos de una red de envío.  
  
 Si usa un protocolo sin conexión en modo de bloqueo, <xref:System.Net.Sockets.Socket.SendTo%2A> se bloqueará hasta que se envíe el datagrama. Si desea enviar datos a una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opción de método y establezca el socket <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. También debe asegurarse de que el tamaño no supera el tamaño máximo de paquetes del proveedor de servicios subyacente. Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.SendTo%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se envía un datagrama sin conexión al host remoto especificado. El desplazamiento, el tamaño y <xref:System.Net.Sockets.SocketFlags> se pasan a la <xref:System.Net.Sockets.Socket.SendTo%2A> método.  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.  
  
O bien 
 <paramref name="remoteEP" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> es menor que 0.  
  
O bien 
 <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.  
  
O bien 
 <paramref name="size" /> es menor que 0.  
  
O bien 
 <paramref name="size" /> es mayor que la longitud de <paramref name="buffer" /> menos el valor del parámetro <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> no es una combinación válida de valores.  
  
O bien 
Se produce un error de sistema operativo al acceder a <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene los permisos necesarios.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> que se usa para esta operación de socket asincrónica.</param>
        <summary>Envía datos de forma asincrónica a un host remoto concreto.</summary>
        <returns>Devuelve <see langword="true" /> si la operación de E/S está pendiente. Al completar la operación se provoca el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" />.  
  
 Devuelve <see langword="false" /> si la operación de E/S se ha completado de forma sincrónica. En ese caso, el evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> del parámetro <paramref name="e" /> no se provoca y el objeto <paramref name="e" /> que se pasa como parámetro puede examinarse inmediatamente después de que se devuelva la llamada al método para recuperar el resultado de la operación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.SendToAsync%2A> método inicia una operación de envío asincrónico al host remoto especificado en el <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propiedad de la `e` parámetro. Una llamada a la <xref:System.Net.Sockets.Socket.SendToAsync%2A> método le permite enviar datos en un subproceso de ejecución independiente. Aunque este método está pensado para protocolos sin conexión, <xref:System.Net.Sockets.Socket.SendToAsync%2A> funciona con los protocolos sin conexión y orientados a conexiones.  
  
 Para recibir una notificación de finalización, debe crear un método de devolución de llamada que implementa el delegado EventHandler\<SocketAsyncEventArgs > delegar y adjuntar la devolución de llamada la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> eventos.  
  
 Las siguientes propiedades y eventos en el <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto son necesarios para llamar correctamente a este método:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 El llamador puede establecer la <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propiedad para cualquier objeto de estado de usuario deseado antes de llamar a la <xref:System.Net.Sockets.Socket.SendToAsync%2A> método, por lo que la información pueda recuperarse en el método de devolución de llamada. Si la devolución de llamada, necesita más información que un único objeto, puede crearse una pequeña clase para contener el resto de información de estado necesaria como miembros.  
  
 Si utiliza un protocolo orientado a conexiones, primero debe llamar a la <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método. En caso contrario <xref:System.Net.Sockets.Socket.SendToAsync%2A> producirá un <xref:System.Net.Sockets.SocketException>. Cuando se usa un protocolo orientado a conexiones, el <xref:System.Net.Sockets.Socket.SendToAsync%2A> método pasará por alto el <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propiedad y envía los datos a la <xref:System.Net.EndPoint?displayProperty=nameWithType> establecidos en el <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A> , o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método.  
  
 Si usa un protocolo sin conexión, no es necesario establecer un host remoto predeterminado mediante el <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendToAsync%2A>. Solo deberá hacer esto si va a llamar a la <xref:System.Net.Sockets.Socket.BeginSend%2A> o <xref:System.Net.Sockets.Socket.SendAsync%2A> métodos. Si se llama a la <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método antes de llamar a <xref:System.Net.Sockets.Socket.SendToAsync%2A>, el <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propiedad invalidará el host remoto predeterminado especificado para que sólo la operación de envío. También no es necesario llamar a la <xref:System.Net.Sockets.Socket.Bind%2A> método. En este caso, el proveedor de servicios subyacente asignará al más adecuado número de puerto y dirección de la IP red local. Use un número de puerto de cero si desea que el proveedor de servicios subyacente para seleccionar un puerto libre. Si tiene que identificar el número de puerto y dirección IP de red local asignado, puede usar el <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propiedad después de la <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> señala el evento y se llaman a los delegados asociados.  
  
 Si desea enviar datos a una dirección de difusión, primero debe llamar a la <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método y establezca el socket opción <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> en true. También debe asegurarse de que el tamaño del búfer no supera el tamaño máximo de paquetes del proveedor de servicios subyacente. Si es así, no se enviará el datagrama y <xref:System.Net.Sockets.Socket.SendToAsync%2A> producirá un <xref:System.Net.Sockets.SocketException>.  
  
 Si especifica el marcador DontRoute en el <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propiedad, los datos que se envía no se enrutarán.  
  
 Para los sockets orientados a mensajes, debe tener cuidado para no superar el tamaño máximo del mensaje del transporte subyacente. Si el tamaño del búfer supera el tamaño máximo de paquetes del proveedor de servicios subyacente, no se envía el datagrama y <xref:System.Net.Sockets.Socket.SendToAsync%2A> producirá un <xref:System.Net.Sockets.SocketException>. La finalización correcta de un <xref:System.Net.Sockets.Socket.SendToAsync%2A> método no indica que los datos se ha entregado correctamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> no puede ser null.</exception>
        <exception cref="T:System.InvalidOperationException">Ya hay una operación de socket en curso que utiliza el objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado en el parámetro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Se requiere Windows XP o posteriores para este método.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">El protocolo especificado está orientado a la conexión, pero el <see cref="T:System.Net.Sockets.Socket" /> no está conectado todavía.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="level">Nivel de protección IP que se va a establecer en este socket.</param>
        <summary>Establece el nivel de protección IP en un socket.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> método permite restringir un un socket IPv6 o la dirección IP para que escuche en un ámbito especificado, como direcciones con el mismo vínculo o sitio prefijo local. Esta opción de socket permite a las aplicaciones colocar restricciones de acceso en sockets IPv6 o la dirección IP. Estas restricciones permiten que una aplicación que se ejecuta en una LAN privada se fortalezca de forma sencilla frente a ataques externos. También se puede usar esta opción de socket para quitar las restricciones de acceso si el `level` parámetro está establecido en <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Esta opción de socket amplía o reduce el ámbito de un socket de escucha, lo que permite el acceso no restringido de usuarios públicos y privados cuando sea adecuado o restringe el acceso únicamente al mismo sitio, según necesidad.  
  
 Esta opción de socket definió niveles de protección especificados en la enumeración <xref:System.Net.Sockets.IPProtectionLevel>.  
  
 El <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> método se utiliza para habilitar o deshabilitar la exploración transversal de direcciones de red (NAT) para un <xref:System.Net.Sockets.Socket> instancia. Cruce seguro de NAT puede proporcionarse mediante un túnel ISATAP, 6to4 o Teredo.  
  
 Cuando el `level` parámetro está establecido en <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, o <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, se deshabilita explícitamente la exploración transversal de NAT para una <xref:System.Net.Sockets.Socket> instancia.  
  
 Cuando el `level` parámetro está establecido en <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, esto puede permitir NAT transversal para un <xref:System.Net.Sockets.Socket> según las reglas de firewall en su lugar en el sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="level" /> no puede ser <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />. El nivel de protección IP no puede estar establecido en no especificado.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Net.Sockets.AddressFamily" /> del socket debe ser <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece una opción de <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Valor de la opción, representado como <see cref="T:System.Boolean" />.</param>
        <summary>Establece la opción de <see cref="T:System.Net.Sockets.Socket" /> especificada en el valor de <see cref="T:System.Boolean" /> indicado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opciones determinan el comportamiento del elemento actual <xref:System.Net.Sockets.Socket>. Establecer `optionValue` a `true` para habilitar la opción, o a `false` para deshabilitar la opción.  
  
 <xref:System.Net.Sockets.Socket> las opciones se agrupan por nivel de compatibilidad de protocolo.  
  
 A continuación aparecen los diversos <xref:System.Net.Sockets.Socket> opciones que se pueden establecer mediante esta sobrecarga. Estas opciones se agrupan por adecuado <xref:System.Net.Sockets.SocketOptionLevel> valor. Si pretende establecer cualquiera de estas opciones, asegúrese de usar adecuado <xref:System.Net.Sockets.SocketOptionLevel> valor para el `optionLevel` parámetro. Debe especificarse la opción que elija para establecer en el `optionName` parámetro. Si desea obtener el valor actual de cualquiera de las opciones enumeradas, use el <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 Para obtener más información sobre estas opciones, consulte el <xref:System.Net.Sockets.SocketOptionName> enumeración.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException> excepción, use el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se abre un socket y permite la `DontLinger` y `OutOfBandInline` opciones de socket.  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Matriz de tipo <see cref="T:System.Byte" /> que representa el valor de la opción.</param>
        <summary>Establece la opción de <see cref="T:System.Net.Sockets.Socket" /> indicada en el valor especificado, representado como una matriz de bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opciones determinan el comportamiento del elemento actual <xref:System.Net.Sockets.Socket>. Utilice esta sobrecarga para establecerlas <xref:System.Net.Sockets.Socket> opciones que requieren una matriz de bytes como un valor de opción.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.Sockets.LingerOption> y <xref:System.Net.Sockets.Socket.Send%2A> los valores de tiempo de espera.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Valor de la opción.</param>
        <summary>Establece la opción de <see cref="T:System.Net.Sockets.Socket" /> especificada en el valor entero indicado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opciones determinan el comportamiento del elemento actual <xref:System.Net.Sockets.Socket>. Para una opción con un <xref:System.Boolean> tipo de datos, especifique un valor distinto de cero para habilitar la opción y un valor de cero para deshabilitar la opción. Para una opción con un tipo de datos entero, especifique el valor adecuado. <xref:System.Net.Sockets.Socket> las opciones se agrupan por nivel de compatibilidad de protocolo.  
  
 A continuación aparecen los diversos <xref:System.Net.Sockets.Socket> opciones que se pueden establecer mediante esta sobrecarga. Estas opciones se agrupan por adecuado <xref:System.Net.Sockets.SocketOptionLevel>. Si pretende establecer cualquiera de estas opciones, asegúrese de usar adecuado <xref:System.Net.Sockets.SocketOptionLevel> para el `optionLevel` parámetro. Debe especificarse la opción que elija para establecer en el `optionName` parámetro. Si desea obtener el valor actual de cualquiera de las opciones enumeradas, use el <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> opciones que se pueden establecer mediante esta sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 Para obtener más información acerca de estas opciones, consulte el <xref:System.Net.Sockets.SocketOptionName> enumeración.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.Sockets.LingerOption> y <xref:System.Net.Sockets.Socket.Send%2A> los valores de tiempo de espera.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Uno de los valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue"><see cref="T:System.Net.Sockets.LingerOption" /> o <see cref="T:System.Net.Sockets.MulticastOption" /> que contiene el valor de la opción.</param>
        <summary>Establece la opción de <see cref="T:System.Net.Sockets.Socket" /> indicada en el valor especificado, representado como un objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> opciones determinan el comportamiento del elemento actual <xref:System.Net.Sockets.Socket>. Utilice esta sobrecarga para establecer el <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, y <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opciones. Para el <xref:System.Net.Sockets.SocketOptionName.Linger> opción, utilice <xref:System.Net.Sockets.Socket> para el `optionLevel` parámetro. Para <xref:System.Net.Sockets.SocketOptionName.AddMembership> y <xref:System.Net.Sockets.SocketOptionName.DropMembership>, utilice <xref:System.Net.Sockets.SocketOptionLevel.IP>. Si desea obtener el valor actual de cualquiera de las opciones enumeradas anteriormente, use el <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece la <xref:System.Net.Sockets.LingerOption> y <xref:System.Net.Sockets.Socket.Send%2A> los valores de tiempo de espera.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="optionValue" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">Uno de los valores de <see cref="T:System.Net.Sockets.SocketShutdown" /> que especifica la operación que ya no estará permitida.</param>
        <summary>Deshabilita los envíos y recepciones en un objeto <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se usa un orientado a conexión <xref:System.Net.Sockets.Socket>, llame siempre a la <xref:System.Net.Sockets.Socket.Shutdown%2A> método antes de cerrar el <xref:System.Net.Sockets.Socket>. Esto garantiza que todos los datos se envía y recibe en el socket conectado antes de cerrarse.  
  
 Llame a la <xref:System.Net.Sockets.Socket.Close%2A> método para liberar todos los recursos administrados y asociados con el <xref:System.Net.Sockets.Socket>. No intente reutilizar el <xref:System.Net.Sockets.Socket> después del cierre.  
  
 La tabla siguiente muestra la <xref:System.Net.Sockets.SocketShutdown> valores de enumeración que son válidos para el `how` parámetro.  
  
|Valor|Descripción|  
|-----------|-----------------|  
|Enviar|Deshabilite los envíos en <xref:System.Net.Sockets.Socket>.|  
|Recibir|Deshabilite las recepciones en esto <xref:System.Net.Sockets.Socket>.|  
|Ambos|Deshabilitar el envío y recepción en esto <xref:System.Net.Sockets.Socket>.|  
  
 Establecer `how` a <xref:System.Net.Sockets.SocketShutdown.Send> especifica que las siguientes llamadas a <xref:System.Net.Sockets.Socket.Send%2A> no se permiten. Si usa un protocolo sin conexión <xref:System.Net.Sockets.Socket>, especificando <xref:System.Net.Sockets.SocketShutdown.Send> no tendrá ningún efecto.  
  
 Establecer `how` a <xref:System.Net.Sockets.SocketShutdown.Receive> especifica que las siguientes llamadas a <xref:System.Net.Sockets.Socket.Receive%2A> no se permiten. Esto no tiene ningún efecto en las capas inferiores de protocolo. Si utiliza un protocolo orientado a conexiones, la conexión finaliza si cualquiera de las siguientes condiciones existe después de llamar a <xref:System.Net.Sockets.Socket.Shutdown%2A> :  
  
-   Datos están en el búfer de red entrante a la espera de recibirse.  
  
-   Ha llegado más datos.  
  
 Si usa un protocolo sin conexión, los datagramas se aceptan y en cola. Sin embargo, si no hay espacio de búfer disponible para los datagramas entrantes adicionales, se descartarán y no se devolverá ningún error al remitente. Uso de <xref:System.Net.Sockets.Socket.Shutdown%2A> en un protocolo sin conexión <xref:System.Net.Sockets.Socket> no se recomienda.  
  
 Establecer `how` a <xref:System.Net.Sockets.SocketShutdown.Both> deshabilita tanto los envíos y recepciones como se describió anteriormente.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException> al llamar a la <xref:System.Net.Sockets.Socket.Shutdown%2A> método, use el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código usa <xref:System.Net.Sockets.Socket.Shutdown%2A> para deshabilitar el <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo de <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Uno de los valores de <see cref="T:System.Net.Sockets.SocketType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> es de solo lectura y se establece cuando el <xref:System.Net.Sockets.Socket> se crea.  
  
   
  
## Examples  
 El siguiente código de ejemplo se muestra el <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, y <xref:System.Net.Sockets.ProtocolType> en la consola.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la compatibilidad con IPv4 está disponible y habilitada en el host actual.</summary>
        <value><see langword="true" /> si el host actual admite el protocolo IPv4; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El sistema operativo puede admitir los protocolos IPv4 e IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el marco de trabajo admite IPv6 para ciertos miembros <see cref="T:System.Net.Dns" /> obsoletos.</summary>
        <value>Es <see langword="true" /> si el marco de trabajo admite IPv6 para determinados métodos obsoletos de <see cref="T:System.Net.Dns" />; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El sistema operativo puede admitir los protocolos IPv4 e IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos que usa <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Llamar a IDisposable.Dispose cuando haya terminado con el <xref:System.Net.Sockets.Socket>. El método IDisposable.Dispose deja el <xref:System.Net.Sockets.Socket> en un estado inutilizable. Después de llamar a IDisposable.Dispose, debe liberar todas las referencias a la <xref:System.Net.Sockets.Socket> por lo que el recolector de elementos no utilizados pueda reclamar la memoria que el <xref:System.Net.Sockets.Socket> estaba ocupando. Para obtener más información, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).

> [!NOTE] 
> Llame siempre a IDisposable.Dispose antes de liberar la última referencia a la <xref:System.Net.Sockets.Socket>. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.Net.Sockets.Socket> del objeto `Finalize`.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica el valor de período de vida (TTL) de los paquetes de protocolo Internet (IP) enviados por <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Valor TTL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de TTL indica el número máximo de enrutadores que puede atravesar un paquete antes de que el enrutador descarta el paquete y un protocolo de mensajes de Internet Control "TTL excedido" (ICMP) mensaje de error se devuelve al remitente.  
  
 El valor de TTL puede establecerse en un valor de 0 a 255. Cuando no se establece esta propiedad, el valor TTL predeterminado para un socket es 32.  
  
 Establecer esta propiedad en un socket de protocolo de Control de transmisión (TCP) se omite la pila TCP/IP si se ha establecido una conexión correcta utilizando el socket.  
  
 Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico. Después de haber obtenido este código, consulte el [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.Socket.Ttl%2A> propiedad.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor TTL no se puede establecer en un número negativo.</exception>
        <exception cref="T:System.NotSupportedException">Esta propiedad sólo se puede establecer para sockets de las familias de <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket. También se devuelve este error cuando se ha intentado para establecer TTL en un valor superior a 255.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica si el socket debe utilizar únicamente el modo de E/S superpuesta.</summary>
        <value><see langword="true" /> si <see cref="T:System.Net.Sockets.Socket" /> utiliza únicamente el modo de E/S superpuesta; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establezca esta propiedad en `true` para un <xref:System.Net.Sockets.Socket> que piensa llamar <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>. En caso contrario, el marco de trabajo puede asignar un puerto de terminación para el socket, lo que impediría el uso de <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El socket se ha enlazado a un puerto de terminación.</exception>
      </Docs>
    </Member>
  </Members>
</Type>