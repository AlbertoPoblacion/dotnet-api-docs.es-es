<Type Name="TcpListener" FullName="System.Net.Sockets.TcpListener">
  <Metadata><Meta Name="ms.openlocfilehash" Value="33b505c306f1ff21ce7a37a4320193f1edde1fb9" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52740264" /></Metadata><TypeSignature Language="C#" Value="public class TcpListener" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpListener extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.TcpListener" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpListener" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpListener" />
  <TypeSignature Language="F#" Value="type TcpListener = class" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Realiza escuchas para conexiones de clientes de red TCP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Net.Sockets.TcpListener> clase proporciona métodos sencillos que escuchan y aceptan las solicitudes de conexión entrantes en modo de bloqueo sincrónico. Puede usar un <xref:System.Net.Sockets.TcpClient> o un <xref:System.Net.Sockets.Socket> para conectarse con un <xref:System.Net.Sockets.TcpListener>. Crear un <xref:System.Net.Sockets.TcpListener> mediante un <xref:System.Net.IPEndPoint>, una dirección IP Local y el número de puerto o simplemente un número de puerto. Especificar <xref:System.Net.IPAddress.Any> para la dirección IP local y 0 para el número de puerto local si desea que el proveedor de servicios subyacente para asignar esos valores para usted. Si decide hacerlo, puede usar el <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> propiedad para identificar la información asignada, una vez que se ha conectado el socket.  
  
 Use el <xref:System.Net.Sockets.TcpListener.Start%2A> método para empezar a escuchar las solicitudes de conexión entrantes. <xref:System.Net.Sockets.TcpListener.Start%2A> se pondrán en cola las conexiones entrantes hasta que llame a la <xref:System.Net.Sockets.TcpListener.Stop%2A> método o se ha puesto en cola <xref:System.Net.Sockets.SocketOptionName.MaxConnections>. Usar <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> o <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> para extraer una conexión desde la cola de solicitudes de conexión entrante. Estos dos métodos se bloquearán. Si desea evitar el bloqueo, puede usar el <xref:System.Net.Sockets.TcpListener.Pending%2A> método primero para determinar si las solicitudes de conexión están disponibles en la cola.  
  
 Llame a la <xref:System.Net.Sockets.TcpListener.Stop%2A> método para cerrar el <xref:System.Net.Sockets.TcpListener>.  
  
> [!NOTE]
>  El <xref:System.Net.Sockets.TcpListener.Stop%2A> método no cierra cualquier conexión aceptada. Usted es responsable de cerrarlas por separado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Net.Sockets.TcpListener>.  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 Consulte <xref:System.Net.Sockets.TcpClient> para obtener un ejemplo de cliente.  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Para establecer una conexión saliente o Aceptar una solicitud entrante.</permission>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.TcpListener" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : int -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener port" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use TcpListener (IPAddress address, int port) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use TcpListener(IPAddress localaddr, int port) instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use TcpListener(IPAddress localaddr, int port).")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Puerto en el cual se escucharán los intentos de conexión entrantes.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.TcpListener" /> que escucha en el puerto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor está obsoleto. Use la <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=nameWithType> o <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=nameWithType> constructores.  
  
 Este constructor permite especificar el número de puerto en donde se escucharán los intentos de conexión entrantes. Con este constructor, el proveedor de servicios subyacente le asigna la dirección de red más adecuada. Si no te importa qué puerto local se utiliza, puede especificar 0 para el número de puerto. En este caso, el proveedor de servicios asignará a un número de puertos efímeros disponibles. Si usa este enfoque, puede detectar qué número de puerto y la dirección de red local se asignó usando el <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> propiedad.  
  
 Llame a la <xref:System.Net.Sockets.TcpListener.Start%2A> método para iniciar la escucha de intentos de conexión entrantes.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Net.Sockets.TcpListener> con un número de puerto local.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> no se encuentra en el intervalo definido por <see cref="F:System.Net.IPEndPoint.MinPort" /> y <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : System.Net.IPEndPoint -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><see cref="T:System.Net.IPEndPoint" /> que representa el extremo local con el que desea enlazar el <see cref="T:System.Net.Sockets.Socket" /> del agente de escucha.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.TcpListener" /> con el extremo local especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor permite especificar la dirección IP local y se trata del número de puerto en el que se va a escuchar las conexiones entrantes. Antes de usar este constructor, debe crear un <xref:System.Net.IPEndPoint> utilizando el local IP dirección y el puerto número deseado. Pase este <xref:System.Net.IPEndPoint> al constructor como el `localEP` parámetro.  
  
 Si no te importa qué dirección local se asigna, puede crear un <xref:System.Net.IPEndPoint> utilizando <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> como el parámetro de dirección y el servicio subyacente proveedor asignará la dirección de red más adecuada. Esto puede ayudar a simplificar la aplicación si tiene varias interfaces de red. Si no te importa qué puerto local se utiliza, puede crear un <xref:System.Net.IPEndPoint> con 0 para el número de puerto. En este caso, el proveedor de servicios asignará a un número de puertos efímeros disponibles. Si usa este enfoque, puede detectar qué número de puerto y la dirección de red local se asignó usando el <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> propiedad.  
  
 Llame a la <xref:System.Net.Sockets.TcpListener.Start%2A> método para iniciar la escucha de intentos de conexión entrantes.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea una instancia de la <xref:System.Net.Sockets.TcpListener> clase utilizando el extremo local.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="localEP" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPAddress localaddr, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPAddress localaddr, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localaddr As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPAddress ^ localaddr, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : System.Net.IPAddress * int -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener (localaddr, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localaddr" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="localaddr"><see cref="T:System.Net.IPAddress" /> que representa la dirección IP local.</param>
        <param name="port">Puerto en el cual se escucharán los intentos de conexión entrantes.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.TcpListener" /> que escucha los intentos de conexión entrantes en la dirección IP local y el número de puerto especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor permite especificar la dirección IP local y se trata del número de puerto en el que se va a escuchar las conexiones entrantes. Antes de llamar a este constructor debe crear primero un <xref:System.Net.IPAddress> utilizando la dirección local deseada. Pase este <xref:System.Net.IPAddress> al constructor como el `localaddr` parámetro. Si no te importa qué dirección local se asigne, especifique <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> para el `localaddr` parámetro y el proveedor de servicios subyacente asignará la dirección de red más adecuada. Esto puede ayudar a simplificar la aplicación si tiene varias interfaces de red. Si no te importa qué puerto local se utiliza, puede especificar 0 para el número de puerto. En este caso, el proveedor de servicios asignará a un número de puerto disponible entre 1024 y 5000. Si usa este enfoque, puede detectar qué número de puerto y la dirección de red local se asignó usando el <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> propiedad.  
  
 Llame a la <xref:System.Net.Sockets.TcpListener.Start%2A> método para iniciar la escucha de intentos de conexión entrantes.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea una instancia de la <xref:System.Net.Sockets.TcpListener> clase mediante un número de puerto y la dirección IP local.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="localaddr" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> no se encuentra en el intervalo definido por <see cref="F:System.Net.IPEndPoint.MinPort" /> y <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket AcceptSocket ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket AcceptSocket() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocket" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocket () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ AcceptSocket();" />
      <MemberSignature Language="F#" Value="member this.AcceptSocket : unit -&gt; System.Net.Sockets.Socket" Usage="tcpListener.AcceptSocket " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acepta una solicitud de conexión pendiente.</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> que se utiliza para enviar y recibir datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> es un método de bloqueo que devuelve un <xref:System.Net.Sockets.Socket> que puede usar para enviar y recibir datos. Si desea evitar el bloqueo, use el <xref:System.Net.Sockets.TcpListener.Pending%2A> método para determinar si las solicitudes de conexión están disponibles en la cola de conexiones entrantes.  
  
 El <xref:System.Net.Sockets.Socket> devuelto se inicializa con el número de puerto y la dirección IP del host remoto. Puede usar cualquiera de los <xref:System.Net.Sockets.Socket.Send%2A> y <xref:System.Net.Sockets.Socket.Receive%2A> métodos disponibles en la <xref:System.Net.Sockets.Socket> clase para comunicarse con el host remoto. Cuando haya terminado con el <xref:System.Net.Sockets.Socket>, no olvide llamar a su <xref:System.Net.Sockets.Socket.Close%2A> método. Si la aplicación es relativamente sencilla, considere el uso de la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método en lugar de <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método. <xref:System.Net.Sockets.TcpClient> Proporciona métodos sencillos para enviar y recibir datos a través de una red en modo de bloqueo sincrónico.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente, la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método se usa para devolver un <xref:System.Net.Sockets.Socket>. Esto <xref:System.Net.Sockets.Socket> se usa para comunicarse con el cliente recién conectado.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El agente de escucha no se ha iniciado con una llamada a <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocketAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt; AcceptSocketAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.Socket&gt; AcceptSocketAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocketAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocketAsync () As Task(Of Socket)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::Socket ^&gt; ^ AcceptSocketAsync();" />
      <MemberSignature Language="F#" Value="member this.AcceptSocketAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt;" Usage="tcpListener.AcceptSocketAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acepta una solicitud de conexión pendiente como una operación asincrónica.</summary>
        <returns>Devuelve <see cref="T:System.Threading.Tasks.Task`1" />  
  
Objeto de tarea que representa la operación asincrónica. La propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> en el objeto de tarea devuelve <see cref="T:System.Net.Sockets.Socket" /> utilizado para enviar y recibir datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación no se bloqueará. El valor devuelto <xref:System.Threading.Tasks.Task%601> objeto se completará cuando se haya aceptado la conexión de socket.  
  
 El <xref:System.Net.Sockets.Socket> devuelto en <xref:System.Threading.Tasks.Task%601> se inicializa con el número de puerto y la dirección IP del host remoto. Puede usar cualquiera de los <xref:System.Net.Sockets.Socket.Send%2A> y <xref:System.Net.Sockets.Socket.Receive%2A> métodos disponibles en la <xref:System.Net.Sockets.Socket> clase para comunicarse con el host remoto. Cuando haya terminado con el <xref:System.Net.Sockets.Socket>, no olvide llamar a su <xref:System.Net.Sockets.Socket.Close%2A> método. Si la aplicación es relativamente sencilla, considere el uso de la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método en lugar de <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A> método. <xref:System.Net.Sockets.TcpClient> Proporciona métodos sencillos para enviar y recibir datos a través de una red en modo de bloqueo sincrónico.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El agente de escucha no se ha iniciado con una llamada a <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient AcceptTcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient AcceptTcpClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClient () As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ AcceptTcpClient();" />
      <MemberSignature Language="F#" Value="member this.AcceptTcpClient : unit -&gt; System.Net.Sockets.TcpClient" Usage="tcpListener.AcceptTcpClient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acepta una solicitud de conexión pendiente.</summary>
        <returns><see cref="T:System.Net.Sockets.TcpClient" /> que se utiliza para enviar y recibir datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> es un método de bloqueo que devuelve un <xref:System.Net.Sockets.TcpClient> que puede usar para enviar y recibir datos. Use el <xref:System.Net.Sockets.TcpListener.Pending%2A> método para determinar si las solicitudes de conexión están disponibles en la cola de conexión entrantes si desea evitar el bloqueo.  
  
 Use la <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType> método obtener subyacente <xref:System.Net.Sockets.NetworkStream> devuelto del <xref:System.Net.Sockets.TcpClient>. El <xref:System.Net.Sockets.NetworkStream> le proporcionará métodos para enviar y recibir con el host remoto. Cuando haya terminado con el <xref:System.Net.Sockets.TcpClient>, no olvide llamar a su <xref:System.Net.Sockets.TcpClient.Close%2A> método. Si desea que la mayor flexibilidad que una <xref:System.Net.Sockets.TcpClient> ofertas, considere el uso de <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente, la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método se usa para devolver un <xref:System.Net.Sockets.TcpClient>. Esto <xref:System.Net.Sockets.TcpClient> se usa para comunicarse con el cliente recién conectado.  
  
 [!code-cpp[Classic TcpListenerExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListenerExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListenerExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListenerExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListenerExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListenerExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El agente de escucha no se ha iniciado con una llamada a <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Utilice la propiedad <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> para obtener el código de error específico. Cuando obtenga este código, puede ver la documentación de <see href="/windows/desktop/winsock/windows-sockets-error-codes-2">códigos de error de la API de Windows Sockets, versión 2</see>, para ver una descripción detallada del error.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClientAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClientAsync () As Task(Of TcpClient)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::TcpClient ^&gt; ^ AcceptTcpClientAsync();" />
      <MemberSignature Language="F#" Value="member this.AcceptTcpClientAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt;" Usage="tcpListener.AcceptTcpClientAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acepta una solicitud de conexión pendiente como una operación asincrónica.</summary>
        <returns>Devuelve <see cref="T:System.Threading.Tasks.Task`1" />  
  
Objeto de tarea que representa la operación asincrónica. La propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> en el objeto de tarea devuelve <see cref="T:System.Net.Sockets.TcpClient" /> utilizado para enviar y recibir datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación no se bloqueará. El valor devuelto <xref:System.Threading.Tasks.Task%601> objeto se completará cuando se haya aceptado la conexión TCP.  
  
 Use la <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType> método obtener subyacente <xref:System.Net.Sockets.NetworkStream> devuelto del <xref:System.Net.Sockets.TcpClient> en el <xref:System.Threading.Tasks.Task%601>. El <xref:System.Net.Sockets.NetworkStream> le proporcionará métodos para enviar y recibir con el host remoto. Cuando haya terminado con el <xref:System.Net.Sockets.TcpClient>, no olvide llamar a su <xref:System.Net.Sockets.TcpClient.Close%2A> método. Si desea que la mayor flexibilidad que una <xref:System.Net.Sockets.TcpClient> ofertas, considere el uso de <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> o <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A>.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El agente de escucha no se ha iniciado con una llamada a <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Utilice la propiedad <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> para obtener el código de error específico. Cuando obtenga este código, puede ver la documentación de <see href="/windows/desktop/winsock/windows-sockets-error-codes-2">códigos de error de la API de Windows Sockets, versión 2</see>, para ver una descripción detallada del error.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Active" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool" Usage="System.Net.Sockets.TcpListener.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Net.Sockets.TcpListener" /> escucha activamente las conexiones de clientes.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Net.Sockets.TcpListener" /> escucha activamente; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas de <xref:System.Net.Sockets.TcpListener> puede utilizar esta propiedad para determinar si el <xref:System.Net.Sockets.Socket> está escuchando los intentos de conexión entrante. El <xref:System.Net.Sockets.TcpClient.Active%2A> propiedad puede usarse para evitar redundantes <xref:System.Net.Sockets.TcpListener.Start%2A> intentos.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AllowNatTraversal">
      <MemberSignature Language="C#" Value="public void AllowNatTraversal (bool allowed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AllowNatTraversal(bool allowed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AllowNatTraversal (allowed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AllowNatTraversal(bool allowed);" />
      <MemberSignature Language="F#" Value="member this.AllowNatTraversal : bool -&gt; unit" Usage="tcpListener.AllowNatTraversal allowed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowed" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="allowed">Valor booleano que especifica si se va a habilitar o deshabilitar NAT transversal.</param>
        <summary>Habilita o deshabilita NAT (Traducción de direcciones de red) transversal en una instancia de <see cref="T:System.Net.Sockets.TcpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> método se utiliza para habilitar o deshabilitar NAT transversal para un <xref:System.Net.Sockets.TcpListener> instancia. Cruce seguro de NAT puede proporcionarse mediante un túnel ISATAP, 6to4 o Teredo.  
  
 Cuando el `allowed` parámetro es false, el <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> opción en el socket asociado se establece en <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>. Esto deshabilita explícitamente la exploración transversal de NAT para una <xref:System.Net.Sockets.TcpListener> instancia.  
  
 Cuando el `allowed` parámetro es true, el <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> opción en el socket asociado se establece en <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Esto puede permitir NAT transversal para un <xref:System.Net.Sockets.TcpListener> según las reglas de firewall en su lugar en el sistema.  
  
 El <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> se debe invocar el método antes de llamar a la <xref:System.Net.Sockets.TcpListener.Start%2A> método para empezar a escuchar las solicitudes de conexión entrante (antes de que se enlaza el socket). Si <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> se llama al método después de la <xref:System.Net.Sockets.TcpListener.Start%2A> método, una <xref:System.InvalidOperationException> se iniciará.  
  
 Una dirección Teredo es una dirección IPv6 con el prefijo de 2001:: / 32. Las direcciones Teredo se pueden devolver a través de la resolución de nombres DNS normal o enumerar como una dirección IPv6 asignada a una interfaz local.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llama al método <see cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" /> después de llamar al método <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptSocket">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptSocket (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptSocket(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptSocket (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptSocket(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAcceptSocket : AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpListener.BeginAcceptSocket (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación se complete.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación de aceptación. Este objeto se pasa al delegado de <paramref name="callback" /> cuando la operación se completa.</param>
        <summary>Comienza una operación asincrónica para aceptar un intento de conexión entrante.</summary>
        <returns>Interfaz <see cref="T:System.IAsyncResult" /> que hace referencia a la creación asincrónica del objeto <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrónico <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> método. Normalmente, se invoca el método por el `callback` delegar.  
  
 Este método no se bloquea hasta que se complete la operación. Para bloquear hasta que se complete la operación, utilice el <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Puede llamar a la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propiedad devuelto del <xref:System.Net.Sockets.Socket> para identificar el número de puerto y la dirección de red del host remoto.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico y consulte la documentación de códigos de error de Windows Sockets versión 2 API en MSDN library en la [ http://msdn.microsoft.com/library/ ](https://msdn.microsoft.com/library/) para una detallada Descripción del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> método para crear y conectar un socket. Las llamadas de delegado de la devolución de llamada la <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> método para finalizar la solicitud asincrónica.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al intentar obtener acceso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptTcpClient">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptTcpClient (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptTcpClient(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptTcpClient (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptTcpClient(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAcceptTcpClient : AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpListener.BeginAcceptTcpClient (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación se complete.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación de aceptación. Este objeto se pasa al delegado de <paramref name="callback" /> cuando la operación se completa.</param>
        <summary>Comienza una operación asincrónica para aceptar un intento de conexión entrante.</summary>
        <returns>Interfaz <see cref="T:System.IAsyncResult" /> que hace referencia a la creación asincrónica del objeto <see cref="T:System.Net.Sockets.TcpClient" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrónico <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> método. Normalmente, se invoca el método por el `callback` delegar.  
  
 Este método no se bloquea hasta que se complete la operación. Para bloquear hasta que se complete la operación, utilice el <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico y consulte la documentación de códigos de error de Windows Sockets versión 2 API en MSDN library en la [ http://msdn.microsoft.com/library/ ](https://msdn.microsoft.com/library/) para una detallada Descripción del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> método para crear y conectar un socket. Las llamadas de delegado de la devolución de llamada la <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> método para finalizar la solicitud asincrónica.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al intentar obtener acceso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Net.Sockets.TcpListener Create (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.Sockets.TcpListener Create(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Create(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (port As Integer) As TcpListener" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::Sockets::TcpListener ^ Create(int port);" />
      <MemberSignature Language="F#" Value="static member Create : int -&gt; System.Net.Sockets.TcpListener" Usage="System.Net.Sockets.TcpListener.Create port" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpListener</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Puerto en el cual se escucharán los intentos de conexión entrantes.</param>
        <summary>Crea una nueva instancia de <see cref="T:System.Net.Sockets.TcpListener" /> para realizar escuchas en el puerto especificado.</summary>
        <returns>Devuelva <see cref="T:System.Net.Sockets.TcpListener" />.  
  
Una nueva instancia de <see cref="T:System.Net.Sockets.TcpListener" /> para realizar escuchas en el puerto especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAcceptSocket (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAcceptSocket(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptSocket (asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAcceptSocket(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAcceptSocket : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="tcpListener.EndAcceptSocket asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Interfaz <see cref="T:System.IAsyncResult" /> que se devuelve al llamar al método <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />.</param>
        <summary>Acepta asincrónicamente un intento de conexión entrante y crea un nuevo objeto <see cref="T:System.Net.Sockets.Socket" /> para controlar la comunicación con el host remoto.</summary>
        <returns>Objeto <see cref="T:System.Net.Sockets.Socket" />.  
  
Objeto <see cref="T:System.Net.Sockets.Socket" /> que se utiliza para enviar y recibir datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que la operación se complete. Para realizar esta operación sincrónicamente, utilice el <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método.  
  
> [!NOTE]
>  Puede llamar a la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propiedad devuelto del <xref:System.Net.Sockets.Socket> para identificar el número de puerto y la dirección de red del host remoto.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico y consulte la documentación de códigos de error de Windows Sockets versión 2 API en MSDN library en la [ http://msdn.microsoft.com/library/ ](https://msdn.microsoft.com/library/) para una detallada Descripción del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> método para crear y conectar un socket. Las llamadas de delegado de la devolución de llamada la <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> método para finalizar la solicitud asincrónica.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> subyacente se ha cerrado.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="asyncResult" /> no se creó mediante una llamada al método <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">El método <see cref="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" /> se definió previamente.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al intentar obtener acceso al <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient EndAcceptTcpClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient EndAcceptTcpClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptTcpClient (asyncResult As IAsyncResult) As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ EndAcceptTcpClient(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAcceptTcpClient : IAsyncResult -&gt; System.Net.Sockets.TcpClient" Usage="tcpListener.EndAcceptTcpClient asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Interfaz <see cref="T:System.IAsyncResult" /> que se devuelve al llamar al método <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" />.</param>
        <summary>Acepta asincrónicamente un intento de conexión entrante y crea un nuevo objeto <see cref="T:System.Net.Sockets.TcpClient" /> para controlar la comunicación con el host remoto.</summary>
        <returns>Objeto <see cref="T:System.Net.Sockets.TcpClient" />.  
  
Objeto <see cref="T:System.Net.Sockets.TcpClient" /> que se utiliza para enviar y recibir datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que la operación se complete. Para realizar esta operación sincrónicamente, utilice el <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método.  
  
> [!NOTE]
>  Puede llamar a la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propiedad del socket subyacente (<xref:System.Net.Sockets.TcpClient.Client%2A>) para identificar el número de puerto y la dirección de red del host remoto.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice el <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico y consulte la documentación de códigos de error de Windows Sockets versión 2 API en MSDN library en la [ http://msdn.microsoft.com/library/ ](https://msdn.microsoft.com/library/) para una detallada Descripción del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> método para crear y conectar un socket. Las llamadas de delegado de la devolución de llamada la <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> método para finalizar la solicitud asincrónica.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.TcpListener.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor <see cref="T:System.Boolean" /> que especifica si <see cref="T:System.Net.Sockets.TcpListener" /> permite a sólo un socket subyacente escuchar en un puerto concreto.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Net.Sockets.TcpListener" /> sólo permite a un objeto <see cref="T:System.Net.Sockets.TcpListener" /> escuchar en un puerto concreto; de lo contrario, es <see langword="false" />. Archivos .natvis El valor predeterminado es <see langword="true" /> para Windows Server 2003 y Windows XP Service Pack 2 y versiones posteriores, y <see langword="false" /> para el resto de versiones.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, varios agentes de escucha pueden escuchar un puerto específico. Sin embargo, solo uno de los agentes de escucha puede realizar operaciones en el tráfico de red enviado al puerto. Si más de un agente de escucha intenta enlazarse a un puerto determinado, el otro con la dirección IP específica más controla el tráfico de red enviado a ese puerto. Puede usar el <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> propiedad para evitar varios agentes de escucha escuche en un puerto concreto.  
  
 Establezca esta propiedad antes de llamar a <xref:System.Net.Sockets.TcpListener.Start%2A>, o llamar a la <xref:System.Net.Sockets.TcpListener.Stop%2A> método y, a continuación, establecer esta propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el <xref:System.Net.Sockets.TcpListener.ExclusiveAddressUse%2A> propiedad.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#2)]
 [!code-csharp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#2)]
 [!code-vb[System.Net.Sockets.TcpListener1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.TcpListener" /> se ha iniciado. Llame al método <see cref="M:System.Net.Sockets.TcpListener.Stop" /> y, a continuación, establezca la propiedad <see cref="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al intentar obtener acceso al socket subyacente.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> subyacente se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TcpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TcpListener ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="tcpListener.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos que usa la clase <see cref="T:System.Net.Sockets.TcpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
El <xref:System.Net.Sockets.TcpListener> clase finalizador libera los recursos asociados con el <xref:System.Net.Sockets.TcpListener> instancia.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalEndpoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndpoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndpoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.LocalEndpoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndpoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndpoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndpoint : System.Net.EndPoint" Usage="System.Net.Sockets.TcpListener.LocalEndpoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Net.EndPoint" /> subyacente del objeto <see cref="T:System.Net.Sockets.TcpListener" /> actual.</summary>
        <value>Objeto <see cref="T:System.Net.EndPoint" /> al que está enlazado el <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> propiedad para identificar el número de puerto y la interfaz de red local que se usa para escuchar las solicitudes de conexión de cliente entrantes, una vez que se ha realizado una conexión de socket. Primero debe convertir esto <xref:System.Net.EndPoint> a un <xref:System.Net.IPEndPoint>. A continuación, puede llamar a la <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> propiedad para recuperar la dirección IP local y el <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> propiedad para recuperar el número de puerto local.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el número de puerto y la dirección IP local en el que el <xref:System.Net.Sockets.TcpListener> está atendiendo las solicitudes de conexión entrante.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.EndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Pending">
      <MemberSignature Language="C#" Value="public bool Pending ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Pending() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Pending" />
      <MemberSignature Language="VB.NET" Value="Public Function Pending () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Pending();" />
      <MemberSignature Language="F#" Value="member this.Pending : unit -&gt; bool" Usage="tcpListener.Pending " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina si existen solicitudes de conexión pendientes.</summary>
        <returns>Es <see langword="true" /> si hay conexiones pendientes; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no sea de bloqueo determina si hay solicitudes de conexión pendientes. Dado que el <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> y <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> métodos bloquean la ejecución hasta que el <xref:System.Net.Sockets.TcpListener.Start%2A> método ha puesto en cola una solicitud de conexión entrante, el <xref:System.Net.Sockets.TcpListener.Pending%2A> método puede utilizarse para determinar si las conexiones están disponibles antes de aceptarlos.  
  
   
  
## Examples  
 El siguiente código de ejemplo se comprueba el <xref:System.Net.Sockets.TcpListener.Pending%2A> método. Si una solicitud de conexión está esperando a ser aceptados, a continuación, una llamada a la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> se realiza el método.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El agente de escucha no se ha iniciado con una llamada a <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Server" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Server { System::Net::Sockets::Socket ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Net.Sockets.Socket" Usage="System.Net.Sockets.TcpListener.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto de red <see cref="T:System.Net.Sockets.Socket" /> subyacente.</summary>
        <value>Objeto <see cref="T:System.Net.Sockets.Socket" /> subyacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener> crea un <xref:System.Net.Sockets.Socket> para escuchar las solicitudes de conexión de cliente entrantes. Las clases derivadas de <xref:System.Net.Sockets.TcpListener> puede utilizar esta propiedad para obtener este <xref:System.Net.Sockets.Socket>. Usar subyacente <xref:System.Net.Sockets.Socket> devuelto por la <xref:System.Net.Sockets.TcpListener.Server%2A> propiedad si necesita tener acceso a más allá de eso que <xref:System.Net.Sockets.TcpListener> proporciona.  
  
> [!NOTE]
>  El <xref:System.Net.Sockets.TcpListener.Server%2A> propiedad sólo devuelve el <xref:System.Net.Sockets.Socket> usa para escuchar las solicitudes de conexión de cliente entrantes. Use la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método para aceptar una solicitud de conexión pendiente y obtener un <xref:System.Net.Sockets.Socket> para enviar y recibir datos. También puede usar el <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método para aceptar una solicitud de conexión pendiente y obtener un <xref:System.Net.Sockets.TcpClient> para enviar y recibir datos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.TcpListener.Server%2A> propiedad. Subyacente <xref:System.Net.Sockets.Socket> se recupera y <xref:System.Net.Sockets.SocketOptionName.Linger> <xref:System.Net.Sockets.Socket> opción está configurada para el tiempo de espera tras 10 segundos si los datos permanecen en el búfer de red después de cerrar la conexión.  
  
 [!code-csharp[TcpListenerProtectedMembers1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListenerProtectedMembers1/CS/source.cs#1)]
 [!code-vb[TcpListenerProtectedMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListenerProtectedMembers1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza la escucha de solicitudes de conexión entrantes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="tcpListener.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comienza la escucha de solicitudes de conexión entrantes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.TcpListener.Start%2A> método inicializa subyacente <xref:System.Net.Sockets.Socket>, lo enlaza a un extremo local y escucha los intentos de conexión entrante. Si se recibe una solicitud de conexión, el <xref:System.Net.Sockets.TcpListener.Start%2A> método poner en cola la solicitud y continuará escuchando las solicitudes adicionales hasta que llame a la <xref:System.Net.Sockets.TcpListener.Stop%2A> método. Si <xref:System.Net.Sockets.TcpListener> recibe una solicitud de conexión después de que ha puesto en cola el número máximo de conexiones, producirá un <xref:System.Net.Sockets.SocketException> en el cliente.  
  
 Para quitar una conexión de la cola de conexiones entrantes, utilice el <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método o la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método. El <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método quitar una conexión de la cola y devolverá un <xref:System.Net.Sockets.TcpClient> que puede usar para enviar y recibir datos. El <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método devolverá un <xref:System.Net.Sockets.Socket> que puede usar para hacer lo mismo. Si la aplicación sólo requiere E/S sincrónica, utilice <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>. Para obtener más control de comportamiento, utilice <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>. Ambos métodos se bloquean hasta que esté disponible en la cola una solicitud de conexión.  
  
 Use la <xref:System.Net.Sockets.TcpListener.Stop%2A> método para cerrar el <xref:System.Net.Sockets.TcpListener> y detener la escucha. Usted es responsable de cerrar las conexiones aceptadas por separado.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo <xref:System.Net.Sockets.TcpListener.Start%2A> se usa para realizar escuchas para los intentos de conexión de cliente entrantes.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Utilice la propiedad <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> para obtener el código de error específico. Cuando obtenga este código, puede ver la documentación de <see href="/windows/desktop/winsock/windows-sockets-error-codes-2">códigos de error de la API de Windows Sockets, versión 2</see>, para ver una descripción detallada del error.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Start : int -&gt; unit" Usage="tcpListener.Start backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Longitud máxima de la cola de conexiones pendientes.</param>
        <summary>Comienza la escucha de solicitudes de conexión entrantes en un número máximo de conexión pendiente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.TcpListener.Start%2A> método inicializa subyacente <xref:System.Net.Sockets.Socket>, lo enlaza a un extremo local y escucha los intentos de conexión entrante. Si se recibe una solicitud de conexión, <xref:System.Net.Sockets.TcpListener.Start%2A> proporcionará poner en cola la solicitud y continuará escuchando las solicitudes adicionales hasta que llame a la <xref:System.Net.Sockets.TcpListener.Stop%2A> método. Si <xref:System.Net.Sockets.TcpListener> recibe una solicitud de conexión después de que ya ha puesto en cola el número máximo de conexiones se producirá un <xref:System.Net.Sockets.SocketException> en el cliente.  
  
 Para quitar una conexión de la cola de conexiones entrantes, utilice el <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método o la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método. El <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método quitar una conexión de la cola y devolverá un <xref:System.Net.Sockets.TcpClient> que puede usar para enviar y recibir datos. El <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método devolverá un <xref:System.Net.Sockets.Socket> que puede usar para hacer lo mismo. Si la aplicación sólo requiere E/S sincrónica, utilice el <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>. Para obtener más control de comportamiento, use <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método. Ambos métodos se bloquean hasta que esté disponible en la cola una solicitud de conexión.  
  
 Use la <xref:System.Net.Sockets.TcpListener.Stop%2A> método para cerrar el <xref:System.Net.Sockets.TcpListener> y detener la escucha. Usted es responsable de cerrar las conexiones aceptadas por separado.  
  
> [!NOTE]
>  Use la <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error específico y consulte la documentación de códigos de error de Windows Sockets versión 2 API en MSDN library en la [ http://msdn.microsoft.com/library/ ](https://msdn.microsoft.com/library/) para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo <xref:System.Net.Sockets.TcpListener.Start%2A> se usa para realizar escuchas para los intentos de conexión de cliente entrantes.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al obtener acceso al socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="backlog" /> es menor que cero o supera el número máximo de conexiones permitidas.</exception>
        <exception cref="T:System.InvalidOperationException">El <see cref="T:System.Net.Sockets.Socket" /> es nulo.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="tcpListener.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra el agente de escucha.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.Stop%2A> Cierra el agente de escucha. Se perderán las solicitudes de conexión no aceptado en la cola. Hosts remotos, esperando una conexión que se acepte producirá un <xref:System.Net.Sockets.SocketException>. Usted es responsable de cerrar las conexiones aceptadas por separado.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Net.Sockets.TcpListener.Stop%2A> método para cerrar subyacente <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Utilice la propiedad <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> para obtener el código de error específico. Cuando obtenga este código, puede ver la documentación de <see href="/windows/desktop/winsock/windows-sockets-error-codes-2">códigos de error de la API de Windows Sockets, versión 2</see>, para ver una descripción detallada del error.</exception>
        <block subset="none" type="usage"><para>El <see cref="M:System.Net.Sockets.TcpListener.Stop" /> método también cierra subyacente <see cref="T:System.Net.Sockets.Socket" />y crea un nuevo <see cref="T:System.Net.Sockets.Socket" /> para el <see cref="T:System.Net.Sockets.TcpListener" />. Si establece las propiedades en subyacente <see cref="T:System.Net.Sockets.Socket" /> antes de llamar a la <see cref="M:System.Net.Sockets.TcpListener.Stop" /> método, esas propiedades no se llevarán a la nueva <see cref="T:System.Net.Sockets.Socket" />.</para></block>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
  </Members>
</Type>