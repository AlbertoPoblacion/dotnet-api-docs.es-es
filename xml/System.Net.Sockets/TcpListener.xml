<Type Name="TcpListener" FullName="System.Net.Sockets.TcpListener">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="70b4efe2d402b27e3285b56bb7a50aff7def9e09" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30461089" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TcpListener" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpListener extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.TcpListener" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpListener" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpListener" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Realiza escuchas para conexiones de clientes de red TCP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Net.Sockets.TcpListener> clase proporciona métodos sencillos para escuchan y aceptan solicitudes de conexión entrantes en modo de bloqueo sincrónico. Puede usar un <xref:System.Net.Sockets.TcpClient> o un <xref:System.Net.Sockets.Socket> para conectar con un <xref:System.Net.Sockets.TcpListener>. Crear un <xref:System.Net.Sockets.TcpListener> mediante un <xref:System.Net.IPEndPoint>, una dirección IP Local y el número de puerto o un número de puerto. Especificar <xref:System.Net.IPAddress.Any> para la dirección IP local y 0 para el número de puerto local si desea que el proveedor de servicio subyacente para asignar esos valores automáticamente. Si decide hacerlo, puede usar el <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> propiedad para identificar la información asignada, una vez se ha conectado el socket.  
  
 Use la <xref:System.Net.Sockets.TcpListener.Start%2A> método para empezar a escuchar las solicitudes de conexión entrantes. <xref:System.Net.Sockets.TcpListener.Start%2A> se pondrán en cola las conexiones entrantes hasta que llame a la <xref:System.Net.Sockets.TcpListener.Stop%2A> método o se ha puesto en cola <xref:System.Net.Sockets.SocketOptionName.MaxConnections>. Usar <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> o <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> para extraer una conexión desde la cola de solicitudes de conexión entrante. Estos dos métodos se bloquearán. Si desea evitar el bloqueo, puede usar el <xref:System.Net.Sockets.TcpListener.Pending%2A> método primero para determinar si las solicitudes de conexión están disponibles en la cola.  
  
 Llame a la <xref:System.Net.Sockets.TcpListener.Stop%2A> método para cerrar la <xref:System.Net.Sockets.TcpListener>.  
  
> [!NOTE]
>  El <xref:System.Net.Sockets.TcpListener.Stop%2A> método no cierra ninguna conexión aceptada. Usted es responsable de cerrarlas por separado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Net.Sockets.TcpListener>.  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 Consulte <xref:System.Net.Sockets.TcpClient> para obtener un ejemplo de cliente.  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Para establecer una conexión saliente o Aceptar una solicitud entrante.</permission>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.TcpListener" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(int port);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use TcpListener (IPAddress address, int port) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Puerto en el cual se escucharán los intentos de conexión entrantes.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.TcpListener" /> que escucha en el puerto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor está obsoleto. Use la <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=nameWithType> o <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=nameWithType> constructores.  
  
 Este constructor permite especificar el número de puerto en el que se va a realizar escuchas de los intentos de conexión entrantes. Con este constructor, el proveedor de servicio subyacente asigna la dirección de red más apropiada. Si no importa qué puerto local se utiliza, puede especificar 0 para el número de puerto. En este caso, el proveedor de servicios asignará a un número de puertos efímeros disponibles. Si usa este enfoque, puede detectar qué número de puerto y la dirección de red local se ha asignado mediante el uso de la <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> propiedad.  
  
 Llame a la <xref:System.Net.Sockets.TcpListener.Start%2A> método debe empezar a escuchar para los intentos de conexión entrante.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Net.Sockets.TcpListener> con un número de puerto local.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> no se encuentra en el intervalo definido por <see cref="F:System.Net.IPEndPoint.MinPort" /> y <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPEndPoint ^ localEP);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">
          <see cref="T:System.Net.IPEndPoint" /> que representa el extremo local con el que desea enlazar el <see cref="T:System.Net.Sockets.Socket" /> del agente de escucha.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.TcpListener" /> con el extremo local especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor permite especificar la dirección IP local y trata de número de puerto en el que se va a escuchar las conexiones entrantes. Antes de usar este constructor, debe crear un <xref:System.Net.IPEndPoint> mediante el local IP dirección y el puerto número deseado. Pase este <xref:System.Net.IPEndPoint> al constructor como el `localEP` parámetro.  
  
 Si no importa qué dirección local se asigna, puede crear un <xref:System.Net.IPEndPoint> utilizando <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> como el parámetro de dirección y el servicio subyacente proveedor asignará la dirección de red más apropiada. Esto puede ayudar a simplificar la aplicación si tiene varias interfaces de red. Si no importa qué puerto local se utiliza, puede crear un <xref:System.Net.IPEndPoint> con 0 para el número de puerto. En este caso, el proveedor de servicios asignará a un número de puertos efímeros disponibles. Si usa este enfoque, puede detectar qué número de puerto y la dirección de red local se ha asignado mediante el uso de la <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> propiedad.  
  
 Llame a la <xref:System.Net.Sockets.TcpListener.Start%2A> método debe empezar a escuchar para los intentos de conexión entrante.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea una instancia de la <xref:System.Net.Sockets.TcpListener> clase utilizando el extremo local.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPAddress localaddr, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPAddress localaddr, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localaddr As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPAddress ^ localaddr, int port);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localaddr" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="localaddr">
          <see cref="T:System.Net.IPAddress" /> que representa la dirección IP local.</param>
        <param name="port">Puerto en el cual se escucharán los intentos de conexión entrantes.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.TcpListener" /> que escucha los intentos de conexión entrantes en la dirección IP local y el número de puerto especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor permite especificar la dirección IP local y trata de número de puerto en el que se va a escuchar las conexiones entrantes. Antes de llamar a este constructor debe crear primero un <xref:System.Net.IPAddress> con la dirección local deseada. Pase este <xref:System.Net.IPAddress> al constructor como el `localaddr` parámetro. Si no importa qué dirección local se asigne, especifique <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> para el `localaddr` parámetro y el proveedor de servicios subyacente asignará la dirección de red más apropiada. Esto puede ayudar a simplificar la aplicación si tiene varias interfaces de red. Si no importa qué puerto local se utiliza, puede especificar 0 para el número de puerto. En este caso, el proveedor de servicios asignará a un número de puerto disponible entre 1024 y 5000. Si usa este enfoque, puede detectar qué número de puerto y la dirección de red local se ha asignado mediante el uso de la <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> propiedad.  
  
 Llame a la <xref:System.Net.Sockets.TcpListener.Start%2A> método debe empezar a escuchar para los intentos de conexión entrante.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea una instancia de la <xref:System.Net.Sockets.TcpListener> clase mediante un número de puerto y la dirección IP local.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localaddr" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> no se encuentra en el intervalo definido por <see cref="F:System.Net.IPEndPoint.MinPort" /> y <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket AcceptSocket ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket AcceptSocket() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocket" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocket () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ AcceptSocket();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acepta una solicitud de conexión pendiente.</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> que se utiliza para enviar y recibir datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> es un método de bloqueo que devuelve un <xref:System.Net.Sockets.Socket> que puede usar para enviar y recibir datos. Si desea evitar el bloqueo, utilice el <xref:System.Net.Sockets.TcpListener.Pending%2A> método para determinar si las solicitudes de conexión están disponibles en la cola de conexiones entrantes.  
  
 El <xref:System.Net.Sockets.Socket> devuelto se inicializa con el número de puerto y la dirección IP del host remoto. Puede usar cualquiera de los <xref:System.Net.Sockets.Socket.Send%2A> y <xref:System.Net.Sockets.Socket.Receive%2A> métodos disponibles en la <xref:System.Net.Sockets.Socket> clase para comunicarse con el host remoto. Cuando haya terminado con el <xref:System.Net.Sockets.Socket>, asegúrese de llamar a su <xref:System.Net.Sockets.Socket.Close%2A> método. Si la aplicación es relativamente simple, considere el uso de la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método en lugar del <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método. <xref:System.Net.Sockets.TcpClient> Proporciona métodos sencillos para enviar y recibir datos a través de una red en modo de bloqueo sincrónico.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente, la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método se utiliza para devolver un <xref:System.Net.Sockets.Socket>. Esto <xref:System.Net.Sockets.Socket> se usa para comunicarse con el cliente recién conectado.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El agente de escucha no se ha iniciado con una llamada a <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocketAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt; AcceptSocketAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.Socket&gt; AcceptSocketAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocketAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocketAsync () As Task(Of Socket)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::Socket ^&gt; ^ AcceptSocketAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acepta una solicitud de conexión pendiente como una operación asincrónica.</summary>
        <returns>Devuelve <see cref="T:System.Threading.Tasks.Task`1" />  
  
 Objeto de tarea que representa la operación asincrónica. La propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> en el objeto de tarea devuelve <see cref="T:System.Net.Sockets.Socket" /> utilizado para enviar y recibir datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación no se bloqueará. El valor devuelto <xref:System.Threading.Tasks.Task%601> objeto se completará después de que se ha aceptado la conexión del socket.  
  
 El <xref:System.Net.Sockets.Socket> devuelto en <xref:System.Threading.Tasks.Task%601> se inicializa con el número de puerto y la dirección IP del host remoto. Puede usar cualquiera de los <xref:System.Net.Sockets.Socket.Send%2A> y <xref:System.Net.Sockets.Socket.Receive%2A> métodos disponibles en la <xref:System.Net.Sockets.Socket> clase para comunicarse con el host remoto. Cuando haya terminado con el <xref:System.Net.Sockets.Socket>, asegúrese de llamar a su <xref:System.Net.Sockets.Socket.Close%2A> método. Si la aplicación es relativamente simple, considere el uso de la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método en lugar del <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A> método. <xref:System.Net.Sockets.TcpClient> Proporciona métodos sencillos para enviar y recibir datos a través de una red en modo de bloqueo sincrónico.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El agente de escucha no se ha iniciado con una llamada a <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient AcceptTcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient AcceptTcpClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClient () As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ AcceptTcpClient();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acepta una solicitud de conexión pendiente.</summary>
        <returns>
          <see cref="T:System.Net.Sockets.TcpClient" /> que se utiliza para enviar y recibir datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> es un método de bloqueo que devuelve un <xref:System.Net.Sockets.TcpClient> que puede usar para enviar y recibir datos. Use la <xref:System.Net.Sockets.TcpListener.Pending%2A> método para determinar si las solicitudes de conexión están disponibles en la cola de conexión entrantes si desea evitar el bloqueo.  
  
 Use la <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType> método obtener subyacente <xref:System.Net.Sockets.NetworkStream> de devuelto <xref:System.Net.Sockets.TcpClient>. El <xref:System.Net.Sockets.NetworkStream> le proporcionará métodos para enviar y recibir con el host remoto. Cuando esté a través con la <xref:System.Net.Sockets.TcpClient>, asegúrese de llamar a su <xref:System.Net.Sockets.TcpClient.Close%2A> método. Si desea mayor flexibilidad que un <xref:System.Net.Sockets.TcpClient> ofertas, considere el uso de <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente, la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método se utiliza para devolver un <xref:System.Net.Sockets.TcpClient>. Esto <xref:System.Net.Sockets.TcpClient> se usa para comunicarse con el cliente recién conectado.  
  
 [!code-cpp[Classic TcpListenerExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListenerExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListenerExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListenerExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListenerExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListenerExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El agente de escucha no se ha iniciado con una llamada a <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Utilice la propiedad <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> para obtener el código de error específico. Cuando obtenga este código, puede ver en MSDN la documentación de códigos de error de la API de Windows Sockets, versión 2, para ver una descripción detallada del error.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClientAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClientAsync () As Task(Of TcpClient)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::TcpClient ^&gt; ^ AcceptTcpClientAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acepta una solicitud de conexión pendiente como una operación asincrónica.</summary>
        <returns>Devuelve <see cref="T:System.Threading.Tasks.Task`1" />  
  
 Objeto de tarea que representa la operación asincrónica. La propiedad <see cref="P:System.Threading.Tasks.Task`1.Result" /> en el objeto de tarea devuelve <see cref="T:System.Net.Sockets.TcpClient" /> utilizado para enviar y recibir datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación no se bloqueará. El valor devuelto <xref:System.Threading.Tasks.Task%601> objeto se completará después de que se ha aceptado la conexión TCP.  
  
 Use la <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType> método obtener subyacente <xref:System.Net.Sockets.NetworkStream> de devuelto <xref:System.Net.Sockets.TcpClient> en el <xref:System.Threading.Tasks.Task%601>. El <xref:System.Net.Sockets.NetworkStream> le proporcionará métodos para enviar y recibir con el host remoto. Cuando esté a través con la <xref:System.Net.Sockets.TcpClient>, asegúrese de llamar a su <xref:System.Net.Sockets.TcpClient.Close%2A> método. Si desea mayor flexibilidad que un <xref:System.Net.Sockets.TcpClient> ofertas, considere el uso de <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> o <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A>.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El agente de escucha no se ha iniciado con una llamada a <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Utilice la propiedad <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> para obtener el código de error específico. Cuando obtenga este código, puede ver en MSDN la documentación de códigos de error de la API de Windows Sockets, versión 2, para ver una descripción detallada del error.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Active" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Net.Sockets.TcpListener" /> escucha activamente las conexiones de clientes.</summary>
        <value>
          Es <see langword="true" /> si <see cref="T:System.Net.Sockets.TcpListener" /> escucha activamente; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Clases derivadas de <xref:System.Net.Sockets.TcpListener> puede utilizar esta propiedad para determinar si el <xref:System.Net.Sockets.Socket> actualmente está realizando escuchas para los intentos de conexión entrante. El <xref:System.Net.Sockets.TcpClient.Active%2A> propiedad puede utilizarse para evitar la redundancia <xref:System.Net.Sockets.TcpListener.Start%2A> intentos.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AllowNatTraversal">
      <MemberSignature Language="C#" Value="public void AllowNatTraversal (bool allowed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AllowNatTraversal(bool allowed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AllowNatTraversal (allowed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AllowNatTraversal(bool allowed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowed" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="allowed">Valor booleano que especifica si se va a habilitar o deshabilitar NAT transversal.</param>
        <summary>Habilita o deshabilita NAT (Traducción de direcciones de red) transversal en una instancia de <see cref="T:System.Net.Sockets.TcpListener" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> método se utiliza para habilitar o deshabilitar la exploración transversal de NAT para una <xref:System.Net.Sockets.TcpListener> instancia. Puede proporcionarse cruce seguro de NAT mediante Teredo, 6to4 o un túnel ISATAP.  
  
 Cuando el `allowed` parámetro es false, el <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> opción en el socket asociado se establece en <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>. Esto deshabilita explícitamente NAT transversal para una <xref:System.Net.Sockets.TcpListener> instancia.  
  
 Cuando el `allowed` del parámetro es true, el <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> opción en el socket asociado se establece en <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Esto puede permitir cruce seguro de NAT para una <xref:System.Net.Sockets.TcpListener> según las reglas de firewall en su lugar en el sistema.  
  
 El <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> se debe invocar el método antes de llamar a la <xref:System.Net.Sockets.TcpListener.Start%2A> método para empezar a escuchar las solicitudes entrantes de conexión (antes de que se enlaza el socket). Si <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> método se llama después de la <xref:System.Net.Sockets.TcpListener.Start%2A> método, un <xref:System.InvalidOperationException> se iniciará.  
  
 Una dirección Teredo es una dirección IPv6 con el prefijo de 2001:: / 32. Direcciones de Teredo se devuelve a través de la resolución de nombres DNS normal o enumerar como una dirección IPv6 que se asigna a una interfaz local.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llama al método <see cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" /> después de llamar al método <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptSocket">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptSocket (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptSocket(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptSocket (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptSocket(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación se complete.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación de aceptación. Este objeto se pasa al delegado <c>callback</c> cuando la operación finaliza.</param>
        <summary>Comienza una operación asincrónica para aceptar un intento de conexión entrante.</summary>
        <returns>Interfaz <see cref="T:System.IAsyncResult" /> que hace referencia a la creación asincrónica del objeto <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrónico <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> operación debe realizarse mediante una llamada a la <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> método. Normalmente, se invoca el método por el `callback` delegar.  
  
 Este método no se bloquea hasta que se complete la operación. Para bloquear hasta que se complete la operación, use el <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [al llamar a métodos sincrónicos asincrónicamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Puede llamar a la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propiedad de devuelto <xref:System.Net.Sockets.Socket> para identificar el número de puerto y la dirección de red del host remoto.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, use la <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error concreto y consulte la documentación de código de error de la API de Windows Sockets, versión 2, en la biblioteca MSDN en [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) para una detallada Descripción del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> método para crear y conectar un socket. Delegado de la devolución de llamada llama el <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> método para finalizar la solicitud asincrónica.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al intentar obtener acceso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha cerrado <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptTcpClient">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptTcpClient (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptTcpClient(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptTcpClient (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptTcpClient(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación se complete.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación de aceptación. Este objeto se pasa al delegado <c>callback</c> cuando la operación finaliza.</param>
        <summary>Comienza una operación asincrónica para aceptar un intento de conexión entrante.</summary>
        <returns>Interfaz <see cref="T:System.IAsyncResult" /> que hace referencia a la creación asincrónica del objeto <see cref="T:System.Net.Sockets.TcpClient" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrónico <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> operación debe realizarse mediante una llamada a la <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> método. Normalmente, se invoca el método por el `callback` delegar.  
  
 Este método no se bloquea hasta que se complete la operación. Para bloquear hasta que se complete la operación, use el <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [al llamar a métodos sincrónicos asincrónicamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, use la <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error concreto y consulte la documentación de código de error de la API de Windows Sockets, versión 2, en la biblioteca MSDN en [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) para una detallada Descripción del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> método para crear y conectar un socket. Delegado de la devolución de llamada llama el <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> método para finalizar la solicitud asincrónica.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al intentar obtener acceso al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha cerrado <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Net.Sockets.TcpListener Create (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.Sockets.TcpListener Create(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Create(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (port As Integer) As TcpListener" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::Sockets::TcpListener ^ Create(int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpListener</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Puerto en el cual se escucharán los intentos de conexión entrantes.</param>
        <summary>Crea una nueva instancia de <see cref="T:System.Net.Sockets.TcpListener" /> para realizar escuchas en el puerto especificado.</summary>
        <returns>Devuelva <see cref="T:System.Net.Sockets.TcpListener" />.  
  
 Una nueva instancia de <see cref="T:System.Net.Sockets.TcpListener" /> para realizar escuchas en el puerto especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAcceptSocket (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAcceptSocket(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptSocket (asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAcceptSocket(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Interfaz <see cref="T:System.IAsyncResult" /> que se devuelve al llamar al método <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />.</param>
        <summary>Acepta asincrónicamente un intento de conexión entrante y crea un nuevo objeto <see cref="T:System.Net.Sockets.Socket" /> para controlar la comunicación con el host remoto.</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" />.  
  
 Objeto <see cref="T:System.Net.Sockets.Socket" /> que se utiliza para enviar y recibir datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que la operación se complete. Para realizar esta operación sincrónicamente, utilice el <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método.  
  
> [!NOTE]
>  Puede llamar a la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propiedad de devuelto <xref:System.Net.Sockets.Socket> para identificar el número de puerto y la dirección de red del host remoto.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, use la <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error concreto y consulte la documentación de código de error de la API de Windows Sockets, versión 2, en la biblioteca MSDN en [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) para una detallada Descripción del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> método para crear y conectar un socket. Delegado de la devolución de llamada llama el <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> método para finalizar la solicitud asincrónica.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> subyacente se ha cerrado.</exception>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="asyncResult" /> no se creó mediante una llamada al método <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">El método <see cref="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" /> se definió previamente.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al intentar obtener acceso al <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient EndAcceptTcpClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient EndAcceptTcpClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptTcpClient (asyncResult As IAsyncResult) As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ EndAcceptTcpClient(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Interfaz <see cref="T:System.IAsyncResult" /> que se devuelve al llamar al método <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" />.</param>
        <summary>Acepta asincrónicamente un intento de conexión entrante y crea un nuevo objeto <see cref="T:System.Net.Sockets.TcpClient" /> para controlar la comunicación con el host remoto.</summary>
        <returns>
          <see cref="T:System.Net.Sockets.TcpClient" />.  
  
 Objeto <see cref="T:System.Net.Sockets.TcpClient" /> que se utiliza para enviar y recibir datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que la operación se complete. Para realizar esta operación sincrónicamente, utilice el <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método.  
  
> [!NOTE]
>  Puede llamar a la <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propiedad del socket subyacente (<xref:System.Net.Sockets.TcpClient.Client%2A>) para identificar el número de puerto y la dirección de red del host remoto.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, use la <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error concreto y consulte la documentación de código de error de la API de Windows Sockets, versión 2, en la biblioteca MSDN en [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) para una detallada Descripción del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> método para crear y conectar un socket. Delegado de la devolución de llamada llama el <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> método para finalizar la solicitud asincrónica.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor <see cref="T:System.Boolean" /> que especifica si <see cref="T:System.Net.Sockets.TcpListener" /> permite a sólo un socket subyacente escuchar en un puerto concreto.</summary>
        <value>
          Es <see langword="true" /> si <see cref="T:System.Net.Sockets.TcpListener" /> sólo permite a un objeto <see cref="T:System.Net.Sockets.TcpListener" /> escuchar en un puerto concreto; de lo contrario, es <see langword="false" />. . El valor predeterminado es <see langword="true" /> para Windows Server 2003 y el Service Pack 2 y posteriores de Windows XP, y <see langword="false" /> para el resto de versiones.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, varios agentes de escucha pueden escuchar en un puerto específico. Sin embargo, solo uno de los agentes de escucha puede realizar operaciones en el tráfico de red enviado al puerto. Si más de un agente de escucha intenta enlazarse a un puerto determinado, uno con la dirección IP más concreta controla el tráfico de red enviado a ese puerto. Puede usar el <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> propiedad para evitar que varios agentes de escucha de escucha de un puerto específico.  
  
 Establezca esta propiedad antes de llamar a <xref:System.Net.Sockets.TcpListener.Start%2A>, o llamar a la <xref:System.Net.Sockets.TcpListener.Stop%2A> método y, a continuación, establezca esta propiedad.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se obtiene y establece el <xref:System.Net.Sockets.TcpListener.ExclusiveAddressUse%2A> propiedad.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#2)]
 [!code-csharp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#2)]
 [!code-vb[System.Net.Sockets.TcpListener1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.TcpListener" /> se ha iniciado. Llame al método <see cref="M:System.Net.Sockets.TcpListener.Stop" /> y, a continuación, establezca la propiedad <see cref="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al intentar obtener acceso al socket subyacente.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> subyacente se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TcpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TcpListener ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalEndpoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndpoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndpoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.LocalEndpoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndpoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndpoint { System::Net::EndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Net.EndPoint" /> subyacente del objeto <see cref="T:System.Net.Sockets.TcpListener" /> actual.</summary>
        <value>Objeto <see cref="T:System.Net.EndPoint" /> al que está enlazado el <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> propiedad para identificar el número de puerto y la interfaz de red local que se usa para escuchar solicitudes de conexión de cliente entrantes, una vez realizada una conexión de socket. Primero debe convertir esto <xref:System.Net.EndPoint> a una <xref:System.Net.IPEndPoint>. A continuación, puede llamar a la <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> propiedad que se va a recuperar la dirección IP local y el <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> propiedad para recuperar el número de puerto local.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el número de puerto y la dirección IP local en el que el <xref:System.Net.Sockets.TcpListener> está realizando escuchas para las solicitudes de conexión entrantes.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.EndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Pending">
      <MemberSignature Language="C#" Value="public bool Pending ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Pending() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Pending" />
      <MemberSignature Language="VB.NET" Value="Public Function Pending () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Pending();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina si existen solicitudes de conexión pendientes.</summary>
        <returns>
          Es <see langword="true" /> si hay conexiones pendientes; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método de no bloqueo determina si hay solicitudes de conexión pendientes. Dado que la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> y <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> métodos bloquean la ejecución hasta que el <xref:System.Net.Sockets.TcpListener.Start%2A> método ha puesto en cola una solicitud de conexión entrante, el <xref:System.Net.Sockets.TcpListener.Pending%2A> método se puede utilizar para determinar si las conexiones están disponibles antes de intentar aceptarlos.  
  
   
  
## Examples  
 El siguiente código de ejemplo se comprueba el <xref:System.Net.Sockets.TcpListener.Pending%2A> método. Si una solicitud de conexión está esperando a ser aceptados, a continuación, una llamada a la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> se realiza el método.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El agente de escucha no se ha iniciado con una llamada a <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Server" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Server { System::Net::Sockets::Socket ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto de red <see cref="T:System.Net.Sockets.Socket" /> subyacente.</summary>
        <value>Objeto <see cref="T:System.Net.Sockets.Socket" /> subyacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener> crea un <xref:System.Net.Sockets.Socket> para realizar escuchas de solicitudes de conexión de cliente entrantes. Clases derivadas de <xref:System.Net.Sockets.TcpListener> puede utilizar esta propiedad para obtener esta <xref:System.Net.Sockets.Socket>. Usar subyacente <xref:System.Net.Sockets.Socket> devuelto por la <xref:System.Net.Sockets.TcpListener.Server%2A> propiedad si necesita tener acceso a más allá de lo que <xref:System.Net.Sockets.TcpListener> proporciona.  
  
> [!NOTE]
>  El <xref:System.Net.Sockets.TcpListener.Server%2A> propiedad sólo devuelve el <xref:System.Net.Sockets.Socket> usa para escuchar las solicitudes de conexión de cliente entrantes. Use la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método para aceptar una solicitud de conexión pendiente y obtener un <xref:System.Net.Sockets.Socket> para enviar y recibir datos. También puede usar el <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método para aceptar una solicitud de conexión pendiente y obtener un <xref:System.Net.Sockets.TcpClient> para enviar y recibir datos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Net.Sockets.TcpListener.Server%2A> propiedad. Subyacente <xref:System.Net.Sockets.Socket> se recupera y <xref:System.Net.Sockets.SocketOptionName.Linger> <xref:System.Net.Sockets.Socket> opción está configurada para el tiempo de espera tras 10 segundos si los datos permanecen en el búfer de red después de cerrar la conexión.  
  
 [!code-csharp[TcpListenerProtectedMembers1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListenerProtectedMembers1/CS/source.cs#1)]
 [!code-vb[TcpListenerProtectedMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListenerProtectedMembers1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza la escucha de solicitudes de conexión entrantes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comienza la escucha de solicitudes de conexión entrantes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.TcpListener.Start%2A> método inicializa subyacente <xref:System.Net.Sockets.Socket>, enlaza a un extremo local y escucha los intentos de conexión entrante. Si se recibe una solicitud de conexión, el <xref:System.Net.Sockets.TcpListener.Start%2A> método poner en cola la solicitud y continuará escuchando las solicitudes adicionales hasta que se llama a la <xref:System.Net.Sockets.TcpListener.Stop%2A> método. Si <xref:System.Net.Sockets.TcpListener> recibe una solicitud de conexión después de que haya puesto en cola el número máximo de conexiones, se producirá un <xref:System.Net.Sockets.SocketException> en el cliente.  
  
 Para quitar una conexión de la cola de conexiones entrantes, use la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método o la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método. El <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método quitará una conexión de la cola y devolverá un <xref:System.Net.Sockets.TcpClient> que puede usar para enviar y recibir datos. El <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método devolverá un <xref:System.Net.Sockets.Socket> que puede usar para hacer lo mismo. Si la aplicación sólo requiere E/S sincrónica, utilice <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>. Para obtener más control de comportamiento, utilice <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>. Ambos métodos bloquearán hasta que haya una solicitud de conexión está disponible en la cola.  
  
 Use la <xref:System.Net.Sockets.TcpListener.Stop%2A> método para cerrar la <xref:System.Net.Sockets.TcpListener> y detener la escucha. Usted es responsable de cerrar las conexiones aceptadas por separado.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo <xref:System.Net.Sockets.TcpListener.Start%2A> se usa para realizar escuchas de los intentos de conexión de cliente entrantes.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Utilice la propiedad <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> para obtener el código de error específico. Cuando obtenga este código, puede ver en MSDN la documentación de códigos de error de la API de Windows Sockets, versión 2, para ver una descripción detallada del error.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(int backlog);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Longitud máxima de la cola de conexiones pendientes.</param>
        <summary>Comienza la escucha de solicitudes de conexión entrantes en un número máximo de conexión pendiente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Net.Sockets.TcpListener.Start%2A> método inicializa subyacente <xref:System.Net.Sockets.Socket>, enlaza a un extremo local y escucha los intentos de conexión entrante. Si se recibe una solicitud de conexión, <xref:System.Net.Sockets.TcpListener.Start%2A> creará poner en cola la solicitud y continuará escuchando las solicitudes adicionales hasta que llame a la <xref:System.Net.Sockets.TcpListener.Stop%2A> método. Si <xref:System.Net.Sockets.TcpListener> recibe una solicitud de conexión después de que ya ha puesto en cola el número máximo de conexiones que se producirá un <xref:System.Net.Sockets.SocketException> en el cliente.  
  
 Para quitar una conexión de la cola de conexiones entrantes, use la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método o la <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método. El <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> método quitará una conexión de la cola y devolverá un <xref:System.Net.Sockets.TcpClient> que puede usar para enviar y recibir datos. El <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método devolverá un <xref:System.Net.Sockets.Socket> que puede usar para hacer lo mismo. Si la aplicación sólo requiere E/S sincrónica, utilice la <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>. Para obtener más control de comportamiento, use <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> método. Ambos métodos bloquearán hasta que haya una solicitud de conexión está disponible en la cola.  
  
 Use la <xref:System.Net.Sockets.TcpListener.Stop%2A> método para cerrar la <xref:System.Net.Sockets.TcpListener> y detener la escucha. Usted es responsable de cerrar las conexiones aceptadas por separado.  
  
> [!NOTE]
>  Use la <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propiedad para obtener el código de error concreto y consulte la documentación de código de error de la API de Windows Sockets, versión 2, en la biblioteca MSDN en [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo <xref:System.Net.Sockets.TcpListener.Start%2A> se usa para realizar escuchas de los intentos de conexión de cliente entrantes.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al obtener acceso al socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="backlog" /> es menor que cero o supera el número máximo de conexiones permitidas.</exception>
        <exception cref="T:System.InvalidOperationException">El <see cref="T:System.Net.Sockets.Socket" /> es nulo.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra el agente de escucha.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.Stop%2A> Cierra el agente de escucha. Se perderán las solicitudes de conexión no aceptado en la cola. Hosts remotos de esperando una conexión para que se acepte producirá un <xref:System.Net.Sockets.SocketException>. Usted es responsable de cerrar las conexiones aceptadas por separado.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Net.Sockets.TcpListener.Stop%2A> método para cerrar subyacente <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Utilice la propiedad <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> para obtener el código de error específico. Cuando obtenga este código, puede ver en MSDN la documentación de códigos de error de la API de Windows Sockets, versión 2, para ver una descripción detallada del error.</exception>
        <block subset="none" type="usage">
          <para>El <see cref="M:System.Net.Sockets.TcpListener.Stop" /> método también cierra subyacente <see cref="T:System.Net.Sockets.Socket" />y crea un nuevo <see cref="T:System.Net.Sockets.Socket" /> para el <see cref="T:System.Net.Sockets.TcpListener" />. Si establece las propiedades en subyacente <see cref="T:System.Net.Sockets.Socket" /> antes de llamar a la <see cref="M:System.Net.Sockets.TcpListener.Stop" /> método, las propiedades no se llevarán a la nueva <see cref="T:System.Net.Sockets.Socket" />.</para>
        </block>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
  </Members>
</Type>