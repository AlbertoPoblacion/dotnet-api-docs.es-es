<Type Name="TcpClient" FullName="System.Net.Sockets.TcpClient">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6c4ef2337a11e9eaacb653f83b646a604476f21e" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55367421" /></Metadata><TypeSignature Language="C#" Value="public class TcpClient : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpClient extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.TcpClient" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpClient&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpClient : IDisposable" />
  <TypeSignature Language="F#" Value="type TcpClient = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Proporciona conexiones de cliente para servicios de red TCP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clase `TcpClient` proporciona métodos sencillos para conectarse, enviar, y recibir transmitir datos a través de una red en modo de bloqueo sincrónico.   
  
 Para que `TcpClient` pueda conectarse e intercambiar datos, un <xref:System.Net.Sockets.TcpListener> o <xref:System.Net.Sockets.Socket> creado con el <xref:System.Net.Sockets.ProtocolType> TCP debe estar escuchando solicitudes de conexión entrantes. Puede conectarse a este agente de escucha en una de las dos maneras siguientes: Puede conectarse a este agente de escucha en una de las dos maneras siguientes:  
  
-   Crear un `TcpClient` y llamar a uno de los tres métodos <xref:System.Net.Sockets.TcpClient.Connect%2A> disponibles.  
  
-   Crear un `TcpClient` con el nombre de host y número de puerto del host remoto. Este constructor intentará automáticamente una conexión.  
  
> [!NOTE]
>  Si desea enviar datagramas sin conexión en modo de bloqueo sincrónico, utilice la clase <xref:System.Net.Sockets.UdpClient>.  
  
   
  
## Examples  
 El siguiente ejemplo de código establece una conexión `TcpClient`.  
  
 [!code-cpp[System.Net.Sockets.TcpClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/CPP/tcpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/CS/tcpclient.cs#1)]
 [!code-vb[System.Net.Sockets.TcpClient#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpClient/VB/tcpclient.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Permiso para establecer una conexión saliente o Aceptar una solicitud entrante.</permission>
    <block subset="none" type="overrides"><para>Para enviar y recibir datos, use el método <see cref="M:System.Net.Sockets.TcpClient.GetStream" /> para obtener un <see cref="T:System.Net.Sockets.NetworkStream" />. Llame a la <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" /> y <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> métodos de la <see cref="T:System.Net.Sockets.NetworkStream" /> para enviar y recibir datos con el host remoto. Use el método <see cref="M:System.Net.Sockets.NetworkStream.Close(System.Int32)" /> para liberar todos los recursos asociados con el <see cref="T:System.Net.Sockets.TcpClient" />.</para></block>
    <altmember cref="T:System.Net.Sockets.TcpListener" />
    <altmember cref="T:System.Net.Sockets.NetworkStream" />
    <altmember cref="T:System.Net.Sockets.Socket" />
    <altmember cref="T:System.Net.Sockets.ProtocolType" />
    <altmember cref="T:System.Net.IPEndPoint" />
    <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
    <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
    <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
    <related type="Article" href="~/docs/framework/network-programming/tcp-udp.md">TCP-UDP</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un nuevo <xref:System.Net.Sockets.TcpClient> y permite que el proveedor de servicios subyacente asignar el más adecuado local IP dirección y número de puerto. Debe llamar primero a la <xref:System.Net.Sockets.TcpClient.Connect%2A> método antes de enviar y recibir datos.  
  
> [!NOTE]
>  Este constructor sólo funciona con tipos de dirección IPv4.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el constructor predeterminado para crear un nuevo <xref:System.Net.Sockets.TcpClient>.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpClient : System.Net.IPEndPoint -&gt; System.Net.Sockets.TcpClient" Usage="new System.Net.Sockets.TcpClient localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><see cref="T:System.Net.IPEndPoint" /> a la que asociará el TCP <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.TcpClient" /> y la enlaza con el punto de conexión local especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un nuevo <xref:System.Net.Sockets.TcpClient> y lo enlaza con el <xref:System.Net.IPEndPoint> especificado por el `localEP` parámetro. Antes de llamar a este constructor, debe crear un `IPEndPoint` con el número de puerto y la dirección IP desde el que se va a enviar y recibir datos. No es necesario especificar un número de puerto y la dirección IP local antes de conectar y comunicar. Si creas un `TcpClient` utilizando cualquier otro constructor, el proveedor de servicios subyacente asignará la más adecuada local IP dirección y número de puerto.  
  
 Debe llamar a la <xref:System.Net.Sockets.TcpClient.Connect%2A> método antes de enviar y recibir datos.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear una instancia de la <xref:System.Net.Sockets.TcpClient> clase con un extremo local.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="localEP" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient(System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpClient : System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.TcpClient" Usage="new System.Net.Sockets.TcpClient family" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="family">Propiedad <see cref="P:System.Net.IPAddress.AddressFamily" /> del protocolo IP.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.TcpClient" /> con la familia especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear una instancia de la <xref:System.Net.Sockets.TcpClient> clase.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#15)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#15)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor del parámetro <paramref name="family" /> no es igual a AddressFamily.InterNetwork. 
O bien 
El valor del parámetro <paramref name="family" /> no es igual a AddressFamily.InterNetworkV6.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpClient (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpClient(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpClient : string * int -&gt; System.Net.Sockets.TcpClient" Usage="new System.Net.Sockets.TcpClient (hostname, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">Nombre DNS del host remoto con el que se desea establecer conexión.</param>
        <param name="port">Número de puerto del host remoto con el que se desea establecer conexión.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Sockets.TcpClient" /> y se conecta al puerto especificado en el host especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un nuevo <xref:System.Net.Sockets.TcpClient> y realiza una conexión sincrónica intento en el nombre de host proporcionado y número de puerto. El proveedor de servicios subyacente asignará a la más adecuada local IP dirección y número de puerto. `TcpClient` se bloqueará hasta que se conecta o se produce un error. Este constructor permite inicializar, resolver el nombre de host DNS y conectarse en un solo paso.  
  
 Si IPv6 está habilitado y el <xref:System.Net.Sockets.TcpClient.%23ctor%28System.String%2CSystem.Int32%29> método se llama para conectarse a un host que se resuelve en ambos IPv6 y direcciones IPv4, la conexión a la dirección será de IPv6 intenta primero antes de la dirección IPv4. Esto puede tener el efecto de retrasar el tiempo para establecer la conexión si el host no está escuchando en la dirección IPv6.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico. Después de haber obtenido este código, puede hacer referencia a la [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear una instancia de la <xref:System.Net.Sockets.TcpClient> clase con un nombre de host y número de puerto.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="hostname" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="port" /> no está entre <see cref="F:System.Net.IPEndPoint.MinPort" /> y <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se produjo un error al acceder al socket.</exception>
        <altmember cref="Overload:System.Net.Sockets.TcpClient.#ctor" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Active" />
      <MemberSignature Language="VB.NET" Value="Protected Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool with get, set" Usage="System.Net.Sockets.TcpClient.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se ha establecido una conexión.</summary>
        <value>Es <see langword="true" /> si se realizó la conexión; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas de <xref:System.Net.Sockets.TcpClient> puede utilizar esta propiedad para determinar si un intento de conexión se ha realizado correctamente. No supervisa el estado de conexión en curso `TcpClient`. Si el host remoto cierra la conexión, `Active` no se actualizará. Si va a derivar de `TcpClient` y requieren más atención en el estado de conexión, use el <xref:System.Net.Sockets.Socket.Connected%2A> propiedad de la <xref:System.Net.Sockets.Socket> devuelto por la <xref:System.Net.Sockets.TcpClient.Client%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.Connected" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.TcpClient.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cantidad de datos que se recibieron de la red y están disponibles para leer.</summary>
        <value>Número de bytes de datos recibidos de la red y disponibles para su lectura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
El `Available` propiedad es una manera de determinar si se pone en cola datos para su lectura. Si hay datos disponibles, llame a <xref:System.Net.Sockets.NetworkStream.Read%2A> para obtener los datos. Los datos disponibles están que la cantidad total de datos en cola en el búfer de red para su lectura. Si no hay datos se pone en cola en el búfer de red, `Available` devuelve 0.  
  
 Si el host remoto se apaga o cierra la conexión, `Available` puede producir un <xref:System.Net.Sockets.SocketException>. Si recibe un `SocketException`, utilice <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico. Después de haber obtenido este código, puede consultar la documentación de códigos de error de Windows Sockets versión 2 API en MSDN library en [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library) para obtener una descripción detallada del error.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la `Available` propiedad.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicia una solicitud asincrónica para una conexión a host remoto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpClient.BeginConnect (address, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address"><see cref="T:System.Net.IPAddress" /> del host remoto.</param>
        <param name="port">Número de puerto del host remoto.</param>
        <param name="requestCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación se complete.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación de conexión. Este objeto se pasa al delegado de <paramref name="requestCallback" /> cuando la operación se completa.</param>
        <summary>Inicia una solicitud asincrónica para una conexión a host remoto. El host remoto se especifica mediante un <see cref="T:System.Net.IPAddress" /> y un número de puerto (<see cref="T:System.Int32" />).</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que hace referencia a la conexión asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrónico `BeginConnect` debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.TcpClient.EndConnect%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar.  
  
 Este método no se bloquea hasta que se complete la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.TcpClient.Connect%2A> sobrecargas del método.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Net.Sockets.TcpClient> y se conecta a un host remoto.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpClient1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="address" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de puerto no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpClient.BeginConnect (addresses, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="addresses">Como mínimo un <see cref="T:System.Net.IPAddress" /> que designa los host remotos.</param>
        <param name="port">Número de puerto de los host remotos.</param>
        <param name="requestCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación se complete.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación de conexión. Este objeto se pasa al delegado de <paramref name="requestCallback" /> cuando la operación se completa.</param>
        <summary>Inicia una solicitud asincrónica para una conexión a host remoto. El host remoto se especifica mediante una matriz <see cref="T:System.Net.IPAddress" /> y un número de puerto (<see cref="T:System.Int32" />).</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que hace referencia a la conexión asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrónico `BeginConnect` debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.TcpClient.EndConnect%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar.  
  
 Este método no se bloquea hasta que se complete la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.TcpClient.Connect%2A> sobrecargas del método.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 Este método se utiliza normalmente inmediatamente después de llamar a la <xref:System.Net.Dns.BeginGetHostAddresses%2A> método, que puede devolver varias direcciones IP para un solo host.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Net.Sockets.TcpClient> y se conecta a un host remoto.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpClient1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="addresses" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de puerto no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpClient.BeginConnect (host, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="host">Nombre del host remoto.</param>
        <param name="port">Número de puerto del host remoto.</param>
        <param name="requestCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la operación se complete.</param>
        <param name="state">Objeto definido por el usuario que contiene información sobre la operación de conexión. Este objeto se pasa al delegado de <paramref name="requestCallback" /> cuando la operación se completa.</param>
        <summary>Inicia una solicitud asincrónica para una conexión a host remoto. El host remoto se especifica mediante un nombre de host (<see cref="T:System.String" />) y un número de puerto (<see cref="T:System.Int32" />).</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que hace referencia a la conexión asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrónico `BeginConnect` debe completarse la operación mediante una llamada a la <xref:System.Net.Sockets.TcpClient.EndConnect%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar.  
  
 Este método no se bloquea hasta que se complete la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Sockets.TcpClient.Connect%2A> sobrecargas del método.  
  
 Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Net.Sockets.TcpClient> y se conecta a un host remoto.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#6)]
 [!code-csharp[System.Net.Sockets.TcpClient1#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="host" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de puerto no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Client">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Client { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Client" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Client" />
      <MemberSignature Language="VB.NET" Value="Public Property Client As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Client { System::Net::Sockets::Socket ^ get(); void set(System::Net::Sockets::Socket ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Client : System.Net.Sockets.Socket with get, set" Usage="System.Net.Sockets.TcpClient.Client" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Net.Sockets.Socket" /> subyacente.</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> de red subyacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpClient> crea un <xref:System.Net.Sockets.Socket> para enviar y recibir datos a través de una red. Las clases derivadas de `TcpClient` puede utilizar esta propiedad para obtener o establecer esto `Socket`. Usar subyacente `Socket` devuelto desde `Client` si necesita tener acceso a más allá de eso que `TcpClient` proporciona. También puede usar `Client` establecer subyacente `Socket` a un `Socket`. Esto puede resultar útil si desea aprovechar la simplicidad de `TcpClient` mediante preexistente `Socket`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la `Client` propiedad. En este ejemplo, el tamaño del búfer de recepción de subyacente <xref:System.Net.Sockets.Socket> se cambia.  
  
 [!code-csharp[TcpClientProtectedMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpClientProtectedMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[TcpClientProtectedMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpClientProtectedMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="tcpClient.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina esta instancia <see cref="T:System.Net.Sockets.TcpClient" /> y solicita que se cierre la conexión TCP subyacente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Close` método marca la instancia como eliminada y solicita que el asociado <xref:System.Net.Sockets.Socket> cerrar la conexión TCP. Según el <xref:System.Net.Sockets.TcpClient.LingerState%2A> propiedad, la conexión TCP puede permanecer abierta durante algún tiempo después de la `Close` método se llama cuando se envíen los datos permanecen. No hay ninguna notificación proporcionada cuando se haya completado cierre la conexión subyacente.  
  
 Llamar a este método producirá finalmente el cierre del asociado `Socket` y también se cerrará asociado <xref:System.Net.Sockets.NetworkStream> que se utiliza para enviar y recibir datos si se ha creado uno.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo cerrar una <xref:System.Net.Sockets.TcpClient> mediante una llamada a la `Close` método.  
  
 [!code-cpp[NCLTCPClientSync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLTcpClientSync/CPP/tcpclient.cpp#1)]
 [!code-csharp[NCLTCPClientSync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLTcpClientSync/CS/tcpclient.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Conecta el cliente a un host TCP remoto con el nombre de host y el número de puerto especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPEndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPEndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPEndPoint -&gt; unit" Usage="tcpClient.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><see cref="T:System.Net.IPEndPoint" /> con el que se desea conectar.</param>
        <summary>Conecta el cliente a un host TCP remoto con el punto de conexión de red remoto especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a este método para establecer una conexión sincrónica de host remoto especificado <xref:System.Net.IPEndPoint>. Antes de llamar a `Connect`, debe crear una instancia de la `IPEndPoint` clase mediante una dirección IP y un número de puerto. Use esta `IPEndPoint` como el `remoteEP` parámetro. El `Connect` método se bloqueará hasta que se conecta o se produce un error. Después de conectarse con el host remoto, use el <xref:System.Net.Sockets.TcpClient.GetStream%2A> método obtener subyacente <xref:System.Net.Sockets.NetworkStream>. Use esta `NetworkStream` para enviar y recibir datos.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico. Después de haber obtenido este código, puede hacer referencia a la [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md)  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza un <xref:System.Net.IPEndPoint> para conectar con un host remoto.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#7)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#7)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="remoteEp" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se produjo un error al acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">La clase <see cref="T:System.Net.Sockets.TcpClient" /> está cerrada.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="tcpClient.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address"><see cref="T:System.Net.IPAddress" /> del host con el que se desea conectar.</param>
        <param name="port">Número de puerto con el que se desea conectar.</param>
        <summary>Conecta el cliente a un host TCP remoto con la dirección IP y el número de puerto especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a este método para establecer una conexión sincrónica de host remoto especificado <xref:System.Net.IPAddress> y número de puerto. El <xref:System.Net.Sockets.TcpClient.Connect%2A> método se bloqueará hasta que se conecta o se produce un error. Después de conectarse con el host remoto, use el <xref:System.Net.Sockets.TcpClient.GetStream%2A> método obtener subyacente <xref:System.Net.Sockets.NetworkStream>. Use esta `NetworkStream` para enviar y recibir datos.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico. Después de haber obtenido este código, puede hacer referencia a la [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se usa una dirección IP y el número de puerto para conectarse con un host remoto.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#6)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#6)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="address" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> no se encuentra en el intervalo definido por <see cref="F:System.Net.IPEndPoint.MinPort" /> y <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se produjo un error al acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> está cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] ipAddresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] ipAddresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (ipAddresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ ipAddresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="tcpClient.Connect (ipAddresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ipAddresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ipAddresses">Matriz <see cref="T:System.Net.IPAddress" /> del host con el que desea conectar.</param>
        <param name="port">Número de puerto con el que se desea conectar.</param>
        <summary>Conecta el cliente a un host TCP remoto con las direcciones IP y el número de puerto que se especificaron.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza normalmente inmediatamente después de llamar a la <xref:System.Net.Dns.BeginGetHostAddresses%2A> método, que puede devolver varias direcciones IP para un solo host. Llame a la `Connect` método para establecer una conexión sincrónica de host remoto al host especificado por la matriz de <xref:System.Net.IPAddress> elementos y el número de puerto. El `Connect` método se bloqueará hasta que se conecta o se produce un error. Después de conectarse con el host remoto, use el <xref:System.Net.Sockets.TcpClient.GetStream%2A> método obtener subyacente <xref:System.Net.Sockets.NetworkStream>. Use esta `NetworkStream` para enviar y recibir datos.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico. Después de haber obtenido este código, puede consultar la documentación de códigos de error de Windows Sockets versión 2 API en MSDN library en [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library) para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se usa una dirección IP y el número de puerto para conectarse con un host remoto.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#8](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#8)]
 [!code-csharp[System.Net.Sockets.TcpClient1#8](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="ipAddresses" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de puerto no es válido.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</exception>
        <exception cref="T:System.NotSupportedException">Este método es válido para sockets que utilizan el marcador <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o el marcador <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <altmember cref="T:System.Net.Sockets.TcpListener" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="tcpClient.Connect (hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="hostname">Nombre DNS del host remoto con el que se desea establecer conexión.</param>
        <param name="port">Número de puerto del host remoto con el que se desea establecer conexión.</param>
        <summary>Conecta el cliente al puerto especificado en el host especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a este método para establecer una conexión sincrónica de host remoto con el nombre de host especificado y el número de puerto. El `Connect` método se bloqueará hasta que se conecta o se produce un error. Después de conectarse con el host remoto, use el <xref:System.Net.Sockets.TcpClient.GetStream%2A> método obtener subyacente <xref:System.Net.Sockets.NetworkStream>. Use esta `NetworkStream` para enviar y recibir datos.  
  
 Si IPv6 está habilitado y el `Connect(String, Int32)` método se llama para conectarse a un host que se resuelve en ambos IPv6 y direcciones IPv4, la conexión a la dirección será de IPv6 intenta primero antes de la dirección IPv4. Esto puede tener el efecto de retrasar el tiempo para establecer la conexión si el host no está escuchando en la dirección IPv6.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico. Después de haber obtenido este código, puede hacer referencia a la [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente utiliza el nombre de host y el puerto número para establecer conexión con un host remoto.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#5)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#5)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="hostname" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="port" /> no está entre <see cref="F:System.Net.IPEndPoint.MinPort" /> y <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se produjo un error al acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> está cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Conecta el cliente a un host TCP remoto con el nombre de host y el número de puerto especificados como una operación asincrónica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (address As IPAddress, port As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.IPAddress * int -&gt; System.Threading.Tasks.Task" Usage="tcpClient.ConnectAsync (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address"><see cref="T:System.Net.IPAddress" /> del host con el que se desea conectar.</param>
        <param name="port">Número de puerto con el que se desea conectar.</param>
        <summary>Conecta el cliente a un host TCP remoto con la dirección IP y el número de puerto especificados como una operación asincrónica.</summary>
        <returns>Objeto de tarea que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación no se bloqueará. La expresión devuelta devuelve <xref:System.Threading.Tasks.Task> objeto se completará una vez establecida la conexión TCP. Este método no bloquea el subproceso de llamada mientras la solicitud de conexión está en curso.  
  
 Llame a este método para establecer una conexión sincrónica de host remoto especificado <xref:System.Net.IPAddress> y número de puerto como una operación asincrónica. Después de conectarse con el host remoto, use el <xref:System.Net.Sockets.TcpClient.GetStream%2A> método obtener subyacente <xref:System.Net.Sockets.NetworkStream>. Use esta `NetworkStream` para enviar y recibir datos.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico. Después de haber obtenido este código, puede hacer referencia a la [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="address" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> no se encuentra en el intervalo definido por <see cref="F:System.Net.IPEndPoint.MinPort" /> y <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se produjo un error al acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> está cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (addresses As IPAddress(), port As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.IPAddress[] * int -&gt; System.Threading.Tasks.Task" Usage="tcpClient.ConnectAsync (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">Matriz <see cref="T:System.Net.IPAddress" /> del host con el que desea conectar.</param>
        <param name="port">Número de puerto con el que se desea conectar.</param>
        <summary>Conecta el cliente a un host TCP remoto con las direcciones IP y el número de puerto especificados como una operación asincrónica.</summary>
        <returns>Objeto de tarea que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación no se bloqueará. La expresión devuelta devuelve <xref:System.Threading.Tasks.Task> objeto se completará una vez establecida la conexión TCP. Este método no bloquea el subproceso de llamada mientras la solicitud de conexión está en curso.  
  
 Este método se utiliza normalmente inmediatamente después de llamar a la <xref:System.Net.Dns.BeginGetHostAddresses%2A> método, que puede devolver varias direcciones IP para un solo host. Llame a este método para establecer una conexión sincrónica de host remoto al host especificado por la matriz de <xref:System.Net.IPAddress> elementos y el número de puerto como una operación asincrónica. Después de conectarse con el host remoto, use el <xref:System.Net.Sockets.TcpClient.GetStream%2A> método obtener subyacente <xref:System.Net.Sockets.NetworkStream>. Use esta `NetworkStream` para enviar y recibir datos.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico. Después de haber obtenido este código, puede consultar la documentación de códigos de error de Windows Sockets versión 2 API en MSDN library en [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library) para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="ipAddresses" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de puerto no es válido.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.Socket" /> se ha cerrado.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la pila de llamadas no tiene permiso para la operación solicitada.</exception>
        <exception cref="T:System.NotSupportedException">Este método es válido para sockets que utilizan el marcador <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> o el marcador <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <altmember cref="T:System.Net.Sockets.TcpListener" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ConnectAsync (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ConnectAsync(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.ConnectAsync(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (host As String, port As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ConnectAsync(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : string * int -&gt; System.Threading.Tasks.Task" Usage="tcpClient.ConnectAsync (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">Nombre DNS del host remoto con el que se desea establecer conexión.</param>
        <param name="port">Número de puerto del host remoto con el que se desea establecer conexión.</param>
        <summary>Conecta al cliente con el puerto TCP especificado en el host especificado como una operación asincrónica.</summary>
        <returns>Objeto de tarea que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operación no se bloqueará. La expresión devuelta devuelve <xref:System.Threading.Tasks.Task> objeto se completará una vez establecida la conexión TCP. Este método no bloquea el subproceso de llamada mientras la solicitud de conexión está en curso.  
  
 Llame a este método para establecer una conexión sincrónica de host remoto con el nombre de host especificado y el puerto número como una operación asincrónica. Después de conectarse con el host remoto, use el <xref:System.Net.Sockets.TcpClient.GetStream%2A> método obtener subyacente <xref:System.Net.Sockets.NetworkStream>. Use esta `NetworkStream` para enviar y recibir datos.  
  
 Si IPv6 está habilitado y el <xref:System.Net.Sockets.TcpClient.ConnectAsync%28System.String%2CSystem.Int32%29> método se llama para conectarse a un host que se resuelve en ambos IPv6 y direcciones IPv4, la conexión a la dirección será de IPv6 intenta primero antes de la dirección IPv4. Esto puede tener el efecto de retrasar el tiempo para establecer la conexión si el host no está escuchando en la dirección IPv6.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico. Después de haber obtenido este código, puede hacer referencia a la [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="hostname" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="port" /> no está entre <see cref="F:System.Net.IPEndPoint.MinPort" /> y <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se produjo un error al acceder al socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.TcpClient" /> está cerrado.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpClient.GetStream" />
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.TcpClient.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el <see cref="T:System.Net.Sockets.Socket" /> subyacente de un <see cref="T:System.Net.Sockets.TcpClient" /> está conectado a un host remoto.</summary>
        <value><see langword="true" /> si el socket de <see cref="P:System.Net.Sockets.TcpClient.Client" /> estaba conectado a un recurso remoto desde la operación más reciente; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Connected` propiedad obtiene el estado de conexión de la <xref:System.Net.Sockets.TcpClient.Client%2A> socket a partir de la última operación de E/S. Cuando devuelve `false`, el `Client` socket nunca se conectó o ya no está conectado.  
  
 Dado que el `Connected` propiedad sólo refleja el estado de la conexión a partir de la operación más reciente, debe intentar enviar o recibir un mensaje para determinar el estado actual. Una vez que se produce un error de envío de mensaje, esta propiedad ya no devuelve `true`. Tenga en cuenta que este comportamiento es así por diseño. Confiable no puede comprobar el estado de la conexión porque, en el tiempo entre la prueba y el envío y recepción, la conexión podría haberse perdida. El código debe suponer el socket está conectado y correctamente las transmisiones de error de identificador.  
  
   
  
## Examples  
 El siguiente ejemplo de código se conecta a un punto de conexión remota y, a continuación, comprueba la conexión.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#2)]
 [!code-csharp[System.Net.Sockets.TcpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="tcpClient.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos administrados y no administrados que utiliza el objeto <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="tcpClient.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Se establece en <see langword="true" /> para liberar tanto los recursos administrados como los no administrados; se establece en <see langword="false" /> para liberar únicamente los recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.Net.Sockets.TcpClient" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama por el público `Dispose()` método y el <xref:System.Object.Finalize%2A> método. `Dispose()` invoca este método con el `disposing` parámetro establecido en `true`. `Finalize` invoca este método con `disposing` establecido en `false`.  
  
 Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.Net.Sockets.TcpClient> hace referencia. Para ello, invocando el `Dispose()` método de cada objeto que se hace referencia.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> puede recibir varias llamadas de otros objetos. Al invalidar <see langword="Dispose(Boolean)" />, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />. Para obtener más información sobre cómo implementar <see langword="Dispose(Boolean)" />, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obtener más información acerca de <see langword="Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [reemplazar el método Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="tcpClient.EndConnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Objeto <see cref="T:System.IAsyncResult" /> devuelto por una llamada a <see cref="Overload:System.Net.Sockets.TcpClient.BeginConnect" />.</param>
        <summary>Finaliza un intento de conexión asincrónica pendiente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que la operación se complete. Para realizar esta operación sincrónicamente, utilice un <xref:System.Net.Sockets.TcpClient.Connect%2A> método.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico. Después de haber obtenido este código, puede consultar la documentación de códigos de error de Windows Sockets versión 2 API en MSDN library en [ http://msdn.microsoft.com/library ](https://msdn.microsoft.com/library) para obtener una descripción detallada del error.  
  
   
  
## Examples  
 El siguiente ejemplo de código finaliza el intento de conexión asincrónica.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#7)]
 [!code-csharp[System.Net.Sockets.TcpClient1#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="asyncResult" /> no se devolvió mediante una llamada a un método <see cref="Overload:System.Net.Sockets.TcpClient.BeginConnect" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha llamado previamente al método <see cref="M:System.Net.Sockets.TcpClient.EndConnect(System.IAsyncResult)" /> para la conexión asincrónica.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Error al intentar obtener acceso a <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> subyacente se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.TcpClient.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor <see cref="T:System.Boolean" /> que especifica si el <see cref="T:System.Net.Sockets.TcpClient" /> permite a un único cliente usar un puerto.</summary>
        <value><see langword="true" /> si el objeto <see cref="T:System.Net.Sockets.TcpClient" /> permite a un único cliente usar un puerto específico; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="true" /> para Windows Server 2003 y Windows XP Service Pack 2 y versiones posteriores, y <see langword="false" /> para el resto de versiones.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, varios clientes pueden utilizar un puerto concreto; Sin embargo, solo uno de los clientes puede realizar operaciones en el tráfico de red enviado al puerto. Puede usar el `ExclusiveAddressUse` propiedad para evitar que varios clientes usen un puerto específico.  
  
 Esta propiedad debe establecerse antes de que el socket subyacente está enlazado a un puerto de cliente. Si se llama a <xref:System.Net.Sockets.TcpClient.Connect%2A>, <xref:System.Net.Sockets.TcpClient.BeginConnect%2A>, <xref:System.Net.Sockets.TcpClient.%23ctor%28System.Net.IPEndPoint%29>, o <xref:System.Net.Sockets.TcpClient.%23ctor%28System.String%2CSystem.Int32%29>, se enlaza el puerto de cliente como un efecto secundario del método y no puede establecer posteriormente las `ExclusiveAddressUse` propiedad.
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un <xref:System.Net.Sockets.TcpClient> y obtiene y establece el valor de la `ExclusiveAddressUse` propiedad.  
  
 [!code-cpp[System.Net.Sockets.TcpClient1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CPP/newtcpclient.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpClient1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpClient1/CS/newtcpclient.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al intentar obtener acceso al socket subyacente.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Net.Sockets.Socket" /> subyacente se ha cerrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TcpClient ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="tcpClient.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos que usa la clase <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. Código de la aplicación no debe llamar a este método; un objeto `Finalize` método se invoca automáticamente durante la recolección de elementos no utilizados, a menos que se ha deshabilitado la finalización por el recolector de elementos no utilizados mediante una llamada a la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.  
  
 El <xref:System.Net.Sockets.TcpClient> finalizador de la clase cierra la conexión TCP y libera todos los recursos administrados asociados con la `TcpClient`. Estos recursos incluyen subyacente <xref:System.Net.Sockets.Socket> usado para conectar con el host remoto y el <xref:System.Net.Sockets.NetworkStream> utilizado para enviar y recibir datos. El finalizador no libera los recursos no administrados.  
  
 Para obtener más información, consulte [métodos de finalización y destructores](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v%3dvs.100)), [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md), y [reemplazar el método Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpClient.Close" />
        <related type="Article" href="~/docs/standard/garbage-collection/index.md">recolección de elementos no utilizados</related>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.NetworkStream GetStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.NetworkStream GetStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.GetStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream () As NetworkStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::NetworkStream ^ GetStream();" />
      <MemberSignature Language="F#" Value="member this.GetStream : unit -&gt; System.Net.Sockets.NetworkStream" Usage="tcpClient.GetStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.NetworkStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la <see cref="T:System.Net.Sockets.NetworkStream" /> usada para enviar y recibir datos.</summary>
        <returns>Objeto <see cref="T:System.Net.Sockets.NetworkStream" /> subyacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
El `GetStream` método devuelve un <xref:System.Net.Sockets.NetworkStream> que puede usar para enviar y recibir datos. El `NetworkStream` clase hereda de la <xref:System.IO.Stream> (clase), que proporciona una amplia colección de métodos y propiedades utilizados para facilitar las comunicaciones de red.  
  
 Debe llamar a la <xref:System.Net.Sockets.TcpClient.Connect%2A> método primero, o la <xref:System.Net.Sockets.TcpClient.GetStream%2A> método producirá una <xref:System.InvalidOperationException>. Después de haber obtenido el `NetworkStream`, llame a la <xref:System.Net.Sockets.NetworkStream.Write%2A> método envíe datos al host remoto. Llame a la <xref:System.Net.Sockets.NetworkStream.Read%2A> método para recibir los datos que llegan desde el host remoto. Ambos métodos se bloquean hasta que se realiza la operación especificada. Se puede evitar el bloqueo en una operación de lectura comprobando el <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> propiedad. Un `true` valor significa que los datos ha llegado desde el host remoto y está disponibles para su lectura. En este caso, <xref:System.Net.Sockets.NetworkStream.Read%2A> garantiza que finalizará inmediatamente. Si el host remoto ha cerrado la conexión, <xref:System.Net.Sockets.NetworkStream.Read%2A> devolverá inmediatamente con cero bytes.  
  
> [!NOTE]
>  Debe cerrar la `NetworkStream` cuando esté a través de enviar y recibir datos. Cerrar <xref:System.Net.Sockets.TcpClient> no libera la `NetworkStream`.  
  
> [!NOTE]
>  Si recibe un <xref:System.Net.Sockets.SocketException>, utilice <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obtener el código de error específico. Después de haber obtenido este código, puede hacer referencia a la [código de error de API de la versión 2 de Windows Sockets](/windows/desktop/winsock/windows-sockets-error-codes-2) documentación para obtener una descripción detallada del error.  
  
> [!NOTE]
>  Este miembro genera información de seguimiento cuando se habilita el seguimiento de red en la aplicación. Para obtener más información, consulte [seguimiento de red en .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código usa `GetStream` obtener subyacente <xref:System.Net.Sockets.NetworkStream>. Después de obtener el <xref:System.Net.Sockets.NetworkStream>, envía y recibe mediante su <xref:System.Net.Sockets.NetworkStream.Write%2A> y <xref:System.Net.Sockets.NetworkStream.Read%2A> métodos.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#14](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#14)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#14](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#14)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.TcpClient" /> no está conectada a un host remoto.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Net.Sockets.TcpClient" /> se ha cerrado.</exception>
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.NetworkStream.DataAvailable" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.TcpClient.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece información sobre el estado de permanencia del socket asociado.</summary>
        <value>Objeto <see cref="T:System.Net.Sockets.LingerOption" />. La permanencia está deshabilitada de manera predeterminada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `LingerState` propiedad cambia la manera <xref:System.Net.Sockets.Socket.Close%2A> método se comporta. Esta propiedad cuando set modifica las condiciones en las que se puede restablecer la conexión mediante Winsock. Restablecimientos de conexión pueden seguir apareciendo según el comportamiento del protocolo IP.  
  
 Esta propiedad controla el período de tiempo que la conexión TCP permanecerá abierta después de llamar a <xref:System.Net.Sockets.TcpClient.Close%2A> cuando quedan enviarán datos. Cuando se llama a la <xref:System.Net.Sockets.NetworkStream.Write%2A> método, los datos se coloca en el búfer de red saliente. Esta propiedad se puede utilizar para asegurarse de que estos datos se envían al host remoto antes de la <xref:System.Net.Sockets.TcpClient.Close%2A> método interrumpe la conexión.  
  
 Para habilitar la permanencia de la conexión, cree un <xref:System.Net.Sockets.LingerOption> de instancia que contiene los valores deseados y establezca el `LingerState` propiedad a esta instancia.  
  
 En la tabla siguiente se describe el comportamiento de la <xref:System.Net.Sockets.TcpClient.Close%2A> método para los valores posibles de la <xref:System.Net.Sockets.LingerOption.Enabled%2A> propiedad y el <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propiedad almacenados en el `LingerState` propiedad.  
  
|LingerState.Enabled|LingerState.LingerTime|Comportamiento|  
|-------------------------|----------------------------|--------------|  
|`false` (deshabilitado), el valor predeterminado|No es aplicable, el tiempo de espera (valor predeterminado).|Intenta enviar los datos pendientes hasta que expire el tiempo de espera de protocolo IP de forma predeterminada.|  
|`true` (habilitado)|Un tiempo de espera distinto de cero|Intenta enviar los datos pendientes hasta que expira el tiempo de espera especificado y, si se produce un error en el intento, Winsock restablece la conexión.|  
|`true` (habilitado)|Un cero tiempo de espera.|Descarta cualquier dato pendiente y Winsock restablece la conexión.|  
  
 La pila IP calcula el tiempo de espera de protocolo IP predeterminado a utilizar basándose en el tiempo de ida y vuelta de la conexión. En la mayoría de los casos, el tiempo de espera calculado por la pila es más relevante que definidos por una aplicación. Este es el comportamiento predeterminado para un socket cuando la `LingerState` no se establece la propiedad.  
  
 Cuando el <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propiedad almacenados en el `LingerState` propiedad está establecida en mayor que el tiempo de espera de protocolo IP de forma predeterminada, el tiempo de espera de protocolo IP de forma predeterminada se todavía se aplican y reemplazan.  
  
   
  
## Examples  
 El siguiente código de ejemplo se establece y obtiene la permanencia de los sockets de tiempo.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#12](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#12)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#12](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#12)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.LingerOption" />
        <altmember cref="M:System.Net.Sockets.TcpClient.Close" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.TcpClient.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que deshabilita cualquier retraso cuando los búferes de envío o recepción no están llenos.</summary>
        <value><see langword="true" /> Si se deshabilita el retraso; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando `NoDelay` es `false`, un <xref:System.Net.Sockets.TcpClient> no envía un paquete a través de la red hasta que haya obtenido una cantidad significativa de datos salientes. Debido a la cantidad de sobrecarga en un segmento TCP, el envío de pequeñas cantidades de datos es ineficaz. Sin embargo, existen situaciones donde deba enviar muy pequeñas cantidades de datos o esperar respuestas inmediatas de cada paquete que se envíe. Su decisión debería sopesar la importancia relativa de la eficacia de la red frente a los requisitos de la aplicación.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se deshabilita el retraso. A continuación, comprueba el valor de `NoDelay` para comprobar que la propiedad se estableció correctamente.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#13)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#13)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.TcpClient.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño del búfer de recepción.</summary>
        <value>Tamaño del búfer de recepción, en bytes. El valor predeterminado es 8192 bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `ReceiveBufferSize` propiedad obtiene o establece el número de bytes que se espera almacenar en el búfer de recepción para cada operación de lectura. Esta propiedad manipula realmente el espacio de búfer de red asignado para recibir los datos entrantes.  
  
 El búfer de red debe ser al menos tan grande como el búfer de aplicación para asegurarse de que los datos deseados estará disponibles cuando se llama a la <xref:System.Net.Sockets.NetworkStream.Read%2A?displayProperty=nameWithType> método. Use el <xref:System.Net.Sockets.TcpClient.ReceiveBufferSize%2A> propiedad para establecer este tamaño. Si la aplicación va a recibir datos de forma masiva, se debe pasar el `Read` método un búfer de aplicación muy grande.  
  
 Si el búfer de red es menor que la cantidad de datos solicitada en el `Read` método, no podrá recuperar la cantidad deseada de datos en una sola operación de lectura. Esto conlleva la sobrecarga de llamadas adicionales a la `Read` método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se establece y obtiene el tamaño del búfer de recepción.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#8)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#8)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al establecer el tamaño del búfer.  
  
O bien 
En las aplicaciones .NET Compact Framework, no se puede establecer esta propiedad. Para obtener una solución alternativa, vea la Nota de la plataforma que se describe en Comentarios.</exception>
        <altmember cref="P:System.Net.Sockets.TcpClient.SendBufferSize" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.TcpClient.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el período de tiempo durante el cual un <see cref="T:System.Net.Sockets.TcpClient" /> esperará para recibir datos tras iniciarse una operación de lectura.</summary>
        <value>Valor de tiempo de espera de la conexión, en milisegundos. El valor predeterminado es 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `ReceiveTimeout` propiedad determina la cantidad de tiempo que el <xref:System.Net.Sockets.NetworkStream.Read%2A> método se bloqueará hasta que se puede recibir datos. Este tiempo se mide en milisegundos. Si el tiempo de espera expira antes de `Read` se complete correctamente, <xref:System.Net.Sockets.TcpClient> produce una <xref:System.IO.IOException>. No hay ningún tiempo de espera de forma predeterminada.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se establece y obtiene el tiempo de espera de recepción.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#10)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#10)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.TcpClient.SendTimeout" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.TcpClient.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño del búfer de envío.</summary>
        <value>Tamaño del búfer de envío, en bytes. El valor predeterminado es 8192 bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `SendBufferSize` propiedad obtiene o establece el número de bytes que se espera para enviar en cada llamada a la <xref:System.Net.Sockets.NetworkStream.Write%2A?displayProperty=nameWithType> método. Esta propiedad manipula realmente el espacio de búfer de red asignado para la operación de envío.  
  
 El búfer de red debe ser al menos tan grande como el búfer de aplicación para asegurarse de que los datos deseados se almacenan y se enviarán en una sola operación. Use el <xref:System.Net.Sockets.TcpClient.SendBufferSize%2A> propiedad para establecer este tamaño. Si la aplicación va a enviar datos de forma masiva, se debe pasar el `Write` método un búfer de aplicación muy grande.  
  
 Si el búfer de red es menor que la cantidad de datos proporciona la `Write` método, varias operaciones se realizarán para todas las llamadas que realice en el envío de red la `Write` método. Puede lograr mayor rendimiento al garantizar que el búfer de red es al menos tan grande como el búfer de aplicación.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se establece y obtiene el tamaño del búfer de envío.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#9)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#9)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.TcpClient.ReceiveBufferSize" />
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpClient.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.TcpClient.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el período de tiempo durante el cual un <see cref="T:System.Net.Sockets.TcpClient" /> esperará para que finalice correctamente una operación de envío.</summary>
        <value>Valor de tiempo de espera de envío, en milisegundos. El valor predeterminado es 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `SendTimeout` propiedad determina la cantidad de tiempo que el <xref:System.Net.Sockets.Socket.Send%2A> método se bloqueará hasta que pueda devolver correctamente. Este tiempo se mide en milisegundos.  
  
 Después de llamar a la <xref:System.Net.Sockets.NetworkStream.Write%2A> método subyacente <xref:System.Net.Sockets.Socket> devuelve el número real de bytes enviados al host. El `SendTimeout` propiedad determina la cantidad de tiempo un <xref:System.Net.Sockets.TcpClient> esperará antes de recibir el número de bytes devueltos. Si el tiempo de espera expira antes de la `Send` método finaliza correctamente, `TcpClient` producirá un <xref:System.Net.Sockets.SocketException>. No hay ningún tiempo de espera de forma predeterminada.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se establece y obtiene la `SendTimeout` valor.  
  
 [!code-cpp[ClassicTcpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/cpp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#11)]
 [!code-csharp[ClassicTcpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/csharp/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/CS/source.cs#11)]
 [!code-vb[ClassicTcpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/ClassicTcpClient.PublicMethodsAndPropertiesExample/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.TcpClient.ReceiveTimeout" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpClient.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos que usa <see cref="T:System.Net.Sockets.TcpClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Llamar a IDisposable.Dispose cuando haya terminado con el <xref:System.Net.Sockets.TcpClient>. El método IDisposable.Dispose deja el <xref:System.Net.Sockets.TcpClient> en un estado inutilizable. Después de llamar a IDisposable.Dispose, debe liberar todas las referencias a la <xref:System.Net.Sockets.TcpClient> por lo que el recolector de elementos no utilizados pueda reclamar la memoria que el <xref:System.Net.Sockets.TcpClient> estaba ocupando. Para obtener más información, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).

> [!NOTE] 
> Llame siempre a IDisposable.Dispose antes de liberar la última referencia a la <xref:System.Net.Sockets.TcpClient>. En caso contrario, los recursos que utiliza no se liberarán hasta que el recolector de elementos no utilizados llame al <xref:System.Net.Sockets.TcpClient> del objeto **Finalize** método.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
  </Members>
</Type>