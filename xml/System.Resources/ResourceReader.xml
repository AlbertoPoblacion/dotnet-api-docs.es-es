<Type Name="ResourceReader" FullName="System.Resources.ResourceReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f2814539bf76d998ae0f4c7bdb789f22102804ce" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52602196" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ResourceReader : System.Resources.IResourceReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ResourceReader extends System.Object implements class System.Collections.IEnumerable, class System.IDisposable, class System.Resources.IResourceReader" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ResourceReader&#xA;Implements IResourceReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceReader sealed : System::Resources::IResourceReader" />
  <TypeSignature Language="F#" Value="type ResourceReader = class&#xA;    interface IResourceReader&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.Reader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Resources.IResourceReader</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Enumera los recursos en un archivo binario de recursos (.resources) leyendo pares secuenciales de nombre/valor del recurso.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 El <xref:System.Resources.ResourceReader> clase proporciona una implementación estándar de la <xref:System.Resources.IResourceReader> interfaz. Un <xref:System.Resources.ResourceReader> instancia representa un archivo .resources independiente o un archivo .resources incrustado en un ensamblado. Sirve para enumerar los recursos en un archivo .resources y recuperar sus pares nombre/valor. Difiere de la <xref:System.Resources.ResourceManager> (clase), que se usa para recuperar recursos con nombre especificados de un archivo .resources incrustado en un ensamblado. El <xref:System.Resources.ResourceManager> clase se utiliza para recuperar recursos cuyos nombres se conocen de antemano, mientras que la <xref:System.Resources.ResourceReader> clase es útil para recuperar los recursos cuyo número o los nombres exactos no se conocen en tiempo de compilación. Por ejemplo, una aplicación puede utilizar un archivo de recursos para almacenar información de configuración que se organiza en secciones y los elementos de una sección, donde el número de secciones o elementos en una sección no se conoce de antemano. Los recursos, a continuación, se pueden denominar genéricamente (como `Section1`, `Section1Item1`, `Section1Item2`, etc.) y recuperar usando un <xref:System.Resources.ResourceReader> objeto.  
  
> [!IMPORTANT]
>  Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo, debe deshacerse de él directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él, indirectamente, usar una construcción de lenguaje, como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
 Para obtener más información sobre el uso de la <xref:System.Resources.ResourceReader> de clases, vea las secciones siguientes:  
  
-   [Instancias de un objeto ResourceReader](#instantiate)  
  
-   [Enumerar los recursos de un objeto ResourceReader](#enumerate)  
  
    -   [Recuperar los recursos mediante propiedades IDictionaryEnumerator](#idictionaryenumerator)  
  
    -   [Recuperar recursos por nombre con GetResourceData](#getresourcedata)  
  
<a name="instantiate"></a>   
## <a name="instantiating-a-resourcereader-object"></a>Instancias de un objeto ResourceReader  
 Un archivo .resources es un archivo binario que se ha compilado desde un archivo de texto o un archivo .resx XML por [Resgen.exe (Resource File Generator)](~/docs/framework/tools/resgen-exe-resource-file-generator.md). Un <xref:System.Resources.ResourceReader> objeto puede representar un archivo .resources independiente o un archivo .resources que se ha incrustado en un ensamblado.  
  
 Para crear instancias de un <xref:System.Resources.ResourceReader> objeto que lee un archivo .resources independiente, use el <xref:System.Resources.ResourceReader> constructor de clase con un flujo de entrada o una cadena que contiene el nombre del archivo .resources. El ejemplo siguiente muestra ambos enfoques. Crea una instancia de la primera una <xref:System.Resources.ResourceReader> objeto que representa un archivo .resources denominado `Resources1.resources` mediante su nombre de archivo. Crea una instancia de la segunda una <xref:System.Resources.ResourceReader> objeto que representa un archivo .resources denominado `Resources2.resources` mediante el uso de un flujo creado a partir del archivo.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#2)]  
  
 Para crear un <xref:System.Resources.ResourceReader> crear una instancia de objeto que representa un archivo .resources incrustado, un <xref:System.Reflection.Assembly> objeto desde el ensamblado en el que se incrusta el archivo. Resources. Su <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> método devuelve un <xref:System.IO.Stream> objeto que puede pasarse a la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructor. El ejemplo siguiente crea un <xref:System.Resources.ResourceReader> objeto que representa un archivo .resources incrustado.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#3)]
 [!code-vb[System.Resources.ResourceReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#3)]  
  
<a name="enumerate"></a>   
## <a name="enumerating-a-resourcereader-objects-resources"></a>Enumerar los recursos de un objeto ResourceReader  
 Para enumerar los recursos en un archivo .resources, llame a la <xref:System.Resources.ResourceReader.GetEnumerator%2A> método, que devuelve un <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> objeto. Se llama a la `IDictionaryEnumerator.MoveNext` método para mover de un recurso a la siguiente. El método devuelve `false` cuando se han enumerado todos los recursos en el archivo. Resources.  
  
> [!NOTE]
>  Aunque el <xref:System.Resources.ResourceReader> la clase implementa la <xref:System.Collections.IEnumerable> interfaz y la <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> método, el <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> método no proporciona el <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> implementación. En su lugar, el <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> método devuelve un <xref:System.Collections.IDictionaryEnumerator> objeto de interfaz que proporciona acceso al par de nombre/valor de cada recurso.  
  
 Puede recuperar los recursos individuales de la colección de dos maneras:  
  
-   Puede recorrer en iteración cada recurso en el <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> recopilación y uso <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> propiedades para recuperar el nombre del recurso y el valor. Se recomienda esta técnica cuando todos los recursos son del mismo tipo, o se conoce el tipo de datos de cada recurso.  
  
-   Puede recuperar el nombre de cada recurso cuando se recorren en el <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> colección y llamar a la <xref:System.Resources.ResourceReader.GetResourceData%2A> método para recuperar los datos del recurso. Se recomienda este enfoque cuando no conoce el tipo de datos de cada recurso o si el enfoque anterior produce excepciones.  
  
<a name="idictionaryenumerator"></a>   
### <a name="retrieving-resources-by-using-idictionaryenumerator-properties"></a>Recuperar los recursos mediante propiedades IDictionaryEnumerator  
 El primer método consiste en enumerar los recursos en un archivo .resources implica recuperar directamente el par de nombre/valor de cada recurso. Después de llamar a la `IDictionaryEnumerator.MoveNext` método para desplazarse a cada recurso de la colección, se puede recuperar el recurso nombre de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> propiedad y los datos de recursos desde el <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propiedad.  
  
 El ejemplo siguiente muestra cómo recuperar el nombre y valor de cada recurso en un archivo .resources mediante el <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> y <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propiedades. Para ejecutar el ejemplo, cree el siguiente archivo de texto denominado ApplicationResources.txt para definir los recursos de cadena.  
  
```  
Title="Contact Information"  
Label1="First Name:"  
Label2="Middle Name:"  
Label3="Last Name:"  
Label4="SSN:"  
Label5="Street Address:"  
Label6="City:"  
Label7="State:"  
Label8="Zip Code:"  
Label9="Home Phone:"  
Label10="Business Phone:"  
Label11="Mobile Phone:"  
Label12="Other Phone:"  
Label13="Fax:"  
Label14="Email Address:"  
Label15="Alternate Email Address:"  
```  
  
 A continuación, puede convertir el archivo de recursos de texto en un archivo binario denominado ApplicationResources.resources mediante el comando siguiente:  
  
 **Resgen ApplicationResources.txt**  
  
 El ejemplo siguiente, a continuación, utiliza el <xref:System.Resources.ResourceReader> clase para enumerar cada recurso en el archivo binario .resources independiente y mostrar su nombre de clave y valor correspondiente.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/class1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/class1.vb#1)]  
  
 El intento de recuperar los datos de recursos de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propiedad puede producir las excepciones siguientes:  
  
-   Un <xref:System.FormatException> si los datos no están en el formato esperado.  
  
-   Un <xref:System.IO.FileNotFoundException> si no se encuentra el ensamblado que contiene el tipo al que pertenecen los datos.  
  
-   Un <xref:System.TypeLoadException> si no puede ser el tipo al que pertenecen los datos no se encuentra.  
  
 Normalmente, estas excepciones se producen si el archivo .resources se ha modificado manualmente, si el ensamblado en el que se define un tipo ha no se han incluido con una aplicación o se ha eliminado accidentalmente, o si el ensamblado es una versión anterior que sea anterior a un tipo. Si se produce una de estas excepciones, puede recuperar los recursos de enumerar cada recurso y llamando a la <xref:System.Resources.ResourceReader.GetResourceData%2A> método, como se muestra en la sección siguiente. Este enfoque proporciona escribe información acerca de los datos del <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propiedad intenta devolver.  
  
<a name="getresourcedata"></a>   
### <a name="retrieving-resources-by-name-with-getresourcedata"></a>Recuperación de recursos por nombre con GetResourceData  
 El segundo enfoque para enumerar los recursos en un archivo .resources también implica navegar por los recursos en el archivo mediante una llamada a la `IDictionaryEnumerator.MoveNext` método. Para cada recurso, recupera el nombre del recurso desde el <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> propiedad, que, a continuación, se pasa a la <xref:System.Resources.ResourceReader.GetResourceData%28System.String%2CSystem.String%40%2CSystem.Byte%5B%5D%40%29> método para recuperar los datos del recurso. Esto se devuelve como una matriz de bytes en el `resourceData` argumento.  
  
 Este enfoque es más difícil que recuperar el nombre del recurso y el valor de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> y <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propiedades, porque devuelve los bytes reales que forman el valor del recurso. Sin embargo, si el intento de recuperar el recurso produce una excepción, el <xref:System.Resources.ResourceReader.GetResourceData%2A> método puede ayudar a identificar el origen de la excepción si se suministra información sobre el tipo de datos del recurso. Para obtener más información acerca de la cadena que indica el tipo de datos del recurso, consulte <xref:System.Resources.ResourceReader.GetResourceData%2A>.  
  
 El ejemplo siguiente muestra cómo usar este enfoque para recuperar los recursos y para controlar las excepciones que se producen. Crea mediante programación un archivo .resources binario que contiene cuatro cadenas, uno booleano, un entero, un mapa de bits y otra personalizada `DateTimeTZI` objeto. Para ejecutar el ejemplo, realice lo siguiente:  
  
1.  Crear un ensamblado denominado Library.dll que contiene el `DateTimeTZI` estructura. Este es el código fuente para el ensamblado.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/library.cs#4)]
     [!code-vb[System.Resources.ResourceReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/library.vb#4)]  
  
     Compile el código fuente en C# mediante el comando siguiente:  
  
    ```  
    csc /t:library library.cs  
    ```  
  
     O bien, puede compilar en Visual Basic mediante el comando siguiente:  
  
    ```  
    vbc library.vb /t:library  
    ```  
  
2.  Compile y ejecute el siguiente código fuente, lo que crea un archivo .resources denominado ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/createresourceex1.cs#5)]
     [!code-vb[System.Resources.ResourceReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/createresourceex1.vb#5)]  
  
     El archivo de código fuente se denomina CreateResources.cs. Puede compilar en C# mediante el comando siguiente:  
  
    ```  
    csc CreateResources.cs /r:library.dll  
    ```  
  
     O bien, puede compilar en Visual Basic mediante el comando siguiente:  
  
    ```  
    vbc CreateResources.vb /r:library.dll  
    ```  
  
3.  Compile y ejecute el siguiente código para enumerar los recursos en el archivo ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/readresourceex1.cs#6)]
     [!code-vb[System.Resources.ResourceReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/readresourceex1.vb#6)]  
  
     Después de modificar el código fuente (por ejemplo, generando deliberadamente un <xref:System.FormatException> al final de la `try` bloque) o cambiar el nombre del ensamblado Library.dll para que no está disponible en tiempo de ejecución, puede ejecutar el ejemplo para ver cómo las llamadas a <xref:System.Resources.ResourceReader.GetResourceData%2A> le permiten recuperar o volver a crear alguna información de recursos.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)].
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : System.IO.Stream -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Flujo de entrada para la lectura de recursos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Resources.ResourceReader" /> para el flujo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructor crea un <xref:System.Resources.ResourceReader> objeto que recupera los recursos desde un archivo .resources independiente o desde un archivo .resources archivo incrustado en un ensamblado. Para leer de un archivo .resources independiente, crear una instancia de un <xref:System.IO.Stream> objeto y pasarlo a la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructor. Para leer desde un archivo .resources incrustado, llame a la <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> método con el nombre del archivo .resources y pase el valor devuelto distingue mayúsculas de minúsculas <xref:System.IO.Stream> de objeto para el <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructor.  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
## Examples  
 El ejemplo de esta sección usa el siguiente archivo .txt denominado `PatientForm.txt` para definir los recursos utilizados por una aplicación.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Puede compilar el archivo .txt en un archivo .resources mediante el comando siguiente:  
  
 **Resgen PatientForm.txt**  
  
 En el siguiente ejemplo se da por supuesto que el archivo de recursos está incrustado en el ensamblado que contiene código ejecutable de la aplicación. Recupera un archivo de recursos denominado `PatientForm.resources` desde los ensamblados que se está ejecutando actualmente y muestra el nombre y valor de cada uno de sus recursos.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream1.vb#1)]  
  
 Si el ejemplo de C# se denomina `Example.cs`, puede compilar mediante el comando siguiente:  
  
 **csc Example.cs /res:PatientForm.resources**  
  
 Si el ejemplo de Visual Basic se denomina `Example.vb`, puede compilar mediante el comando siguiente:  
  
 **vbc Example.vb /res:PatientForm.resources**  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="stream" /> no se puede leer.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="stream" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S durante el acceso al parámetro <paramref name="stream" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar servicios de serialización. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : string -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Ruta de acceso y nombre del archivo de recursos que se van a leer. <c>filename</c> no distingue mayúsculas de minúsculas.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Resources.ResourceReader" /> para el archivo de recursos con nombre especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Resources.ResourceReader.%23ctor%28System.String%29> constructor crea un <xref:System.Resources.ResourceReader> objeto que recupera los recursos de un archivo .resources independiente. Para recuperar recursos desde un archivo .resources incrustado, utilice la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructor.  

[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]

## Examples  
 El ejemplo de esta sección usa el siguiente archivo .txt denominado `PatientForm.txt` para definir los recursos utilizados por una aplicación.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Puede compilar este archivo .txt en un archivo .resources mediante el comando siguiente:  
  
 **Resgen PatientForm.txt**  
  
 En el ejemplo siguiente se enumeran los recursos de `PatientForm.resources` y muestra el nombre y valor de cada uno.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="fileName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S.</exception>
        <exception cref="T:System.BadImageFormatException">El archivo de recursos tiene un formato no válido. Por ejemplo, la longitud del archivo puede ser cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="resourceReader.Close " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos del sistema operativo asociados a este objeto <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.Close%2A> puede llamarse de forma segura varias veces.  
  
   
  
## Examples  
 El ejemplo siguiente se mueve a través de recursos de un archivo y muestra todos los pares de clave-valor que encuentra. El código, a continuación, usa el <xref:System.Resources.ResourceReader.Close%2A> método para apagar el <xref:System.Resources.ResourceReader> y liberar todos los recursos utilizados por ella.  
  
 [!code-cpp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CPP/getenumerator.cpp#1)]
 [!code-csharp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CS/getenumerator.cs#1)]
 [!code-vb[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="resourceReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya terminado de utilizar esta instancia de <xref:System.Resources.ResourceReader>, llame a <xref:System.Resources.ResourceReader.Dispose%2A> para liberar todos los recursos utilizados por esta instancia. Debe eliminar las demás referencias a este <xref:System.Resources.ResourceReader> para que el recolector de elementos no utilizados pueda reclamar la memoria de la instancia en lugar de mantener activo para la finalización de la instancia.  
  
 <xref:System.Resources.ResourceReader.Dispose%2A> llama al método Dispose (Boolean) privado, que contiene el código para liberar recursos no administrados y no administrados. Para obtener más información, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="resourceReader.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador para este objeto <see cref="T:System.Resources.ResourceReader" />.</summary>
        <returns>Enumerador de este objeto <see cref="T:System.Resources.ResourceReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, enumerar los recursos mediante una llamada a la <xref:System.Resources.ResourceReader.GetEnumerator%2A> método y, a continuación, llamar repetidamente a la <xref:System.Collections.IEnumerator.MoveNext%2A> método en el valor devuelto <xref:System.Collections.IDictionaryEnumerator> objeto hasta que el método devuelve `false`. El nombre del recurso está disponible desde el <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> propiedad; su valor desde el <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propiedad. El ejemplo muestra cómo enumerar los recursos de esta manera.  
  
 La implementación de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propiedad por la <xref:System.Resources.ResourceReader> clase puede producir las excepciones siguientes:  
  
-   <xref:System.IO.FileNotFoundException>  
  
     No se encuentra el ensamblado que contiene el tipo al que pertenecen los datos.  
  
-   <xref:System.FormatException>  
  
     Los datos no están en el formato esperado.  
  
-   <xref:System.TypeLoadException>  
  
     No se encuentra el tipo al que pertenecen los datos.  
  
 Puede controlar la excepción llamando a la <xref:System.Resources.ResourceReader.GetResourceData%2A> método para recuperar información sobre el tipo de datos y la matriz de bytes asignados para el recurso mencionado. Para obtener más información, vea la sección "Recuperación de recursos por nombre con GetResourceData" en el <xref:System.Resources.ResourceReader> tema de la clase.  
  
> [!IMPORTANT]
>  La <xref:System.Resources.ResourceReader> clase incluye dos métodos que devuelven los enumeradores. El <xref:System.Resources.ResourceReader.GetEnumerator%2A> método devuelve un <xref:System.Collections.IDictionaryEnumerator> objeto de la interfaz y es el método recomendado, debe llamar al enumerar los recursos.  
  
   
  
## Examples  
 El ejemplo de esta sección usa el siguiente archivo .txt denominado `PatientForm.txt` para definir los recursos utilizados por una aplicación.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Puede compilar el archivo .txt en un archivo .resources mediante el comando siguiente:  
  
 **Resgen PatientForm.txt**  
  
 En el ejemplo siguiente se enumeran los recursos de `PatientForm.resources` y muestra el nombre y valor de cada uno.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El lector se ha cerrado o se ha eliminado y no se puede obtener acceso.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceData">
      <MemberSignature Language="C#" Value="public void GetResourceData (string resourceName, out string resourceType, out byte[] resourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetResourceData(string resourceName, [out] string&amp; resourceType, [out] unsigned int8[]&amp; resourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetResourceData(System.String,System.String@,System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetResourceData (resourceName As String, ByRef resourceType As String, ByRef resourceData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetResourceData(System::String ^ resourceName, [Runtime::InteropServices::Out] System::String ^ % resourceType, [Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % resourceData);" />
      <MemberSignature Language="F#" Value="member this.GetResourceData : string *  *  -&gt; unit" Usage="resourceReader.GetResourceData (resourceName, resourceType, resourceData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
        <Parameter Name="resourceType" Type="System.String" RefType="out" />
        <Parameter Name="resourceData" Type="System.Byte[]" RefType="out" />
      </Parameters>
      <Docs>
        <param name="resourceName">Nombre de un recurso.</param>
        <param name="resourceType">El resultado que devuelve este método contiene una cadena que representa el nombre de tipo del recurso recuperado. Este parámetro se pasa sin inicializar.</param>
        <param name="resourceData">Cuando se devuelve este método, contiene una matriz de bytes que es la representación binaria del tipo recuperado. Este parámetro se pasa sin inicializar.</param>
        <summary>Recupera el nombre de tipo y datos de un recurso con nombre a partir de un archivo de recursos o secuencia abiertos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Resources.ResourceReader.GetResourceData%2A> método recupera el valor de un recurso con nombre como una matriz de bytes. Normalmente se usa cuando el <xref:System.Collections.IDictionaryEnumerator.Value%2A> propiedad produce una excepción cuando intenta recuperar el valor de un recurso.  
  
 `resourceType` es una cadena que representa el tipo de datos del recurso. Puede ser cualquiera de los siguientes valores:  
  
-   La representación de cadena de un `ResourceTypeCode` miembro de enumeración que indica el tipo de datos del recurso. `ResourceTypeCode` es una enumeración privada que usa .para indicar que un formato binario especial se utiliza para almacenar uno de los 19 tipos de datos comunes. Se incluyen los tipos de datos primitivos de .NET Framework (<xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.Single>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, <xref:System.UInt64>), así como <xref:System.String>, <xref:System.DateTime>, y <xref:System.TimeSpan>, además, el `ResourceTypeCode` enumeración incluye los valores mostrados en la tabla siguiente.  
  
    |Valor ResourceTypeCode|Descripción|  
    |----------------------------|-----------------|  
    |`ResourceTypeCode.ByteArray`|Los datos están una matriz de bytes. Este tipo de datos con frecuencia los resultados de la llamada a la <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Byte%5B%5D%29?displayProperty=nameWithType> método.|  
    |`ResourceTypeCode.Null`|Los datos están una referencia nula. Este tipo de datos con frecuencia los resultados de la llamada a la <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Object%29?displayProperty=nameWithType> método con un objeto cuyo valor es `null`.|  
    |`ResourceTypeCode.Stream`|Los datos se almacenan en una secuencia. Este tipo de datos con frecuencia los resultados de la llamada a la <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%29?displayProperty=nameWithType> o <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%2CSystem.Boolean%29?displayProperty=nameWithType> método.|  
  
     Suponiendo que `resourceData` no ha sido dañado, normalmente se puede convertir desde una matriz de bytes a su valor original mediante una llamada a un <xref:System.BitConverter> o <xref:System.IO.BinaryReader> método.  
  
-   Una cadena que contiene el nombre completo del tipo cuyos datos serializados se asignan a la `resourceData` argumento (por ejemplo, `System.String`). Además, para los tipos que no forman parte de la biblioteca de clases de .NET Framework, la cadena incluye el nombre, versión, referencia cultural y clave pública del ensamblado que contiene el tipo. Por ejemplo, la siguiente cadena indica que los datos serializados representan una instancia de la `Person` escriba en el `Extensions` espacio de nombres, que se encuentra en la versión 1.0 de un ensamblado denominado utilidad que tiene ninguna clave pública y ninguna referencia cultural designada.  
  
     `Extensions.Person, Utility, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`  
  
     Suponiendo que `resourceData` no se ha dañado y que está disponible, el tipo de origen `resourceData` puede convertirse de una matriz de bytes a su valor original mediante la conversión de la matriz de bytes a un <xref:System.IO.Stream> objeto y pasar la secuencia a la <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType>método.  
  
-   La cadena utilizada para describir el tipo de datos en el <xref:System.Resources.ResourceWriter.AddResourceData%2A?displayProperty=nameWithType> llamada al método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="resourceName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceName" /> no existe.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="resourceName" /> tiene un tipo no válido.</exception>
        <exception cref="T:System.FormatException">Los datos del recurso están dañados.</exception>
        <exception cref="T:System.InvalidOperationException">El objeto <see cref="T:System.Resources.ResourceReader" /> actual no se ha inicializado, probablemente porque está cerrado.</exception>
        <altmember cref="M:System.Resources.ResourceWriter.AddResourceData(System.String,System.String,System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador para este objeto <see cref="T:System.Resources.ResourceReader" />.</summary>
        <returns>Enumerador de este objeto <see cref="T:System.Resources.ResourceReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.System%23Collections%23IEnumerable%23GetEnumerator%2A?displayProperty=nameWithType> es una implementación de interfaz explícita. Solo se puede utilizar cuando la instancia de <xref:System.Resources.ResourceReader> se convierte en una interfaz <xref:System.Collections.IEnumerable>. El método recomendado para enumerar los recursos en un archivo .resources es llamar a la <xref:System.Collections.IEnumerator.MoveNext%2A> método de la <xref:System.Collections.IDictionaryEnumerator> objeto devuelto por la <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El lector ya se ha cerrado y no es accesible.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos que usa <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Llamar a Dispose permite a los recursos utilizados por el <xref:System.Resources.ResourceReader> que reasignarse para otros fines. Para obtener más información acerca de Dispose, vea [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).

## Examples  
El ejemplo de código siguiente se mueve a través de recursos de un archivo e imprime todos los pares de clave-valor que encuentra. El código, a continuación, usa el método de theIDisposable.Dispose para apagar el <xref:System.Resources.ResourceReader> y liberar todos los recursos utilizados por ella.

```vb
Imports System
Imports System.Resources
Imports System.Collections

Public Class ReadResources

    Public Shared Sub Main(args() As String)
        ' Create a resource reader for items.resources 
        ' and get an enumerator to iterate through the file. 
        Dim reader As IResourceReader = New ResourceReader("items.resources")
        Dim en As IDictionaryEnumerator = reader.GetEnumerator()

        ' Iterate through the file, printing the key and value pairs. 
        While en.MoveNext()
            Console.WriteLine()
            Console.WriteLine("Name: {0}", en.Key)
            Console.WriteLine("Value: {0}", en.Value)
        End While 

        ' Clean up all resources associated with the reader. 
        ' Calling Dispose is equivalent to calling Close.
        reader.Dispose()
    End Sub 

End Class
```

```csharp
using System;
using System.Resources;
using System.Collections;

public class ReadResources 
{
    public static void Main(string[] args) 
    {
        // Create a resource reader for items.resources 
        // and get an enumerator to iterate through the file.
        IResourceReader reader = new ResourceReader("items.resources");
        IDictionaryEnumerator en = reader.GetEnumerator();

        // Iterate through the file, printing the key/value pairs. 
        while (en.MoveNext()) 
        {
            Console.WriteLine();
            Console.WriteLine("Name: {0}", en.Key);
            Console.WriteLine("Value: {0}", en.Value);
        }

        // Clean up all resources associated with the reader. 
        // Calling Dispose is equivalent to calling Close.
        reader.Dispose();
    }
}
```

```cpp
using namespace System;
using namespace System::Resources;
using namespace System::Collections;
int main()
{
   array<String^>^args = Environment::GetCommandLineArgs();

   // Create a resource reader for items.resources 
   // and get an enumerator to iterate through the file.
   IResourceReader^ reader = gcnew ResourceReader( "items.resources" );
   IDictionaryEnumerator^ en = reader->GetEnumerator();

   // Iterate through the file, printing the key/value pairs. 
   while ( en->MoveNext() )
   {
      Console::WriteLine();
      Console::WriteLine( "Name: {0}", en->Key );
      Console::WriteLine( "Value: {0}", en->Value );
   }

   // Clean up all resources associated with the reader. 
   // Calling the destructor is equivalent to calling Close.
   reader->~IResourceReader();
}
```

]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>