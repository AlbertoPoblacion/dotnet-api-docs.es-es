<Type Name="ResourceReader" FullName="System.Resources.ResourceReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="682738b4136d074223cbe025a9380b3cca9bc1d0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480259" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ResourceReader : System.Resources.IResourceReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ResourceReader extends System.Object implements class System.Collections.IEnumerable, class System.IDisposable, class System.Resources.IResourceReader" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ResourceReader&#xA;Implements IResourceReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceReader sealed : System::Resources::IResourceReader" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.Reader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Resources.IResourceReader</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Enumera los recursos en un archivo binario de recursos (.resources) leyendo pares secuenciales de nombre/valor del recurso.  
  
 **Nota de seguridad**: llamar a métodos en esta clase con datos que no son de confianza conlleva un riesgo de seguridad. Llame a los métodos en la clase solo con datos de confianza. Para más información, consulte [Riesgos de seguridad de datos que no son de confianza](https://docs.com/rick-anderson-1/8710/untrusted-data-security-risks).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Resources.ResourceReader> clase proporciona una implementación estándar de la <xref:System.Resources.IResourceReader> interfaz. Un <xref:System.Resources.ResourceReader> instancia representa un archivo .resources independiente o un archivo .resources que se incrusta en un ensamblado. Sirve para enumerar los recursos en un archivo .resources y recuperar sus pares de nombre/valor. Difiere de la <xref:System.Resources.ResourceManager> (clase), que se usa para recuperar recursos con nombre especificados de un archivo .resources que se incrusta en un ensamblado. El <xref:System.Resources.ResourceManager> clase se utiliza para recuperar recursos cuyos nombres se conocen de antemano, mientras que la <xref:System.Resources.ResourceReader> clase es útil para recuperar los recursos cuyo número o los nombres exactos no se conocen en tiempo de compilación. Por ejemplo, una aplicación puede utilizar un archivo de recursos para almacenar información de configuración que se organiza en las secciones y los elementos de una sección, donde el número de secciones o elementos en una sección no se conoce de antemano. Recursos, a continuación, pueden llamarse genéricamente (como `Section1`, `Section1Item1`, `Section1Item2`, etc.) y recuperar usando una <xref:System.Resources.ResourceReader> objeto.  
  
> [!IMPORTANT]
>  Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo, debe eliminar del mismo directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él indirectamente, use una construcción de lenguaje como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
 Para obtener más información sobre el uso de la <xref:System.Resources.ResourceReader> de clases, consulte las secciones siguientes:  
  
-   [Instancias de un objeto ResourceReader](#instantiate)  
  
-   [Enumerar los recursos de un objeto ResourceReader](#enumerate)  
  
    -   [Recuperar recursos mediante propiedades IDictionaryEnumerator](#idictionaryenumerator)  
  
    -   [Recuperar recursos por el nombre con GetResourceData](#getresourcedata)  
  
<a name="instantiate"></a>   
## <a name="instantiating-a-resourcereader-object"></a>Instancias de un objeto ResourceReader  
 Un archivo .resources es un archivo binario que se ha compilado en un archivo de texto o un archivo .resx XML [Resgen.exe (generador de archivos de recursos)](~/docs/framework/tools/resgen-exe-resource-file-generator.md). Un <xref:System.Resources.ResourceReader> objeto puede representar un archivo .resources independiente o un archivo .resources que se han incrustado en un ensamblado.  
  
 Para crear instancias de un <xref:System.Resources.ResourceReader> objeto que lee desde un archivo .resources independiente, utilice la <xref:System.Resources.ResourceReader> constructor de clase con un flujo de entrada o una cadena que contiene el nombre del archivo .resources. En el ejemplo siguiente se muestra ambos enfoques. Crea una instancia de la primera un <xref:System.Resources.ResourceReader> objeto que representa un archivo .resources denominado `Resources1.resources` mediante su nombre de archivo. Crea una instancia de la segunda un <xref:System.Resources.ResourceReader> objeto que representa un archivo .resources denominado `Resources2.resources` mediante el uso de una secuencia que se crea a partir del archivo.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#2)]  
  
 Para crear un <xref:System.Resources.ResourceReader> crear una instancia de objeto que representa un archivo .resources incrustado, un <xref:System.Reflection.Assembly> objeto desde el ensamblado en el que se incrusta el archivo .resources. Su <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> método devuelve un <xref:System.IO.Stream> objeto que puede pasarse a la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructor. El ejemplo siguiente crea un <xref:System.Resources.ResourceReader> objeto que representa un archivo .resources incrustado.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#3)]
 [!code-vb[System.Resources.ResourceReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#3)]  
  
<a name="enumerate"></a>   
## <a name="enumerating-a-resourcereader-objects-resources"></a>Enumerar los recursos de un objeto ResourceReader  
 Para enumerar los recursos en un archivo .resources, se llama a la <xref:System.Resources.ResourceReader.GetEnumerator%2A> método, que devuelve un <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> objeto. Se llama a la `IDictionaryEnumerator.MoveNext` método para mover de un recurso a la siguiente. El método devuelve `false` cuando se han enumerado todos los recursos en el archivo .resources.  
  
> [!NOTE]
>  Aunque la <xref:System.Resources.ResourceReader> la clase implementa la <xref:System.Collections.IEnumerable> interfaz y la <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> método, el <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> método no proporciona el <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> implementación. En su lugar, el <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> método devuelve un <xref:System.Collections.IDictionaryEnumerator> objeto de interfaz que proporciona acceso al par de nombre/valor de cada recurso.  
  
 Puede recuperar los recursos individuales de la colección de dos maneras:  
  
-   Puede recorrer en iteración cada recurso en el <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> recopilación y uso <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> propiedades para recuperar el nombre del recurso y el valor. Se recomienda esta técnica cuando todos los recursos son del mismo tipo, o sabe el tipo de datos de cada recurso.  
  
-   Puede recuperar el nombre de cada recurso cuando se recorra en el <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType> colección y llame al método el <xref:System.Resources.ResourceReader.GetResourceData%2A> método para recuperar los datos del recurso. Se recomienda este enfoque cuando no se conoce el tipo de datos de cada recurso o si el enfoque anterior genera una excepción.  
  
<a name="idictionaryenumerator"></a>   
### <a name="retrieving-resources-by-using-idictionaryenumerator-properties"></a>Recuperar recursos mediante propiedades IDictionaryEnumerator  
 El primer método de enumerar los recursos en un archivo .resources implica recuperar directamente el par de nombre/valor de cada recurso. Después de llamar a la `IDictionaryEnumerator.MoveNext` nombre de método para desplazarse a cada recurso de la colección, se puede recuperar el recurso de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> propiedad y los datos de recursos de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propiedad.  
  
 En el ejemplo siguiente se muestra cómo recuperar el nombre y valor de cada recurso en un archivo .resources mediante el uso de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> y <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propiedades. Para ejecutar el ejemplo, cree el siguiente archivo de texto denominado ApplicationResources.txt para definir recursos de cadena.  
  
```  
Title="Contact Information"  
Label1="First Name:"  
Label2="Middle Name:"  
Label3="Last Name:"  
Label4="SSN:"  
Label5="Street Address:"  
Label6="City:"  
Label7="State:"  
Label8="Zip Code:"  
Label9="Home Phone:"  
Label10="Business Phone:"  
Label11="Mobile Phone:"  
Label12="Other Phone:"  
Label13="Fax:"  
Label14="Email Address:"  
Label15="Alternate Email Address:"  
```  
  
 A continuación, puede convertir el archivo de recursos de texto a un archivo binario denominado ApplicationResources.resources mediante el comando siguiente:  
  
 **resgen ApplicationResources.txt**  
  
 El ejemplo siguiente, a continuación, utiliza el <xref:System.Resources.ResourceReader> clase para enumerar cada recurso en el archivo binario .resources independiente y mostrar el nombre de la clave y el valor correspondiente.  
  
 [!code-csharp[System.Resources.ResourceReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/class1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/class1.vb#1)]  
  
 Al intentar recuperar datos de recursos de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propiedad puede producir las excepciones siguientes:  
  
-   A <xref:System.FormatException> si los datos no están en el formato esperado.  
  
-   A <xref:System.IO.FileNotFoundException> si no se encuentra el ensamblado que contiene el tipo al que pertenecen los datos.  
  
-   A <xref:System.TypeLoadException> si no puede ser el tipo al que pertenecen los datos no se encuentra.  
  
 Normalmente, estas excepciones se producen si el archivo .resources se ha modificado manualmente, si el ensamblado en el que se define un tipo ha no se han incluido con una aplicación o se ha eliminado accidentalmente, o si el ensamblado es una versión anterior precede a un tipo. Si se produce una de estas excepciones, puede recuperar recursos enumerar cada recurso y llamando a la <xref:System.Resources.ResourceReader.GetResourceData%2A> método, tal como se muestra en la siguiente sección. Este enfoque proporciona escribe información acerca de los datos del <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propiedad intenta devolver.  
  
<a name="getresourcedata"></a>   
### <a name="retrieving-resources-by-name-with-getresourcedata"></a>Recuperar recursos por el nombre con GetResourceData  
 El segundo enfoque para enumerar los recursos en un archivo .resources también implica desplazarse por los recursos en el archivo mediante una llamada a la `IDictionaryEnumerator.MoveNext` método. Para cada recurso, recuperar el nombre del recurso de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> propiedad, que se pasa a continuación el <xref:System.Resources.ResourceReader.GetResourceData%28System.String%2CSystem.String%40%2CSystem.Byte%5B%5D%40%29> método para recuperar los datos del recurso. Esto se devuelve como una matriz de bytes en el `resourceData` argumento.  
  
 Este enfoque es más difícil que recuperar el nombre del recurso y el valor de la <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> y <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propiedades, porque devuelve la cantidad real de bytes que forman el valor del recurso. Sin embargo, si el intento de recuperar el recurso produce una excepción, el <xref:System.Resources.ResourceReader.GetResourceData%2A> método puede ayudar a identificar el origen de la excepción proporcionando información sobre el tipo de datos del recurso. Para obtener más información acerca de la cadena que indica el tipo de datos del recurso, vea <xref:System.Resources.ResourceReader.GetResourceData%2A>.  
  
 En el ejemplo siguiente se muestra cómo utilizar este enfoque para recuperar los recursos y para controlar las excepciones que se producen. Crea mediante programación un archivo .resources binario que contiene cuatro cadenas, un valor booleano, un número entero, un mapa de bits y uno personalizado `DateTimeTZI` objeto. Para ejecutar el ejemplo, haga lo siguiente:  
  
1.  Crear un ensamblado denominado Library.dll que contiene el `DateTimeTZI` estructura. Éste es el código fuente para el ensamblado.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/library.cs#4)]
     [!code-vb[System.Resources.ResourceReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/library.vb#4)]  
  
     Compile el código fuente de C# mediante el comando siguiente:  
  
    ```  
    csc /t:library library.cs  
    ```  
  
     O bien, puede compilar en Visual Basic mediante el comando siguiente:  
  
    ```  
    vbc library.vb /t:library  
    ```  
  
2.  Compile y ejecute el siguiente código fuente, lo que crea un archivo .resources denominado ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/createresourceex1.cs#5)]
     [!code-vb[System.Resources.ResourceReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/createresourceex1.vb#5)]  
  
     El archivo de código fuente se denomina CreateResources.cs. Puede compilar en C# mediante el comando siguiente:  
  
    ```  
    csc CreateResources.cs /r:library.dll  
    ```  
  
     O bien, puede compilar en Visual Basic mediante el comando siguiente:  
  
    ```  
    vbc CreateResources.vb /r:library.dll  
    ```  
  
3.  Compile y ejecute el código siguiente para enumerar los recursos en el archivo ContactResources.resources.  
  
     [!code-csharp[System.Resources.ResourceReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/readresourceex1.cs#6)]
     [!code-vb[System.Resources.ResourceReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/readresourceex1.vb#6)]  
  
     Después de modificar el código fuente (por ejemplo, al lanzar deliberadamente una <xref:System.FormatException> al final de la `try` bloque) o cambiar el nombre del ensamblado Library.dll para que esté disponible en tiempo de ejecución, puede ejecutar el ejemplo para ver cómo las llamadas a <xref:System.Resources.ResourceReader.GetResourceData%2A> le permiten recuperar o volver a crear información de recursos.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Usar una instancia de este objeto con datos no es de confianza es un riesgo de seguridad. Use este objeto solo con datos de confianza. Para obtener más información, consulte [validación de datos](https://www.owasp.org/index.php/Data_Validation).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::IO::Stream ^ stream);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Flujo de entrada para la lectura de recursos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Resources.ResourceReader" /> para la secuencia especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructor crea un <xref:System.Resources.ResourceReader> objeto que recupera los recursos desde un archivo .resources independiente o desde un archivo .resources archivo que está incrustado en un ensamblado. Para leer de un archivo .resources independiente, crear una instancia de un <xref:System.IO.Stream> objeto y lo pasa a la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructor. Para leer desde un archivo .resources incrustado, llame a la <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType> método con el nombre del archivo .resources y pase el valor devuelto entre mayúsculas y minúsculas <xref:System.IO.Stream> el objeto a la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructor.  
  
> [!IMPORTANT]
>  Usar una instancia de este objeto con datos no es de confianza es un riesgo de seguridad. Use este objeto solo con datos de confianza. Para obtener más información, consulte [validación de datos](https://www.owasp.org/index.php/Data_Validation).  
  
   
  
## Examples  
 El ejemplo de esta sección usa el siguiente archivo .txt denominado `PatientForm.txt` para definir los recursos utilizados por una aplicación.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Puede compilar el archivo .txt en un archivo .resources emitiendo el comando siguiente:  
  
 **resgen PatientForm.txt**  
  
 En el siguiente ejemplo se da por supuesto que el archivo de recursos está incrustado en el ensamblado que contiene código ejecutable de la aplicación. Recupera un archivo de recursos denominado `PatientForm.resources` desde los ensamblados que se está ejecutando actualmente y muestra el nombre y valor de cada uno de sus recursos.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream1.vb#1)]  
  
 Si el ejemplo de C# se denomina `Example.cs`, puede compilar mediante el comando siguiente:  
  
 **csc Example.cs /res:PatientForm.resources**  
  
 Si el ejemplo de Visual Basic se denomina `Example.vb`, puede compilar mediante el comando siguiente:  
  
 **vbc Example.vb /res:PatientForm.resources**  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="stream" /> no se puede leer.</exception>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="stream" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S durante el acceso al parámetro <paramref name="stream" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar servicios de serialización. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::String ^ fileName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Ruta de acceso y nombre del archivo de recursos que se va a leer. <c>filename</c> no distingue mayúsculas de minúsculas.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Resources.ResourceReader" /> para el archivo de recursos denominado especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Resources.ResourceReader.%23ctor%28System.String%29> constructor crea un <xref:System.Resources.ResourceReader> objeto que recupera los recursos de un archivo .resources independiente. Para recuperar recursos de un archivo .resources incrustado, utilice la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> constructor.  
  
> [!IMPORTANT]
>  Usar una instancia de este objeto con datos no es de confianza es un riesgo de seguridad. Use este objeto solo con datos de confianza. Para obtener más información, consulte [validación de datos](https://www.owasp.org/index.php/Data_Validation).  
  
   
  
## Examples  
 El ejemplo de esta sección usa el siguiente archivo .txt denominado `PatientForm.txt` para definir los recursos utilizados por una aplicación.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Puede compilar este archivo .txt en un archivo .resources emitiendo el comando siguiente:  
  
 **resgen PatientForm.txt**  
  
 En el ejemplo siguiente se enumeran los recursos de `PatientForm.resources` y muestra el nombre y valor de cada uno.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="fileName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se puede encontrar el archivo.</exception>
        <exception cref="T:System.IO.IOException">Se produjo un error de E/S.</exception>
        <exception cref="T:System.BadImageFormatException">El archivo de recursos tiene un formato no válido. Por ejemplo, la longitud del archivo puede ser cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos del sistema operativo asociados a este objeto <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.Close%2A> puede llamarse de forma segura varias veces.  
  
   
  
## Examples  
 En el ejemplo siguiente se mueve a través de recursos de un archivo y muestra todos los pares de clave/valor que busca. El código utiliza el <xref:System.Resources.ResourceReader.Close%2A> método para cerrar la <xref:System.Resources.ResourceReader> y liberar todos los recursos usados por el mismo.  
  
 [!code-cpp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CPP/getenumerator.cpp#1)]
 [!code-csharp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CS/getenumerator.cs#1)]
 [!code-vb[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Resources.ResourceReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya terminado de usar esta instancia de <xref:System.Resources.ResourceReader>, llame a <xref:System.Resources.ResourceReader.Dispose%2A> para liberar todos los recursos usados por esta instancia. Debe eliminar las demás referencias a este <xref:System.Resources.ResourceReader> para que el recolector de elementos no utilizados pueda reclamar la memoria de la instancia en lugar de mantener activo para la finalización de la instancia.  
  
 <xref:System.Resources.ResourceReader.Dispose%2A> llama al método Dispose (Boolean) privado, que contiene el código para liberar recursos no administrados y no administrados. Para obtener más información, consulte [implementa un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador para este objeto <see cref="T:System.Resources.ResourceReader" />.</summary>
        <returns>Enumerator para este objeto <see cref="T:System.Resources.ResourceReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por lo general, enumerar los recursos mediante una llamada a la <xref:System.Resources.ResourceReader.GetEnumerator%2A> método y, a continuación, al llamar repetidamente la <xref:System.Collections.IEnumerator.MoveNext%2A> método en el valor devuelto <xref:System.Collections.IDictionaryEnumerator> objeto hasta que el método devuelve `false`. El nombre de recurso está disponible desde el <xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType> propiedad; su valor desde el <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propiedad. En el ejemplo se muestra cómo enumerar los recursos de esta manera.  
  
 La implementación de la <xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType> propiedad por la <xref:System.Resources.ResourceReader> puede producir las excepciones siguientes:  
  
-   <xref:System.IO.FileNotFoundException>  
  
     No se encuentra el ensamblado que contiene el tipo al que pertenecen los datos.  
  
-   <xref:System.FormatException>  
  
     Los datos no están en el formato esperado.  
  
-   <xref:System.TypeLoadException>  
  
     No se puede encontrar el tipo al que pertenecen los datos.  
  
 Puede controlar la excepción mediante una llamada a la <xref:System.Resources.ResourceReader.GetResourceData%2A> método para recuperar información sobre el tipo de datos y la matriz de bytes que se asignan al recurso con nombre. Para obtener más información, vea la sección "Recuperar recursos por nombre con GetResourceData" en el <xref:System.Resources.ResourceReader> tema de la clase.  
  
> [!IMPORTANT]
>  La <xref:System.Resources.ResourceReader> clase incluye dos métodos que devuelven los enumeradores. El <xref:System.Resources.ResourceReader.GetEnumerator%2A> método devuelve un <xref:System.Collections.IDictionaryEnumerator> objeto de la interfaz y es el método recomendado para llamar al enumerar los recursos.  
  
   
  
## Examples  
 El ejemplo de esta sección usa el siguiente archivo .txt denominado `PatientForm.txt` para definir los recursos utilizados por una aplicación.  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 Puede compilar el archivo .txt en un archivo .resources emitiendo el comando siguiente:  
  
 **resgen PatientForm.txt**  
  
 En el ejemplo siguiente se enumeran los recursos de `PatientForm.resources` y muestra el nombre y valor de cada uno.  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El lector se ha cerrado o se ha eliminado y no se puede obtener acceso.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceData">
      <MemberSignature Language="C#" Value="public void GetResourceData (string resourceName, out string resourceType, out byte[] resourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetResourceData(string resourceName, [out] string&amp; resourceType, [out] unsigned int8[]&amp; resourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetResourceData(System.String,System.String@,System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetResourceData (resourceName As String, ByRef resourceType As String, ByRef resourceData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetResourceData(System::String ^ resourceName, [Runtime::InteropServices::Out] System::String ^ % resourceType, [Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % resourceData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
        <Parameter Name="resourceType" Type="System.String&amp;" RefType="out" />
        <Parameter Name="resourceData" Type="System.Byte[]&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="resourceName">Nombre de un recurso.</param>
        <param name="resourceType">El resultado que devuelve este método contiene una cadena que representa el nombre de tipo del recurso recuperado. Este parámetro se pasa sin inicializar.</param>
        <param name="resourceData">Cuando este método devuelve el control al sistema, contiene una matriz de bytes que es la representación binaria del tipo recuperado. Este parámetro se pasa sin inicializar.</param>
        <summary>Recupera el nombre de tipo y datos de un recurso con nombre a partir de un archivo de recursos o secuencia abierto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Resources.ResourceReader.GetResourceData%2A> método recupera el valor de un recurso con nombre como una matriz de bytes. Suele utilizar cuando la <xref:System.Collections.IDictionaryEnumerator.Value%2A> propiedad produce una excepción cuando intenta recuperar el valor de un recurso.  
  
 `resourceType` es una cadena que representa el tipo de datos del recurso. Puede ser cualquiera de los siguientes valores:  
  
-   La representación de cadena de un `ResourceTypeCode` miembro de enumeración que indica el tipo de datos del recurso. `ResourceTypeCode` es una enumeración privada que se utiliza por .para indican que se usa un formato binario especial para almacenar uno de 19 tipos de datos comunes. Se incluyen los tipos de datos primitivos de .NET Framework (<xref:System.Boolean>, <xref:System.Byte>, <xref:System.Char>, <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.Single>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, <xref:System.UInt64>), así como <xref:System.String>, <xref:System.DateTime>, y <xref:System.TimeSpan>, además, la `ResourceTypeCode` enumeración incluye los valores mostrados en la tabla siguiente.  
  
    |Valor de ResourceTypeCode|Descripción|  
    |----------------------------|-----------------|  
    |`ResourceTypeCode.ByteArray`|Los datos son una matriz de bytes. Estos datos normalmente escribe los resultados de la llamada a la <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Byte%5B%5D%29?displayProperty=nameWithType> método.|  
    |`ResourceTypeCode.Null`|Los datos son una referencia nula. Estos datos normalmente escribe los resultados de la llamada a la <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Object%29?displayProperty=nameWithType> método con un objeto cuyo valor es `null`.|  
    |`ResourceTypeCode.Stream`|Los datos se almacenan en una secuencia. Estos datos normalmente escribe los resultados de la llamada a la <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%29?displayProperty=nameWithType> o <xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%2CSystem.Boolean%29?displayProperty=nameWithType> método.|  
  
     Suponiendo que `resourceData` no ha sido dañado, normalmente se puede convertir de una matriz de bytes a su valor original mediante una llamada a un <xref:System.BitConverter> o <xref:System.IO.BinaryReader> método.  
  
-   Una cadena que contiene el nombre completo del tipo cuyos datos serializados se asignan a la `resourceData` argumento (por ejemplo, `System.String`). Además, para los tipos que no forman parte de la biblioteca de clases de .NET Framework, la cadena incluye el nombre, la versión, la referencia cultural y la clave pública del ensamblado que contiene el tipo. Por ejemplo, la siguiente cadena indica que los datos serializados representan una instancia de la `Person` escriba en el `Extensions` espacio de nombres, que se encuentra en la versión 1.0 de un ensamblado denominado utilidad con ninguna clave pública y ninguna referencia cultural designada.  
  
     `Extensions.Person, Utility, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`  
  
     Suponiendo que `resourceData` no se ha dañado y que el tipo de origen está disponible, `resourceData` se pueden convertir de una matriz de bytes a su valor original mediante la conversión de la matriz de bytes a una <xref:System.IO.Stream> objeto y se pasa a la secuencia a la <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType> método.  
  
-   La cadena que se usa para describir el tipo de datos en el <xref:System.Resources.ResourceWriter.AddResourceData%2A?displayProperty=nameWithType> llamada al método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceName" /> no existe.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="resourceName" /> tiene un tipo no válido.</exception>
        <exception cref="T:System.FormatException">Los datos del recurso están dañados.</exception>
        <exception cref="T:System.InvalidOperationException">El objeto <see cref="T:System.Resources.ResourceReader" /> actual no se ha inicializado, probablemente porque está cerrado.</exception>
        <altmember cref="M:System.Resources.ResourceWriter.AddResourceData(System.String,System.String,System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador para este objeto <see cref="T:System.Resources.ResourceReader" />.</summary>
        <returns>Enumerator para este objeto <see cref="T:System.Resources.ResourceReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.System%23Collections%23IEnumerable%23GetEnumerator%2A?displayProperty=nameWithType> es una implementación de interfaz explícita. Solo se puede utilizar cuando la instancia de <xref:System.Resources.ResourceReader> se convierte en una interfaz <xref:System.Collections.IEnumerable>. El método recomendado para enumerar los recursos en un archivo .resources es llamar a la <xref:System.Collections.IEnumerator.MoveNext%2A> método de la <xref:System.Collections.IDictionaryEnumerator> objeto devuelto por la <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El lector ya se ha cerrado y no es accesible.</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
  </Members>
</Type>