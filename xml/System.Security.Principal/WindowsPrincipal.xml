<Type Name="WindowsPrincipal" FullName="System.Security.Principal.WindowsPrincipal">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a765a326d05a5dd5386d19dff04e6097dc5f9cae" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49139459" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WindowsPrincipal : System.Security.Claims.ClaimsPrincipal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit WindowsPrincipal extends System.Security.Claims.ClaimsPrincipal" />
  <TypeSignature Language="DocId" Value="T:System.Security.Principal.WindowsPrincipal" />
  <TypeSignature Language="VB.NET" Value="Public Class WindowsPrincipal&#xA;Inherits ClaimsPrincipal" />
  <TypeSignature Language="C++ CLI" Value="public ref class WindowsPrincipal : System::Security::Claims::ClaimsPrincipal" />
  <TypeSignature Language="F#" Value="type WindowsPrincipal = class&#xA;    inherit ClaimsPrincipal" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Principal.Windows</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Claims.ClaimsPrincipal</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permite que el código compruebe la condición de pertenencia de un usuario de Windows a un grupo de Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Security.Principal.WindowsPrincipal> clase se utiliza principalmente para comprobar el rol de un usuario de Windows. El <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType> sobrecargas del método permiten comprobar el rol de usuario mediante el uso de contextos de rol diferentes.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> sobrecargas del método. El <xref:System.Security.Principal.WindowsBuiltInRole> enumeración se utiliza como el origen de los identificadores relativos (RID) que identifican las funciones integradas. Los RID se usan para determinar los roles de la entidad de seguridad actual.  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsPrincipal (System.Security.Principal.WindowsIdentity ntIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Principal.WindowsIdentity ntIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.#ctor(System.Security.Principal.WindowsIdentity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ntIdentity As WindowsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsPrincipal(System::Security::Principal::WindowsIdentity ^ ntIdentity);" />
      <MemberSignature Language="F#" Value="new System.Security.Principal.WindowsPrincipal : System.Security.Principal.WindowsIdentity -&gt; System.Security.Principal.WindowsPrincipal" Usage="new System.Security.Principal.WindowsPrincipal ntIdentity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ntIdentity" Type="System.Security.Principal.WindowsIdentity" />
      </Parameters>
      <Docs>
        <param name="ntIdentity">Objeto a partir del cual se construye la nueva instancia de <see cref="T:System.Security.Principal.WindowsPrincipal" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Principal.WindowsPrincipal" /> mediante el objeto <see cref="T:System.Security.Principal.WindowsIdentity" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea un nuevo <xref:System.Security.Principal.WindowsPrincipal> objeto desde la actual <xref:System.Security.Principal.WindowsIdentity> objeto.  
  
 [!code-cpp[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/CS/source.cs#1)]
 [!code-vb[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="ntIdentity" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeviceClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; DeviceClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; DeviceClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.DeviceClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeviceClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ DeviceClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeviceClaims : seq&lt;System.Security.Claims.Claim&gt;" Usage="System.Security.Principal.WindowsPrincipal.DeviceClaims" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_DeviceClaims&gt;d__13))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_DeviceClaims&gt;d__1))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene todas las notificaciones de dispositivo de Windows de esta entidad de seguridad.</summary>
        <value>Colección de todas las notificaciones de dispositivo de Windows de esta entidad de seguridad.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Identity">
      <MemberSignature Language="C#" Value="public override System.Security.Principal.IIdentity Identity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity Identity" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.Identity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Identity As IIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::IIdentity ^ Identity { System::Security::Principal::IIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Identity : System.Security.Principal.IIdentity" Usage="System.Security.Principal.WindowsPrincipal.Identity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la identidad de la entidad de seguridad actual.</summary>
        <value>Objeto <see cref="T:System.Security.Principal.WindowsIdentity" /> de la entidad de seguridad actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente recupera el nombre del usuario mediante el uso de la <xref:System.Security.Principal.WindowsPrincipal.Identity%2A> propiedad de la <xref:System.Security.Principal.WindowsPrincipal> objeto.  
  
 [!code-cpp[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/CS/source.cs#1)]
 [!code-vb[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsInRole">
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si la entidad de seguridad actual pertenece a un grupo de usuarios de Windows especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hay cuatro sobrecargas para este método. Por motivos de rendimiento, la <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> sobrecarga es muy recomendable.  
  
> [!IMPORTANT]
>  El <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método no se admite en Windows 98 o Windows Millennium Edition.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (int rid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(int32 rid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (rid As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(int rid);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : int -&gt; bool" Usage="windowsPrincipal.IsInRole rid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rid" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rid">RID del grupo de usuarios de Windows en que se comprueba el estado de pertenencia de la entidad de seguridad.</param>
        <summary>Determina si la entidad de seguridad actual pertenece al grupo de usuarios de Windows con el identificador relativo (RID) especificado.</summary>
        <returns>
          <see langword="true" /> si la entidad de seguridad actual es miembro del grupo de usuarios de Windows especificado, es decir, está en un rol concreto; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se prueba para obtener información de la función recién creada, como un nuevo usuario o un grupo nuevo, es importante cerrar sesión e inicie sesión para forzar la propagación de información de funciones dentro del dominio. No hacerlo puede provocar la <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> prueba devuelva `false`. No se admite este método en Windows 98 ni en Windows Millennium.  
  
 Por motivos de rendimiento, la <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> se recomienda la sobrecarga como sobrecarga preferible para determinar el rol del usuario.  
  
> [!NOTE]
>  En Windows Vista, el control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Cuando se intenta realizar una tarea que requiere privilegios administrativos, puede elevar dinámicamente su rol utilizando el cuadro de diálogo de consentimiento. El código que se ejecuta el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método no muestra el cuadro de diálogo de consentimiento. El código devuelve false si se encuentra en el rol de usuario estándar, incluso si se encuentra en el grupo de administradores integrado. Puede elevar sus privilegios antes de ejecutar el código haciendo clic en el icono de aplicación y que indique que desea ejecutar como administrador.  
  
 Identificadores relativos (RID) forman parte de identificador de seguridad del grupo de usuarios de Windows (SID) y se admiten para ayudar a evitar problemas de localización de multiplataforma. Muchas cuentas de usuario, grupos locales y grupos globales tienen un valor RID predeterminado que es una constante en todas las versiones de Windows.  
  
 Por ejemplo, el RID de la función BUILTIN\Administradores es 0 x 220. Con 0 x 220 como parámetro de entrada para el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método da como resultado `true` que es devuelven si la entidad de seguridad actual es un administrador.  
  
 Las siguientes tablas enumeran los valores RID de forma predeterminada.  
  
|Usuarios integrados|RID|  
|---------------------|---------|  
|DOMAINNAME\Administrator|0x1F4|  
|DOMAINNAME\Guest|0x1F5|  
  
|Grupos globales integrados|RID|  
|-----------------------------|---------|  
|Domainname\administradores|0 x 200|  
|Domainname\usuarios|0 x 201|  
|Domainname\invitados|0x202|  
  
|Grupos locales integrados|RID|  
|----------------------------|---------|  
|BUILTIN\Administradores|0 x 220|  
|BUILTIN\Users|0x221|  
|BUILTIN\Invitados|0x222|  
|Builtin\operadores de|0x224|  
|Builtin\operadores de servidores|0x225|  
|Builtin\operadores de impresión|0x226|  
|Builtin\operadores de copia|0x227|  
|BUILTIN\Replicator|0x228|  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> métodos. El <xref:System.Security.Principal.WindowsBuiltInRole> enumeración se utiliza como el origen de los RID que identifican las funciones integradas. Los RID se usan para determinar los roles de la entidad de seguridad actual.  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (System.Security.Principal.SecurityIdentifier sid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(class System.Security.Principal.SecurityIdentifier sid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Security.Principal.SecurityIdentifier)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (sid As SecurityIdentifier) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(System::Security::Principal::SecurityIdentifier ^ sid);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : System.Security.Principal.SecurityIdentifier -&gt; bool" Usage="windowsPrincipal.IsInRole sid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sid" Type="System.Security.Principal.SecurityIdentifier" />
      </Parameters>
      <Docs>
        <param name="sid">
          <see cref="T:System.Security.Principal.SecurityIdentifier" /> que identifica un grupo de usuarios de Windows de forma única.</param>
        <summary>Determina si la entidad de seguridad actual pertenece al grupo de usuarios de Windows con el identificador de seguridad (SID) especificado.</summary>
        <returns>Es <see langword="true" /> si la entidad de seguridad actual es un miembro del grupo de usuarios de Windows especificado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Security.Principal.SecurityIdentifier> identifica un usuario o grupo en las implementaciones de Windows 2000, Windows Server y Windows XP. Cuando se prueba para obtener información de la función recién creada, como un nuevo usuario o un grupo nuevo, es importante cerrar sesión e inicie sesión para forzar la propagación de información de funciones dentro del dominio. No hacerlo puede provocar la <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> prueba devuelva `false`. No se admite este método en Windows 98 ni en Windows Millennium.  
  
> [!NOTE]
>  En Windows Vista, el control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Cuando se intenta realizar una tarea que requiere privilegios administrativos, puede elevar dinámicamente su rol utilizando el cuadro de diálogo de consentimiento. El código que se ejecuta el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método no muestra el cuadro de diálogo de consentimiento. El código devuelve false si se encuentra en el rol de usuario estándar, incluso si se encuentra en el grupo de administradores integrado. Puede elevar sus privilegios antes de ejecutar el código haciendo clic en el icono de aplicación y que indique que desea ejecutar como administrador.  
  
 Por motivos de rendimiento, esta es la sobrecarga preferible para determinar el rol de un usuario.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29?displayProperty=nameWithType> método. El <xref:System.Security.Principal.WellKnownSidType.BuiltinAdministratorsSid> valor de enumeración se usa para determinar si la entidad de seguridad actual es un administrador. El ejemplo de código completo, vea el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#5)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="sid" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Windows devolvió un error de Win32.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (System.Security.Principal.WindowsBuiltInRole role);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(valuetype System.Security.Principal.WindowsBuiltInRole role) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Security.Principal.WindowsBuiltInRole)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (role As WindowsBuiltInRole) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(System::Security::Principal::WindowsBuiltInRole role);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : System.Security.Principal.WindowsBuiltInRole -&gt; bool" Usage="windowsPrincipal.IsInRole role" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="role" Type="System.Security.Principal.WindowsBuiltInRole" />
      </Parameters>
      <Docs>
        <param name="role">Uno de los valores de <see cref="T:System.Security.Principal.WindowsBuiltInRole" />.</param>
        <summary>Determina si la entidad de seguridad actual pertenece al grupo de usuarios de Windows con el <see cref="T:System.Security.Principal.WindowsBuiltInRole" /> especificado.</summary>
        <returns>Es <see langword="true" /> si la entidad de seguridad actual es un miembro del grupo de usuarios de Windows especificado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se prueba para obtener información de la función recién creada, como un nuevo usuario o un grupo nuevo, es importante cerrar sesión e inicie sesión para forzar la propagación de información de funciones dentro del dominio. No hacerlo puede provocar la <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> prueba devuelva `false`. No se admite este método en Windows 98 ni en Windows Millennium.  
  
 Por motivos de rendimiento, la <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> se recomienda la sobrecarga como sobrecarga preferible para determinar el rol del usuario.  
  
> [!NOTE]
>  En Windows Vista, el control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Cuando se intenta realizar una tarea que requiere privilegios administrativos, puede elevar dinámicamente su rol utilizando el cuadro de diálogo de consentimiento. El código que se ejecuta el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método no muestra el cuadro de diálogo de consentimiento. El código devuelve false si se encuentra en el rol de usuario estándar, incluso si se encuentra en el grupo de administradores integrado. Puede elevar sus privilegios antes de ejecutar el código haciendo clic en el icono de aplicación y que indique que desea ejecutar como administrador.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Security.Principal.WindowsBuiltInRole> enumeración se utiliza para determinar si la entidad de seguridad actual es un <xref:System.Security.Principal.WindowsBuiltInRole.Administrator>. El ejemplo de código completo, vea el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#4)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="role" /> no es un valor <see cref="T:System.Security.Principal.WindowsBuiltInRole" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public override bool IsInRole (string role);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsInRole(string role) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsInRole (role As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsInRole(System::String ^ role);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : string -&gt; bool" Usage="windowsPrincipal.IsInRole role" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="role" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="role">Nombre de Windows cuya condición de pertenencia se va a comprobar.</param>
        <summary>Determina si la entidad de seguridad actual pertenece al grupo de usuarios de Windows con el nombre especificado.</summary>
        <returns>Es <see langword="true" /> si la entidad de seguridad actual es un miembro del grupo de usuarios de Windows especificado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se prueba para obtener información de la función recién creada, como un nuevo usuario o un grupo nuevo, es importante cerrar sesión e inicie sesión para forzar la propagación de información de funciones dentro del dominio. No hacerlo puede provocar la <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> prueba devuelva `false`. No se admite este método en Windows 98 ni en Windows Millennium.  
  
 Por motivos de rendimiento, la <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> se recomienda la sobrecarga como sobrecarga preferible para determinar el rol del usuario.  
  
> [!NOTE]
>  En Windows Vista, el control de cuentas de usuario (UAC) determina los privilegios de un usuario. Si es miembro del grupo Administradores integrados, se le asignarán dos símbolos (tokens) de acceso en tiempo de ejecución: un símbolo (token) de acceso de usuario estándar y un símbolo (token) de acceso de administrador. De forma predeterminada, se le asignará el rol de usuario estándar. Cuando se intenta realizar una tarea que requiere privilegios administrativos, puede elevar dinámicamente su rol utilizando el cuadro de diálogo de consentimiento. El código que se ejecuta el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método no muestra el cuadro de diálogo de consentimiento. El código devuelve false si se encuentra en el rol de usuario estándar, incluso si se encuentra en el grupo de administradores integrado. Puede elevar sus privilegios antes de ejecutar el código haciendo clic en el icono de aplicación y que indique que desea ejecutar como administrador.  
  
 Para las funciones integradas, el `role` cadena debe tener el formato "BUILTIN\\*nombreDeFunción*". Por ejemplo, para comprobar la pertenencia al rol de administrador de Windows, la cadena que representa el rol debe ser "BUILTIN\Administrators". Tenga en cuenta que la barra diagonal inversa es posible que deba convertirse. En la tabla siguiente se enumera las funciones integradas.  
  
> [!NOTE]
>  La ortografía de las funciones BUILTIN en formato de cadena difiere de la ortografía que usa en el <xref:System.Security.Principal.WindowsBuiltInRole> enumeración. Por ejemplo, la ortografía de un administrador de la enumeración es "Administrador", no "administradores". Al utilizar esta sobrecarga, utilice la ortografía para el rol de la tabla siguiente.  
  
|Grupos locales integrados|  
|----------------------------|  
|BUILTIN\Administradores|  
|BUILTIN\Users|  
|BUILTIN\Invitados|  
|Builtin\operadores de|  
|Builtin\operadores de servidores|  
|Builtin\operadores de impresión|  
|Builtin\operadores de copia|  
|BUILTIN\Replicator|  
  
 Para las funciones específicas del equipo, el `role` cadena debe tener el formato "NombreDeEquipo\\*nombreDeFunción*".  
  
 Para roles específicos de dominio, el `role` cadena debe tener el formato "nombreDeDominio\\*nombreDeFunción*"; por ejemplo, `"SomeDomain\Domain Users`".  
  
> [!NOTE]
>  En .NET Framework versión 1.0, la `role` parámetro distingue mayúsculas de minúsculas. En .NET Framework versión 1.1 y versiones posterior, el `role` parámetro distingue mayúsculas de minúsculas.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType> método.  
  
 Las cadenas `BUILTIN\Administrators` y `BUILTIN\Users` se usan para determinar si la entidad de seguridad actual es un administrador o un usuario. El ejemplo de código completo, vea el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#3)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacidad de manipular el objeto principal. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
        <altmember cref="T:System.Security.Principal.WindowsBuiltInRole" />
      </Docs>
    </Member>
    <Member MemberName="UserClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; UserClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; UserClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.UserClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UserClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ UserClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserClaims : seq&lt;System.Security.Claims.Claim&gt;" Usage="System.Security.Principal.WindowsPrincipal.UserClaims" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_UserClaims&gt;d__11))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_UserClaims&gt;d__1))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene todas las notificaciones de usuario de Windows de esta entidad de seguridad.</summary>
        <value>Colección de todas las notificaciones de usuario de Windows de esta entidad de seguridad.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>