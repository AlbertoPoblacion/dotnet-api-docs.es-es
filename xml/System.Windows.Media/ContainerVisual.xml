<Type Name="ContainerVisual" FullName="System.Windows.Media.ContainerVisual">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0fa03054dbf34d0d8371cda37b5ffc4bcb715941" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30669269" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ContainerVisual : System.Windows.Media.Visual" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ContainerVisual extends System.Windows.Media.Visual" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.ContainerVisual" />
  <TypeSignature Language="VB.NET" Value="Public Class ContainerVisual&#xA;Inherits Visual" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContainerVisual : System::Windows::Media::Visual" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Visual</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Administra una colección de objetos <see cref="T:System.Windows.Media.Visual" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Media.ContainerVisual> clase se utiliza como un contenedor para una colección de <xref:System.Windows.Media.Visual> objetos. El <xref:System.Windows.Media.DrawingVisual> clase se deriva de la <xref:System.Windows.Media.ContainerVisual> (clase), por ejemplo, que la <xref:System.Windows.Media.DrawingVisual> clase también puede contener una colección de objetos visuales.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo crear un <xref:System.Windows.Media.ContainerVisual> objeto que se usa como elemento primario para dos <xref:System.Windows.Media.DrawingVisual> objetos. Objetos que se agregan a la <xref:System.Windows.Media.ContainerVisual> objeto debe agregarse en orden z inverso (de abajo arriba) para asegurar que se representan en el orden de dibujo correcto. En orden para el árbol visual se enumere correctamente, el ejemplo proporciona implementaciones reemplazadas de la <xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A> método y <xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A> propiedad.  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContainerVisual ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContainerVisual();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Crea una nueva instancia de la clase <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo crear una nueva instancia de un <xref:System.Windows.Media.ContainerVisual> de objeto y, a continuación, agregarle los objetos visuales secundarios.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet1)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect BitmapEffect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect BitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.BitmapEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffect As BitmapEffect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffect ^ BitmapEffect { System::Windows::Media::Effects::BitmapEffect ^ get(); void set(System::Windows::Media::Effects::BitmapEffect ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor de <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> para <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Efecto de imagen para este objeto visual.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.BitmapEffectInput" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffectInput As BitmapEffectInput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffectInput ^ BitmapEffectInput { System::Windows::Media::Effects::BitmapEffectInput ^ get(); void set(System::Windows::Media::Effects::BitmapEffectInput ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor de <see cref="T:System.Windows.Media.Effects.BitmapEffectInput" /> para <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Valor de entrada del efecto de imagen para este objeto visual.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode CacheMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode CacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.CacheMode" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheMode As CacheMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::CacheMode ^ CacheMode { System::Windows::Media::CacheMode ^ get(); void set(System::Windows::Media::CacheMode ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una representación en caché del objeto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.CacheMode" /> que tiene una representación en caché del objeto <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer el <xref:System.Windows.Media.ContainerVisual.CacheMode%2A> propiedad cuando necesite aumentar el rendimiento para el contenido que requiere mucho tiempo representar. Para obtener más información, vea <xref:System.Windows.Media.BitmapCache>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.CacheMode" />
        <altmember cref="P:System.Windows.Media.Visual.VisualCacheMode" />
        <altmember cref="T:System.Windows.Media.BitmapCache" />
        <altmember cref="T:System.Windows.Media.BitmapCacheBrush" />
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Media.VisualCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.VisualCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As VisualCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::VisualCollection ^ Children { System::Windows::Media::VisualCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.VisualCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección secundaria de <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.VisualCollection" /> que contiene los elementos secundarios de <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo recuperar el <xref:System.Windows.Media.VisualCollection> desde un <xref:System.Windows.Media.ContainerVisual> objeto.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet3)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Property Clip As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Geometry ^ Clip { System::Windows::Media::Geometry ^ get(); void set(System::Windows::Media::Geometry ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la región de recorte de <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.Geometry" /> que define la región de recorte.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.Clip" />
      </Docs>
    </Member>
    <Member MemberName="ContentBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect ContentBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect ContentBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.ContentBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect ContentBounds { System::Windows::Rect get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el rectángulo de selección para el contenido de <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>
          <see cref="T:System.Windows.Rect" /> que especifica el rectángulo de selección.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Windows.Media.ContainerVisual.DescendantBounds%2A> propiedad para devolver la unión de todo el contenido de cuadros de límite para todos los descendientes de un <xref:System.Windows.Media.ContainerVisual> objeto, pero no el propio objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo recuperar el rectángulo delimitador de un <xref:System.Windows.Media.ContainerVisual> objeto.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet4)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect DescendantBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect DescendantBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.DescendantBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DescendantBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect DescendantBounds { System::Windows::Rect get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la unión de todos los rectángulos de selección del contenido de todos los descendientes del objeto <see cref="T:System.Windows.Media.ContainerVisual" />, sin incluir el contenido de <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>
          <see cref="T:System.Windows.Rect" /> que especifica el rectángulo de selección de la combinación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obtener la <xref:System.Windows.Media.ContainerVisual.ContentBounds%2A> propiedad para devolver el rectángulo delimitador de cuadro en caché para el <xref:System.Windows.Media.ContainerVisual> propio.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo recuperar el rectángulo delimitador de un <xref:System.Windows.Media.ContainerVisual> descendientes del objeto.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet4)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Effect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect Effect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect Effect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Effect" />
      <MemberSignature Language="VB.NET" Value="Public Property Effect As Effect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::Effect ^ Effect { System::Windows::Media::Effects::Effect ^ get(); void set(System::Windows::Media::Effects::Effect ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el efecto de imagen que se va a aplicar a <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>
          <see cref="T:System.Windows.Media.Effects.Effect" /> que representa el efecto de imagen.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.ShaderEffect" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Entero con signo de 32 bits que representa el valor de índice del objeto <see cref="T:System.Windows.Media.Visual" /> secundario. El valor de <c>index</c> debe estar entre 0 y <see cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" /> - 1.</param>
        <summary>Devuelve el objeto <see cref="T:System.Windows.Media.Visual" /> secundario especificado del objeto <see cref="T:System.Windows.Media.ContainerVisual" /> primario.</summary>
        <returns>Objeto <see cref="T:System.Windows.Media.Visual" /> secundario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, un <xref:System.Windows.Media.ContainerVisual> no tiene ningún elemento secundario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo crear un <xref:System.Windows.Media.ContainerVisual> objeto que se usa como elemento primario para dos <xref:System.Windows.Media.DrawingVisual> objetos. Objetos que se agregan a la <xref:System.Windows.Media.ContainerVisual> objeto debe agregarse en orden z inverso (de abajo arriba) para asegurar que se representan en el orden de dibujo correcto. En orden para el árbol visual se enumere correctamente, el ejemplo proporciona implementaciones reemplazadas de la <xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A> método y <xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A> propiedad.  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>No se puede modificar el árbol visual durante esta llamada.</para>
        </block>
        <altmember cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTest">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el objeto visual de nivel superior de una prueba de posicionamiento.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public System.Windows.Media.HitTestResult HitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.HitTestResult HitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.HitTest(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::HitTestResult ^ HitTest(System::Windows::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">El valor de punto de prueba de posicionamiento.</param>
        <summary>Devuelve el objeto visual de nivel superior de una prueba de posicionamiento al especificar un objeto <see cref="T:System.Windows.Point" />.</summary>
        <returns>El resultado de la prueba de posicionamiento del objeto visual devuelto como un tipo <see cref="T:System.Windows.Media.HitTestResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Media.HitTestResult.VisualHit%2A> propiedad del valor devuelto representa el <xref:System.Windows.Media.Visual> objeto que se alcanzó.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo recuperar el <xref:System.Windows.Media.HitTestResult> devolver el valor de la <xref:System.Windows.Media.ContainerVisual.HitTest%2A> método.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet2)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public void HitTest (System.Windows.Media.HitTestFilterCallback filterCallback, System.Windows.Media.HitTestResultCallback resultCallback, System.Windows.Media.HitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HitTest(class System.Windows.Media.HitTestFilterCallback filterCallback, class System.Windows.Media.HitTestResultCallback resultCallback, class System.Windows.Media.HitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.HitTest(System.Windows.Media.HitTestFilterCallback,System.Windows.Media.HitTestResultCallback,System.Windows.Media.HitTestParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HitTest(System::Windows::Media::HitTestFilterCallback ^ filterCallback, System::Windows::Media::HitTestResultCallback ^ resultCallback, System::Windows::Media::HitTestParameters ^ hitTestParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterCallback" Type="System.Windows.Media.HitTestFilterCallback" />
        <Parameter Name="resultCallback" Type="System.Windows.Media.HitTestResultCallback" />
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.HitTestParameters" />
      </Parameters>
      <Docs>
        <param name="filterCallback">Delegado que permite omitir las partes del árbol visual que no se desean procesar en los resultados de la prueba de posicionamiento.</param>
        <param name="resultCallback">Delegado que se usa para controlar la devolución de información de la prueba de posicionamiento.</param>
        <param name="hitTestParameters">Define el conjunto de parámetros para una prueba de posicionamiento.</param>
        <summary>Inicia una prueba de posicionamiento en <see cref="T:System.Windows.Media.ContainerVisual" /> mediante los objetos <see cref="T:System.Windows.Media.HitTestFilterCallback" /> y <see cref="T:System.Windows.Media.HitTestResultCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `filterCallback` parámetro puede ser null, en cuyo caso se omite. Si `filterCallback` no `null`, se invoca antes de `resultCallback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public System.Windows.Vector Offset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Vector Offset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Offset" />
      <MemberSignature Language="VB.NET" Value="Public Property Offset As Vector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Vector Offset { System::Windows::Vector get(); void set(System::Windows::Vector value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor de desplazamiento de <see cref="T:System.Windows.Media.ContainerVisual" /> desde su punto de referencia.</summary>
        <value>
          <see cref="T:System.Windows.Vector" /> que representa el valor de desplazamiento del objeto <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Opacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Opacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Opacity { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la opacidad de <see cref="T:System.Windows.Media.ContainerVisual" />, siendo 0 = transparente y 1 = opaco.</summary>
        <value>Valor de 0 a 1 que especifica un intervalo de totalmente transparente a totalmente opaco. El valor 0 indica que <see cref="T:System.Windows.Media.ContainerVisual" /> es completamente transparente, mientras que el valor 1 indica que <see cref="T:System.Windows.Media.ContainerVisual" /> es completamente opaco. El valor 0,5 indica una opacidad del 50 por ciento, el valor 0,725 indica una opacidad del 72,5 por ciento, etc. Los valores menores que 0 se tratan como 0, mientras que los valores mayores que 1 se tratan como 1.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.Opacity" />
      </Docs>
    </Member>
    <Member MemberName="OpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush OpacityMask { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush OpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.OpacityMask" />
      <MemberSignature Language="VB.NET" Value="Public Property OpacityMask As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ OpacityMask { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un pincel que especifica una posible máscara de opacidad para <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Valor de tipo <see cref="T:System.Windows.Media.Brush" /> que representa el valor de la máscara de opacidad del objeto <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Máscaras de opacidad pueden utilizarse para crear efectos como viñetas, basándose en los valores de canal alfa del pincel.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Windows.Media.Visual" /> primario de <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Elemento primario del objeto visual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que esto se devuelve como <xref:System.Windows.DependencyObject>, en lugar de un objeto sin formato.  
  
 Esta propiedad podría devolver `null` en un árbol desconectado, o si ha recorrido a la raíz del árbol en el nivel de ventana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform Transform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform Transform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Transform" />
      <MemberSignature Language="VB.NET" Value="Public Property Transform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ Transform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la transformación aplicada a <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Valor de transformación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Transform> es una clase base que unifica muchas formas diferentes de transformaciones. Para obtener información detallada, vea <xref:System.Windows.Media.Transform>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override sealed int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int VisualChildrenCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de elementos secundarios del objeto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Número de elementos secundarios en la colección <see cref="T:System.Windows.Media.VisualCollection" /> del objeto <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, un <xref:System.Windows.Media.ContainerVisual> no tiene ningún elemento secundario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo crear un <xref:System.Windows.Media.ContainerVisual> objeto que se usa como elemento primario para dos <xref:System.Windows.Media.DrawingVisual> objetos. Objetos que se agregan a la <xref:System.Windows.Media.ContainerVisual> objeto debe agregarse en orden z inverso (de abajo arriba) para asegurar que se representan en el orden de dibujo correcto. En orden para el árbol visual se enumere correctamente, el ejemplo proporciona implementaciones reemplazadas de la <xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A> método y <xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A> propiedad.  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Las clases que derivan de <see cref="T:System.Windows.Media.ContainerVisual" /> debe implementar la <see cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" /> propiedad que se va a enumerar los elementos secundarios visuales. La propiedad derivada debe devolver el número de elementos secundarios para el <see cref="T:System.Windows.Media.ContainerVisual" />.  
  
 No se puede modificar el árbol visual durante esta llamada.</para>
        </block>
        <altmember cref="M:System.Windows.Media.ContainerVisual.GetVisualChild(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="XSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection XSnappingGuidelines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection XSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.XSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property XSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::DoubleCollection ^ XSnappingGuidelines { System::Windows::Media::DoubleCollection ^ get(); void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la instrucción de coordenada X (horizontal) del objeto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Coordenada horizontal.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ajuste de píxeles es el proceso en el que se corrige el diseño de contenido para que los bordes de los objetos se representan en píxeles específicos del dispositivo. El sistema de gráficos de [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] usa unidades independientes del dispositivo para habilitar la resolución y la independencia del dispositivo. Cada píxel independiente del dispositivo se escala automáticamente con el sistema [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] configuración. Esto proporciona a las aplicaciones de [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] un escalado adecuado para diferentes configuraciones de [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] y hace que la aplicación detecte el valor de [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] automáticamente.  
  
 Sin embargo, esto [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] independencia puede crear la representación de bordes irregulares debido a la función de suavizado. Estos artefactos, suelen aparecer como bordes borrosos o "soft", pueden producirse cuando un borde se encuentra en medio de un píxel de dispositivo en lugar de hacerlo entre píxeles de dispositivo. Para resolver este problema, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] proporciona una manera de bordes de los objetos de un árbol visual para "ajuste" con los píxeles del dispositivo a través de ajuste de píxeles, lo que elimina los bordes suaves generados por suavizado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.ContainerVisual.YSnappingGuidelines" />
      </Docs>
    </Member>
    <Member MemberName="YSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection YSnappingGuidelines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection YSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.YSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property YSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::DoubleCollection ^ YSnappingGuidelines { System::Windows::Media::DoubleCollection ^ get(); void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la instrucción de coordenada Y (vertical) del objeto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Coordenada vertical.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ajuste de píxeles es el proceso en el que se corrige el diseño de contenido para que los bordes de los objetos se representan en píxeles específicos del dispositivo. El sistema de gráficos de [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] usa unidades independientes del dispositivo para habilitar la resolución y la independencia del dispositivo. Cada píxel independiente del dispositivo se escala automáticamente con el sistema [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] configuración. Esto proporciona a las aplicaciones de [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] un escalado adecuado para diferentes configuraciones de [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] y hace que la aplicación detecte el valor de [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] automáticamente.  
  
 Sin embargo, esto [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] independencia puede crear la representación de bordes irregulares debido a la función de suavizado. Estos artefactos, suelen aparecer como bordes borrosos o "soft", pueden producirse cuando un borde se encuentra en medio de un píxel de dispositivo en lugar de hacerlo entre píxeles de dispositivo. Para resolver este problema, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] proporciona una manera de bordes de los objetos de un árbol visual para "ajuste" con los píxeles del dispositivo a través de ajuste de píxeles, lo que elimina los bordes suaves generados por suavizado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.ContainerVisual.XSnappingGuidelines" />
      </Docs>
    </Member>
  </Members>
</Type>