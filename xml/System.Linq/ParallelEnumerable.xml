<Type Name="ParallelEnumerable" FullName="System.Linq.ParallelEnumerable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f281504925f8c17c54fcaceed174873364fa31cd" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52241332" /></Metadata><TypeSignature Language="C#" Value="public static class ParallelEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ParallelEnumerable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.ParallelEnumerable" />
  <TypeSignature Language="VB.NET" Value="Public Module ParallelEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ParallelEnumerable abstract sealed" />
  <TypeSignature Language="F#" Value="type ParallelEnumerable = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona un conjunto de métodos para consultar objetos que implementan ParallelQuery{TSource}. Es el equivalente paralelo de <see cref="T:System.Linq.Enumerable" />.</summary>
    <remarks>To be added.</remarks>
    <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Aggregate&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aplica en paralelo una función de acumulador a una secuencia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TSource,TSource&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``1(System.Linq.ParallelQuery{``0},System.Func{``0,``0,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource) (source As ParallelQuery(Of TSource), func As Func(Of TSource, TSource, TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Aggregate(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TSource, TSource&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Source, 'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Aggregate (source, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia a la que se va a agregar.</param>
        <param name="func">Función de acumulador que se va a invocar en cada elemento.</param>
        <summary>Aplica en paralelo una función de acumulador a una secuencia.</summary>
        <returns>Valor final del acumulador.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="func" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``2(System.Linq.ParallelQuery{``0},``1,System.Func{``1,``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate) (source As ParallelQuery(Of TSource), seed As TAccumulate, func As Func(Of TAccumulate, TSource, TAccumulate)) As TAccumulate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TAccumulate Aggregate(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.ParallelQuery&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; -&gt; 'Accumulate" Usage="System.Linq.ParallelEnumerable.Aggregate (source, seed, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Tipo del valor del acumulador.</typeparam>
        <param name="source">Secuencia a la que se va a agregar.</param>
        <param name="seed">Valor de inicio del acumulador.</param>
        <param name="func">Función de acumulador que se va a invocar en cada elemento.</param>
        <summary>Aplica en paralelo una función de acumulador a una secuencia. El valor de inicialización especificado se utiliza como valor de inicio del acumulador.</summary>
        <returns>Valor final del acumulador.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="func" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.ParallelQuery{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As ParallelQuery(Of TSource), seed As TAccumulate, func As Func(Of TAccumulate, TSource, TAccumulate), resultSelector As Func(Of TAccumulate, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ func, Func&lt;TAccumulate, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.ParallelQuery&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; * Func&lt;'Accumulate, 'Result&gt; -&gt; 'Result" Usage="System.Linq.ParallelEnumerable.Aggregate (source, seed, func, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Tipo del valor del acumulador.</typeparam>
        <typeparam name="TResult">Tipo del valor resultante.</typeparam>
        <param name="source">Secuencia a la que se va a agregar.</param>
        <param name="seed">Valor de inicio del acumulador.</param>
        <param name="func">Función de acumulador que se va a invocar en cada elemento.</param>
        <param name="resultSelector">Función que va a transformar el valor final del acumulador en el valor del resultado.</param>
        <summary>Aplica en paralelo una función de acumulador a una secuencia. El valor de inicialización especificado se utiliza como valor inicial del acumulador y la función especificada se utiliza para seleccionar el valor resultante.</summary>
        <returns>El valor final del acumulador transformado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="func" /> o <paramref name="resultSelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TAccumulate&gt; seedFactory, Func&lt;TAccumulate,TSource,TAccumulate&gt; updateAccumulatorFunc, Func&lt;TAccumulate,TAccumulate,TAccumulate&gt; combineAccumulatorsFunc, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TAccumulate&gt; seedFactory, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; updateAccumulatorFunc, class System.Func`3&lt;!!TAccumulate, !!TAccumulate, !!TAccumulate&gt; combineAccumulatorsFunc, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.ParallelQuery{``0},System.Func{``1},System.Func{``1,``0,``1},System.Func{``1,``1,``1},System.Func{``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As ParallelQuery(Of TSource), seedFactory As Func(Of TAccumulate), updateAccumulatorFunc As Func(Of TAccumulate, TSource, TAccumulate), combineAccumulatorsFunc As Func(Of TAccumulate, TAccumulate, TAccumulate), resultSelector As Func(Of TAccumulate, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TAccumulate&gt; ^ seedFactory, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ updateAccumulatorFunc, Func&lt;TAccumulate, TAccumulate, TAccumulate&gt; ^ combineAccumulatorsFunc, Func&lt;TAccumulate, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Accumulate&gt; * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; * Func&lt;'Accumulate, 'Accumulate, 'Accumulate&gt; * Func&lt;'Accumulate, 'Result&gt; -&gt; 'Result" Usage="System.Linq.ParallelEnumerable.Aggregate (source, seedFactory, updateAccumulatorFunc, combineAccumulatorsFunc, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seedFactory" Type="System.Func&lt;TAccumulate&gt;" />
        <Parameter Name="updateAccumulatorFunc" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="combineAccumulatorsFunc" Type="System.Func&lt;TAccumulate,TAccumulate,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Tipo del valor del acumulador.</typeparam>
        <typeparam name="TResult">Tipo del valor resultante.</typeparam>
        <param name="source">Secuencia a la que se va a agregar.</param>
        <param name="seedFactory">Función que devuelve el valor inicial del acumulador.</param>
        <param name="updateAccumulatorFunc">Función de acumulador que se va a invocar en cada elemento de una partición.</param>
        <param name="combineAccumulatorsFunc">Función de acumulador que se va a invocar en el resultado de acumulador obtenido de cada partición.</param>
        <param name="resultSelector">Función que va a transformar el valor final del acumulador en el valor del resultado.</param>
        <summary>Aplica en paralelo una función de acumulador a una secuencia. Esta sobrecarga no está disponible en la implementación secuencial.</summary>
        <returns>El valor final del acumulador transformado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga es específica para las consultas en paralelo. Una consulta en paralelo puede crear particiones de la secuencia de origen de datos en varias secuencias secundarias (particiones). El `updateAccumulatorFunc` se invoca en cada elemento dentro de las particiones. Cada partición, a continuación, produce un único resultado acumulado. El `combineAccumulatorsFunc` , a continuación, se invoca en los resultados de cada partición para producir un único elemento. Este elemento, a continuación, se transforma por la `resultSelector` función.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="seedFactory" /> o <paramref name="updateAccumulatorFunc" /> o <paramref name="combineAccumulatorsFunc" /> o <paramref name="resultSelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; updateAccumulatorFunc, Func&lt;TAccumulate,TAccumulate,TAccumulate&gt; combineAccumulatorsFunc, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; updateAccumulatorFunc, class System.Func`3&lt;!!TAccumulate, !!TAccumulate, !!TAccumulate&gt; combineAccumulatorsFunc, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.ParallelQuery{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``1,``1},System.Func{``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As ParallelQuery(Of TSource), seed As TAccumulate, updateAccumulatorFunc As Func(Of TAccumulate, TSource, TAccumulate), combineAccumulatorsFunc As Func(Of TAccumulate, TAccumulate, TAccumulate), resultSelector As Func(Of TAccumulate, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ updateAccumulatorFunc, Func&lt;TAccumulate, TAccumulate, TAccumulate&gt; ^ combineAccumulatorsFunc, Func&lt;TAccumulate, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.ParallelQuery&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; * Func&lt;'Accumulate, 'Accumulate, 'Accumulate&gt; * Func&lt;'Accumulate, 'Result&gt; -&gt; 'Result" Usage="System.Linq.ParallelEnumerable.Aggregate (source, seed, updateAccumulatorFunc, combineAccumulatorsFunc, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="updateAccumulatorFunc" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="combineAccumulatorsFunc" Type="System.Func&lt;TAccumulate,TAccumulate,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Tipo del valor del acumulador.</typeparam>
        <typeparam name="TResult">Tipo del valor resultante.</typeparam>
        <param name="source">Secuencia a la que se va a agregar.</param>
        <param name="seed">Valor de inicio del acumulador.</param>
        <param name="updateAccumulatorFunc">Función de acumulador que se va a invocar en cada elemento de una partición.</param>
        <param name="combineAccumulatorsFunc">Función de acumulador que se va a invocar en el resultado de acumulador obtenido de cada partición.</param>
        <param name="resultSelector">Función que va a transformar el valor final del acumulador en el valor del resultado.</param>
        <summary>Aplica en paralelo una función de acumulador a una secuencia. Esta sobrecarga no está disponible en la implementación secuencial.</summary>
        <returns>El valor final del acumulador transformado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga es específica del procesamiento de una consulta en paralelo. Una consulta en paralelo puede crear particiones de la secuencia de origen de datos en varias secuencias secundarias (particiones). El `updateAccumulatorFunc` se invoca en cada elemento dentro de las particiones. Cada partición, a continuación, produce un único resultado acumulado. El `combineAccumulatorsFunc` , a continuación, se invoca en los resultados de cada partición para producir un único elemento. Este elemento, a continuación, se transforma por la `resultSelector` función.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="updateAccumulatorFunc" /> o <paramref name="combineAccumulatorsFunc" /> o <paramref name="resultSelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.All``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool All(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member All : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.All (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia a cuyos elementos se va a aplicar el predicado.</param>
        <param name="predicate">Función para probar cada elemento de una condición.</param>
        <summary>Determina en paralelo si todos los elementos de una secuencia satisfacen una condición.</summary>
        <returns>Es true si todos los elementos de la secuencia de origen pasan la prueba del predicado especificado o si la secuencia está vacía; de lo contrario, es false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Any&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si una secuencia paralela contiene elementos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Any``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As ParallelQuery(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Any : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.Any source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia que se va a comprobar para ver si está vacía.</param>
        <summary>Determina si una secuencia paralela contiene elementos.</summary>
        <returns>Es true si la secuencia de salida contiene elementos; de lo contrario, es false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga del método cualquier hace que una combinación intermedia antes de que se devuelve el resultado. El comportamiento de combinación puede afectar al rendimiento o provocar una excepción de memoria insuficiente en grandes enumerables. Para evitar el comportamiento de combinación, utilice la sobrecarga de cualquiera que toma un parámetro de Func, o bien usar un método alternativo, como FirstOrDefault.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Any``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Any : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.Any (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia a cuyos elementos se va a aplicar el predicado.</param>
        <param name="predicate">Función para probar cada elemento de una condición.</param>
        <summary>Determina en paralelo si un elemento de una secuencia satisface una condición.</summary>
        <returns>Es true si algún elemento de la secuencia de salida pasa la prueba en el predicado especificado; de lo contrario, es false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsEnumerable&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsEnumerable&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsEnumerable``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsEnumerable(Of TSource) (source As ParallelQuery(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ AsEnumerable(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsEnumerable : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsEnumerable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia que se va a convertir como <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Convierte <see cref="T:System.Linq.ParallelQuery`1" /> en <see cref="T:System.Collections.Generic.IEnumerable`1" /> para forzar la evaluación secuencial de la consulta.</summary>
        <returns>Secuencia de entrada tipada como <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsOrdered">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery AsOrdered (this System.Linq.ParallelQuery source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery AsOrdered(class System.Linq.ParallelQuery source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsOrdered(System.Linq.ParallelQuery)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsOrdered (source As ParallelQuery) As ParallelQuery" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery ^ AsOrdered(System::Linq::ParallelQuery ^ source);" />
      <MemberSignature Language="F#" Value="static member AsOrdered : System.Linq.ParallelQuery -&gt; System.Linq.ParallelQuery" Usage="System.Linq.ParallelEnumerable.AsOrdered source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de entrada.</param>
        <summary>Habilita el tratamiento de un origen de datos como si estuviera ordenado, con lo que se invalida el valor predeterminado de no ordenado. AsOrdered solo se puede invocar en secuencias no genéricas devueltas por AsParallel, ParallelEnumerable.Range y ParallelEnumerable.Repeat.</summary>
        <returns>Secuencia de origen que mantendrá la ordenación original en los operadores de consulta subsiguientes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Existe una tensión natural entre el rendimiento y la conservación del orden de procesamiento en paralelo. De forma predeterminada, una consulta en paralelo se comporta como si la ordenación de los resultados es arbitraria a menos que se aplica a AsOrdered o hay un operador OrderBy explícito en la consulta. Para más información, consulte cómo [conservar el orden en PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">se produce si <paramref name="source" /> no contiene ningún elemento 
O bien 
se produce si se llama a AsOrdered durante una consulta. Se puede llamar inmediatamente después de <see cref="M:System.Linq.ParallelEnumerable.AsParallel(System.Collections.IEnumerable)" />, <see cref="M:System.Linq.ParallelEnumerable.Range(System.Int32,System.Int32)" /> o <see cref="M:System.Linq.ParallelEnumerable.Repeat``1(``0,System.Int32)" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsOrdered&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsOrdered&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsOrdered&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsOrdered``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsOrdered(Of TSource) (source As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ AsOrdered(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsOrdered : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsOrdered source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de entrada.</param>
        <summary>Habilita el tratamiento de un origen de datos como si estuviera ordenado, con lo que se invalida el valor predeterminado de no ordenado. AsOrdered solo se puede invocar en secuencias genéricas devueltas por AsParallel, ParallelEnumerable.Range y ParallelEnumerable.Repeat.</summary>
        <returns>Secuencia de origen que mantendrá la ordenación original en los operadores de consulta subsiguientes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Existe una tensión natural entre el rendimiento y la conservación del orden de procesamiento en paralelo. De forma predeterminada, una consulta en paralelo se comporta como si la ordenación de los resultados es arbitraria a menos que se aplica a AsOrdered o hay un operador OrderBy explícito en la consulta. Para más información, consulte cómo [conservar el orden en PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException">Se produce si <paramref name="source" /> no contiene ningún elemento 
O bien 
si <paramref name="source" /> no es de AsParallel, ParallelEnumerable.Range o ParallelEnumerable.Repeat.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AsParallel">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Habilita la paralelización de una consulta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método enlaza la consulta a PLINQ. Para más información, consulte [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AsParallel">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery AsParallel (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery AsParallel(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsParallel(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsParallel (source As IEnumerable) As ParallelQuery" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery ^ AsParallel(System::Collections::IEnumerable ^ source);" />
      <MemberSignature Language="F#" Value="static member AsParallel : System.Collections.IEnumerable -&gt; System.Linq.ParallelQuery" Usage="System.Linq.ParallelEnumerable.AsParallel source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" /> que se va a convertir en <see cref="T:System.Linq.ParallelQuery" />.</param>
        <summary>Habilita la paralelización de una consulta.</summary>
        <returns>Origen como ParallelQuery para enlazar a los métodos de extensión ParallelEnumerable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Linq.ParallelEnumerable.Cast%2A> operador puede usarse para convertir ParallelQuery en (t) ParallelQuery.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsParallel&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsParallel&lt;TSource&gt; (this System.Collections.Concurrent.Partitioner&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsParallel&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsParallel``1(System.Collections.Concurrent.Partitioner{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsParallel(Of TSource) (source As Partitioner(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ AsParallel(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsParallel : System.Collections.Concurrent.Partitioner&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsParallel source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Particionador de la secuencia de entrada.</param>
        <summary>Habilita la paralelización de una consulta, tal como la obtiene de un particionador personalizado responsable de dividir la secuencia de entrada en particiones.</summary>
        <returns><paramref name="source" /> como ParallelQuery para enlazar a los métodos de extensión ParallelEnumerable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetOrderedPartitions del particionador de origen que se usa el método al ordenar está habilitada, mientras que el particionador se usa si la ordenación no está habilitado (valor predeterminado). No se utilizan los métodos GetDynamicPartitions y GetDynamicOrderedPartitions del particionador de origen. Para obtener más información y ejemplos, vea [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsParallel&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsParallel&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsParallel&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsParallel``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsParallel(Of TSource) (source As IEnumerable(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ AsParallel(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsParallel : seq&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsParallel source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Collections.Generic.IEnumerable`1" /> que se va a convertir en <see cref="T:System.Linq.ParallelQuery`1" />.</param>
        <summary>Habilita la paralelización de una consulta.</summary>
        <returns>Origen como <see cref="T:System.Linq.ParallelQuery`1" /> para enlazar a los métodos de extensión ParallelEnumerable.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsSequential&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsSequential&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsSequential&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsSequential``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSequential(Of TSource) (source As ParallelQuery(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ AsSequential(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsSequential : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsSequential source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.ParallelQuery`1" /> que se va a convertir en <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Convierte <see cref="T:System.Linq.ParallelQuery`1" /> en <see cref="T:System.Collections.Generic.IEnumerable`1" /> para forzar la evaluación secuencial de la consulta.</summary>
        <returns>Origen como <see cref="T:System.Collections.Generic.IEnumerable`1" /> para enlazar a los métodos de extensión secuenciales.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, consulte [conservar el orden en PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md) y [Cómo: controlar la ordenación en una consulta PLINQ](~/docs/standard/parallel-programming/how-to-control-ordering-in-a-plinq-query.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsUnordered&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsUnordered&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsUnordered&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsUnordered``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsUnordered(Of TSource) (source As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ AsUnordered(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsUnordered : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsUnordered source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de entrada.</param>
        <summary>Permite tratar una consulta intermedia como si no hubiera ningún orden implícito entre los elementos.</summary>
        <returns>Secuencia de salida con orden arbitrario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 AsUnordered puede proporcionar ventajas de rendimiento cuando no se necesita la ordenación en una parte de una consulta. De forma predeterminada, PLINQ trata una secuencia de entrada como no ordenada a menos que se especifique OrderBy o AsOrdered. Sin embargo, si ordenación estaba activada y ya no es necesario, a continuación, se puede usar AsUnordered para desactivarla en la consulta intermedia y esto puede dar lugar a ventajas de rendimiento. El propio operador AsUnordered no orden aleatorio de la secuencia de origen; simplemente se quita el requisito de ordenación para los operadores subsiguientes. Si el origen está ordenado, pueden mantener los operadores subsiguientes esa ordenación si es más eficaz para hacerlo. AsUnordered puede llamarse en cualquier lugar en la consulta. no debe llamarse inmediatamente después de AsParallel. Para obtener más información, consulte [Introducción a la velocidad en PLINQ](~/docs/standard/parallel-programming/understanding-speedup-in-plinq.md) y [conservar el orden en PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Average">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcula en paralelo el promedio de una secuencia de valores.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Linq::ParallelQuery&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;int&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma o cuenta de los elementos de la secuencia es mayor que <see cref="F:System.Int32.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;int64&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma o cuenta de los elementos de la secuencia es mayor que <see cref="F:System.Int32.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Linq::ParallelQuery&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de salida.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores.</summary>
        <returns>Devuelve el promedio de una secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException">Una secuencia de valores que se utilizan para calcular una media. La media de la secuencia de valores.<paramref name="source" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma o cuenta de los elementos de la secuencia es mayor que <see cref="F:System.Int32.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma o cuenta de los elementos de la secuencia es mayor que <see cref="F:System.Int32.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Linq::ParallelQuery&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Linq::ParallelQuery&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <exception cref="T:System.OverflowException">(Se produce como excepción interna en una <see cref="T:System.AggregateException" />). La función <paramref name="selector" /> devuelve un valor mayor que MaxValue para el tipo de elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <exception cref="T:System.OverflowException">(Se produce como excepción interna en una <see cref="T:System.AggregateException" />). La función <paramref name="selector" /> devuelve un valor mayor que MaxValue para el tipo de elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma o cuenta de los elementos de la secuencia es mayor que <see cref="F:System.Int32.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <exception cref="T:System.OverflowException">(Se produce como excepción interna en una <see cref="T:System.AggregateException" />). La función <paramref name="selector" /> devuelve un valor mayor que MaxValue para el tipo de elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma o cuenta de los elementos de la secuencia es mayor que <see cref="F:System.Int32.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <exception cref="T:System.OverflowException">(Se produce como excepción interna en una <see cref="T:System.AggregateException" />). La función <paramref name="selector" /> devuelve un valor mayor que MaxValue para el tipo de elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <exception cref="T:System.OverflowException">(Se produce como excepción interna en una <see cref="T:System.AggregateException" />). La función <paramref name="selector" /> devuelve un valor mayor que MaxValue para el tipo de elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <exception cref="T:System.OverflowException">(Se produce como excepción interna en una <see cref="T:System.AggregateException" />). La función <paramref name="selector" /> devuelve un valor mayor que MaxValue para el tipo de elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma o cuenta de los elementos de la secuencia es mayor que <see cref="F:System.Int32.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <exception cref="T:System.OverflowException">(Se produce como excepción interna en una <see cref="T:System.AggregateException" />). La función <paramref name="selector" /> devuelve un valor mayor que MaxValue para el tipo de elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma o cuenta de los elementos de la secuencia es mayor que <see cref="F:System.Int64.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <exception cref="T:System.OverflowException">(Se produce como excepción interna en una <see cref="T:System.AggregateException" />). La función <paramref name="selector" /> devuelve un valor mayor que MaxValue para el tipo de elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <exception cref="T:System.OverflowException">(Se produce como excepción interna en una <see cref="T:System.AggregateException" />). La función <paramref name="selector" /> devuelve un valor mayor que MaxValue para el tipo de elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores que se utilizan para calcular un promedio.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo el promedio de una secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>El promedio de la secuencia de valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <exception cref="T:System.OverflowException">(Se produce como excepción interna en una <see cref="T:System.AggregateException" />). La función <paramref name="selector" /> devuelve un valor mayor que MaxValue para el tipo de elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Linq.ParallelQuery source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Linq.ParallelQuery source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Cast``1(System.Linq.ParallelQuery)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Cast(Of TResult) (source As ParallelQuery) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Cast(System::Linq::ParallelQuery ^ source);" />
      <MemberSignature Language="F#" Value="static member Cast : System.Linq.ParallelQuery -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Cast source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo al que se convierten los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia que contiene los elementos que se van a convertir.</param>
        <summary>Convierte los elementos de ParallelQuery en el tipo especificado.</summary>
        <returns>Secuencia que contiene cada elemento de la secuencia de salida convertido en el tipo especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.InvalidCastException">El tipo de la secuencia de origen no puede convertirse automáticamente en <paramref name="TResult" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatena dos secuencias paralelas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Concat``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concat(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Concat(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Concat : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Concat (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Este parámetro de tipo no se utiliza.</typeparam>
        <param name="first">Este parámetro no se utiliza.</param>
        <param name="second">Este parámetro no se utiliza.</param>
        <summary>Nunca se debería llamar a esta sobrecarga Concat. Este método está marcado como obsoleto y, cuando se llama, siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Esta sobrecarga siempre produce una excepción <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga existe para denegar el uso de Concat con un origen de datos izquierdo de tipo <xref:System.Linq.ParallelQuery%601> y un origen de datos derecho de tipo <xref:System.Collections.Generic.IEnumerable%601>. En caso contrario, el Operador Concat parecería que enlaza a la implementación paralela, pero en realidad enlazaría a la implementación secuencial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La excepción que se produce al llamar a este método.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Concat``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concat(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Concat(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Concat : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Concat (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
        <param name="first">Primera secuencia que se va a concatenar.</param>
        <param name="second">Secuencia que se va a concatenar con la primera secuencia.</param>
        <summary>Concatena dos secuencias paralelas.</summary>
        <returns>Secuencia que contiene los elementos concatenados de las dos secuencias de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> o <paramref name="second" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina en paralelo si una secuencia contiene un elemento especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TSource value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TSource value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Contains``1(System.Linq.ParallelQuery{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As ParallelQuery(Of TSource), value As TSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TSource value);" />
      <MemberSignature Language="F#" Value="static member Contains : System.Linq.ParallelQuery&lt;'Source&gt; * 'Source -&gt; bool" Usage="System.Linq.ParallelEnumerable.Contains (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia en la que se va a buscar un valor.</param>
        <param name="value">Valor que se va a buscar en la secuencia.</param>
        <summary>Determina en paralelo si una secuencia contiene un elemento especificado mediante el comparador de igualdad predeterminado.</summary>
        <returns>Es true si la secuencia de salida contiene un elemento que tiene el valor especificado; de lo contrario, es false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TSource value, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TSource value, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Contains``1(System.Linq.ParallelQuery{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As ParallelQuery(Of TSource), value As TSource, comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TSource value, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Contains : System.Linq.ParallelQuery&lt;'Source&gt; * 'Source * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.Contains (source, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia en la que se va a buscar un valor.</param>
        <param name="value">Valor que se va a buscar en la secuencia.</param>
        <param name="comparer">Comparador de igualdad que va a comparar los valores.</param>
        <summary>Determina en paralelo si una secuencia contiene un elemento especificado usando un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> determinado.</summary>
        <returns>Es true si la secuencia de salida contiene un elemento que tiene el valor especificado; de lo contrario, es false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Count&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el número de elementos de una secuencia paralela.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Count``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As ParallelQuery(Of TSource)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Count : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Count source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia que contiene los elementos que se van a contar.</param>
        <summary>Devuelve el número de elementos de una secuencia paralela.</summary>
        <returns>El número de elementos de la secuencia de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">El número de elementos del origen es mayor que <see cref="F:System.Int32.MaxValue" />. (En este caso InnerException es <see cref="T:System.OverflowException" />) - o bien- Una o más excepciones se produjeron durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Count``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Count : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Count (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia que contiene los elementos que se van a contar.</param>
        <param name="predicate">Función para probar cada elemento de una condición.</param>
        <summary>Devuelve un número que representa cuántos elementos de la secuencia paralela especificada satisfacen una condición.</summary>
        <returns>Un número que representa cuántos elementos de la secuencia especificada satisfacen la condición de la función de predicado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">El número de elementos del origen es mayor que <see cref="F:System.Int32.MaxValue" />. (En este caso InnerException es <see cref="T:System.OverflowException" />) - o bien- Una o más excepciones se produjeron durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Si la secuencia está vacía, devuelve los elementos de la secuencia paralela especificada o el valor especificado en una colección singleton.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.DefaultIfEmpty``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ DefaultIfEmpty(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.DefaultIfEmpty source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia para la que se va a devolver un valor predeterminado si está vacía.</param>
        <summary>Si la secuencia está vacía, devuelve los elementos de la secuencia paralela especificada o el valor predeterminado del parámetro de tipo en una colección singleton.</summary>
        <returns>Secuencia que contiene default(TSource) si <paramref name="source" /> está vacío; en caso contrario, es <paramref name="source" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.DefaultIfEmpty``1(System.Linq.ParallelQuery{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As ParallelQuery(Of TSource), defaultValue As TSource) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ DefaultIfEmpty(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TSource defaultValue);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : System.Linq.ParallelQuery&lt;'Source&gt; * 'Source -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.DefaultIfEmpty (source, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia para la que se va a devolver el valor especificado si está vacía.</param>
        <param name="defaultValue">Valor que se va a devolver si la secuencia está vacía.</param>
        <summary>Si la secuencia está vacía, devuelve los elementos de la secuencia paralela especificada o el valor especificado en una colección singleton.</summary>
        <returns>Secuencia que contiene defaultValue si <paramref name="source" /> está vacío; en caso contrario, es <paramref name="source" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Distinct&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve diversos elementos de una secuencia paralela al emplear el comparador de igualdad predeterminado para comparar valores.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Distinct``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Distinct(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Distinct source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se van a quitar los elementos duplicados.</param>
        <summary>Devuelve diversos elementos de una secuencia paralela al emplear el comparador de igualdad predeterminado para comparar valores.</summary>
        <returns>Secuencia que contiene diversos elementos de la secuencia de salida.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Distinct``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As ParallelQuery(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Distinct(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Linq.ParallelQuery&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Distinct (source, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se van a quitar los elementos duplicados.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
        <summary>Devuelve diversos elementos de una secuencia paralela usando un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar los valores.</summary>
        <returns>Secuencia que contiene diversos elementos de la secuencia de salida.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ElementAt``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAt(Of TSource) (source As ParallelQuery(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAt(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAt : System.Linq.ParallelQuery&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.ElementAt (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se va a devolver un elemento.</param>
        <param name="index">Índice de base cero del elemento que se debe recuperar.</param>
        <summary>Devuelve el elemento en un índice especificado en una secuencia paralela.</summary>
        <returns>El elemento situado en la posición especificada de la secuencia de origen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que 0 o mayor o igual que el número de elementos de <paramref name="source" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ElementAtOrDefault``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAtOrDefault(Of TSource) (source As ParallelQuery(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAtOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAtOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.ElementAtOrDefault (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se va a devolver un elemento.</param>
        <param name="index">Índice de base cero del elemento que se debe recuperar.</param>
        <summary>Devuelve el elemento en un índice especificado en una secuencia paralela o, si el índice está fuera del intervalo, un valor predeterminado.</summary>
        <returns>Devuelve default(TSource) si el índice está fuera de los límites de la secuencia de salida; de lo contrario, el elemento en la posición especificada en la secuencia de salida.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Empty&lt;TResult&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Empty&lt;TResult&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Function Empty(Of TResult) () As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TResult">Tipo que se va a asignar al parámetro de tipo de la secuencia genérica devuelta.</typeparam>
        <summary>Devuelve un objeto ParallelQuery{TResult} vacío que tiene el argumento de tipo especificado.</summary>
        <returns>Secuencia vacía cuyo argumento de tipo es <paramref name="TResult" />.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Except&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Proporciona la diferencia de conjuntos de dos secuencias paralelas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Except(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Except (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Este parámetro de tipo no se utiliza.</typeparam>
        <param name="first">Este parámetro no se utiliza.</param>
        <param name="second">Este parámetro no se utiliza.</param>
        <summary>Nunca se debería llamar a esta sobrecarga Except. Este método está marcado como obsoleto y, cuando se llama, siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Esta sobrecarga siempre produce una excepción <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga existe para denegar el uso de Except con un origen de datos izquierdo de tipo <xref:System.Linq.ParallelQuery%601> y un origen de datos derecho de tipo <xref:System.Collections.Generic.IEnumerable%601>. En caso contrario, el operador Except parecería que enlaza a la implementación paralela, pero en realidad enlazaría a la implementación secuencial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La excepción que se produce al llamar a este método.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Except(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Except (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
        <param name="first">Secuencia cuyos elementos que no estén además en <paramref name="second" /> se van a devolver.</param>
        <param name="second">Secuencia cuyos elementos que también aparezcan en la primera secuencia harán que se quiten esos elementos de la secuencia devuelta.</param>
        <summary>Proporciona la diferencia de conjunto de dos secuencias paralelas al emplear el comparador de igualdad predeterminado para comparar valores.</summary>
        <returns>Una secuencia que contiene la diferencia de conjuntos de los elementos de dos secuencias.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> o <paramref name="second" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Except(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Except (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Este parámetro de tipo no se utiliza.</typeparam>
        <param name="first">Este parámetro no se utiliza.</param>
        <param name="second">Este parámetro no se utiliza.</param>
        <param name="comparer">Este parámetro no se utiliza.</param>
        <summary>Nunca se debería llamar a esta sobrecarga Except. Este método está marcado como obsoleto y, cuando se llama, siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Esta sobrecarga siempre produce una excepción <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga existe para denegar el uso de Except con un origen de datos izquierdo de tipo <xref:System.Linq.ParallelQuery%601> y un origen de datos derecho de tipo <xref:System.Collections.Generic.IEnumerable%601>. En caso contrario, el operador Except parecería que enlaza a la implementación paralela, pero en realidad enlazaría a la implementación secuencial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La excepción que se produce al llamar a este método.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Except(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Except (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
        <param name="first">Secuencia cuyos elementos que no estén además en <paramref name="second" /> se van a devolver.</param>
        <param name="second">Secuencia cuyos elementos que también aparezcan en la primera secuencia harán que se quiten esos elementos de la secuencia devuelta.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
        <summary>Proporciona la diferencia de conjuntos de dos secuencias paralelas usando el <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar los valores.</summary>
        <returns>Una secuencia que contiene la diferencia de conjuntos de los elementos de dos secuencias.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> o <paramref name="second" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="First&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el primer elemento de una secuencia paralela.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.First``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member First : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.First source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se va a devolver el primer elemento.</param>
        <summary>Devuelve el primer elemento de una secuencia paralela.</summary>
        <returns>El primer elemento de la secuencia especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la consulta no está ordenada, el primer elemento es no determinista. Para más información, consulte cómo [conservar el orden en PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.First``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member First : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.First (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se va a devolver un elemento.</param>
        <param name="predicate">Función para probar cada elemento de una condición.</param>
        <summary>Devuelve el primer elemento de una secuencia paralela que satisface una condición concreta.</summary>
        <returns>El primer elemento de la secuencia que pasa la prueba de la función de predicado especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la consulta no está ordenada, el primer elemento es no determinista. Para más información, consulte cómo [conservar el orden en PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException">Ningún elemento de <paramref name="source" /> satisface la condición de <paramref name="predicate" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FirstOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el primer elemento de una secuencia paralela o, si la secuencia no contiene elementos, un valor predeterminado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.FirstOrDefault``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.FirstOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se va a devolver el primer elemento.</param>
        <summary>Devuelve el primer elemento de una secuencia paralela o, si la secuencia no contiene elementos, un valor predeterminado.</summary>
        <returns>Devuelve default(TSource) si <paramref name="source" /> está vacío; en caso contrario, el primer elemento de <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la consulta no está ordenada, el primer elemento es no determinista. Para más información, consulte cómo [conservar el orden en PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.FirstOrDefault``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.FirstOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se va a devolver un elemento.</param>
        <param name="predicate">Función para probar cada elemento de una condición.</param>
        <summary>Devuelve el primer elemento de la secuencia paralela que satisface una condición o, si no se encuentra dicho elemento, un valor predeterminado.</summary>
        <returns>Devuelve default(TSource) si <paramref name="source" /> está vacío o si ningún elemento pasa la prueba especificada por el predicado; en caso contrario, el primer elemento de <paramref name="source" /> que pasa dicha prueba.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la consulta no está ordenada, el primer elemento es no determinista. Para más información, consulte cómo [conservar el orden en PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static void ForAll&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Action&lt;TSource&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForAll&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ForAll``1(System.Linq.ParallelQuery{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ForAll(Of TSource) (source As ParallelQuery(Of TSource), action As Action(Of TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void ForAll(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForAll : System.Linq.ParallelQuery&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; unit" Usage="System.Linq.ParallelEnumerable.ForAll (source, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="action" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.ParallelQuery`1" /> cuyos elementos procesará <paramref name="action" />.</param>
        <param name="action">Acción para invocar en cada elemento.</param>
        <summary>Invoca en paralelo la acción especificada para cada elemento de <paramref name="source" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de una manera eficaz de procesar el resultado de una consulta en paralelo porque no requiere un paso de combinación al final. Para obtener más información, consulte [opciones de combinación en PLINQ](~/docs/standard/parallel-programming/merge-options-in-plinq.md) o [conservar el orden en PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md). Puesto que este método produce un efecto secundario, puede usarlo para observar el orden real de ejecución en una consulta en paralelo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrupa en paralelo los elementos de una secuencia según una función del selector de claves.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As ParallelQuery(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <param name="source">OrderedParallelQuery{TSource} que contiene los elementos que se van a ordenar.</param>
        <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
        <summary>Agrupa en paralelo los elementos de una secuencia según una función especificada del selector de claves.</summary>
        <returns>Secuencia de grupos en orden descendente de acuerdo con <paramref name="TKey" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">El tipo de la clave devuelta por <paramref name="keySelector" /> &gt;.</typeparam>
        <param name="source"><see cref="T:System.Linq.OrderedParallelQuery`1" /> que contiene los elementos que se van a ordenar.</param>
        <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> para comparar claves.</param>
        <summary>Agrupa en paralelo los elementos de una secuencia según una función especificada del selector de claves y compara las claves mediante un <see cref="T:System.Collections.Generic.IComparer`1" /> especificado.</summary>
        <returns>Secuencia de grupos en orden descendente de acuerdo con <paramref name="TKey" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As ParallelQuery(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Tipo de los elementos de <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source"><see cref="T:System.Linq.OrderedParallelQuery`1" /> que contiene los elementos que se van a ordenar.</param>
        <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
        <param name="elementSelector">Función que asigna cada elemento de origen a un elemento de <see cref="T:System.Linq.IGrouping`2" />.</param>
        <summary>Agrupa en paralelo los elementos de una secuencia según una función especificada del selector de claves y proyecta los elementos de cada grupo mediante una función determinada.</summary>
        <returns>Secuencia de grupos en orden descendente de acuerdo con <paramref name="TKey" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Tipo de los elementos de IGrouping.</typeparam>
        <param name="source">OrderedParallelQuery{TSource} que contiene los elementos que se van a ordenar.</param>
        <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
        <param name="elementSelector">Función que asigna cada elemento de origen a un elemento de IGrouping.</param>
        <param name="comparer">IComparer{TSource} para comparar claves.</param>
        <summary>Agrupa en paralelo los elementos de una secuencia según una función del selector de claves. Las claves se comparan utilizando un comparador y los elementos de cada grupo se proyectan utilizando una función especificada.</summary>
        <returns>Secuencia de grupos en orden descendente de acuerdo con <paramref name="TKey" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), resultSelector As Func(Of TKey, IEnumerable(Of TSource), TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TResult">Tipo del valor de resultado devuelto por <paramref name="resultSelector" />.</typeparam>
        <param name="source">Secuencia cuyos elementos se van a agrupar.</param>
        <param name="keySelector">Función para extraer la clave de cada elemento.</param>
        <param name="resultSelector">Función que va a crear un valor de resultado a partir de cada grupo.</param>
        <summary>Agrupa en paralelo los elementos de una secuencia según la función especificada del selector de claves y crea un valor de resultado a partir de cada grupo y su clave.</summary>
        <returns>Secuencia de elementos de tipo <paramref name="TResult" /> donde cada elemento representa una proyección sobre un grupo y su clave.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), resultSelector As Func(Of TKey, IEnumerable(Of TSource), TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TResult">Tipo del valor de resultado devuelto por <paramref name="resultSelector" />.</typeparam>
        <param name="source">Secuencia cuyos elementos se van a agrupar.</param>
        <param name="keySelector">Función para extraer la clave de cada elemento.</param>
        <param name="resultSelector">Función que va a crear un valor de resultado a partir de cada grupo.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
        <summary>Agrupa en paralelo los elementos de una secuencia según la función especificada del selector de claves y crea un valor de resultado a partir de cada grupo y su clave. Las claves se comparan utilizando un comparador especificado.</summary>
        <returns>Secuencia de grupos.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``4(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), resultSelector As Func(Of TKey, IEnumerable(Of TElement), TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, elementSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Tipo de los elementos de cada IGrouping {TKey, TElement}.</typeparam>
        <typeparam name="TResult">Tipo del valor de resultado devuelto por <paramref name="resultSelector" />.</typeparam>
        <param name="source">Secuencia cuyos elementos se van a agrupar.</param>
        <param name="keySelector">Función para extraer la clave de cada elemento.</param>
        <param name="elementSelector">Función para asignar cada elemento de origen a un elemento IGrouping&lt;TKey, TElement&gt;.</param>
        <param name="resultSelector">Función que va a crear un valor de resultado a partir de cada grupo.</param>
        <summary>Agrupa en paralelo los elementos de una secuencia según la función especificada del selector de claves y crea un valor de resultado a partir de cada grupo y su clave. Los elementos de cada grupo se proyectan utilizando una función determinada.</summary>
        <returns>Secuencia de elementos de tipo <paramref name="TResult" /> donde cada elemento representa una proyección sobre un grupo y su clave.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``4(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), resultSelector As Func(Of TKey, IEnumerable(Of TElement), TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, elementSelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Tipo de los elementos de cada IGrouping {TKey, TElement}.</typeparam>
        <typeparam name="TResult">Tipo del valor de resultado devuelto por <paramref name="resultSelector" />.</typeparam>
        <param name="source">Secuencia cuyos elementos se van a agrupar.</param>
        <param name="keySelector">Función para extraer la clave de cada elemento.</param>
        <param name="elementSelector">Función para asignar cada elemento de origen a un elemento en IGrouping{Key, TElement}.</param>
        <param name="resultSelector">Función que va a crear un valor de resultado a partir de cada grupo.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
        <summary>Agrupa los elementos de una secuencia según una función del selector de claves especificada y crea un valor de resultado a partir de cada grupo y su clave. Los valores de las claves se comparan utilizando un comparador especificado y los elementos de cada grupo se proyectan utilizando una función especificada.</summary>
        <returns>Secuencia de elementos de tipo <paramref name="TResult" /> donde cada elemento representa una proyección sobre un grupo y su clave.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Correlaciona en paralelo los elementos de dos secuencias en función de la igualdad de claves y agrupa los resultados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupJoin(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.ParallelQuery&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Este parámetro de tipo no se utiliza.</typeparam>
        <typeparam name="TInner">Este parámetro de tipo no se utiliza.</typeparam>
        <typeparam name="TKey">Este parámetro de tipo no se utiliza.</typeparam>
        <typeparam name="TResult">Este parámetro de tipo no se utiliza.</typeparam>
        <param name="outer">Este parámetro no se utiliza.</param>
        <param name="inner">Este parámetro no se utiliza.</param>
        <param name="outerKeySelector">Este parámetro no se utiliza.</param>
        <param name="innerKeySelector">Este parámetro no se utiliza.</param>
        <param name="resultSelector">Este parámetro no se utiliza.</param>
        <summary>Nunca se debería llamar a esta sobrecarga GroupJoin. Este método está marcado como obsoleto y, cuando se llama, siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Esta sobrecarga siempre produce una excepción <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga existe para denegar el uso de GroupJoin con un origen de datos izquierdo de tipo <xref:System.Linq.ParallelQuery%601> y un origen de datos derecho de tipo <xref:System.Collections.Generic.IEnumerable%601>. En caso contrario, el operador GroupJoin parecería que enlaza a la implementación paralela, pero en realidad enlazaría a la implementación secuencial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As ParallelQuery(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupJoin(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Linq::ParallelQuery&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.ParallelQuery&lt;'Outer&gt; * System.Linq.ParallelQuery&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Tipo de los elementos de la primera secuencia.</typeparam>
        <typeparam name="TInner">Tipo de los elementos de la segunda secuencia.</typeparam>
        <typeparam name="TKey">Tipo de las claves devueltas por las funciones del selector de claves.</typeparam>
        <typeparam name="TResult">Tipo de los elementos del resultado.</typeparam>
        <param name="outer">Primera secuencia que se va a combinar.</param>
        <param name="inner">Secuencia que se va a combinar con la primera secuencia.</param>
        <param name="outerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la primera secuencia.</param>
        <param name="innerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la segunda secuencia.</param>
        <param name="resultSelector">Función para crear un elemento de resultado a partir de un elemento de la primera secuencia y una colección de elementos coincidentes de la segunda.</param>
        <summary>Correlaciona en paralelo los elementos de dos secuencias en función de la igualdad de claves y agrupa los resultados. El comparador de igualdad predeterminado se usa para comparar claves.</summary>
        <returns>Secuencia que tiene elementos de tipo <paramref name="TResult" /> que se han obtenido al realizar una combinación agrupada de dos secuencias.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupJoin(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.ParallelQuery&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Este parámetro de tipo no se utiliza.</typeparam>
        <typeparam name="TInner">Este parámetro de tipo no se utiliza.</typeparam>
        <typeparam name="TKey">Este parámetro de tipo no se utiliza.</typeparam>
        <typeparam name="TResult">Este parámetro de tipo no se utiliza.</typeparam>
        <param name="outer">Este parámetro no se utiliza.</param>
        <param name="inner">Este parámetro no se utiliza.</param>
        <param name="outerKeySelector">Este parámetro no se utiliza.</param>
        <param name="innerKeySelector">Este parámetro no se utiliza.</param>
        <param name="resultSelector">Este parámetro no se utiliza.</param>
        <param name="comparer">Este parámetro no se utiliza.</param>
        <summary>Nunca se debería llamar a esta sobrecarga GroupJoin. Este método está marcado como obsoleto y, cuando se llama, siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Esta sobrecarga siempre produce una excepción <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga existe para denegar el uso de GroupJoin con un origen de datos izquierdo de tipo <xref:System.Linq.ParallelQuery%601> y un origen de datos derecho de tipo <xref:System.Collections.Generic.IEnumerable%601>. En caso contrario, el operador GroupJoin parecería que enlaza a la implementación paralela, pero en realidad enlazaría a la implementación secuencial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La excepción que se produce al llamar a este método.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As ParallelQuery(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupJoin(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Linq::ParallelQuery&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.ParallelQuery&lt;'Outer&gt; * System.Linq.ParallelQuery&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Tipo de los elementos de la primera secuencia.</typeparam>
        <typeparam name="TInner">Tipo de los elementos de la segunda secuencia.</typeparam>
        <typeparam name="TKey">Tipo de las claves devueltas por las funciones del selector de claves.</typeparam>
        <typeparam name="TResult">Tipo de los elementos del resultado.</typeparam>
        <param name="outer">Primera secuencia que se va a combinar.</param>
        <param name="inner">Secuencia que se va a combinar con la primera secuencia.</param>
        <param name="outerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la primera secuencia.</param>
        <param name="innerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la segunda secuencia.</param>
        <param name="resultSelector">Función para crear un elemento de resultado a partir de un elemento de la primera secuencia y una colección de elementos coincidentes de la segunda.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que va a aplicar un algoritmo hash y a comparar las claves.</param>
        <summary>Correlaciona en paralelo los elementos de dos secuencias en función de la igualdad de claves y agrupa los resultados. Se usa un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar claves.</summary>
        <returns>Secuencia que tiene elementos de tipo <paramref name="TResult" /> que se han obtenido al realizar una combinación agrupada de dos secuencias.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Intersect&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Proporciona la intersección de conjuntos de dos secuencias paralelas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Intersect(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Intersect (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Este parámetro de tipo no se utiliza.</typeparam>
        <param name="first">Este parámetro no se utiliza.</param>
        <param name="second">Este parámetro no se utiliza.</param>
        <summary>Nunca se debería llamar a esta sobrecarga Intersect. Este método está marcado como obsoleto y, cuando se llama, siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Esta sobrecarga siempre produce una excepción <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga existe para denegar el uso de Intersect con un origen de datos izquierdo de tipo <xref:System.Linq.ParallelQuery%601> y un origen de datos derecho de tipo <xref:System.Collections.Generic.IEnumerable%601>. En caso contrario, el operador Intersect parecería que enlaza a la implementación paralela, pero en realidad enlazaría a la implementación secuencial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La excepción que se produce al llamar a este método.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Intersect(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Intersect (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
        <param name="first">Secuencia de la que se devolverán los diversos elementos que también aparecen en <paramref name="second" />.</param>
        <param name="second">Secuencia de la que se devolverán los diversos elementos que también aparecen en la primera secuencia.</param>
        <summary>Proporciona la intersección de conjunto de dos secuencias paralelas al emplear el comparador de igualdad predeterminado para comparar valores.</summary>
        <returns>Una secuencia que contiene los elementos que forman la intersección de conjuntos de dos secuencias.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Intersect(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Intersect (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Este parámetro de tipo no se utiliza.</typeparam>
        <param name="first">Este parámetro no se utiliza.</param>
        <param name="second">Este parámetro no se utiliza.</param>
        <param name="comparer">Este parámetro no se utiliza.</param>
        <summary>Nunca se debería llamar a esta sobrecarga Intersect. Este método está marcado como obsoleto y, cuando se llama, siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Esta sobrecarga siempre produce una excepción <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga existe para denegar el uso de Intersect con un origen de datos izquierdo de tipo <xref:System.Linq.ParallelQuery%601> y un origen de datos derecho de tipo <xref:System.Collections.Generic.IEnumerable%601>. En caso contrario, el operador Intersect parecería que enlaza a la implementación paralela, pero en realidad enlazaría a la implementación secuencial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La excepción que se produce al llamar a este método.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Intersect(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Intersect (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
        <param name="first">Secuencia de la que se devolverán los diversos elementos que también aparecen en <paramref name="second" />.</param>
        <param name="second">Secuencia de la que se devolverán los diversos elementos que también aparecen en la primera secuencia.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
        <summary>Proporciona la intersección de conjunto de dos secuencias paralelas al emplear el objeto IEqualityComparer{T} especificado para comparar valores.</summary>
        <returns>Una secuencia que contiene los elementos que forman la intersección de conjuntos de dos secuencias.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Correlaciona en paralelo los elementos de dos secuencias basándose en claves coincidentes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Join(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.ParallelQuery&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Este parámetro de tipo no se utiliza.</typeparam>
        <typeparam name="TInner">Este parámetro de tipo no se utiliza.</typeparam>
        <typeparam name="TKey">Este parámetro de tipo no se utiliza.</typeparam>
        <typeparam name="TResult">Este parámetro de tipo no se utiliza.</typeparam>
        <param name="outer">Este parámetro no se utiliza.</param>
        <param name="inner">Este parámetro no se utiliza.</param>
        <param name="outerKeySelector">Este parámetro no se utiliza.</param>
        <param name="innerKeySelector">Este parámetro no se utiliza.</param>
        <param name="resultSelector">Este parámetro no se utiliza.</param>
        <summary>Nunca se debería llamar a esta sobrecarga Join. Este método está marcado como obsoleto y, cuando se invoca, siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Esta sobrecarga siempre produce una excepción <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga existe para denegar el uso de Join con un origen de datos izquierdo de tipo <xref:System.Linq.ParallelQuery%601> y un origen de datos derecho de tipo <xref:System.Collections.Generic.IEnumerable%601>. En caso contrario, el operador de combinación parecería que enlaza a la implementación paralela, pero en realidad enlazaría a la implementación secuencial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As ParallelQuery(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Join(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Linq::ParallelQuery&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.ParallelQuery&lt;'Outer&gt; * System.Linq.ParallelQuery&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Tipo de los elementos de la primera secuencia.</typeparam>
        <typeparam name="TInner">Tipo de los elementos de la segunda secuencia.</typeparam>
        <typeparam name="TKey">Tipo de las claves devueltas por las funciones del selector de claves.</typeparam>
        <typeparam name="TResult">Tipo de los elementos del resultado.</typeparam>
        <param name="outer">Primera secuencia que se va a combinar.</param>
        <param name="inner">Secuencia que se va a combinar con la primera secuencia.</param>
        <param name="outerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la primera secuencia.</param>
        <param name="innerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la segunda secuencia.</param>
        <param name="resultSelector">Función que va a crear un elemento de resultado a partir de dos elementos coincidentes.</param>
        <summary>Correlaciona en paralelo los elementos de dos secuencias basándose en claves coincidentes. El comparador de igualdad predeterminado se usa para comparar claves.</summary>
        <returns>Secuencia que tiene elementos de tipo <paramref name="TResult" /> que se han obtenido al realizar una combinación interna de dos secuencias.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Join(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.ParallelQuery&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Este parámetro de tipo no se utiliza.</typeparam>
        <typeparam name="TInner">Este parámetro de tipo no se utiliza.</typeparam>
        <typeparam name="TKey">Este parámetro de tipo no se utiliza.</typeparam>
        <typeparam name="TResult">Este parámetro de tipo no se utiliza.</typeparam>
        <param name="outer">Este parámetro no se utiliza.</param>
        <param name="inner">Este parámetro no se utiliza.</param>
        <param name="outerKeySelector">Este parámetro no se utiliza.</param>
        <param name="innerKeySelector">Este parámetro no se utiliza.</param>
        <param name="resultSelector">Este parámetro no se utiliza.</param>
        <param name="comparer">Este parámetro no se utiliza.</param>
        <summary>Nunca se debería llamar a esta sobrecarga Join. Este método está marcado como obsoleto y, cuando se invoca, siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Esta sobrecarga siempre produce una excepción <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga existe para denegar el uso de combinación con un origen de datos izquierdo de tipo <xref:System.Linq.ParallelQuery%601> y un origen de datos derecho de tipo <xref:System.Collections.Generic.IEnumerable%601>. En caso contrario, el operador de combinación parecería que enlaza a la implementación paralela, pero en realidad enlazaría a la implementación secuencial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La excepción que se produce al llamar a este método.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As ParallelQuery(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Join(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Linq::ParallelQuery&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.ParallelQuery&lt;'Outer&gt; * System.Linq.ParallelQuery&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Tipo de los elementos de la primera secuencia.</typeparam>
        <typeparam name="TInner">Tipo de los elementos de la segunda secuencia.</typeparam>
        <typeparam name="TKey">Tipo de las claves devueltas por las funciones del selector de claves.</typeparam>
        <typeparam name="TResult">Tipo de los elementos del resultado.</typeparam>
        <param name="outer">Primera secuencia que se va a combinar.</param>
        <param name="inner">Secuencia que se va a combinar con la primera secuencia.</param>
        <param name="outerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la primera secuencia.</param>
        <param name="innerKeySelector">Función para extraer la clave de combinación a partir de cada elemento de la segunda secuencia.</param>
        <param name="resultSelector">Función que va a crear un elemento de resultado a partir de dos elementos coincidentes.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que va a aplicar un algoritmo hash y a comparar las claves.</param>
        <summary>Correlaciona en paralelo los elementos de dos secuencias basándose en claves coincidentes. Se usa un <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar claves.</summary>
        <returns>Secuencia que tiene elementos de tipo <paramref name="TResult" /> que se han obtenido al realizar una combinación interna de dos secuencias.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="action" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Last&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el último elemento de una secuencia paralela.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Last``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Last : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Last source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se va a devolver el último elemento.</param>
        <summary>Devuelve el último elemento de una secuencia paralela.</summary>
        <returns>El valor de la última posición de la secuencia de origen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la consulta no está ordenada, el último elemento es no determinista. Para más información, consulte cómo [conservar el orden en PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Last``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Last : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Last (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se va a devolver un elemento.</param>
        <param name="predicate">Función para probar cada elemento de una condición.</param>
        <summary>Devuelve el último elemento de una secuencia paralela que satisface una condición concreta.</summary>
        <returns>El último elemento de la secuencia que pasa la prueba de la función de predicado especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la consulta no está ordenada, el último elemento es no determinista. Para más información, consulte cómo [conservar el orden en PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException">Ningún elemento de <paramref name="source" /> satisface la condición de <paramref name="predicate" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el último elemento de una secuencia paralela o, si la secuencia no contiene elementos, un valor predeterminado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LastOrDefault``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.LastOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se va a devolver un elemento.</param>
        <summary>Devuelve el último elemento de una secuencia paralela o, si la secuencia no contiene elementos, un valor predeterminado.</summary>
        <returns>Es default() si la secuencia de salida está vacía; de lo contrario, el último elemento de la misma.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la consulta no está ordenada, el último elemento es no determinista. Para más información, consulte cómo [conservar el orden en PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LastOrDefault``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.LastOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se va a devolver un elemento.</param>
        <param name="predicate">Función para probar cada elemento de una condición.</param>
        <summary>Devuelve el último elemento de una secuencia paralela que satisface una condición o, si no se encuentra dicho elemento, un valor predeterminado.</summary>
        <returns>Es default() si la secuencia está vacía o si ningún elemento pasa la prueba de la función de predicado; en caso contrario, el último elemento que pasa dicha prueba.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la consulta no está ordenada, el último elemento es no determinista. Para más información, consulte cómo [conservar el orden en PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="LongCount&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor Int64 que representa el número total de elementos de una secuencia paralela.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LongCount``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As ParallelQuery(Of TSource)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LongCount : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.LongCount source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia que contiene los elementos que se van a contar.</param>
        <summary>Devuelve un valor Int64 que representa el número total de elementos de una secuencia paralela.</summary>
        <returns>El número de elementos de la secuencia de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">El número de elementos del origen es mayor que <see cref="F:System.Int64.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.OverflowException">El resultado calculado es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LongCount``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LongCount : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.LongCount (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia que contiene los elementos que se van a contar.</param>
        <param name="predicate">Función para probar cada elemento de una condición.</param>
        <summary>Devuelve un valor Int64 que representa el número de elementos de una secuencia paralela que satisfacen una condición.</summary>
        <returns>Un número que representa cuántos elementos de la secuencia especificada satisfacen la condición de la función de predicado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">El número de elementos del origen es mayor que <see cref="F:System.Int64.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.OverflowException">El resultado calculado es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Max">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el valor máximo de una secuencia paralela de valores.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Max(System::Linq::ParallelQuery&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <summary>Devuelve el valor máximo de una secuencia paralela de valores.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Max(System::Linq::ParallelQuery&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <summary>Devuelve el valor máximo de una secuencia paralela de valores.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Max(System::Linq::ParallelQuery&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <summary>Devuelve el valor máximo de una secuencia paralela de valores.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Max(System::Linq::ParallelQuery&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <summary>Devuelve el valor máximo de una secuencia paralela de valores.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Max(System::Linq::ParallelQuery&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <summary>Devuelve el valor máximo de una secuencia paralela de valores.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Max(System::Linq::ParallelQuery&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <summary>Devuelve el valor máximo de una secuencia paralela de valores.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Max(System::Linq::ParallelQuery&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <summary>Devuelve el valor máximo de una secuencia paralela de valores.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Max(System::Linq::ParallelQuery&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <summary>Devuelve el valor máximo de una secuencia paralela de valores.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Max(System::Linq::ParallelQuery&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <summary>Devuelve el valor máximo de una secuencia paralela de valores.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Max(System::Linq::ParallelQuery&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <summary>Devuelve el valor máximo de una secuencia paralela de valores.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de la secuencia de salida.</typeparam>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <summary>Devuelve el valor máximo de una secuencia paralela de valores.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor máximo.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor máximo.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor máximo.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor máximo.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor máximo.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor máximo.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor máximo.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor máximo.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor máximo.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor máximo.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; 'Result" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Tipo de valor devuelto por <paramref name="selector" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor máximo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor máximo.</summary>
        <returns>El valor máximo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Min">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el valor mínimo de una secuencia paralela de valores.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Min(System::Linq::ParallelQuery&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <summary>Devuelve el valor mínimo de una secuencia paralela de valores.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Min(System::Linq::ParallelQuery&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <summary>Devuelve el valor mínimo de una secuencia paralela de valores.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Min(System::Linq::ParallelQuery&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <summary>Devuelve el valor mínimo de una secuencia paralela de valores.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Min(System::Linq::ParallelQuery&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <summary>Devuelve el valor mínimo de una secuencia paralela de valores.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Min(System::Linq::ParallelQuery&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <summary>Devuelve el valor mínimo de una secuencia paralela de valores.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Min(System::Linq::ParallelQuery&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <summary>Devuelve el valor mínimo de una secuencia paralela de valores.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Min(System::Linq::ParallelQuery&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <summary>Devuelve el valor mínimo de una secuencia paralela de valores.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Min(System::Linq::ParallelQuery&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <summary>Devuelve el valor mínimo de una secuencia paralela de valores.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Min(System::Linq::ParallelQuery&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <summary>Devuelve el valor mínimo de una secuencia paralela de valores.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Min(System::Linq::ParallelQuery&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <summary>Devuelve el valor mínimo de una secuencia paralela de valores.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <summary>Devuelve el valor mínimo de una secuencia paralela de valores.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor mínimo.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor mínimo.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor mínimo.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor mínimo.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor mínimo.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor mínimo.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor mínimo.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor mínimo.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor mínimo.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor mínimo.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; 'Result" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Tipo de valor devuelto por <paramref name="selector" />.</typeparam>
        <param name="source">Secuencia de valores cuyo valor mínimo se va a determinar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Invoca en paralelo una función de transformación en cada elemento de una secuencia y devuelve el valor mínimo.</summary>
        <returns>El valor mínimo de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> no contiene ningún elemento y es un tipo de valor <paramref name="TSource" /> que no acepta valores null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Linq.ParallelQuery source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Linq.ParallelQuery source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OfType``1(System.Linq.ParallelQuery)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfType(Of TResult) (source As ParallelQuery) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ OfType(System::Linq::ParallelQuery ^ source);" />
      <MemberSignature Language="F#" Value="static member OfType : System.Linq.ParallelQuery -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.OfType source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">El tipo según el cual se van a filtrar los elementos de la secuencia.</typeparam>
        <param name="source">Secuencia cuyos elementos se van a filtrar.</param>
        <summary>Filtra los elementos de ParallelQuery en función de un tipo especificado.</summary>
        <returns>Secuencia que contiene los elementos de la secuencia de entrada de tipo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ordena paralelamente los elementos de una secuencia en orden ascendente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ OrderBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.OrderBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <param name="source">Secuencia de valores que se va a ordenar.</param>
        <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
        <summary>Ordena en paralelo en orden ascendente los elementos de una secuencia de acuerdo con una clave.</summary>
        <returns>OrderedParallelQuery{TSource} cuyos elementos se van a ordenar de acuerdo con una clave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la implementación secuencial, no es una ordenación estable. Para lograr una ordenación estable, cambiar una consulta del formulario: var ordenada = origen. Select((e,i) = > new {E = e, I = i}). OrderBy((v) = > v.e). ThenBy (v = > v.i). Select((v) = > v.e);  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="keySelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ OrderBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.OrderBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <param name="source">Secuencia de valores que se va a ordenar.</param>
        <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
        <param name="comparer">IComparer{TKey} para comparar claves.</param>
        <summary>Ordena en paralelo en orden ascendente los elementos de una secuencia mediante un comparador especificado.</summary>
        <returns>OrderedParallelQuery{TSource} cuyos elementos se van a ordenar de acuerdo con una clave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la implementación secuencial, no es una ordenación estable. Vea los comentarios sobre <xref:System.Linq.ParallelEnumerable.OrderBy%2A> para un enfoque para implementar una ordenación estable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="keySelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ordena de manera descendente los elementos de una secuencia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderByDescending``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ OrderByDescending(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.OrderByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <param name="source">Secuencia de valores que se va a ordenar.</param>
        <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
        <summary>Ordena en paralelo en orden descendente los elementos de una secuencia de acuerdo con una clave.</summary>
        <returns>OrderedParallelQuery{TSource} cuyos elementos se van a ordenar de forma descendente de acuerdo con una clave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la implementación secuencial, no es una ordenación estable. Vea los comentarios sobre <xref:System.Linq.ParallelEnumerable.OrderBy%2A> para un enfoque para implementar una ordenación estable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="keySelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderByDescending``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ OrderByDescending(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.OrderByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <param name="source">Secuencia de valores que se va a ordenar.</param>
        <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
        <param name="comparer">IComparer{TKey} para comparar claves.</param>
        <summary>Ordena de manera descendente los elementos de una secuencia utilizando un comparador especificado.</summary>
        <returns>OrderedParallelQuery{TSource} cuyos elementos se van a ordenar de forma descendente de acuerdo con una clave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la implementación secuencial, no es una ordenación estable. Vea los comentarios sobre <xref:System.Linq.ParallelEnumerable.OrderBy%2A> para un enfoque para implementar una ordenación estable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="KeySelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Range">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;int&gt; Range (int start, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;int32&gt; Range(int32 start, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Range(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Range (start As Integer, count As Integer) As ParallelQuery(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::ParallelQuery&lt;int&gt; ^ Range(int start, int count);" />
      <MemberSignature Language="F#" Value="static member Range : int * int -&gt; System.Linq.ParallelQuery&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Range (start, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Valor del primer entero de la secuencia.</param>
        <param name="count">Número de enteros secuenciales que se van a generar.</param>
        <summary>Genera una secuencia paralela de números enteros en un intervalo especificado.</summary>
        <returns>IEnumerable&lt;Int32&gt; en C# o IEnumerable(Of Int32) en Visual Basic que contiene un intervalo de números enteros secuenciales.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es menor que 0 -o bien- <paramref name="start" /> + <paramref name="count" /> - 1 es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Repeat&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Repeat&lt;TResult&gt; (TResult element, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Repeat&lt;TResult&gt;(!!TResult element, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Repeat``1(``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Repeat(Of TResult) (element As TResult, count As Integer) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Repeat(TResult element, int count);" />
      <MemberSignature Language="F#" Value="static member Repeat : 'Result * int -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Repeat (element, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="TResult" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">El tipo de valor que se va a repetir en la secuencia de resultado.</typeparam>
        <param name="element">El valor que se va a repetir.</param>
        <param name="count">El número de veces que se va a repetir el valor en la secuencia generada.</param>
        <summary>Genera una secuencia paralela que contiene un valor repetido.</summary>
        <returns>Secuencia que contiene un valor repetido.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es menor que 0.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Reverse``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reverse(Of TSource) (source As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Reverse(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Reverse : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Reverse source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores que se va a invertir.</param>
        <summary>Invierte el orden de los elementos de una secuencia paralela.</summary>
        <returns>Una secuencia cuyos elementos se corresponden en orden inverso con los de la secuencia de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Proyecta en paralelo cada elemento de una secuencia en un nuevo formulario.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Select``2(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Select(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Tipo de elementos devueltos por el selector.</typeparam>
        <param name="source">Secuencia de valores sobre la que se va a invocar una función de transformación.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Proyecta en paralelo cada elemento de una secuencia en un nuevo formulario mediante la incorporación del índice del elemento.</summary>
        <returns>Secuencia cuyos elementos son el resultado de invocar la función de transformación en cada elemento de <paramref name="source" />, en función del índice suministrado a <paramref name="selector" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.OverflowException">La consulta enumera más de <see cref="F:System.Int32.MaxValue" /> elementos. Esta situación puede darse en escenarios de streaming.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Select``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Select(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Tipo de elementos devueltos por el selector.</typeparam>
        <param name="source">Secuencia de valores sobre la que se va a invocar una función de transformación.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Proyecta en paralelo cada elemento de una secuencia en un nuevo formulario.</summary>
        <returns>Secuencia cuyos elementos son el resultado de invocar la función de transformación en cada elemento de <paramref name="source" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectMany&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Proyecta en paralelo cada elemento de una secuencia en un <see cref="T:System.Collections.Generic.IEnumerable`1" /> y reduce las secuencias resultantes en una secuencia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``2(System.Linq.ParallelQuery{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, IEnumerable(Of TResult))) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ SelectMany(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, seq&lt;'Result&gt;&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Tipo de los elementos de la secuencia devueltos por el selector.</typeparam>
        <param name="source">Secuencia de valores que se va a proyectar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Proyecta en paralelo cada elemento de una secuencia en un <see cref="T:System.Collections.Generic.IEnumerable`1" /> y reduce las secuencias resultantes en una secuencia.</summary>
        <returns>Secuencia cuyos elementos son el resultado de invocar la función de transformación uno a varios en cada elemento de la secuencia de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``2(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer, IEnumerable(Of TResult))) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ SelectMany(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, seq&lt;'Result&gt;&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Tipo de los elementos de la secuencia devueltos por el selector.</typeparam>
        <param name="source">Secuencia de valores que se va a proyectar.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Proyecta en paralelo cada elemento de una secuencia en un <see cref="T:System.Collections.Generic.IEnumerable`1" /> y reduce las secuencias resultantes en una secuencia. El índice de cada elemento de origen se utiliza en el formulario proyectado de ese elemento.</summary>
        <returns>Secuencia cuyos elementos son el resultado de invocar la función de transformación uno a varios en cada elemento de la secuencia de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.OverflowException">La consulta enumera más de <see cref="F:System.Int32.MaxValue" /> elementos.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``3(System.Linq.ParallelQuery{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As ParallelQuery(Of TSource), collectionSelector As Func(Of TSource, IEnumerable(Of TCollection)), resultSelector As Func(Of TSource, TCollection, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ SelectMany(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^ collectionSelector, Func&lt;TSource, TCollection, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, seq&lt;'Collection&gt;&gt; * Func&lt;'Source, 'Collection, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos intermedios recopilados por <paramref name="collectionSelector" />.</typeparam>
        <typeparam name="TCollection">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Tipo de elementos de la secuencia de resultados.</typeparam>
        <param name="source">Secuencia de valores que se va a proyectar.</param>
        <param name="collectionSelector">Función de transformación que se va a aplicar a cada elemento de origen; el segundo parámetro de la función representa el índice del elemento de origen.</param>
        <param name="resultSelector">Función para crear un elemento de resultado a partir de un elemento de la primera secuencia y una colección de elementos coincidentes de la segunda.</param>
        <summary>Proyecta cada elemento de una secuencia en <see cref="T:System.Collections.Generic.IEnumerable`1" />, reduce las secuencias resultantes en una única secuencia e invoca una función del selector de resultados en cada elemento.</summary>
        <returns>Secuencia cuyos elementos son el resultado de invocar la función de transformación uno a varios <paramref name="collectionSelector" /> en cada elemento de <paramref name="source" /> sobre la base del índice suministrado a <paramref name="collectionSelector" /> y de asignar entonces cada uno de esos elementos de la secuencia y sus elementos de origen correspondientes a un elemento de resultado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.OverflowException">La consulta enumera más de <see cref="F:System.Int32.MaxValue" /> elementos.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``3(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As ParallelQuery(Of TSource), collectionSelector As Func(Of TSource, Integer, IEnumerable(Of TCollection)), resultSelector As Func(Of TSource, TCollection, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ SelectMany(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^ collectionSelector, Func&lt;TSource, TCollection, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, seq&lt;'Collection&gt;&gt; * Func&lt;'Source, 'Collection, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos intermedios recopilados por <paramref name="collectionSelector" />.</typeparam>
        <typeparam name="TCollection">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Tipo de elementos que se van a devolver.</typeparam>
        <param name="source">Secuencia de valores que se va a proyectar.</param>
        <param name="collectionSelector">Función de transformación que se va a aplicar a cada elemento de origen; el segundo parámetro de la función representa el índice del elemento de origen.</param>
        <param name="resultSelector">Función para crear un elemento de resultado a partir de un elemento de la primera secuencia y una colección de elementos coincidentes de la segunda.</param>
        <summary>Proyecta cada elemento de una secuencia en <see cref="T:System.Collections.Generic.IEnumerable`1" />, reduce las secuencias resultantes en una única secuencia e invoca una función del selector de resultados en cada elemento. El índice de cada elemento de origen se utiliza en el formulario proyectado intermedio de ese elemento.</summary>
        <returns>Secuencia cuyos elementos son el resultado de invocar la función de transformación uno a varios <paramref name="collectionSelector" /> en cada elemento de <paramref name="source" /> sobre la base del índice suministrado a <paramref name="collectionSelector" /> y de asignar entonces cada uno de esos elementos de la secuencia y sus elementos de origen correspondientes a un elemento de resultado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.OverflowException">La consulta enumera más de <see cref="F:System.Int32.MaxValue" /> elementos.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SequenceEqual&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si dos secuencias paralelas son iguales; para ello, se comparan sus elementos mediante el comparador de igualdad para su tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.SequenceEqual (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Este parámetro de tipo no se utiliza.</typeparam>
        <param name="first">Este parámetro no se utiliza.</param>
        <param name="second">Este parámetro no se utiliza.</param>
        <summary>Nunca se debería llamar a esta sobrecarga SequenceEqual. Este método está marcado como obsoleto y, cuando se llama, siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Esta sobrecarga siempre produce una excepción <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga existe para denegar el uso de SequenceEqual con un origen de datos izquierdo de tipo <xref:System.Linq.ParallelQuery%601> y un origen de datos derecho de tipo <xref:System.Collections.Generic.IEnumerable%601>. En caso contrario, el operador SequenceEqual parecería que enlaza a la implementación paralela, pero en realidad enlazaría a la implementación secuencial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Se produce cada vez que se llama a este método.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.SequenceEqual (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
        <param name="first">Secuencia que se va a comparar con la segunda.</param>
        <param name="second">Secuencia que se va a comparar con la primera secuencia de entrada.</param>
        <summary>Determina si dos secuencias paralelas son iguales al comparar los elementos mediante el comparador de igualdad predeterminado para su tipo.</summary>
        <returns>Es true si las dos secuencias de salida tienen la misma longitud y sus elementos correspondientes son iguales según el comparador de igualdad predeterminado para su tipo; de lo contrario, es false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> o <paramref name="second" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.SequenceEqual (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Este parámetro de tipo no se utiliza.</typeparam>
        <param name="first">Este parámetro no se utiliza.</param>
        <param name="second">Este parámetro no se utiliza.</param>
        <param name="comparer">Este parámetro no se utiliza.</param>
        <summary>Nunca se debería llamar a esta sobrecarga SequenceEqual. Este método está marcado como obsoleto y, cuando se llama, siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Esta sobrecarga siempre produce una excepción <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga existe para denegar el uso de SequenceEqual con un origen de datos izquierdo de tipo <xref:System.Linq.ParallelQuery%601> y un origen de datos derecho de tipo <xref:System.Collections.Generic.IEnumerable%601>. En caso contrario, el operador SequenceEqual parecería que enlaza a la implementación paralela, pero en realidad enlazaría a la implementación secuencial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Se produce cada vez que se llama a este método.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource), comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.SequenceEqual (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
        <param name="first">Secuencia que se va a comparar con <paramref name="second" />.</param>
        <param name="second">Secuencia que se va a comparar con la primera secuencia de entrada.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a utilizar para comparar elementos.</param>
        <summary>Determina si dos secuencias paralelas son iguales al comparar sus elementos mediante un objeto IEqualityComparer{T} especificado.</summary>
        <returns>Es true si las dos secuencias de salida tienen la misma longitud y sus elementos correspondientes son iguales según el comparador de igualdad predeterminado para su tipo; de lo contrario, es false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> o <paramref name="second" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Single&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el único elemento de una secuencia paralela y, si no hay exactamente un elemento en la secuencia, produce una excepción.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Single``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Single : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Single source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se va a devolver el único elemento.</param>
        <summary>Devuelve el único elemento de una secuencia paralela y, si no hay exactamente un elemento en la secuencia, produce una excepción.</summary>
        <returns>El único elemento de la secuencia de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException">La secuencia de entrada contiene más de un elemento. -o bien- la secuencia de entrada está vacía.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Single``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Single : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Single (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se va a devolver el único elemento.</param>
        <param name="predicate">Función que va a probar si un elemento satisface una condición.</param>
        <summary>Devuelve el único elemento de una secuencia paralela que satisface una condición especificada y, si existe más de un elemento semejante, produce una excepción.</summary>
        <returns>El único elemento de la secuencia de entrada que satisface una condición.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException">Ningún elemento satisface la condición de <paramref name="predicate" />. - o bien - Más de un elemento satisface la condición de <paramref name="predicate" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SingleOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el único elemento de una secuencia paralela o, si la secuencia está vacía, un valor predeterminado; este método produce una excepción si hay más de un elemento en la secuencia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SingleOrDefault``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.SingleOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se va a devolver el único elemento.</param>
        <summary>Devuelve el único elemento de una secuencia paralela o, si la secuencia está vacía, un valor predeterminado; este método produce una excepción si hay más de un elemento en la secuencia.</summary>
        <returns>Único elemento de la secuencia de entrada o default() si la secuencia no contiene ningún elemento.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> tiene más de un elemento.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SingleOrDefault``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.SingleOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de la que se va a devolver el único elemento.</param>
        <param name="predicate">Función que va a probar si un elemento satisface una condición.</param>
        <summary>Devuelve el único elemento de una secuencia paralela que satisface una condición especificada o, si ese elemento no existe, un valor predeterminado; este método produce una excepción si hay varios elementos que satisfacen la condición.</summary>
        <returns>Único elemento de la secuencia de entrada que satisface la condición o default() si no se encuentra dicho elemento.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> está vacío o se devuelven varios elementos.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Skip``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip(Of TSource) (source As ParallelQuery(Of TSource), count As Integer) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Skip(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Skip : System.Linq.ParallelQuery&lt;'Source&gt; * int -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Skip (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia cuyos elementos se van a devolver.</param>
        <param name="count">Número de elementos que se van a omitir antes de devolver los elementos restantes.</param>
        <summary>Omite un número especificado de elementos de una secuencia paralela y, a continuación, devuelve los elementos restantes.</summary>
        <returns>Secuencia que contiene los elementos que hay después del índice especificado en la secuencia de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si count > origen. Count (), se devuelve ningún elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.OverflowException">El recuento es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Omite los elementos de una secuencia paralela siempre que el valor de una condición especificada sea true y, a continuación, devuelve los elementos restantes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SkipWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ SkipWhile(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia cuyos elementos se van a devolver.</param>
        <param name="predicate">Función para probar cada elemento de una condición.</param>
        <summary>Omite los elementos de una secuencia paralela siempre que el valor de una condición especificada sea true y, a continuación, devuelve los elementos restantes.</summary>
        <returns>Secuencia que contiene los elementos de la secuencia de entrada a partir del primer elemento de la serie lineal que no pasa la prueba especificada por el predicado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SkipWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ SkipWhile(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia cuyos elementos se van a devolver.</param>
        <param name="predicate">Función que va a probar cada elemento de origen para determinar si satisface una condición; el segundo parámetro de la función representa el índice del elemento de origen.</param>
        <summary>Omite los elementos de una secuencia paralela siempre que el valor de una condición especificada sea true y, a continuación, devuelve los elementos restantes. El índice del elemento se usa en la lógica de la función de predicado.</summary>
        <returns>Secuencia que contiene los elementos de la secuencia de entrada a partir del primer elemento de la serie lineal que no pasa la prueba especificada por el predicado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.OverflowException">La consulta enumera más de <see cref="F:System.Int32.MaxValue" /> elementos.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sum">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcula en paralelo la suma de una secuencia de valores.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Linq::ParallelQuery&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <summary>Calcula en paralelo la suma de una secuencia de valores.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Decimal.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Linq::ParallelQuery&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <summary>Calcula en paralelo la suma de una secuencia de valores.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Double.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Linq::ParallelQuery&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <summary>Calcula en paralelo la suma de una secuencia de valores.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Int32.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Linq::ParallelQuery&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <summary>Calcula en paralelo la suma de una secuencia de valores.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Int64.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Linq::ParallelQuery&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <summary>Calcula en paralelo la suma de una secuencia de valores.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Decimal.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Linq::ParallelQuery&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <summary>Calcula en paralelo la suma de una secuencia de valores.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Double.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Linq::ParallelQuery&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <summary>Calcula en paralelo la suma de una secuencia de valores.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Int32.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Linq::ParallelQuery&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <summary>Calcula en paralelo la suma de una secuencia de valores.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Int64.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Linq::ParallelQuery&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <summary>Calcula en paralelo la suma de una secuencia de valores.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Single.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Linq::ParallelQuery&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <summary>Calcula en paralelo la suma de una secuencia de valores.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Single.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo la suma de la secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Decimal.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo la suma de la secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Double.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de la secuencia de salida.</typeparam>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo la suma de la secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Int32.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo la suma de la secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Int64.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo la suma de la secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Decimal.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo la suma de la secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Double.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo la suma de la secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Int32.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo la suma de la secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Int64.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo la suma de la secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Single.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia de valores cuya suma se va a calcular.</param>
        <param name="selector">Función de transformación que se va a aplicar a cada elemento.</param>
        <summary>Calcula en paralelo la suma de la secuencia de valores que se obtienen mediante la invocación de una función de transformación en cada elemento de la secuencia de entrada.</summary>
        <returns>Suma de los valores proyectados de la secuencia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="selector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">La suma es mayor que <see cref="F:System.Single.MaxValue" />. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Take&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Take``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Take(Of TSource) (source As ParallelQuery(Of TSource), count As Integer) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Take(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Take : System.Linq.ParallelQuery&lt;'Source&gt; * int -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Take (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia cuyos elementos se van a devolver.</param>
        <param name="count">Número de elementos que se van a devolver.</param>
        <summary>Devuelve un número especificado de elementos contiguos desde el principio de una secuencia paralela.</summary>
        <returns>Secuencia que contiene el número especificado de elementos desde el principio de la secuencia de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve elementos de una secuencia paralela siempre que el valor de una condición especificada sea true.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.TakeWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ TakeWhile(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia cuyos elementos se van a devolver.</param>
        <param name="predicate">Función para probar cada elemento de una condición.</param>
        <summary>Devuelve elementos de una secuencia paralela siempre que el valor de una condición especificada sea true.</summary>
        <returns>Secuencia que contiene los elementos de la secuencia de entrada que se encuentran antes del elemento que no pasa la prueba.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.TakeWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ TakeWhile(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia cuyos elementos se van a devolver.</param>
        <param name="predicate">Función que va a probar cada elemento de origen para determinar si satisface una condición; el segundo parámetro de la función representa el índice del elemento de origen.</param>
        <summary>Devuelve elementos de una secuencia paralela siempre que el valor de una condición especificada sea true. El índice del elemento se usa en la lógica de la función de predicado.</summary>
        <returns>Secuencia que contiene elementos de la secuencia de entrada que se encuentran antes del elemento que no pasa la prueba.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.OverflowException">Esta consulta enumera más de <see cref="F:System.Int32.MaxValue" /> elementos.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Realiza una ordenación posterior en paralelo de los elementos de una secuencia en orden ascendente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenBy``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As OrderedParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ ThenBy(System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.OrderedParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.ThenBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <param name="source">OrderedParallelQuery{TSource} que contiene los elementos que se van a ordenar.</param>
        <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
        <summary>Realiza en paralelo una ordenación subsiguiente de los elementos de una secuencia en orden ascendente de acuerdo con una clave.</summary>
        <returns>OrderedParallelQuery{TSource} cuyos elementos se van a ordenar de acuerdo con una clave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la implementación secuencial, no es una ordenación estable. Vea los comentarios sobre <xref:System.Linq.ParallelEnumerable.OrderBy%2A> para un enfoque para implementar una ordenación estable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="keySelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenBy``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As OrderedParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ ThenBy(System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.OrderedParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.ThenBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <param name="source">OrderedParallelQuery{TSource} que contiene los elementos que se van a ordenar.</param>
        <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
        <param name="comparer">IComparer{TKey} para comparar claves.</param>
        <summary>Realiza en paralelo una ordenación subsiguiente de los elementos de una secuencia en orden ascendente mediante un comparador especificado.</summary>
        <returns>OrderedParallelQuery{TSource} cuyos elementos se van a ordenar de acuerdo con una clave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la implementación secuencial, no es una ordenación estable. Vea los comentarios sobre <xref:System.Linq.ParallelEnumerable.OrderBy%2A> para un enfoque para implementar una ordenación estable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="keySelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Realiza una ordenación posterior en paralelo de los elementos de una secuencia en orden descendente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenByDescending``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As OrderedParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ ThenByDescending(System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.OrderedParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.ThenByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <param name="source">OrderedParallelQuery{TSource} que contiene los elementos que se van a ordenar.</param>
        <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
        <summary>Realiza en paralelo una ordenación subsiguiente de los elementos de una secuencia en orden descendente de acuerdo con una clave.</summary>
        <returns>Secuencia cuyos elementos se ordenan de manera descendente según una clave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la implementación secuencial, no es una ordenación estable. Vea los comentarios sobre <xref:System.Linq.ParallelEnumerable.OrderBy%2A> para un enfoque para implementar una ordenación estable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="keySelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenByDescending``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As OrderedParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ ThenByDescending(System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.OrderedParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.ThenByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <param name="source">OrderedParallelQuery{TSource} que contiene los elementos que se van a ordenar.</param>
        <param name="keySelector">Función para extraer una clave a partir de un elemento.</param>
        <param name="comparer">IComparer{TKey} para comparar claves.</param>
        <summary>Realiza en paralelo una ordenación subsiguiente de los elementos de una secuencia en orden descendente mediante un comparador especificado.</summary>
        <returns>Secuencia cuyos elementos se ordenan de manera descendente según una clave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la implementación secuencial, no es una ordenación estable. Vea los comentarios sobre <xref:System.Linq.ParallelEnumerable.OrderBy%2A> para un enfoque para implementar una ordenación estable.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="keySelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToArray&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource[] ToArray&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource[] ToArray&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToArray``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToArray(Of TSource) (source As ParallelQuery(Of TSource)) As TSource()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static cli::array &lt;TSource&gt; ^ ToArray(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToArray : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source[]" Usage="System.Linq.ParallelEnumerable.ToArray source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia a partir de la que se va a crear una matriz.</param>
        <summary>Crea una matriz a partir de un <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
        <returns>Una matriz que contiene los elementos de la secuencia de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un <see cref="T:System.Collections.Generic.Dictionary`2" /> a partir de un <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As Dictionary(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TSource&gt; ^ ToDictionary(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Source&gt;" Usage="System.Linq.ParallelEnumerable.ToDictionary (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <param name="source">Secuencia a partir de la que se va a crear un <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
        <summary>Crea un <see cref="T:System.Collections.Generic.Dictionary`2" /> a partir de un <see cref="T:System.Linq.ParallelQuery`1" /> según una función del selector de claves especificada.</summary>
        <returns><see cref="T:System.Collections.Generic.Dictionary`2" /> que contiene claves y valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="keySelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException"><paramref name="keySelector" /> produce una clave que es una referencia nula (Nothing en Visual Basic). -o bien- <paramref name="keySelector" /> genera claves duplicadas para dos elementos. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As Dictionary(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TSource&gt; ^ ToDictionary(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Source&gt;" Usage="System.Linq.ParallelEnumerable.ToDictionary (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <param name="source">Secuencia a partir de la que se va a crear un <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
        <summary>Crea un objeto <see cref="T:System.Collections.Generic.Dictionary`2" /> a partir de un objeto <see cref="T:System.Linq.ParallelQuery`1" /> según una función del selector de claves y el comparador de claves especificados.</summary>
        <returns><see cref="T:System.Collections.Generic.Dictionary`2" /> que contiene claves y valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="keySelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException"><paramref name="keySelector" /> produce una clave que es una referencia nula (Nothing en Visual Basic). -o bien- <paramref name="keySelector" /> genera claves duplicadas para dos elementos. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As Dictionary(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TElement&gt; ^ ToDictionary(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Element&gt;" Usage="System.Linq.ParallelEnumerable.ToDictionary (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Tipo de valor devuelto por <paramref name="elementSelector" />.</typeparam>
        <param name="source">Secuencia a partir de la que se va a crear un <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
        <param name="elementSelector">Función de transformación que va a generar un valor de elemento de resultado a partir de cada elemento.</param>
        <summary>Crea un <see cref="T:System.Collections.Generic.Dictionary`2" /> a partir de un <see cref="T:System.Linq.ParallelQuery`1" /> según el selector de claves y las funciones del selector de elementos especificados.</summary>
        <returns><see cref="T:System.Collections.Generic.Dictionary`2" /> que contiene valores de tipo <paramref name="TElement" /> seleccionados en la secuencia de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException"><paramref name="keySelector" /> produce una clave que es una referencia nula (Nothing en Visual Basic). -o bien- <paramref name="keySelector" /> genera claves duplicadas para dos elementos. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As Dictionary(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TElement&gt; ^ ToDictionary(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Element&gt;" Usage="System.Linq.ParallelEnumerable.ToDictionary (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Tipo de valor devuelto por <paramref name="elementSelector" />.</typeparam>
        <param name="source">Secuencia a partir de la que se va a crear un <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
        <param name="elementSelector">Función de transformación que va a generar un valor de elemento de resultado a partir de cada elemento.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
        <summary>Crea un <see cref="T:System.Collections.Generic.Dictionary`2" /> a partir de un <see cref="T:System.Linq.ParallelQuery`1" /> según una función del selector de claves, un comparador y una función del selector de elementos especificados.</summary>
        <returns><see cref="T:System.Collections.Generic.Dictionary`2" /> que contiene valores de tipo <paramref name="TElement" /> seleccionados en la secuencia de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException"><paramref name="keySelector" /> produce una clave que es una referencia nula (Nothing en Visual Basic). -o bien- <paramref name="keySelector" /> genera claves duplicadas para dos elementos. - o bien- Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.List&lt;TSource&gt; ToList&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.List`1&lt;!!TSource&gt; ToList&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToList``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToList(Of TSource) (source As ParallelQuery(Of TSource)) As List(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::List&lt;TSource&gt; ^ ToList(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToList : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Collections.Generic.List&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.ToList source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Secuencia a partir de la que se va a crear un <see cref="T:System.Collections.Generic.List`1" />.</param>
        <summary>Crea un <see cref="T:System.Collections.Generic.List`1" /> a partir de un <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
        <returns><see cref="T:System.Collections.Generic.List`1" /> que contiene los elementos de la secuencia de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLookup&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un <see cref="T:System.Linq.ILookup`2" /> a partir de un <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As ILookup(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TSource&gt; ^ ToLookup(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ToLookup : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Source&gt;" Usage="System.Linq.ParallelEnumerable.ToLookup (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <param name="source">Secuencia a partir de la que se va a crear un <see cref="T:System.Linq.ILookup`2" />.</param>
        <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
        <summary>Crea un <see cref="T:System.Linq.ILookup`2" /> a partir de un <see cref="T:System.Linq.ParallelQuery`1" /> según una función del selector de claves especificada.</summary>
        <returns><see cref="T:System.Linq.ILookup`2" /> que contiene claves y valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="keySelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As ILookup(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TSource&gt; ^ ToLookup(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToLookup : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Source&gt;" Usage="System.Linq.ParallelEnumerable.ToLookup (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <param name="source">Secuencia a partir de la que se va a crear un <see cref="T:System.Linq.ILookup`2" />.</param>
        <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
        <summary>Crea un <see cref="T:System.Linq.ILookup`2" /> a partir de un <see cref="T:System.Linq.ParallelQuery`1" /> según una función del selector de claves y el comparador de claves especificados.</summary>
        <returns><see cref="T:System.Linq.ILookup`2" /> que contiene claves y valores.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="keySelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As ILookup(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TElement&gt; ^ ToLookup(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member ToLookup : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Element&gt;" Usage="System.Linq.ParallelEnumerable.ToLookup (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Tipo de valor devuelto por <paramref name="elementSelector" />.</typeparam>
        <param name="source">Secuencia a partir de la que se va a crear un <see cref="T:System.Linq.ILookup`2" />.</param>
        <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
        <param name="elementSelector">Función de transformación que va a generar un valor de elemento de resultado a partir de cada elemento.</param>
        <summary>Crea un <see cref="T:System.Linq.ILookup`2" /> a partir de un <see cref="T:System.Linq.ParallelQuery`1" /> según el selector de claves y las funciones del selector de elementos especificados.</summary>
        <returns><see cref="T:System.Linq.ILookup`2" /> que contiene valores de tipo <paramref name="TElement" /> seleccionados en la secuencia de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As ILookup(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TElement&gt; ^ ToLookup(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToLookup : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Element&gt;" Usage="System.Linq.ParallelEnumerable.ToLookup (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Tipo de la clave devuelta por <paramref name="keySelector" />.</typeparam>
        <typeparam name="TElement">Tipo de valor devuelto por <paramref name="elementSelector" />.</typeparam>
        <param name="source">Secuencia a partir de la que se va a crear un <see cref="T:System.Linq.ILookup`2" />.</param>
        <param name="keySelector">Función para extraer una clave a partir de cada elemento.</param>
        <param name="elementSelector">Función de transformación que va a generar un valor de elemento de resultado a partir de cada elemento.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar claves.</param>
        <summary>Crea un <see cref="T:System.Linq.ILookup`2" /> a partir de un <see cref="T:System.Linq.ParallelQuery`1" /> según una función del selector de claves, un comparador y una función del selector de elementos especificados.</summary>
        <returns>A Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) que contiene valores de tipo TElement seleccionados en la secuencia de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="keySelector" /> o <paramref name="elementSelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Union&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Proporciona la unión de conjuntos de dos secuencias paralelas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Union(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Union (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Este parámetro de tipo no se utiliza.</typeparam>
        <param name="first">Este parámetro no se utiliza.</param>
        <param name="second">Este parámetro no se utiliza.</param>
        <summary>Nunca se debería llamar a esta sobrecarga Union. Este método está marcado como obsoleto y, cuando se llama, siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Esta sobrecarga siempre produce una excepción <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga existe para denegar el uso de unión con un origen de datos izquierdo de tipo <xref:System.Linq.ParallelQuery%601> y un origen de datos derecho de tipo <xref:System.Collections.Generic.IEnumerable%601>. En caso contrario, el operador Union parecería que enlaza a la implementación paralela, pero en realidad enlazaría a la implementación secuencial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La excepción que se produce al llamar a este método.</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Union(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Union (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
        <param name="first">Secuencia cuyos diversos elementos forman el primer conjunto de la unión.</param>
        <param name="second">Secuencia cuyos diversos elementos forman el segundo conjunto de la unión.</param>
        <summary>Proporciona la unión de conjunto de dos secuencias paralelas mediante el comparador de igualdad predeterminado.</summary>
        <returns>Secuencia que contiene los elementos de las dos secuencias de entrada, excepto los duplicados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> o <paramref name="second" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Union(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Union (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Este parámetro de tipo no se utiliza.</typeparam>
        <param name="first">Este parámetro no se utiliza.</param>
        <param name="second">Este parámetro no se utiliza.</param>
        <param name="comparer">Este parámetro no se utiliza.</param>
        <summary>Nunca se debería llamar a esta sobrecarga Union. Este método está marcado como obsoleto y, cuando se llama, siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Esta sobrecarga siempre produce una excepción <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga existe para denegar el uso de unión con un origen de datos izquierdo de tipo <xref:System.Linq.ParallelQuery%601> y un origen de datos derecho de tipo <xref:System.Collections.Generic.IEnumerable%601>. En caso contrario, el operador Union parecería que enlaza a la implementación paralela, pero en realidad enlazaría a la implementación secuencial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La excepción que se produce al llamar a este método.</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Union(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Union (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de las secuencias de entrada.</typeparam>
        <param name="first">Secuencia cuyos diversos elementos forman el primer conjunto de la unión.</param>
        <param name="second">Secuencia cuyos diversos elementos forman el segundo conjunto de la unión.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
        <summary>Proporciona la unión de conjunto de dos secuencias paralelas mediante un objeto IEqualityComparer{T} especificado.</summary>
        <returns>Secuencia que contiene los elementos de las dos secuencias de entrada, excepto los duplicados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> o <paramref name="second" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Where&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Filtra en paralelo una secuencia de valores en función de un predicado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Where``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Where(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de origen.</typeparam>
        <param name="source">Secuencia que se va a filtrar.</param>
        <param name="predicate">Función para probar cada elemento de una condición.</param>
        <summary>Filtra en paralelo una secuencia de valores en función de un predicado.</summary>
        <returns>Secuencia que contiene elementos de la secuencia de entrada que satisfacen la condición.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Where``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Where(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de origen.</typeparam>
        <param name="source">Secuencia que se va a filtrar.</param>
        <param name="predicate">Función para probar cada elemento de una condición.</param>
        <summary>Filtra en paralelo una secuencia de valores en función de un predicado. El índice de cada elemento se usa en la lógica de la función de predicado.</summary>
        <returns>Secuencia que contiene elementos de la secuencia de entrada que satisfacen la condición.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> o <paramref name="predicate" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.OverflowException">La consulta enumera más de <see cref="F:System.Int32.MaxValue" /> elementos.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="WithCancellation&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithCancellation&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithCancellation&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithCancellation``1(System.Linq.ParallelQuery{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ WithCancellation(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WithCancellation : System.Linq.ParallelQuery&lt;'Source&gt; * System.Threading.CancellationToken -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.WithCancellation (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">ParallelQuery en la que se va a establecer la opción.</param>
        <param name="cancellationToken">Token de cancelación.</param>
        <summary>Establece el <see cref="T:System.Threading.CancellationToken" /> que se va a asociar a la consulta.</summary>
        <returns>ParallelQuery que representa la misma consulta como origen, pero con el token de cancelación registrado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado al <paramref name="cancellationToken" /> se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="WithCancellation" /> se usa varias veces en la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/80b14640-edfa-4153-be1b-3e003d3e9c1a">Cómo: Cancelar una consulta PLINQ</related>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Cancelación</related>
      </Docs>
    </Member>
    <Member MemberName="WithDegreeOfParallelism&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithDegreeOfParallelism&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int degreeOfParallelism);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithDegreeOfParallelism&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 degreeOfParallelism) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithDegreeOfParallelism``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithDegreeOfParallelism(Of TSource) (source As ParallelQuery(Of TSource), degreeOfParallelism As Integer) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ WithDegreeOfParallelism(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, int degreeOfParallelism);" />
      <MemberSignature Language="F#" Value="static member WithDegreeOfParallelism : System.Linq.ParallelQuery&lt;'Source&gt; * int -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.WithDegreeOfParallelism (source, degreeOfParallelism)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="degreeOfParallelism" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">ParallelQuery en la que se va a establecer el límite de grados de paralelismo.</param>
        <param name="degreeOfParallelism">Grado de paralelismo de la consulta. El valor predeterminado es Math.Min(<see cref="P:System.Environment.ProcessorCount" />, <see langword="MAX_SUPPORTED_DOP" />) donde <see langword="MAX_SUPPORTED_DOP" /> es 512.</param>
        <summary>Establece el grado de paralelismo que se va a emplear en una consulta. El grado de paralelismo es el número máximo de tareas ejecutándose de forma simultánea que se utilizará para procesar la consulta.</summary>
        <returns>ParallelQuery que representa la misma consulta como origen, con el límite de los grados de paralelismo establecidos.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="degreeOfParallelism" /> es menor que 1 o mayor que 511.</exception>
        <exception cref="T:System.InvalidOperationException">WithDegreeOfParallelism se utiliza varias veces en la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="WithExecutionMode&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithExecutionMode&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Linq.ParallelExecutionMode executionMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithExecutionMode&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, valuetype System.Linq.ParallelExecutionMode executionMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithExecutionMode``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelExecutionMode)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithExecutionMode(Of TSource) (source As ParallelQuery(Of TSource), executionMode As ParallelExecutionMode) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ WithExecutionMode(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, System::Linq::ParallelExecutionMode executionMode);" />
      <MemberSignature Language="F#" Value="static member WithExecutionMode : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelExecutionMode -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.WithExecutionMode (source, executionMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="executionMode" Type="System.Linq.ParallelExecutionMode" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">ParallelQuery en la que se va a establecer la opción.</param>
        <param name="executionMode">Modo en el que se va a ejecutar la consulta.</param>
        <summary>Establece el modo de ejecución de la consulta.</summary>
        <returns>ParallelQuery que representa la misma consulta como origen, pero con el modo de ejecución registrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El modo de ejecución especifica si PLINQ intentará revertir a la ejecución secuencial si detecta ciertas formas de consulta. Para obtener más información y ejemplos, vea [Cómo: especificar el modo de ejecución en PLINQ](~/docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="executionMode" /> no es un valor <see cref="T:System.Linq.ParallelExecutionMode" /> válido.</exception>
        <exception cref="T:System.InvalidOperationException">WithExecutionMode se utiliza varias veces en la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="WithMergeOptions&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithMergeOptions&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Linq.ParallelMergeOptions mergeOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithMergeOptions&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, valuetype System.Linq.ParallelMergeOptions mergeOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithMergeOptions``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelMergeOptions)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithMergeOptions(Of TSource) (source As ParallelQuery(Of TSource), mergeOptions As ParallelMergeOptions) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ WithMergeOptions(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, System::Linq::ParallelMergeOptions mergeOptions);" />
      <MemberSignature Language="F#" Value="static member WithMergeOptions : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelMergeOptions -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.WithMergeOptions (source, mergeOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="mergeOptions" Type="System.Linq.ParallelMergeOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de elementos de <paramref name="source" />.</typeparam>
        <param name="source">ParallelQuery en la que se va a establecer la opción.</param>
        <param name="mergeOptions">Opciones de fusión mediante combinación que se van a establecer para esta consulta.</param>
        <summary>Establece las opciones de fusión mediante combinación de esta consulta, que especifican cómo almacenará ésta en búfer el resultado.</summary>
        <returns>ParallelQuery que representa la misma consulta como origen, pero con las opciones de fusión mediante combinación registradas.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> es una referencia nula (nada en Visual Basic).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mergeOptions" /> no es un valor <see cref="T:System.Linq.ParallelMergeOptions" /> válido.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="WithMergeOptions" /> se usa varias veces en la consulta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/e8f7be3b-88de-4f33-ab14-dc008e76c1ba">Opciones de fusión mediante combinación en PLINQ</related>
        <related type="Article" href="https://msdn.microsoft.com/library/0f33b527-e91a-4550-a39a-e63e396fd831">Cómo: Especificar opciones de fusión mediante combinación en PLINQ</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Combina en paralelo dos secuencias mediante la función de predicado especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Linq.ParallelQuery&lt;TFirst&gt; first, System.Collections.Generic.IEnumerable&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TFirst&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Zip``3(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond, TResult) (first As ParallelQuery(Of TFirst), second As IEnumerable(Of TSecond), resultSelector As Func(Of TFirst, TSecond, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Zip(System::Linq::ParallelQuery&lt;TFirst&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSecond&gt; ^ second, Func&lt;TFirst, TSecond, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Zip : System.Linq.ParallelQuery&lt;'First&gt; * seq&lt;'Second&gt; * Func&lt;'First, 'Second, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Zip (first, second, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Este parámetro de tipo no se utiliza.</typeparam>
        <typeparam name="TSecond">Este parámetro de tipo no se utiliza.</typeparam>
        <typeparam name="TResult">Este parámetro de tipo no se utiliza.</typeparam>
        <param name="first">Este parámetro no se utiliza.</param>
        <param name="second">Este parámetro no se utiliza.</param>
        <param name="resultSelector">Este parámetro no se utiliza.</param>
        <summary>Nunca se debería llamar a esta sobrecarga Zip. Este método está marcado como obsoleto y, cuando se invoca, siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Esta sobrecarga siempre produce una excepción <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga existe para denegar el uso de Zip con un origen de datos izquierdo de tipo <xref:System.Linq.ParallelQuery%601> y un origen de datos derecho de tipo <xref:System.Collections.Generic.IEnumerable%601>. En caso contrario, el operador Zip podría parecer un enlace a la implementación paralela, pero en realidad enlazaría a la implementación secuencial.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La excepción que se produce al llamar a este método.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Parallel LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Linq.ParallelQuery&lt;TFirst&gt; first, System.Linq.ParallelQuery&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TFirst&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Zip``3(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond, TResult) (first As ParallelQuery(Of TFirst), second As ParallelQuery(Of TSecond), resultSelector As Func(Of TFirst, TSecond, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Zip(System::Linq::ParallelQuery&lt;TFirst&gt; ^ first, System::Linq::ParallelQuery&lt;TSecond&gt; ^ second, Func&lt;TFirst, TSecond, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Zip : System.Linq.ParallelQuery&lt;'First&gt; * System.Linq.ParallelQuery&lt;'Second&gt; * Func&lt;'First, 'Second, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Zip (first, second, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Tipo de los elementos de la primera secuencia.</typeparam>
        <typeparam name="TSecond">Tipo de los elementos de la segunda secuencia.</typeparam>
        <typeparam name="TResult">Tipo de los elementos devueltos.</typeparam>
        <param name="first">Primera secuencia que se va a comprimir.</param>
        <param name="second">Segunda secuencia que se va a comprimir.</param>
        <param name="resultSelector">Función que va a crear un elemento de resultado a partir de dos elementos coincidentes.</param>
        <summary>Combina en paralelo dos secuencias mediante la función de predicado especificada.</summary>
        <returns>Secuencia que tiene elementos de tipo <paramref name="TResult" /> que se han obtenido al realizar <paramref name="resultSelector" /> en pares en dos secuencias. Si las longitudes de la secuencia son desiguales, se trunca a la longitud de la secuencia más corta.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> o <paramref name="second" /> o <paramref name="resultSelector" /> es una referencia nula (Nothing en Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló la consulta con el token que se pasa a través de <paramref name="WithCancellation" />.</exception>
        <exception cref="T:System.AggregateException">Se han producido una o más excepciones durante la evaluación de la consulta.</exception>
      </Docs>
    </Member>
  </Members>
</Type>