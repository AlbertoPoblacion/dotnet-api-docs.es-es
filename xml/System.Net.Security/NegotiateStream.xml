<Type Name="NegotiateStream" FullName="System.Net.Security.NegotiateStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a976e8f1ed002a954921659f3c43b7004d169b2e" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36474676" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class NegotiateStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NegotiateStream extends System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.NegotiateStream" />
  <TypeSignature Language="VB.NET" Value="Public Class NegotiateStream&#xA;Inherits AuthenticatedStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NegotiateStream : System::Net::Security::AuthenticatedStream" />
  <TypeSignature Language="F#" Value="type NegotiateStream = class&#xA;    inherit AuthenticatedStream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides a stream that uses the Negotiate security protocol to authenticate the client, and optionally the server, in client-server communication.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Net.Security.NegotiateStream> (clase) para la autenticación y para ayudar a proteger la información que se transmite entre un cliente y un servidor. Usar <xref:System.Net.Security.NegotiateStream>, puede hacer lo siguiente.  
  
-   Enviar las credenciales del cliente al servidor para su suplantación o delegación.  
  
-   Solicitar la autenticación de servidor.  
  
-   Cifrar o firmar los datos antes de transmitirlos.  
  
 Autenticación se debe realizar antes de transmitir información. Los clientes solicitan la autenticación mediante sincrónico <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> métodos, que se bloquean hasta que finaliza la autenticación, o la asincrónica <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> métodos, que no se bloquean mientras se espera a que termine la autenticación. Servidores solicitan la autenticación mediante sincrónico <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> o asincrónico <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos. El cliente y, opcionalmente, el servidor, se autentica utilizando el protocolo de seguridad Negotiate. En los sistemas Windows 95 o Windows 98, Windows NT LAN Manager (NTLM) es el protocolo utilizado para la autenticación. En otras plataformas Kerberos es usar el protocolo para la autenticación si tanto el cliente como el servidor lo admiten; en caso contrario, se utiliza NTLM. Para obtener descripciones detalladas de estos protocolos, consulte la documentación de Platform SDK en MSDN, en msdn.microsoft.com/library/. La <xref:System.Net.Security.NegotiateStream> clase realiza la autenticación mediante la interfaz de proveedor de soporte técnico de seguridad (SSPI).  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad que se usará en el <xref:System.Net.Security.NegotiateStream> para ayudar a proteger los datos durante la transmisión. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua. Puede obtener información sobre el cliente remoto o el servidor mediante el <xref:System.Net.Security.NegotiateStream.RemoteIdentity%2A> propiedad.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 Enviar datos mediante sincrónico <xref:System.Net.Security.NegotiateStream.Write%2A> o asincrónico <xref:System.Net.Security.NegotiateStream.BeginWrite%2A> métodos. Recibir datos mediante sincrónico <xref:System.Net.Security.NegotiateStream.Read%2A> o asincrónico <xref:System.Net.Security.NegotiateStream.BeginRead%2A> métodos. Si los servicios de seguridad, como cifrado o la firma se habilitan, éstos se aplican automáticamente a los datos por la <xref:System.Net.Security.NegotiateStream>.  
  
 El <xref:System.Net.Security.NegotiateStream> transmite datos mediante una secuencia que se proporciona al crear la <xref:System.Net.Security.NegotiateStream>. Al proporcionar esta secuencia subyacente, tiene la opción para especificar si se cierra el <xref:System.Net.Security.NegotiateStream> también cierra la secuencia subyacente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el lado del cliente de una conexión de cliente y servidor que usa el <xref:System.Net.Security.NegotiateStream>. El cliente se autentica y envía un mensaje al servidor de forma asincrónica.  
  
 [!code-cpp[NclNegoAsyncClient#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#0)]
 [!code-csharp[NclNegoAsyncClient#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#0)]  
  
 En el ejemplo de código siguiente se muestra el lado del servidor de una conexión de cliente y servidor que usa el <xref:System.Net.Security.NegotiateStream> para autenticar el cliente y leer un mensaje enviado por el cliente.  
  
 [!code-cpp[NclNegoAsyncServer#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#0)]
 [!code-csharp[NclNegoAsyncServer#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Security.NegotiateStream" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para evitar la <xref:System.Net.Security.NegotiateStream> de cerrar la secuencia proporcionada, utilice el <xref:System.Net.Security.NegotiateStream.%23ctor%28System.IO.Stream%2CSystem.Boolean%29> constructor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateStream(System::IO::Stream ^ innerStream);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.NegotiateStream : System.IO.Stream -&gt; System.Net.Security.NegotiateStream" Usage="new System.Net.Security.NegotiateStream innerStream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="innerStream">A <see cref="T:System.IO.Stream" /> object used by the <see cref="T:System.Net.Security.NegotiateStream" /> for sending and receiving data.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Security.NegotiateStream" /> class using the specified <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este constructor.  
  
 [!code-cpp[NclNegoSyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#3)]
 [!code-csharp[NclNegoSyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.NegotiateStream : System.IO.Stream * bool -&gt; System.Net.Security.NegotiateStream" Usage="new System.Net.Security.NegotiateStream (innerStream, leaveInnerStreamOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="innerStream">A <see cref="T:System.IO.Stream" /> object used by the <see cref="T:System.Net.Security.NegotiateStream" /> for sending and receiving data.</param>
        <param name="leaveInnerStreamOpen">
          <see langword="true" /> to indicate that closing this <see cref="T:System.Net.Security.NegotiateStream" /> has no effect on <c>innerstream</c>; <see langword="false" /> to indicate that closing this <see cref="T:System.Net.Security.NegotiateStream" /> also closes <c>innerStream</c>.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Security.NegotiateStream" /> class using the specified <see cref="T:System.IO.Stream" /> and stream closure behavior.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se especifica `true` para el `leaveStreamOpen` parámetro, cerrar la <xref:System.Net.Security.NegotiateStream> no tiene ningún efecto sobre la `innerStream` transmitir; deberá cerrarlo usted expresamente `innerStream` cuando ya no necesite.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este constructor. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Net.Security.NegotiateStream> clase.  
  
 [!code-cpp[NclNegoAsyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#1)]
 [!code-csharp[NclNegoAsyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="innerStream" /> is <see langword="null" />.  \- or -  <paramref name="innerStream" /> is equal to <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Called by clients to authenticate the client, and optionally the server, in a client-server connection.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : unit -&gt; unit&#xA;override this.AuthenticateAsClient : unit -&gt; unit" Usage="negotiateStream.AuthenticateAsClient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called by clients to authenticate the client, and optionally the server, in a client-server connection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación usa el cliente <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, y se solicita la autenticación mutua. La <xref:System.Net.Security.NegotiateStream> clase construirá el SPN utilizado para la autenticación mutua.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar el explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, targetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * string -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * string -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="targetName">The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
        <summary>Called by clients to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified client credential.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, y se solicita la autenticación mutua. La <xref:System.Net.Security.NegotiateStream> clase construirá el SPN utilizado para la autenticación mutua.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar el explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, binding As ChannelBinding, targetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, binding, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="binding">The <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> that is used for extended protection.</param>
        <param name="targetName">The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
        <summary>Called by clients to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified client credential and the channel binding.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, y se solicita la autenticación mutua. La <xref:System.Net.Security.NegotiateStream> clase construirá el SPN utilizado para la autenticación mutua.  
  
 El <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> utilizado para la protección extendida que se pasa a este método en el `binding` parámetro recuperaría una aplicación de <xref:System.Net.Security.SslStream.TransportContext%2A> propiedad asociado <xref:System.Net.Security.SslStream>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> is <see langword="null" />.  \- or -  <paramref name="credential" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="targetName">The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
        <param name="requiredProtectionLevel">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="allowedImpersonationLevel">One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
        <summary>Called by clients to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified credentials and authentication options.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar el <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que el solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="allowedImpersonationLevel" /> is not a valid value.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> is null.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar el explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, binding As ChannelBinding, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="binding">The <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> that is used for extended protection.</param>
        <param name="targetName">The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
        <param name="requiredProtectionLevel">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="allowedImpersonationLevel">One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
        <summary>Called by clients to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified credential, authentication options, and channel binding.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar el <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que el solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 El <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> utilizado para la protección extendida que se pasa a este método en el `binding` parámetro recuperaría una aplicación de <xref:System.Net.Security.SslStream.TransportContext%2A> propiedad asociado <xref:System.Net.Security.SslStream>.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> is <see langword="null" />.  \- or -  <paramref name="credential" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="allowedImpersonationLevel" /> is not a valid value.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClientAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Called by clients to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : unit -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called by clients to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task" />  The task object representing the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación usa el cliente <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, y se solicita la autenticación mutua. La <xref:System.Net.Security.NegotiateStream> clase construirá el SPN utilizado para la autenticación mutua.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar el explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, targetName As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * string -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * string -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="targetName">The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
        <summary>Called by clients to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation. The authentication process uses the specified client credential.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task" />  The task object representing the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, y se solicita la autenticación mutua. La <xref:System.Net.Security.NegotiateStream> clase construirá el SPN utilizado para la autenticación mutua.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar el explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, binding As ChannelBinding, targetName As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, binding, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="binding">The <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> that is used for extended protection.</param>
        <param name="targetName">The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
        <summary>Called by clients to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation. The authentication process uses the specified client credential and the channel binding.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task" />  The task object representing the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, y se solicita la autenticación mutua. La <xref:System.Net.Security.NegotiateStream> clase construirá el SPN utilizado para la autenticación mutua.  
  
 El <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> utilizado para la protección extendida que se pasa a este método en el `binding` parámetro recuperaría una aplicación de <xref:System.Net.Security.SslStream.TransportContext%2A> propiedad asociado <xref:System.Net.Security.SslStream>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> is <see langword="null" />.  \- or -  <paramref name="credential" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="targetName">The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
        <param name="requiredProtectionLevel">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="allowedImpersonationLevel">One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
        <summary>Called by clients to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation. The authentication process uses the specified credentials and authentication options.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task" />  The task object representing the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar el <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que el solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="allowedImpersonationLevel" /> is not a valid value.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> is null.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar el explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, binding As ChannelBinding, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="binding">The <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> that is used for extended protection.</param>
        <param name="targetName">The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
        <param name="requiredProtectionLevel">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="allowedImpersonationLevel">One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
        <summary>Called by clients to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation. The authentication process uses the specified credential, authentication options, and channel binding.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task" />  The task object representing the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar el <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que el solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 El <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> utilizado para la protección extendida que se pasa a este método en el `binding` parámetro recuperaría una aplicación de <xref:System.Net.Security.SslStream.TransportContext%2A> propiedad asociado <xref:System.Net.Security.SslStream>.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> is <see langword="null" />.  \- or -  <paramref name="credential" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="allowedImpersonationLevel" /> is not a valid value.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Handles the server side of an authentication for a client-server connection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estos métodos se bloquean mientras la autenticación está en curso. Para evitar que la aplicación desde el bloqueo mientras se espera a que termine la autenticación, utilice la <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : unit -&gt; unit&#xA;override this.AuthenticateAsServer : unit -&gt; unit" Usage="negotiateStream.AuthenticateAsServer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called by servers to authenticate the client, and optionally the server, in a client-server connection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación utiliza el servidor <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, y el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Este método se bloquea hasta que se complete la operación. Para evitar que se bloquee hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> sobrecargas del método.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 and Windows 98 are not supported.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar el explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (policy As ExtendedProtectionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; unit&#xA;override this.AuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; unit" Usage="negotiateStream.AuthenticateAsServer policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">The <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> that is used for extended protection.</param>
        <summary>Called by servers to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified extended protection policy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación utiliza el servidor <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, y el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Si el `policy` parámetro es `null`, a continuación, se usa una directiva de protección extendida que tiene <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> establecido en <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Este método se bloquea hasta que se complete la operación. Para evitar que se bloquee hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> sobrecargas del método.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> and <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> on the extended protection policy passed in the <paramref name="policy" /> parameter are both <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 and Windows 98 are not supported.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The <paramref name="policy" /> parameter was set to <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> on a platform that does not support extended protection.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (credential As NetworkCredential, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsServer (credential, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the server.</param>
        <param name="requiredProtectionLevel">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="requiredImpersonationLevel">One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
        <summary>Called by servers to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified server credentials and authentication options.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Este método se bloquea hasta que se complete la operación. Para evitar que se bloquee hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> sobrecargas del método.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> must be <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, or <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to try to r-authenticate.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 and Windows 98 are not supported.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar el explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (credential As NetworkCredential, policy As ExtendedProtectionPolicy, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsServer (credential, policy, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="policy">The <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> that is used for extended protection.</param>
        <param name="requiredProtectionLevel">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="requiredImpersonationLevel">One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
        <summary>Called by servers to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified server credentials, authentication options, and extended protection policy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `policy` parámetro es `null`, a continuación, se usa una directiva de protección extendida que tiene <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> establecido en <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Este método se bloquea hasta que se complete la operación. Para evitar que se bloquee hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> sobrecargas del método.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> and <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> on the extended protection policy passed in the <paramref name="policy" /> parameter are both <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> must be <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, or <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to try to r-authenticate.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 and Windows 98 are not supported.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The <paramref name="policy" /> parameter was set to <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> on a platform that does not support extended protection.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServerAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Handles the server side of an authentication for a client-server connection as an asynchronous operation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : unit -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called by servers to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task" />  The task object representing the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación utiliza el servidor <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, y el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 and Windows 98 are not supported.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar el explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (policy As ExtendedProtectionPolicy) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">The <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> that is used for extended protection.</param>
        <summary>Called by servers to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation. The authentication process uses the specified extended protection policy.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task" />  The task object representing the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación utiliza el servidor <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, y el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Si el `policy` parámetro es `null`, a continuación, se usa una directiva de protección extendida que tiene <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> establecido en <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> and <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> on the extended protection policy passed in the <paramref name="policy" /> parameter are both <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 and Windows 98 are not supported.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The <paramref name="policy" /> parameter was set to <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> on a platform that does not support extended protection.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (credential As NetworkCredential, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync (credential, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the server.</param>
        <param name="requiredProtectionLevel">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="requiredImpersonationLevel">One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
        <summary>Called by servers to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation. The authentication process uses the specified server credentials and authentication options.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task" />  The task object representing the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> must be <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, or <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to try to r-authenticate.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 and Windows 98 are not supported.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar el explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (credential As NetworkCredential, policy As ExtendedProtectionPolicy, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync (credential, policy, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="policy">The <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> that is used for extended protection.</param>
        <param name="requiredProtectionLevel">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="requiredImpersonationLevel">One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
        <summary>Called by servers to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation. The authentication process uses the specified server credentials, authentication options, and extended protection policy.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task" />  The task object representing the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `policy` parámetro es `null`, a continuación, se usa una directiva de protección extendida que tiene <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> establecido en <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> and <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> on the extended protection policy passed in the <paramref name="policy" /> parameter are both <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> must be <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, or <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to try to r-authenticate.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 and Windows 98 are not supported.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The <paramref name="policy" /> parameter was set to <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> on a platform that does not support extended protection.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Begins an asynchronous operation to authenticate the client side of a client-server connection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de este método no bloquea mientras la autenticación está en curso. Para bloquear mientras se espera a que termine la autenticación, utilice uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> métodos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="asyncCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the authentication is complete.</param>
        <param name="asyncState">A user-defined object containing information about the operation. This object is passed to the <c>asyncCallback</c> delegate when the operation completes.</param>
        <summary>Called by clients to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. This method does not block.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación usa el cliente <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, y el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>. La <xref:System.Net.Security.NegotiateStream> clase construirá el SPN utilizado para la autenticación mutua.  
  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> sobrecargas del método.  
  
 Debe completarse la operación de autenticación asincrónica mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [al llamar a métodos sincrónicos asincrónicamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este método para comenzar una autenticación asincrónica para el cliente.  
  
 [!code-cpp[NclNegoAsyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#2)]
 [!code-csharp[NclNegoAsyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar el explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * string * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * string * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, targetName, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="targetName">The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
        <param name="asyncCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the authentication is complete.</param>
        <param name="asyncState">A user-defined object containing information about the write operation. This object is passed to the <c>asyncCallback</c> delegate when the operation completes.</param>
        <summary>Called by clients to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified credentials. This method does not block.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> sobrecargas del método.  
  
 Debe completarse la operación de autenticación asincrónica mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [al llamar a métodos sincrónicos asincrónicamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> is <see langword="null" />.  \- or -  <paramref name="targetName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar el explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, binding, targetName, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="binding">The <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> that is used for extended protection.</param>
        <param name="targetName">The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
        <param name="asyncCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the authentication is complete.</param>
        <param name="asyncState">A user-defined object containing information about the write operation. This object is passed to the <c>asyncCallback</c> delegate when the operation completes.</param>
        <summary>Called by clients to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified credentials and channel binding. This method does not block.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> sobrecargas del método.  
  
 Debe completarse la operación de autenticación asincrónica mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [al llamar a métodos sincrónicos asincrónicamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> is <see langword="null" />.  \- or -  <paramref name="targetName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="targetName">The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
        <param name="requiredProtectionLevel">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="allowedImpersonationLevel">One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
        <param name="asyncCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the authentication is complete.</param>
        <param name="asyncState">A user-defined object containing information about the write operation. This object is passed to the <c>asyncCallback</c> delegate when the operation completes.</param>
        <summary>Called by clients to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified credentials and authentication options. This method does not block.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar el <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que el solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> sobrecargas del método.  
  
 Debe completarse la operación de autenticación asincrónica mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [al llamar a métodos sincrónicos asincrónicamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> is <see langword="null" />.  \- or -  <paramref name="targetName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar el explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="binding">The <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> that is used for extended protection.</param>
        <param name="targetName">The Service Principal Name (SPN) that uniquely identifies the server to authenticate.</param>
        <param name="requiredProtectionLevel">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="allowedImpersonationLevel">One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
        <param name="asyncCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the authentication is complete.</param>
        <param name="asyncState">A user-defined object containing information about the write operation. This object is passed to the <c>asyncCallback</c> delegate when the operation completes.</param>
        <summary>Called by clients to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified credentials, authentication options, and channel binding. This method does not block.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar el <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que el solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> sobrecargas del método.  
  
 Debe completarse la operación de autenticación asincrónica mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [al llamar a métodos sincrónicos asincrónicamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> is <see langword="null" />.  \- or -  <paramref name="targetName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Begins an asynchronous operation to handle the server side of authenticating a client-server connection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de este método no bloquea mientras la autenticación está en curso. Para bloquear mientras se espera a que termine la autenticación, utilice la <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="asyncCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the authentication is complete.</param>
        <param name="asyncState">A user-defined object containing information about the operation. This object is passed to the <c>asyncCallback</c> delegate when the operation completes.</param>
        <summary>Called by servers to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. This method does not block.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación utiliza el servidor <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> sobrecargas del método.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 and Windows 98 are not supported.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar el explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (policy, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="policy">The <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> that is used for extended protection.</param>
        <param name="asyncCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the authentication is complete.</param>
        <param name="asyncState">A user-defined object containing information about the write operation. This object is passed to the <c>asyncCallback</c> delegate when the operation completes.</param>
        <summary>Called by servers to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified extended protection policy. This method does not block.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación utiliza el servidor <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Si el `policy` parámetro es `null`, a continuación, se usa una directiva de protección extendida que tiene <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> establecido en <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> sobrecargas del método.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> and <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> on the extended protection policy passed in the <paramref name="policy" /> parameter are both <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 and Windows 98 are not supported.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The <paramref name="policy" /> parameter was set to <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> on a platform that does not support extended protection.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (credential, requiredProtectionLevel, requiredImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="requiredProtectionLevel">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="requiredImpersonationLevel">One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
        <param name="asyncCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the authentication is complete.</param>
        <param name="asyncState">A user-defined object containing information about the operation. This object is passed to the <c>asyncCallback</c> delegate when the operation completes.</param>
        <summary>Called by servers to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified server credentials and authentication options. This method does not block.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar el <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que, solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> sobrecargas del método.  
  
 Debe completarse la operación de autenticación asincrónica mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [al llamar a métodos sincrónicos asincrónicamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> must be <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, or <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 and Windows 98 are not supported.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar el explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (credential, policy, requiredProtectionLevel, requiredImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">The <see cref="T:System.Net.NetworkCredential" /> that is used to establish the identity of the client.</param>
        <param name="policy">The <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> that is used for extended protection.</param>
        <param name="requiredProtectionLevel">One of the <see cref="T:System.Net.Security.ProtectionLevel" /> values, indicating the security services for the stream.</param>
        <param name="requiredImpersonationLevel">One of the <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> values, indicating how the server can use the client's credentials to access resources.</param>
        <param name="asyncCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the authentication is complete.</param>
        <param name="asyncState">A user-defined object containing information about the write operation. This object is passed to the <c>asyncCallback</c> delegate when the operation completes.</param>
        <summary>Called by servers to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified server credentials, authentication options, and extended protection policy. This method does not block.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar el <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que, solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 Si el `policy` parámetro es `null`, a continuación, se usa una directiva de protección extendida que tiene <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> establecido en <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> sobrecargas del método.  
  
 Debe completarse la operación de autenticación asincrónica mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [al llamar a métodos sincrónicos asincrónicamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> and <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> on the extended protection policy passed in the <paramref name="policy" /> parameter are both <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="credential" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> must be <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" />, or <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />,</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has already occurred.  \- or -  This stream was used previously to attempt authentication as the client. You cannot use the stream to retry authentication as the server.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 and Windows 98 are not supported.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The <paramref name="policy" /> parameter was set to <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> on a platform that does not support extended protection.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginRead (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">A <see cref="T:System.Byte" /> array that receives the bytes read from the stream.</param>
        <param name="offset">The zero-based location in <c>buffer</c> at which to begin storing the data read from this stream.</param>
        <param name="count">The maximum number of bytes to read from the stream.</param>
        <param name="asyncCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the read operation is complete.</param>
        <param name="asyncState">A user-defined object containing information about the read operation. This object is passed to the <c>asyncCallback</c> delegate when the operation completes.</param>
        <summary>Begins an asynchronous read operation that reads data from the stream and stores it in the specified array.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se habilitan el cifrado, firma, o cifrado y firma, la operación de lectura lee los datos de la secuencia subyacente, comprueba la integridad de los datos y lo descifra. Si ningún servicio de seguridad, como el cifrado de datos o la firma están en uso, este método inicia una operación de lectura asincrónica en la secuencia subyacente.  
  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use el <xref:System.Net.Security.NegotiateStream.Read%2A> método.  
  
 Debe realizarse la operación de lectura asincrónica mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndRead%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [al llamar a métodos sincrónicos asincrónicamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 La <xref:System.Net.Security.NegotiateStream> clase no admite varias de las operaciones de lectura simultáneas. Si se intenta iniciar una operación de lectura mientras otra lectura operación ya se está ejecutando en la misma secuencia, un <xref:System.NotSupportedException> excepción.  
  
 No se puede llamar este método hasta que se haya autenticado correctamente. Para autenticar, llame a uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo iniciar una operación de lectura asincrónica. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Net.Security.NegotiateStream> clase.  
  
 [!code-cpp[NclNegoAsyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#1)]
 [!code-csharp[NclNegoAsyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> is less than 0.  \- or -  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  \- or -  <paramref name="offset" /> plus <paramref name="count" /> is greater than the length of <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">The read operation failed.  \- or -  Encryption is in use, but the data could not be decrypted.</exception>
        <exception cref="T:System.NotSupportedException">There is already a read operation in progress.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has not occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginWrite (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">A <see cref="T:System.Byte" /> array that supplies the bytes to be written to the stream.</param>
        <param name="offset">The zero-based location in <c>buffer</c> at which to begin reading bytes to be written to the stream.</param>
        <param name="count">An <see cref="T:System.Int32" /> value that specifies the number of bytes to read from <c>buffer</c>.</param>
        <param name="asyncCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the write operation is complete.</param>
        <param name="asyncState">A user-defined object containing information about the write operation. This object is passed to the <c>asyncCallback</c> delegate when the operation completes.</param>
        <summary>Begins an asynchronous write operation that writes <see cref="T:System.Byte" />s from the specified buffer to the stream.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object indicating the status of the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se habilitan el cifrado, firma, o cifrado y firma, este método lee los datos del búfer, cifra, firma o cifra y lo firma y transmite mediante la secuencia subyacente. Si ningún servicio de seguridad, como el cifrado de datos o la firma están en uso, este método inicia una operación de escritura asincrónica en la secuencia subyacente.  
  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use el <xref:System.Net.Security.NegotiateStream.Read%2A> método.  
  
 Debe realizarse la operación de lectura asincrónica mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndWrite%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [al llamar a métodos sincrónicos asincrónicamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 La <xref:System.Net.Security.NegotiateStream> clase no admite varias operaciones de escritura simultáneas. Si intenta iniciar una operación de escritura mientras ya se está ejecutando otra operación de escritura en la misma secuencia, un <xref:System.NotSupportedException> excepción.  
  
 No se puede llamar este método hasta que se haya autenticado correctamente. Para autenticar, llame a uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo iniciar una operación de escritura asincrónica.  
  
 [!code-cpp[NclNegoAsyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#3)]
 [!code-csharp[NclNegoAsyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#3)]  
  
 El siguiente método se llama cuando finaliza la operación.  
  
 [!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
 [!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset is less than 0" />.  \- or -  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  \- or -  <paramref name="offset" /> plus count is greater than the length of <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">The write operation failed.  \- or -  Encryption is in use, but the data could not be encrypted.</exception>
        <exception cref="T:System.NotSupportedException">There is already a write operation in progress.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has not occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Net.Security.NegotiateStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Boolean" /> value that indicates whether the underlying stream is readable.</summary>
        <value>
          <see langword="true" /> Si se ha producido la autenticación y la secuencia subyacente es legible; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se ha producido una autenticación correcta, esta propiedad devuelve el valor devuelto al invocar el <xref:System.IO.Stream.CanRead%2A> propiedad en la secuencia subyacente. La secuencia subyacente se especifica cuando se crea una instancia de la <xref:System.Net.Security.NegotiateStream> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Net.Security.NegotiateStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Boolean" /> value that indicates whether the underlying stream is seekable.</summary>
        <value>Esta propiedad devuelve siempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No debe intentar establecer la posición de la <xref:System.Net.Security.NegotiateStream> objeto o su secuencia subyacente. La secuencia subyacente se especifica cuando se crea una instancia de la <xref:System.Net.Security.NegotiateStream> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Security.NegotiateStream.Position" />
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Net.Security.NegotiateStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Boolean" /> value that indicates whether the underlying stream supports time-outs.</summary>
        <value>
          <see langword="true" /> Si la secuencia subyacente admite tiempos de espera; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el valor devuelto al invocar el <xref:System.IO.Stream.CanTimeout%2A> propiedad en la secuencia subyacente. La secuencia subyacente se especifica cuando se crea una instancia de la <xref:System.Net.Security.NegotiateStream> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Net.Security.NegotiateStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Boolean" /> value that indicates whether the underlying stream is writable.</summary>
        <value>
          <see langword="true" /> Si se ha producido la autenticación y la secuencia subyacente es grabable; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se ha producido una autenticación correcta, esta propiedad devuelve el valor devuelto al invocar el <xref:System.IO.Stream.CanWrite%2A> propiedad en la secuencia subyacente. La secuencia subyacente se especifica cuando se crea una instancia de la <xref:System.Net.Security.NegotiateStream> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="negotiateStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases the unmanaged resources used by the <see cref="T:System.Net.Security.NegotiateStream" /> and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama a este método público `Dispose()` método y <xref:System.Object.Finalize%2A> método. `Dispose()` se invoca el protegido `Dispose(Boolean)` método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` con `disposing` establecido en `false`.  
  
 Cuando el `disposing` del parámetro es true, este método libera todos los recursos retenidos por los objetos administrados que este <xref:System.Net.Security.NegotiateStream> referencias. Este método invoca al método `Dispose()` de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> puede recibir varias llamadas de otros objetos. Al reemplazar <see langword="Dispose(Boolean)" /> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />. Para obtener más información sobre cómo implementar <see langword="Dispose(Boolean)" />, vea [implementar un Method](~/docs/standard/garbage-collection/implementing-dispose.md) Dispose.  Para obtener más información acerca de <see langword="Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpieza seguridad Resources](~/docs/standard/garbage-collection/unmanaged.md) no administrado y [invalidación del método Finalize] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsClient (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsClient(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsClient : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsClient : IAsyncResult -&gt; unit" Usage="negotiateStream.EndAuthenticateAsClient asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> instance returned by a call to <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</param>
        <summary>Ends a pending asynchronous client authentication operation that was started with a call to <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se ha completado la operación, este método se bloquea hasta que lo hace. Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 Para realizar esta operación sincrónicamente, utilice uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not created by a call to <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.InvalidOperationException">There is no pending client authentication to complete.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsServer (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsServer(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsServer : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsServer : IAsyncResult -&gt; unit" Usage="negotiateStream.EndAuthenticateAsServer asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> instance returned by a call to <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</param>
        <summary>Ends a pending asynchronous client authentication operation that was started with a call to <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se ha completado la operación, este método se bloquea hasta que lo hace.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá una <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 Para realizar esta operación sincrónicamente, utilice el <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not created by a call to <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">The authentication failed. You can use this object to retry the authentication.</exception>
        <exception cref="T:System.InvalidOperationException">There is no pending authentication to complete.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="negotiateStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> instance returned by a call to <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Ends an asynchronous read operation that was started with a call to <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <returns>A <see cref="T:System.Int32" /> value that specifies the number of bytes read from the underlying stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se ha completado la operación, este método se bloquea hasta que lo hace.  
  
 Para realizar esta operación sincrónicamente, utilice el <xref:System.Net.Security.NegotiateStream.Read%2A> método.  
  
 No se puede llamar este método hasta que se haya autenticado correctamente. Para autenticar, llame a uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la operación de lectura de finalización asincrónica. Para obtener un ejemplo que muestra cómo iniciar la operación, vea <xref:System.Net.Security.NegotiateStream.BeginRead%2A>.  
  
 [!code-cpp[NclNegoAsyncServer#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#3)]
 [!code-csharp[NclNegoAsyncServer#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The asyncResult was not created by a call to <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has not occurred.</exception>
        <exception cref="T:System.IO.IOException">The read operation failed.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="negotiateStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> instance returned by a call to <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Ends an asynchronous write operation that was started with a call to <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se ha completado la operación, este método se bloquea hasta que lo hace.  
  
 No se puede llamar este método hasta que se haya autenticado correctamente. Para autenticar, llame a uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
 Para realizar esta operación sincrónicamente, utilice el <xref:System.Net.Security.NegotiateStream.Write%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra un método que se llama para completar la operación de escritura asincrónica. Para obtener un ejemplo que muestra cómo iniciar la operación, vea <xref:System.Net.Security.NegotiateStream.BeginWrite%2A>.  
  
 [!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
 [!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The asyncResult was not created by a call to <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has not occurred.</exception>
        <exception cref="T:System.IO.IOException">The write operation failed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="negotiateStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes any buffered data to be written to the underlying device.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invoca <xref:System.IO.Stream.Flush%2A> en la secuencia subyacente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo vaciar la secuencia.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); };" />
      <MemberSignature Language="F#" Value="member this.ImpersonationLevel : System.Security.Principal.TokenImpersonationLevel" Usage="System.Net.Security.NegotiateStream.ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates how the server can use the client's credentials.</summary>
        <value>Uno de los valores de <see cref="T:System.Security.Principal.TokenImpersonationLevel" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe autenticar correctamente antes de llamar a este método. Los clientes especificar el nivel de suplantación cuando solicitan la autenticación mediante una llamada a uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> métodos. Si realiza la autenticación sin especificar un <xref:System.Security.Principal.TokenImpersonationLevel> , <xref:System.Security.Principal.TokenImpersonationLevel.Identification> se utiliza.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Authentication failed or has not occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Net.Security.NegotiateStream.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Boolean" /> value that indicates whether authentication was successful.</summary>
        <value>
          <see langword="true" /> Si se realizó una autenticación correcta; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los clientes se autentican mediante una llamada a la <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> métodos. Servidores que se autentican mediante una llamada a la <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsEncrypted" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEncrypted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEncrypted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEncrypted : bool" Usage="System.Net.Security.NegotiateStream.IsEncrypted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Boolean" /> value that indicates whether this <see cref="T:System.Net.Security.NegotiateStream" /> uses data encryption.</summary>
        <value>
          <see langword="true" /> Si los datos se cifran antes de transmitirse a través de la red y se descifran cuando llegue al extremo remoto; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El cifrado ayuda a proteger la privacidad de los datos; es decir, ayuda a garantizar que mientras están en tránsito no se puede descifrar un tercero.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Security.ProtectionLevel" />
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsMutuallyAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMutuallyAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMutuallyAuthenticated : bool" Usage="System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Boolean" /> value that indicates whether both the server and the client have been authenticated.</summary>
        <value>
          <see langword="true" /> Si se ha autenticado el servidor; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación mutua se especifica mediante el cliente cuando el cliente desea que el servidor para proporcionar las credenciales para la autenticación. De forma predeterminada, los clientes solicitan la autenticación mutua.  
  
 El protocolo de negociación selecciona NTLM o Kerberos dependiendo de los protocolos de seguridad admitidos por el cliente y el servidor. NTLM no admite la autenticación mutua.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsServer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsServer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsServer : bool" Usage="System.Net.Security.NegotiateStream.IsServer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Boolean" /> value that indicates whether the local side of the connection used by this <see cref="T:System.Net.Security.NegotiateStream" /> was authenticated as the server.</summary>
        <value>
          <see langword="true" /> Si el extremo local se autenticó correctamente como el lado del servidor de la conexión autenticada; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la autenticación no se pudo o no se producía, esta propiedad devuelve `false`.  
  
 Para autenticar como el servidor, llame a la <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsSigned" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSigned As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSigned { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSigned : bool" Usage="System.Net.Security.NegotiateStream.IsSigned" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Boolean" /> value that indicates whether the data sent using this stream is signed.</summary>
        <value>
          <see langword="true" /> Si los datos se firman antes de transmitirse; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Firma de datos ayuda a proteger la integridad de los datos; es decir, ayuda al destinatario a determinar si se ha alterado los datos mientras están en tránsito.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Net.Security.NegotiateStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the length of the underlying stream.</summary>
        <value>Un <see cref="T:System.Int64" /> que especifica la longitud de la secuencia subyacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el valor devuelto al invocar el <xref:System.IO.Stream.Length%2A> propiedad en la secuencia subyacente. Si no se puede buscar la secuencia subyacente, esta propiedad normalmente producirá una excepción. El tipo de tiempo de ejecución de la secuencia subyacente determina el tipo de tiempo de ejecución de la excepción que se produce.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Getting the value of this property is not supported when the underlying stream is a <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Net.Security.NegotiateStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current position in the underlying stream.</summary>
        <value>Un <see cref="T:System.Int64" /> que especifica la posición actual en la secuencia subyacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el valor devuelto al invocar el <xref:System.IO.Stream.Position%2A> propiedad en la secuencia subyacente. Si no se puede buscar la secuencia subyacente, esta propiedad normalmente producirá una excepción. El tipo de tiempo de ejecución de la secuencia subyacente determina el tipo de tiempo de ejecución de la excepción que se produce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Setting this property is not supported.  \- or -  Getting the value of this property is not supported when the underlying stream is a <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="negotiateStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">A <see cref="T:System.Byte" /> array that receives the bytes read from the stream.</param>
        <param name="offset">A <see cref="T:System.Int32" /> containing the zero-based location in <c>buffer</c> at which to begin storing the data read from this stream.</param>
        <param name="count">A <see cref="T:System.Int32" /> containing the maximum number of bytes to read from the stream.</param>
        <summary>Reads data from this stream and stores it in the specified array.</summary>
        <returns>A <see cref="T:System.Int32" /> value that specifies the number of bytes read from the underlying stream. When there is no more data to be read, returns 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método lee un máximo de `count` secuencia de bytes a partir de la actual y los almacena en `buffer` empezando por `offset`.  
  
 No se puede llamar este método hasta que se haya autenticado correctamente. Para autenticar, llame a uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
 Para realizar esta operación asincrónicamente, utilice el <xref:System.Net.Security.NegotiateStream.BeginRead%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo leer de un <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncServer/CPP/NclNegoSyncServer.cpp#1)]
 [!code-csharp[NclNegoSyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">The read operation failed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has not occurred.</exception>
        <exception cref="T:System.NotSupportedException">A <see cref="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" /> operation is already in progress.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Net.Security.NegotiateStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the amount of time a read operation blocks waiting for data.</summary>
        <value>Un <see cref="T:System.Int32" /> que especifica la cantidad de tiempo que debe transcurrir antes de que se produce un error en una operación de lectura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el valor devuelto al invocar el <xref:System.IO.Stream.ReadTimeout%2A> propiedad en la secuencia subyacente. Cuando se establece esta propiedad, el <xref:System.IO.Stream.ReadTimeout%2A> valor en la secuencia subyacente se establece en el valor especificado.  
  
 Si la secuencia subyacente es una <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.NegotiateStream.ReadTimeout%2A> está en milisegundos y se establece en <xref:System.Threading.Timeout.Infinite> de forma predeterminada, por lo que leerá operaciones no tienen tiempo de espera.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteIdentity">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.IIdentity RemoteIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity RemoteIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.RemoteIdentity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RemoteIdentity As IIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::IIdentity ^ RemoteIdentity { System::Security::Principal::IIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteIdentity : System.Security.Principal.IIdentity" Usage="System.Net.Security.NegotiateStream.RemoteIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets information about the identity of the remote party sharing this authenticated stream.</summary>
        <value>Un <see cref="T:System.Security.Principal.IIdentity" /> objeto que describe la identidad del extremo remoto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se tiene acceso por el cliente, esta propiedad devuelve un <xref:System.Security.Principal.GenericIdentity> que contiene el nombre Principal de servicio (SPN) del servidor y el protocolo de autenticación utilizado. Cuando se tiene acceso el servidor, esta propiedad devuelve un <xref:System.Security.Principal.WindowsIdentity> que describe el cliente. Si el <xref:System.Security.Principal.WindowsIdentity> es no disponible, se devuelve información del cliente al servidor en un <xref:System.Security.Principal.GenericIdentity>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoAsyncServer#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#2)]
 [!code-csharp[NclNegoAsyncServer#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Authentication failed or has not occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="negotiateStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">This value is ignored.</param>
        <param name="origin">This value is ignored.</param>
        <summary>Throws <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Always throws a <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No llame a este método. Se hereda, pero no es compatible con <xref:System.Net.Security.NegotiateStream>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Seeking is not supported on <see cref="T:System.Net.Security.NegotiateStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="negotiateStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">An <see cref="T:System.Int64" /> value that specifies the length of the stream.</param>
        <summary>Sets the length of the underlying stream.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="negotiateStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">A <see cref="T:System.Byte" /> array that supplies the bytes written to the stream.</param>
        <param name="offset">An <see cref="T:System.Int32" /> containing the zero-based location in <c>buffer</c> at which to begin reading bytes to be written to the stream.</param>
        <param name="count">A <see cref="T:System.Int32" /> containing the number of bytes to read from <c>buffer</c>.</param>
        <summary>Write the specified number of <see cref="T:System.Byte" />s to the underlying stream using the specified buffer and offset.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se habilitan el cifrado, firma, o cifrado y firma, este método lee los datos del búfer, cifra, firma o cifra y lo firma y transmite mediante la secuencia subyacente. Si ningún servicio de seguridad, como el cifrado de datos o la firma están en uso, este método invoca <xref:System.IO.Stream.Write%2A> en la secuencia subyacente.  
  
 Este método se bloquea mientras se completa la operación de escritura. Para evitar que se bloquee mientras se completa la operación, use el <xref:System.Net.Security.NegotiateStream.Write%2A> método.  
  
 No se puede llamar este método hasta que se haya autenticado correctamente. Para autenticar, llame a uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
 La <xref:System.Net.Security.NegotiateStream> clase no admite varias operaciones de escritura simultáneas. Si intenta iniciar una operación de escritura mientras ya se está ejecutando otra operación de escritura en la misma secuencia, un <xref:System.NotSupportedException> excepción.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la escritura a un <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset is less than 0" />.  \- or -  <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  \- or -  <paramref name="offset" /> plus count is greater than the length of <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">The write operation failed.  \- or -  Encryption is in use, but the data could not be encrypted.</exception>
        <exception cref="T:System.NotSupportedException">There is already a write operation in progress.</exception>
        <exception cref="T:System.ObjectDisposedException">This object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">Authentication has not occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Net.Security.NegotiateStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the amount of time a write operation blocks waiting for data.</summary>
        <value>Un <see cref="T:System.Int32" /> que especifica la cantidad de tiempo que debe transcurrir antes de que se produce un error en una operación de escritura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el valor devuelto al invocar el <xref:System.IO.Stream.WriteTimeout%2A> propiedad en la secuencia subyacente. Para las operaciones de conjunto, se establece el valor especificado la <xref:System.IO.Stream.WriteTimeout%2A> valor en la secuencia subyacente.  
  
 Si la secuencia subyacente es una <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.NegotiateStream.WriteTimeout%2A> está en milisegundos y se establece en <xref:System.Threading.Timeout.Infinite> de forma predeterminada, por lo que escribir las operaciones no tienen tiempo de espera.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>