<Type Name="NegotiateStream" FullName="System.Net.Security.NegotiateStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="11db0f7e9d3843d1816a582e23224cbcdac14a7f" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52234170" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class NegotiateStream : System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NegotiateStream extends System.Net.Security.AuthenticatedStream" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.NegotiateStream" />
  <TypeSignature Language="VB.NET" Value="Public Class NegotiateStream&#xA;Inherits AuthenticatedStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class NegotiateStream : System::Net::Security::AuthenticatedStream" />
  <TypeSignature Language="F#" Value="type NegotiateStream = class&#xA;    inherit AuthenticatedStream" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Security.AuthenticatedStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona una secuencia que utiliza el protocolo de negociación de seguridad para autenticar el cliente, y opcionalmente el servidor, en la comunicación cliente-servidor.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Net.Security.NegotiateStream> clase para la autenticación y para ayudar a proteger la información transmitida entre un cliente y un servidor. Uso de <xref:System.Net.Security.NegotiateStream>, puede hacer lo siguiente.  
  
-   Enviar las credenciales del cliente al servidor para la suplantación o delegación.  
  
-   Solicitar la autenticación de servidor.  
  
-   Cifrar o firmar los datos antes de transmitirlos.  
  
 Autenticación se debe realizar antes de transmitir información. Los clientes solicitan la autenticación mediante sincrónico <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> métodos, que se bloquean hasta que se complete la autenticación, o la asincrónica <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> métodos, que no se bloquean mientras esperan a completar la autenticación. Servidores de solicitan la autenticación mediante sincrónico <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> o asincrónicas <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos. El cliente y opcionalmente el servidor, se autentica utilizando el protocolo de seguridad Negotiate. En los sistemas Windows 95/98, Windows NT LAN Manager (NTLM) es el protocolo utilizado para la autenticación. En otras plataformas Kerberos protocolo se usa para la autenticación si el cliente y servidor admiten; en caso contrario, se utiliza NTLM. Para obtener descripciones detalladas de estos protocolos, consulte la documentación de Platform SDK en MSDN, en msdn.microsoft.com/library/. La <xref:System.Net.Security.NegotiateStream> clase realiza la autenticación mediante la interfaz del proveedor de soporte técnico de seguridad (SSPI).  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> se usarán las propiedades para determinar qué servicios de seguridad mediante el <xref:System.Net.Security.NegotiateStream> para ayudar a proteger los datos durante la transmisión. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua. Puede obtener información sobre el cliente remoto o el servidor mediante el <xref:System.Net.Security.NegotiateStream.RemoteIdentity%2A> propiedad.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 Enviar datos mediante sincrónico <xref:System.Net.Security.NegotiateStream.Write%2A> o asincrónicas <xref:System.Net.Security.NegotiateStream.BeginWrite%2A> métodos. Recibir datos mediante sincrónico <xref:System.Net.Security.NegotiateStream.Read%2A> o asincrónicas <xref:System.Net.Security.NegotiateStream.BeginRead%2A> métodos. Si el servicio de seguridad como cifrado o firma están habilitadas, estas se aplican automáticamente a los datos por la <xref:System.Net.Security.NegotiateStream>.  
  
 El <xref:System.Net.Security.NegotiateStream> transmite datos mediante una secuencia que se proporciona al crear el <xref:System.Net.Security.NegotiateStream>. Al proporcionar esta secuencia subyacente, tiene la opción para especificar si se cierra el <xref:System.Net.Security.NegotiateStream> también se cierra la secuencia subyacente.  
  
   
  
## Examples  
 El código siguiente muestra el lado cliente de una conexión cliente / servidor que usa el <xref:System.Net.Security.NegotiateStream>. El cliente se autentica y envía un mensaje al servidor de forma asincrónica.  
  
 [!code-cpp[NclNegoAsyncClient#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#0)]
 [!code-csharp[NclNegoAsyncClient#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#0)]  
  
 El código siguiente muestra el lado del servidor de una conexión cliente / servidor que usa el <xref:System.Net.Security.NegotiateStream> para autenticar el cliente y leer un mensaje enviado por el cliente.  
  
 [!code-cpp[NclNegoAsyncServer#0](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#0)]
 [!code-csharp[NclNegoAsyncServer#0](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#0)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/8bf0b428-5a21-4299-8d6e-bf8251fd978a">Cambios en la autenticación NTLM para HTTPWebRequest en la versión 3.5 SP1</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Security.NegotiateStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para evitar la <xref:System.Net.Security.NegotiateStream> al cerrar la secuencia proporcionada, utilice el <xref:System.Net.Security.NegotiateStream.%23ctor%28System.IO.Stream%2CSystem.Boolean%29> constructor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateStream(System::IO::Stream ^ innerStream);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.NegotiateStream : System.IO.Stream -&gt; System.Net.Security.NegotiateStream" Usage="new System.Net.Security.NegotiateStream innerStream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="innerStream">Objeto <see cref="T:System.IO.Stream" /> que la clase <see cref="T:System.Net.Security.NegotiateStream" /> utiliza para enviar y recibir datos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Security.NegotiateStream" /> utilizando la clase <see cref="T:System.IO.Stream" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este constructor.  
  
 [!code-cpp[NclNegoSyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#3)]
 [!code-csharp[NclNegoSyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream innerStream, bool leaveInnerStreamOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (innerStream As Stream, leaveInnerStreamOpen As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateStream(System::IO::Stream ^ innerStream, bool leaveInnerStreamOpen);" />
      <MemberSignature Language="F#" Value="new System.Net.Security.NegotiateStream : System.IO.Stream * bool -&gt; System.Net.Security.NegotiateStream" Usage="new System.Net.Security.NegotiateStream (innerStream, leaveInnerStreamOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="innerStream" Type="System.IO.Stream" />
        <Parameter Name="leaveInnerStreamOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="innerStream">Objeto <see cref="T:System.IO.Stream" /> que la clase <see cref="T:System.Net.Security.NegotiateStream" /> utiliza para enviar y recibir datos.</param>
        <param name="leaveInnerStreamOpen">
          <see langword="true" /> para indicar que el cierre de este <see cref="T:System.Net.Security.NegotiateStream" /> no tiene ningún efecto sobre <c>innerstream</c>; <see langword="false" /> para indicar que el cierre de este <see cref="T:System.Net.Security.NegotiateStream" /> también provoca el de <paramref name="innerStream" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Net.Security.NegotiateStream" /> utilizando el objeto <see cref="T:System.IO.Stream" /> especificado y el comportamiento de cierre de secuencias.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al especificar `true` para el `leaveStreamOpen` parámetro, cierre el <xref:System.Net.Security.NegotiateStream> no tiene ningún efecto el `innerStream` transmitir; deberá cerrarlo usted expresamente `innerStream` cuando ya no necesita.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este constructor. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Net.Security.NegotiateStream> clase.  
  
 [!code-cpp[NclNegoAsyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#1)]
 [!code-csharp[NclNegoAsyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="innerStream" /> es <see langword="null" />.  
  
\- o - 
 <paramref name="innerStream" /> es igual a <see cref="F:System.IO.Stream.Null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lo llaman los clientes para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : unit -&gt; unit&#xA;override this.AuthenticateAsClient : unit -&gt; unit" Usage="negotiateStream.AuthenticateAsClient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lo llaman los clientes para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación utiliza el cliente <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, y se solicita la autenticación mutua. La <xref:System.Net.Security.NegotiateStream> clase construirá el SPN que se usa para la autenticación mutua.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como servidor. No puede utilizar la secuencia para reintentar la autenticación como cliente.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar la configuración explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, targetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * string -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * string -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="targetName">Nombre de entidad de seguridad de servicio (SPN) que identifica de forma única el servidor que se va a autenticar.</param>
        <summary>Lo llaman los clientes para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. El proceso de autenticación utiliza las credenciales de cliente especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, y se solicita la autenticación mutua. La <xref:System.Net.Security.NegotiateStream> clase construirá el SPN que se usa para la autenticación mutua.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como servidor. No puede utilizar la secuencia para reintentar la autenticación como cliente.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="targetName" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar la configuración explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, binding As ChannelBinding, targetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, binding, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="binding">Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> que se usa para la protección extendida.</param>
        <param name="targetName">Nombre de entidad de seguridad de servicio (SPN) que identifica de forma única el servidor que se va a autenticar.</param>
        <summary>Lo llaman los clientes para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. El proceso de autenticación utiliza las credenciales de cliente y el enlace de canal especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, y se solicita la autenticación mutua. La <xref:System.Net.Security.NegotiateStream> clase construirá el SPN que se usa para la autenticación mutua.  
  
 El <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> utilizado para la protección extendida que se pasa a este método en el `binding` parámetro se recuperaría por una aplicación de <xref:System.Net.Security.SslStream.TransportContext%2A> propiedad asociado <xref:System.Net.Security.SslStream>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="targetName" /> es <see langword="null" />.  
  
\- o - 
 El valor de <paramref name="credential" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como servidor. No puede utilizar la secuencia para reintentar la autenticación como cliente.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="targetName">Nombre de entidad de seguridad de servicio (SPN) que identifica de forma única el servidor que se va a autenticar.</param>
        <param name="requiredProtectionLevel">Uno de los valores de <see cref="T:System.Net.Security.ProtectionLevel" />, que indica los servicios de seguridad de la secuencia.</param>
        <param name="allowedImpersonationLevel">Uno de los valores de <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, que indica cómo puede utilizar el servidor las credenciales del cliente para tener acceso a los recursos.</param>
        <summary>Lo llaman los clientes para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. El proceso de autenticación utiliza las credenciales y las opciones de autenticación especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que el solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="allowedImpersonationLevel" /> no es un valor válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> es null.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como servidor. No puede utilizar la secuencia para reintentar la autenticación como cliente.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar la configuración explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsClient (credential As NetworkCredential, binding As ChannelBinding, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsClient (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="binding">Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> que se usa para la protección extendida.</param>
        <param name="targetName">Nombre de entidad de seguridad de servicio (SPN) que identifica de forma única el servidor que se va a autenticar.</param>
        <param name="requiredProtectionLevel">Uno de los valores de <see cref="T:System.Net.Security.ProtectionLevel" />, que indica los servicios de seguridad de la secuencia.</param>
        <param name="allowedImpersonationLevel">Uno de los valores de <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, que indica cómo puede utilizar el servidor las credenciales del cliente para tener acceso a los recursos.</param>
        <summary>Lo llaman los clientes para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. El proceso de autenticación utiliza las credenciales, las opciones de autenticación y el enlace de canal especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que el solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 El <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> utilizado para la protección extendida que se pasa a este método en el `binding` parámetro se recuperaría por una aplicación de <xref:System.Net.Security.SslStream.TransportContext%2A> propiedad asociado <xref:System.Net.Security.SslStream>.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="targetName" /> es <see langword="null" />.  
  
\- o - 
 El valor de <paramref name="credential" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="allowedImpersonationLevel" /> no es un valor válido.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como servidor. No puede utilizar la secuencia para reintentar la autenticación como cliente.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsClientAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lo llaman los clientes para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor como una operación asincrónica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : unit -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lo llaman los clientes para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor como una operación asincrónica.</summary>
        <returns>Devuelve <see cref="T:System.Threading.Tasks.Task" />  
  
Objeto de tarea que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación utiliza el cliente <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, y se solicita la autenticación mutua. La <xref:System.Net.Security.NegotiateStream> clase construirá el SPN que se usa para la autenticación mutua.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como servidor. No puede utilizar la secuencia para reintentar la autenticación como cliente.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar la configuración explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, targetName As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * string -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * string -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="targetName">Nombre de entidad de seguridad de servicio (SPN) que identifica de forma única el servidor que se va a autenticar.</param>
        <summary>Lo llaman los clientes para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor como una operación asincrónica. El proceso de autenticación utiliza las credenciales de cliente especificadas.</summary>
        <returns>Devuelve <see cref="T:System.Threading.Tasks.Task" />  
  
Objeto de tarea que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, y se solicita la autenticación mutua. La <xref:System.Net.Security.NegotiateStream> clase construirá el SPN que se usa para la autenticación mutua.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como servidor. No puede utilizar la secuencia para reintentar la autenticación como cliente.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="targetName" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar la configuración explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, binding As ChannelBinding, targetName As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, binding, targetName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="binding">Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> que se usa para la protección extendida.</param>
        <param name="targetName">Nombre de entidad de seguridad de servicio (SPN) que identifica de forma única el servidor que se va a autenticar.</param>
        <summary>Lo llaman los clientes para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor como una operación asincrónica. El proceso de autenticación utiliza las credenciales de cliente y el enlace de canal especificados.</summary>
        <returns>Devuelve <see cref="T:System.Threading.Tasks.Task" />  
  
Objeto de tarea que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>, y se solicita la autenticación mutua. La <xref:System.Net.Security.NegotiateStream> clase construirá el SPN que se usa para la autenticación mutua.  
  
 El <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> utilizado para la protección extendida que se pasa a este método en el `binding` parámetro se recuperaría por una aplicación de <xref:System.Net.Security.SslStream.TransportContext%2A> propiedad asociado <xref:System.Net.Security.SslStream>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="targetName" /> es <see langword="null" />.  
  
\- o - 
 El valor de <paramref name="credential" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como servidor. No puede utilizar la secuencia para reintentar la autenticación como cliente.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="targetName">Nombre de entidad de seguridad de servicio (SPN) que identifica de forma única el servidor que se va a autenticar.</param>
        <param name="requiredProtectionLevel">Uno de los valores de <see cref="T:System.Net.Security.ProtectionLevel" />, que indica los servicios de seguridad de la secuencia.</param>
        <param name="allowedImpersonationLevel">Uno de los valores de <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, que indica cómo puede utilizar el servidor las credenciales del cliente para tener acceso a los recursos.</param>
        <summary>Lo llaman los clientes para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor como una operación asincrónica. El proceso de autenticación utiliza las credenciales y las opciones de autenticación especificadas.</summary>
        <returns>Devuelve <see cref="T:System.Threading.Tasks.Task" />  
  
Objeto de tarea que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que el solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="allowedImpersonationLevel" /> no es un valor válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetName" /> es null.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como servidor. No puede utilizar la secuencia para reintentar la autenticación como cliente.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar la configuración explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsClientAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsClientAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsClientAsync (credential As NetworkCredential, binding As ChannelBinding, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsClientAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsClientAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsClientAsync (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="binding">Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> que se usa para la protección extendida.</param>
        <param name="targetName">Nombre de entidad de seguridad de servicio (SPN) que identifica de forma única el servidor que se va a autenticar.</param>
        <param name="requiredProtectionLevel">Uno de los valores de <see cref="T:System.Net.Security.ProtectionLevel" />, que indica los servicios de seguridad de la secuencia.</param>
        <param name="allowedImpersonationLevel">Uno de los valores de <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, que indica cómo puede utilizar el servidor las credenciales del cliente para tener acceso a los recursos.</param>
        <summary>Lo llaman los clientes para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor como una operación asincrónica. El proceso de autenticación utiliza las credenciales, las opciones de autenticación y el enlace de canal especificados.</summary>
        <returns>Devuelve <see cref="T:System.Threading.Tasks.Task" />  
  
Objeto de tarea que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que el solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 El <xref:System.Security.Authentication.ExtendedProtection.ChannelBinding> utilizado para la protección extendida que se pasa a este método en el `binding` parámetro se recuperaría por una aplicación de <xref:System.Net.Security.SslStream.TransportContext%2A> propiedad asociado <xref:System.Net.Security.SslStream>.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="targetName" /> es <see langword="null" />.  
  
\- o - 
 El valor de <paramref name="credential" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="allowedImpersonationLevel" /> no es un valor válido.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como servidor. No puede utilizar la secuencia para reintentar la autenticación como cliente.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controla el lado del servidor de una autenticación de una conexión cliente-servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estos métodos se bloquean mientras la autenticación está en curso. Para evitar que la aplicación se bloquea mientras espera a completar la autenticación, utilice el <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : unit -&gt; unit&#xA;override this.AuthenticateAsServer : unit -&gt; unit" Usage="negotiateStream.AuthenticateAsServer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lo llaman los servidores para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación utiliza el servidor <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, y el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Este método se bloquea hasta que se complete la operación. Para evitar el bloqueo hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> sobrecargas del método.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 y Windows 98 no se admiten.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar la configuración explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (policy As ExtendedProtectionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; unit&#xA;override this.AuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; unit" Usage="negotiateStream.AuthenticateAsServer policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> que se usa para la protección extendida.</param>
        <summary>Lo llaman los servidores para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. El proceso de autenticación utiliza la directiva de protección extendida especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación utiliza el servidor <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, y el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Si el `policy` parámetro es `null`, a continuación, se usa una directiva de protección extendida que tiene <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> establecido en <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Este método se bloquea hasta que se complete la operación. Para evitar el bloqueo hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> sobrecargas del método.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> y <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> en la directiva de protección extendida que se ha pasado en el parámetro <paramref name="policy" />, son <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 y Windows 98 no se admiten.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El parámetro <paramref name="policy" /> se estableció en <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> en una plataforma que no admite la protección extendida.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (credential As NetworkCredential, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsServer (credential, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del servidor.</param>
        <param name="requiredProtectionLevel">Uno de los valores de <see cref="T:System.Net.Security.ProtectionLevel" />, que indica los servicios de seguridad de la secuencia.</param>
        <param name="requiredImpersonationLevel">Uno de los valores de <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, que indica cómo puede utilizar el servidor las credenciales del cliente para tener acceso a los recursos.</param>
        <summary>Lo llaman los servidores para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. El proceso de autenticación utiliza las credenciales de servidor y las opciones de autenticación especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Este método se bloquea hasta que se complete la operación. Para evitar el bloqueo hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> sobrecargas del método.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="credential" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> debe ser <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> o <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /></exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para intentar repetir la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como cliente. No puede utilizar la secuencia para reintentar la autenticación como servidor.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 y Windows 98 no se admiten.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar la configuración explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateAsServer (credential As NetworkCredential, policy As ExtendedProtectionPolicy, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit&#xA;override this.AuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; unit" Usage="negotiateStream.AuthenticateAsServer (credential, policy, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="policy">Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> que se usa para la protección extendida.</param>
        <param name="requiredProtectionLevel">Uno de los valores de <see cref="T:System.Net.Security.ProtectionLevel" />, que indica los servicios de seguridad de la secuencia.</param>
        <param name="requiredImpersonationLevel">Uno de los valores de <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, que indica cómo puede utilizar el servidor las credenciales del cliente para tener acceso a los recursos.</param>
        <summary>Lo llaman los servidores para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. El proceso de autenticación utiliza las credenciales de servidor, las opciones de autenticación y la directiva de protección extendida especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `policy` parámetro es `null`, a continuación, se usa una directiva de protección extendida que tiene <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> establecido en <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Este método se bloquea hasta que se complete la operación. Para evitar el bloqueo hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> sobrecargas del método.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> y <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> en la directiva de protección extendida que se ha pasado en el parámetro <paramref name="policy" />, son <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="credential" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> debe ser <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> o <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /></exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para intentar repetir la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como cliente. No puede utilizar la secuencia para reintentar la autenticación como servidor.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 y Windows 98 no se admiten.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El parámetro <paramref name="policy" /> se estableció en <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> en una plataforma que no admite la protección extendida.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AuthenticateAsServerAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controla el lado del servidor de una autenticación de una conexión cliente-servidor como una operación asincrónica.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync();" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : unit -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lo llaman los servidores con el fin de autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor como una operación asincrónica.</summary>
        <returns>Devuelve <see cref="T:System.Threading.Tasks.Task" />  
  
Objeto de tarea que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación utiliza el servidor <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, y el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 y Windows 98 no se admiten.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar la configuración explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (policy As ExtendedProtectionPolicy) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> que se usa para la protección extendida.</param>
        <summary>Lo llaman los servidores con el fin de autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor como una operación asincrónica. El proceso de autenticación utiliza la directiva de protección extendida especificada.</summary>
        <returns>Devuelve <see cref="T:System.Threading.Tasks.Task" />  
  
Objeto de tarea que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación utiliza el servidor <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, y el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Si el `policy` parámetro es `null`, a continuación, se usa una directiva de protección extendida que tiene <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> establecido en <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> y <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> en la directiva de protección extendida que se ha pasado en el parámetro <paramref name="policy" />, son <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 y Windows 98 no se admiten.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El parámetro <paramref name="policy" /> se estableció en <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> en una plataforma que no admite la protección extendida.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (credential As NetworkCredential, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync (credential, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del servidor.</param>
        <param name="requiredProtectionLevel">Uno de los valores de <see cref="T:System.Net.Security.ProtectionLevel" />, que indica los servicios de seguridad de la secuencia.</param>
        <param name="requiredImpersonationLevel">Uno de los valores de <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, que indica cómo puede utilizar el servidor las credenciales del cliente para tener acceso a los recursos.</param>
        <summary>Lo llaman los servidores con el fin de autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor como una operación asincrónica. El proceso de autenticación utiliza las credenciales de servidor y las opciones de autenticación especificadas.</summary>
        <returns>Devuelve <see cref="T:System.Threading.Tasks.Task" />  
  
Objeto de tarea que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="credential" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> debe ser <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> o <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /></exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para intentar repetir la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como cliente. No puede utilizar la secuencia para reintentar la autenticación como servidor.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 y Windows 98 no se admiten.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar la configuración explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateAsServerAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task AuthenticateAsServerAsync(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AuthenticateAsServerAsync (credential As NetworkCredential, policy As ExtendedProtectionPolicy, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As TokenImpersonationLevel) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ AuthenticateAsServerAsync(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task&#xA;override this.AuthenticateAsServerAsync : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.AuthenticateAsServerAsync (credential, policy, requiredProtectionLevel, requiredImpersonationLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="policy">Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> que se usa para la protección extendida.</param>
        <param name="requiredProtectionLevel">Uno de los valores de <see cref="T:System.Net.Security.ProtectionLevel" />, que indica los servicios de seguridad de la secuencia.</param>
        <param name="requiredImpersonationLevel">Uno de los valores de <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, que indica cómo puede utilizar el servidor las credenciales del cliente para tener acceso a los recursos.</param>
        <summary>Lo llaman los servidores con el fin de autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor como una operación asincrónica. El proceso de autenticación utiliza las credenciales de servidor, las opciones de autenticación y la directiva de protección extendida especificadas.</summary>
        <returns>Devuelve <see cref="T:System.Threading.Tasks.Task" />  
  
Objeto de tarea que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `policy` parámetro es `null`, a continuación, se usa una directiva de protección extendida que tiene <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> establecido en <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> y <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> en la directiva de protección extendida que se ha pasado en el parámetro <paramref name="policy" />, son <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="credential" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> debe ser <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> o <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /></exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para intentar repetir la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como cliente. No puede utilizar la secuencia para reintentar la autenticación como servidor.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 y Windows 98 no se admiten.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El parámetro <paramref name="policy" /> se estableció en <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> en una plataforma que no admite la protección extendida.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsClient">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza una operación asincrónica para autenticar el cliente de una conexión cliente-servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de este método no bloquea mientras la autenticación está en curso. Para bloquear mientras espera a completar la autenticación, utilice uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> métodos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="asyncCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la autenticación se complete.</param>
        <param name="asyncState">Un objeto definido por el usuario que contiene información sobre la operación. Este objeto se pasa al delegado de <paramref name="asyncCallback" /> cuando la operación ha terminado.</param>
        <summary>Lo llaman los clientes para comenzar una operación asincrónica para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. Este método no se bloquea.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que indica el estado de la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación utiliza el cliente <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, y el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>. La <xref:System.Net.Security.NegotiateStream> clase construirá el SPN que se usa para la autenticación mutua.  
  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> sobrecargas del método.  
  
 Debe completar la operación asincrónica de la autenticación mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a este método para comenzar una autenticación asincrónica para el cliente.  
  
 [!code-cpp[NclNegoAsyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#2)]
 [!code-csharp[NclNegoAsyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como servidor. No puede utilizar la secuencia para reintentar la autenticación como cliente.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar la configuración explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * string * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * string * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, targetName, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="targetName">Nombre de entidad de seguridad de servicio (SPN) que identifica de forma única el servidor que se va a autenticar.</param>
        <param name="asyncCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la autenticación se complete.</param>
        <param name="asyncState">Objeto definido por el usuario que contiene información sobre la operación de escritura. Este objeto se pasa al delegado de <paramref name="asyncCallback" /> cuando la operación ha terminado.</param>
        <summary>Lo llaman los clientes para comenzar una operación asincrónica para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. El proceso de autenticación utiliza las credenciales especificadas. Este método no se bloquea.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que indica el estado de la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> sobrecargas del método.  
  
 Debe completar la operación asincrónica de la autenticación mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="credential" /> es <see langword="null" />.  
  
\- o - 
 El valor de <paramref name="targetName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como servidor. No puede utilizar la secuencia para reintentar la autenticación como cliente.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar la configuración explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, binding, targetName, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="binding">Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> que se usa para la protección extendida.</param>
        <param name="targetName">Nombre de entidad de seguridad de servicio (SPN) que identifica de forma única el servidor que se va a autenticar.</param>
        <param name="asyncCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la autenticación se complete.</param>
        <param name="asyncState">Objeto definido por el usuario que contiene información sobre la operación de escritura. Este objeto se pasa al delegado de <paramref name="asyncCallback" /> cuando la operación ha terminado.</param>
        <summary>Lo llaman los clientes para comenzar una operación asincrónica para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. El proceso de autenticación utiliza las credenciales y el enlace de canal especificados. Este método no se bloquea.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que indica el estado de la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> sobrecargas del método.  
  
 Debe completar la operación asincrónica de la autenticación mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="credential" /> es <see langword="null" />.  
  
\- o - 
 El valor de <paramref name="targetName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como servidor. No puede utilizar la secuencia para reintentar la autenticación como cliente.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, targetName, requiredProtectionLevel, allowedImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="targetName">Nombre de entidad de seguridad de servicio (SPN) que identifica de forma única el servidor que se va a autenticar.</param>
        <param name="requiredProtectionLevel">Uno de los valores de <see cref="T:System.Net.Security.ProtectionLevel" />, que indica los servicios de seguridad de la secuencia.</param>
        <param name="allowedImpersonationLevel">Uno de los valores de <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, que indica cómo puede utilizar el servidor las credenciales del cliente para tener acceso a los recursos.</param>
        <param name="asyncCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la autenticación se complete.</param>
        <param name="asyncState">Objeto definido por el usuario que contiene información sobre la operación de escritura. Este objeto se pasa al delegado de <paramref name="asyncCallback" /> cuando la operación ha terminado.</param>
        <summary>Lo llaman los clientes para comenzar una operación asincrónica para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. El proceso de autenticación utiliza las credenciales y las opciones de autenticación especificadas. Este método no se bloquea.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que indica el estado de la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que el solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> sobrecargas del método.  
  
 Debe completar la operación asincrónica de la autenticación mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="credential" /> es <see langword="null" />.  
  
\- o - 
 El valor de <paramref name="targetName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como servidor. No puede utilizar la secuencia para reintentar la autenticación como cliente.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar la configuración explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsClient (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsClient(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ChannelBinding binding, string targetName, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel allowedImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsClient(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ChannelBinding ^ binding, System::String ^ targetName, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsClient : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ChannelBinding * string * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsClient (credential, binding, targetName, requiredProtectionLevel, allowedImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="binding" Type="System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <Parameter Name="targetName" Type="System.String" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="allowedImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="binding">Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> que se usa para la protección extendida.</param>
        <param name="targetName">Nombre de entidad de seguridad de servicio (SPN) que identifica de forma única el servidor que se va a autenticar.</param>
        <param name="requiredProtectionLevel">Uno de los valores de <see cref="T:System.Net.Security.ProtectionLevel" />, que indica los servicios de seguridad de la secuencia.</param>
        <param name="allowedImpersonationLevel">Uno de los valores de <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, que indica cómo puede utilizar el servidor las credenciales del cliente para tener acceso a los recursos.</param>
        <param name="asyncCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la autenticación se complete.</param>
        <param name="asyncState">Objeto definido por el usuario que contiene información sobre la operación de escritura. Este objeto se pasa al delegado de <paramref name="asyncCallback" /> cuando la operación ha terminado.</param>
        <summary>Lo llaman los clientes para comenzar una operación asincrónica para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. El proceso de autenticación utiliza las credenciales, las opciones de autenticación y el enlace de canal especificados. Este método no se bloquea.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que indica el estado de la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que el solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> sobrecargas del método.  
  
 Debe completar la operación asincrónica de la autenticación mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsClient%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="credential" /> es <see langword="null" />.  
  
\- o - 
 El valor de <paramref name="targetName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como servidor. No puede utilizar la secuencia para reintentar la autenticación como cliente.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAuthenticateAsServer">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza una operación asincrónica para controlar la autenticación del servidor de una conexión cliente-servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de este método no bloquea mientras la autenticación está en curso. Para bloquear mientras espera a completar la autenticación, utilice el <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="asyncCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la autenticación se complete.</param>
        <param name="asyncState">Un objeto definido por el usuario que contiene información sobre la operación. Este objeto se pasa al delegado de <paramref name="asyncCallback" /> cuando la operación ha terminado.</param>
        <summary>Lo llaman los servidores para comenzar una operación asincrónica para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. Este método no se bloquea.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que indica el estado de la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación utiliza el servidor <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> sobrecargas del método.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 y Windows 98 no se admiten.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar la configuración explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (policy, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="policy">Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> que se usa para la protección extendida.</param>
        <param name="asyncCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la autenticación se complete.</param>
        <param name="asyncState">Objeto definido por el usuario que contiene información sobre la operación de escritura. Este objeto se pasa al delegado de <paramref name="asyncCallback" /> cuando la operación ha terminado.</param>
        <summary>Lo llaman los servidores para comenzar una operación asincrónica para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. El proceso de autenticación utiliza la directiva de protección extendida especificada. Este método no se bloquea.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que indica el estado de la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación utiliza el servidor <xref:System.Net.CredentialCache.DefaultCredentials%2A>. Se especifica ningún nombre Principal de servicio (SPN) para el servidor. El nivel de suplantación es <xref:System.Security.Principal.TokenImpersonationLevel.Identification>, el nivel de seguridad es <xref:System.Net.Security.ProtectionLevel.EncryptAndSign>.  
  
 Si el `policy` parámetro es `null`, a continuación, se usa una directiva de protección extendida que tiene <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> establecido en <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> sobrecargas del método.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> y <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> en la directiva de protección extendida que se ha pasado en el parámetro <paramref name="policy" />, son <see langword="null" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 y Windows 98 no se admiten.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El parámetro <paramref name="policy" /> se estableció en <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> en una plataforma que no admite la protección extendida.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (credential, requiredProtectionLevel, requiredImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="requiredProtectionLevel">Uno de los valores de <see cref="T:System.Net.Security.ProtectionLevel" />, que indica los servicios de seguridad de la secuencia.</param>
        <param name="requiredImpersonationLevel">Uno de los valores de <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, que indica cómo puede utilizar el servidor las credenciales del cliente para tener acceso a los recursos.</param>
        <param name="asyncCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la autenticación se complete.</param>
        <param name="asyncState">Un objeto definido por el usuario que contiene información sobre la operación. Este objeto se pasa al delegado de <paramref name="asyncCallback" /> cuando la operación ha terminado.</param>
        <summary>Lo llaman los servidores para comenzar una operación asincrónica para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. El proceso de autenticación utiliza las credenciales de servidor y las opciones de autenticación especificadas. Este método no se bloquea.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que indica el estado de la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que, solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> sobrecargas del método.  
  
 Debe completar la operación asincrónica de la autenticación mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="credential" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> debe ser <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> o <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /></exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como cliente. No puede utilizar la secuencia para reintentar la autenticación como servidor.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 y Windows 98 no se admiten.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar la configuración explícita <see cref="T:System.Net.NetworkCredential" />. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginAuthenticateAsServer (System.Net.NetworkCredential credential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, System.Net.Security.ProtectionLevel requiredProtectionLevel, System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginAuthenticateAsServer(class System.Net.NetworkCredential credential, class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy policy, valuetype System.Net.Security.ProtectionLevel requiredProtectionLevel, valuetype System.Security.Principal.TokenImpersonationLevel requiredImpersonationLevel, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginAuthenticateAsServer(System::Net::NetworkCredential ^ credential, System::Security::Authentication::ExtendedProtection::ExtendedProtectionPolicy ^ policy, System::Net::Security::ProtectionLevel requiredProtectionLevel, System::Security::Principal::TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="abstract member BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginAuthenticateAsServer : System.Net.NetworkCredential * System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy * System.Net.Security.ProtectionLevel * System.Security.Principal.TokenImpersonationLevel * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginAuthenticateAsServer (credential, policy, requiredProtectionLevel, requiredImpersonationLevel, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="credential" Type="System.Net.NetworkCredential" />
        <Parameter Name="policy" Type="System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <Parameter Name="requiredProtectionLevel" Type="System.Net.Security.ProtectionLevel" />
        <Parameter Name="requiredImpersonationLevel" Type="System.Security.Principal.TokenImpersonationLevel" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="credential">
          <see cref="T:System.Net.NetworkCredential" /> que se utiliza para establecer la identidad del cliente.</param>
        <param name="policy">Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" /> que se usa para la protección extendida.</param>
        <param name="requiredProtectionLevel">Uno de los valores de <see cref="T:System.Net.Security.ProtectionLevel" />, que indica los servicios de seguridad de la secuencia.</param>
        <param name="requiredImpersonationLevel">Uno de los valores de <see cref="T:System.Security.Principal.TokenImpersonationLevel" />, que indica cómo puede utilizar el servidor las credenciales del cliente para tener acceso a los recursos.</param>
        <param name="asyncCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se invocará cuando la autenticación se complete.</param>
        <param name="asyncState">Objeto definido por el usuario que contiene información sobre la operación de escritura. Este objeto se pasa al delegado de <paramref name="asyncCallback" /> cuando la operación ha terminado.</param>
        <summary>Lo llaman los servidores para comenzar una operación asincrónica para autenticar el cliente, y opcionalmente el servidor, en una conexión cliente-servidor. El proceso de autenticación utiliza las credenciales de servidor, las opciones de autenticación y la directiva de protección extendida especificadas. Este método no se bloquea.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que indica el estado de la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el `requiredProtectionLevel` parámetro de solicitud de servicios de seguridad de los datos transmitidos mediante la secuencia autenticada. Por ejemplo, para que los datos cifrados y firmados, especificar la <xref:System.Net.Security.ProtectionLevel.EncryptAndSign> valor. Autenticación correcta no garantiza que, solicitado <xref:System.Net.Security.ProtectionLevel> se ha concedido. Debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>.  
  
 Si el `policy` parámetro es `null`, a continuación, se usa una directiva de protección extendida que tiene <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> establecido en <xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never>.  
  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, use uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> sobrecargas del método.  
  
 Debe completar la operación asincrónica de la autenticación mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndAuthenticateAsServer%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding" /> y <see cref="P:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames" /> en la directiva de protección extendida que se ha pasado en el parámetro <paramref name="policy" />, son <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="credential" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="requiredImpersonationLevel" /> debe ser <see cref="F:System.Security.Principal.TokenImpersonationLevel.Identification" />, <see cref="F:System.Security.Principal.TokenImpersonationLevel.Impersonation" /> o <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" /></exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.InvalidOperationException">Ya se ha producido la autenticación.  
  
\- o - 
Esta secuencia se ha utilizado previamente para intentar la autenticación como cliente. No puede utilizar la secuencia para reintentar la autenticación como servidor.</exception>
        <exception cref="T:System.NotSupportedException">Windows 95 y Windows 98 no se admiten.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">El parámetro <paramref name="policy" /> se estableció en <see cref="F:System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always" /> en una plataforma que no admite la protección extendida.</exception>
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
        <related type="Article" href="~/docs/framework/network-programming/integrated-windows-authentication-with-extended-protection.md">Autenticación de Windows integrada con protección ampliada</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginRead (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz <see cref="T:System.Byte" /> que recibe los bytes leídos de la secuencia.</param>
        <param name="offset">Posición de base cero de <paramref name="buffer" /> donde se comienzan a almacenar los datos leídos de esta secuencia.</param>
        <param name="count">Número máximo de bytes que se van a leer de la secuencia.</param>
        <param name="asyncCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se va a invocar una vez finalizada la operación de lectura.</param>
        <param name="asyncState">Objeto definido por el usuario que contiene información sobre la operación de lectura. Este objeto se pasa al delegado de <paramref name="asyncCallback" /> cuando la operación ha terminado.</param>
        <summary>Inicia una operación de lectura asincrónica que lee los datos de la secuencia y los almacena en la matriz especificada.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que indica el estado de la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si están habilitados el cifrado, firma, o cifrado y firma, la operación de lectura lee los datos de la secuencia subyacente, comprueba la integridad de los datos y lo descifra. Si ningún servicio de seguridad, como el cifrado de datos o de firma están en uso, este método inicia una operación de lectura asincrónica en la secuencia subyacente.  
  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, utilice el <xref:System.Net.Security.NegotiateStream.Read%2A> método.  
  
 La operación de lectura asincrónica debe realizarse mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndRead%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 La <xref:System.Net.Security.NegotiateStream> clase no admite varias de las operaciones de lectura simultáneas. Si intenta iniciar una operación de lectura mientras otra lectura operación ya se está ejecutando en la misma secuencia, un <xref:System.NotSupportedException> se producirá la excepción.  
  
 No se puede llamar este método hasta que se haya autenticado correctamente. Para autenticar, llame a uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo iniciar una operación de lectura asincrónica. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Net.Security.NegotiateStream> clase.  
  
 [!code-cpp[NclNegoAsyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#1)]
 [!code-csharp[NclNegoAsyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> es menor que 0.  
  
\- o - 
 <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.  
  
\- o - 
 <paramref name="offset" /> más <paramref name="count" /> es mayor que la longitud de <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error en la operación de lectura.  
  
\- o - 
El cifrado está en uso, pero los datos no se pudieron descifrar.</exception>
        <exception cref="T:System.NotSupportedException">Ya hay una operación de lectura en curso.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha producido la autenticación.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback asyncCallback, object asyncState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ asyncCallback, System::Object ^ asyncState);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="negotiateStream.BeginWrite (buffer, offset, count, asyncCallback, asyncState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="asyncCallback" Type="System.AsyncCallback" />
        <Parameter Name="asyncState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz <see cref="T:System.Byte" /> que proporciona los bytes que se van a escribir en la secuencia.</param>
        <param name="offset">La ubicación de base cero de <paramref name="buffer" /> en la que se va a empezar a leer los bytes que se van a escribir en la secuencia.</param>
        <param name="count">Valor de <see cref="T:System.Int32" /> que especifica el número de bytes que se van a al leer desde <paramref name="buffer" />.</param>
        <param name="asyncCallback">Delegado de <see cref="T:System.AsyncCallback" /> que hace referencia al método que se va a invocar una vez finalizada la operación de escritura.</param>
        <param name="asyncState">Objeto definido por el usuario que contiene información sobre la operación de escritura. Este objeto se pasa al delegado de <paramref name="asyncCallback" /> cuando la operación ha terminado.</param>
        <summary>Inicia una operación de escritura asincrónica que escribe <see cref="T:System.Byte" />s desde el búfer especificado en la secuencia.</summary>
        <returns>Objeto <see cref="T:System.IAsyncResult" /> que indica el estado de la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si están habilitados el cifrado, firma, o cifrado y firma, este método lee los datos del búfer, cifra, firma o cifra y lo firma y transmite mediante la secuencia subyacente. Si ningún servicio de seguridad, como el cifrado de datos o de firma están en uso, este método inicia una operación de escritura asincrónica en la secuencia subyacente.  
  
 Este método es asincrónico y no se bloquea mientras se completa la operación. Para bloquear hasta que se complete la operación, utilice el <xref:System.Net.Security.NegotiateStream.Read%2A> método.  
  
 La operación de lectura asincrónica debe realizarse mediante una llamada a la <xref:System.Net.Security.NegotiateStream.EndWrite%2A> método. Normalmente, se invoca el método por el `asyncCallback` delegar. Para obtener información detallada acerca de cómo utilizar el modelo de programación asincrónico, vea [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 La <xref:System.Net.Security.NegotiateStream> clase no admite varias operaciones de escritura simultáneas. Si intenta iniciar una operación de escritura cuando ya se está ejecutando otra operación de escritura en la misma secuencia, un <xref:System.NotSupportedException> se producirá la excepción.  
  
 No se puede llamar este método hasta que se haya autenticado correctamente. Para autenticar, llame a uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra a partir de una operación de escritura asincrónica.  
  
 [!code-cpp[NclNegoAsyncClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#3)]
 [!code-csharp[NclNegoAsyncClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#3)]  
  
 El siguiente método se llama cuando se complete la operación.  
  
 [!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
 [!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset is less than 0" />.  
  
\- o - 
 <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.  
  
\- o - 
 La suma de <paramref name="offset" /> y el recuento es mayor que la longitud de <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">No se pudo realizar la operación de escritura.  
  
\- o - 
El cifrado está en uso, pero no se pudieron cifrar los datos.</exception>
        <exception cref="T:System.NotSupportedException">Ya hay una operación de escritura en curso.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha producido la autenticación.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Net.Security.NegotiateStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor <see cref="T:System.Boolean" /> que indica si se puede leer la secuencia subyacente.</summary>
        <value>
          <see langword="true" /> si se ha efectuado la autenticación y la secuencia subyacente es legible; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se ha producido una autenticación correcta, esta propiedad devuelve el valor devuelto al invocar el <xref:System.IO.Stream.CanRead%2A> propiedad en la secuencia subyacente. La secuencia subyacente se especifica cuando se crea una instancia de la <xref:System.Net.Security.NegotiateStream> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Net.Security.NegotiateStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor <see cref="T:System.Boolean" /> que indica si se puede buscar en la secuencia subyacente.</summary>
        <value>Esta propiedad devuelve siempre <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No debe intentar establecer la posición de la <xref:System.Net.Security.NegotiateStream> objeto o la secuencia subyacente. La secuencia subyacente se especifica cuando se crea una instancia de la <xref:System.Net.Security.NegotiateStream> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Security.NegotiateStream.Position" />
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public override bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.Net.Security.NegotiateStream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor <see cref="T:System.Boolean" /> que indica si la secuencia subyacente admite tiempos de espera.</summary>
        <value>Es <see langword="true" /> si la secuencia subyacente admite tiempos de espera; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el valor devuelto al invocar el <xref:System.IO.Stream.CanTimeout%2A> propiedad en la secuencia subyacente. La secuencia subyacente se especifica cuando se crea una instancia de la <xref:System.Net.Security.NegotiateStream> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Net.Security.NegotiateStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor <see cref="T:System.Boolean" /> que indica si se puede escribir en la secuencia subyacente.</summary>
        <value>
          <see langword="true" /> si se ha efectuado la autenticación y se puede escribir la secuencia subyacente; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se ha producido una autenticación correcta, esta propiedad devuelve el valor devuelto al invocar el <xref:System.IO.Stream.CanWrite%2A> propiedad en la secuencia subyacente. La secuencia subyacente se especifica cuando se crea una instancia de la <xref:System.Net.Security.NegotiateStream> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="negotiateStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.Net.Security.NegotiateStream" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama por el público `Dispose()` método y el <xref:System.Object.Finalize%2A> método. `Dispose()` invoca el protegido `Dispose(Boolean)` método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` con `disposing` establecido en `false`.  
  
 Cuando el `disposing` parámetro es true, este método libera todos los recursos mantenidos por los objetos administrados que este <xref:System.Net.Security.NegotiateStream> referencias. Este método invoca al método `Dispose()` de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> puede recibir varias llamadas de otros objetos. Cuando se reemplaza <see langword="Dispose(Boolean)" /> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />. Para obtener más información sobre cómo implementar <see langword="Dispose(Boolean)" />, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obtener más información acerca de <see langword="Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [reemplazar el método Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsClient">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsClient (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsClient(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsClient : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsClient : IAsyncResult -&gt; unit" Usage="negotiateStream.EndAuthenticateAsClient asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Una instancia <see cref="T:System.IAsyncResult" /> devuelta por una llamada a <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</param>
        <summary>Finaliza una operación de autenticación del cliente asincrónica pendiente que se inició con una llamada a <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se ha completado la operación, este método se bloquea hasta que lo haga. Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 Para realizar esta operación sincrónicamente, utilice uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="asyncResult" /> no se creó mediante una llamada a <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.InvalidOperationException">No queda ninguna autenticación de cliente sin finalizar.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAuthenticateAsServer">
      <MemberSignature Language="C#" Value="public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndAuthenticateAsServer(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndAuthenticateAsServer (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndAuthenticateAsServer(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndAuthenticateAsServer : IAsyncResult -&gt; unit&#xA;override this.EndAuthenticateAsServer : IAsyncResult -&gt; unit" Usage="negotiateStream.EndAuthenticateAsServer asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Una instancia <see cref="T:System.IAsyncResult" /> devuelta por una llamada a <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</param>
        <summary>Finaliza una operación de autenticación del cliente asincrónica pendiente que se inició con una llamada a <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se ha completado la operación, este método se bloquea hasta que lo haga.  
  
 Cuando la autenticación se realiza correctamente, debe comprobar la <xref:System.Net.Security.NegotiateStream.IsEncrypted%2A> y <xref:System.Net.Security.NegotiateStream.IsSigned%2A> propiedades para determinar qué servicios de seguridad se usan por el <xref:System.Net.Security.NegotiateStream>. Compruebe el <xref:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated%2A> propiedad para determinar si ocurrió una autenticación mutua.  
  
 Si se produce un error en la autenticación, recibirá un <xref:System.Security.Authentication.AuthenticationException> o <xref:System.Security.Authentication.InvalidCredentialException>. En este caso, puede volver a intentar la autenticación con una credencial distinta.  
  
 Para realizar esta operación sincrónicamente, utilice el <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="asyncResult" /> no se creó mediante una llamada a <see cref="Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer" />.</exception>
        <exception cref="T:System.Security.Authentication.AuthenticationException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.Security.Authentication.InvalidCredentialException">Se produjo un error en la autenticación. Puede utilizar este objeto para reintentar la autenticación.</exception>
        <exception cref="T:System.InvalidOperationException">No hay ninguna autenticación pendiente de finalizar.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="negotiateStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Una instancia <see cref="T:System.IAsyncResult" /> devuelta por una llamada a <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Finaliza una operación de lectura asincrónica que se inició con una llamada a <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <returns>Valor <see cref="T:System.Int32" /> que especifica el número de bytes leídos de la secuencia subyacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se ha completado la operación, este método se bloquea hasta que lo haga.  
  
 Para realizar esta operación sincrónicamente, utilice el <xref:System.Net.Security.NegotiateStream.Read%2A> método.  
  
 No se puede llamar este método hasta que se haya autenticado correctamente. Para autenticar, llame a uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra de fin asincrónico la operación de lectura. Para obtener un ejemplo que muestra cómo iniciar la operación, vea <xref:System.Net.Security.NegotiateStream.BeginRead%2A>.  
  
 [!code-cpp[NclNegoAsyncServer#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#3)]
 [!code-csharp[NclNegoAsyncServer#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">asyncResult no se creó mediante una llamada a <see cref="M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha producido la autenticación.</exception>
        <exception cref="T:System.IO.IOException">Se ha producido un error en la operación de lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="negotiateStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Una instancia <see cref="T:System.IAsyncResult" /> devuelta por una llamada a <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /></param>
        <summary>Finaliza una operación de escritura asincrónica que se inició con una llamada a <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se ha completado la operación, este método se bloquea hasta que lo haga.  
  
 No se puede llamar este método hasta que se haya autenticado correctamente. Para autenticar, llame a uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
 Para realizar esta operación sincrónicamente, utilice el <xref:System.Net.Security.NegotiateStream.Write%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra un método que se llama para completar la operación de escritura asincrónica. Para obtener un ejemplo que muestra cómo iniciar la operación, vea <xref:System.Net.Security.NegotiateStream.BeginWrite%2A>.  
  
 [!code-cpp[NclNegoAsyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoasyncClient/CPP/NclNegoasyncClient.cpp#4)]
 [!code-csharp[NclNegoAsyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoasyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">asyncResult no se creó mediante una llamada a <see cref="M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha producido la autenticación.</exception>
        <exception cref="T:System.IO.IOException">No se pudo realizar la operación de escritura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="negotiateStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Provoca la escritura de los datos almacenados en el búfer del dispositivo subyacente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invoca <xref:System.IO.Stream.Flush%2A> en la secuencia subyacente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra vuelca la secuencia.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="negotiateStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); };" />
      <MemberSignature Language="F#" Value="member this.ImpersonationLevel : System.Security.Principal.TokenImpersonationLevel" Usage="System.Net.Security.NegotiateStream.ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica cómo puede utilizar el servidor las credenciales del cliente.</summary>
        <value>Uno de los valores de <see cref="T:System.Security.Principal.TokenImpersonationLevel" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe autenticar correctamente antes de llamar a este método. Los clientes especificar el nivel de suplantación cuando solicitan la autenticación mediante una llamada a uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> métodos. Si se autentica sin especificar un <xref:System.Security.Principal.TokenImpersonationLevel> , <xref:System.Security.Principal.TokenImpersonationLevel.Identification> se utiliza.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se produjo un error de autenticación o ésta no se produjo.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Net.Security.NegotiateStream.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor <see cref="T:System.Boolean" /> que indica si la autenticación se realizó correctamente.</summary>
        <value>Es <see langword="true" /> si la autenticación se realizó correctamente; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los clientes autenticarse mediante una llamada a la <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A> o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A> métodos. Los servidores autenticarán mediante una llamada a la <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public override bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsEncrypted" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEncrypted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEncrypted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEncrypted : bool" Usage="System.Net.Security.NegotiateStream.IsEncrypted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor <see cref="T:System.Boolean" /> que indica si esta clase <see cref="T:System.Net.Security.NegotiateStream" /> utiliza el cifrado de datos.</summary>
        <value>
          <see langword="true" /> si los datos se cifran antes de transmitirse a través de la red y se descifran al llegar al extremo remoto; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El cifrado ayuda a proteger la privacidad de los datos; es decir, ayuda a garantizar que haya datos en tránsito no se puede descifrar un tercero.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Security.ProtectionLevel" />
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public override bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsMutuallyAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMutuallyAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMutuallyAuthenticated : bool" Usage="System.Net.Security.NegotiateStream.IsMutuallyAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor <see cref="T:System.Boolean" /> que indica si se han autenticado el cliente y el servidor.</summary>
        <value>
          <see langword="true" /> si se ha autenticado el servidor; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La autenticación mutua es especificada por el cliente cuando el cliente desea que el servidor para proporcionar las credenciales para la autenticación. De forma predeterminada, los clientes solicitan la autenticación mutua.  
  
 El protocolo de negociación selecciona NTLM o Kerberos dependiendo de los protocolos de seguridad admitidos por el cliente y servidor. NTLM no admite la autenticación mutua.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public override bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsServer" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsServer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsServer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsServer : bool" Usage="System.Net.Security.NegotiateStream.IsServer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor <see cref="T:System.Boolean" /> que indica si el lado local de la conexión utilizada por <see cref="T:System.Net.Security.NegotiateStream" /> se autenticó como el servidor.</summary>
        <value>Es <see langword="true" /> si el extremo local se autenticó correctamente como el lado del servidor de la conexión autenticada; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la autenticación no se pudo o no se ha producido, esta propiedad devuelve `false`.  
  
 Para autenticar que el servidor, llame a la <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A> o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public override bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.IsSigned" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSigned As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSigned { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSigned : bool" Usage="System.Net.Security.NegotiateStream.IsSigned" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor <see cref="T:System.Boolean" /> que indica si los datos enviados utilizando esta secuencia tienen signo.</summary>
        <value>Es <see langword="true" /> si los datos se firman antes de transmitirse; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Firma de datos ayuda a proteger la integridad de los datos; es decir, ayuda al destinatario a determinar si se ha alterado los datos mientras están en tránsito.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#1)]
 [!code-csharp[NclNegoSyncClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Net.Security.NegotiateStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la longitud de la secuencia subyacente.</summary>
        <value>
          <see cref="T:System.Int64" /> que especifica la longitud de la secuencia subyacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el valor devuelto al invocar el <xref:System.IO.Stream.Length%2A> propiedad en la secuencia subyacente. Si no se puede buscar la secuencia subyacente, esta propiedad normalmente producirá una excepción. El tipo de tiempo de ejecución de la secuencia subyacente determina el tipo de tiempo de ejecución de la excepción que se produce.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La obtención del valor de esta propiedad no se admite cuando la secuencia subyacente es una <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Net.Security.NegotiateStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la posición actual en la secuencia subyacente.</summary>
        <value>
          <see cref="T:System.Int64" /> que especifica la posición actual en la secuencia subyacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el valor devuelto al invocar el <xref:System.IO.Stream.Position%2A> propiedad en la secuencia subyacente. Si no se puede buscar la secuencia subyacente, esta propiedad normalmente producirá una excepción. El tipo de tiempo de ejecución de la secuencia subyacente determina el tipo de tiempo de ejecución de la excepción que se produce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">No se admite el establecimiento de esta propiedad.  
  
\- o - 
La obtención del valor de esta propiedad no se admite cuando la secuencia subyacente es una <see cref="T:System.Net.Sockets.NetworkStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="negotiateStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz <see cref="T:System.Byte" /> que recibe los bytes leídos de la secuencia.</param>
        <param name="offset">
          <see cref="T:System.Int32" /> que contiene la ubicación de base cero de <paramref name="buffer" /> donde se comienza a almacenar los datos leídos de esta secuencia.</param>
        <param name="count">
          <see cref="T:System.Int32" /> que contiene el número máximo de bytes que se van a leer de la secuencia.</param>
        <summary>Lee datos de esta secuencia y los almacena en la matriz especificada.</summary>
        <returns>Valor <see cref="T:System.Int32" /> que especifica el número de bytes leídos de la secuencia subyacente. Cuando ya no quedan datos por leer, devuelve 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método lee un máximo de `count` secuencia de bytes del actual y los almacena en `buffer` comenzando por `offset`.  
  
 No se puede llamar este método hasta que se haya autenticado correctamente. Para autenticar, llame a uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
 Para realizar esta operación asincrónicamente, utilice el <xref:System.Net.Security.NegotiateStream.BeginRead%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo leer desde un <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncServer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncServer/CPP/NclNegoSyncServer.cpp#1)]
 [!code-csharp[NclNegoSyncServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncServer/CS/server.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se ha producido un error en la operación de lectura.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha producido la autenticación.</exception>
        <exception cref="T:System.NotSupportedException">Una operación <see cref="M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)" /> ya está en curso.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public override int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.Net.Security.NegotiateStream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el período de tiempo que se bloquea una operación de lectura mientras espera datos.</summary>
        <value>
          <see cref="T:System.Int32" /> que especifica la cantidad de tiempo que pasará antes de que falle una operación de lectura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el valor devuelto al invocar el <xref:System.IO.Stream.ReadTimeout%2A> propiedad en la secuencia subyacente. Al establecer esta propiedad, el <xref:System.IO.Stream.ReadTimeout%2A> valor en la secuencia subyacente se establece en el valor especificado.  
  
 Si la secuencia subyacente es un <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.NegotiateStream.ReadTimeout%2A> está en milisegundos y se establece en <xref:System.Threading.Timeout.Infinite> de forma predeterminada para que las operaciones no tienen tiempo de espera de lectura.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteIdentity">
      <MemberSignature Language="C#" Value="public virtual System.Security.Principal.IIdentity RemoteIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity RemoteIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.RemoteIdentity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RemoteIdentity As IIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::IIdentity ^ RemoteIdentity { System::Security::Principal::IIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteIdentity : System.Security.Principal.IIdentity" Usage="System.Net.Security.NegotiateStream.RemoteIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene información sobre la identidad de la parte remota que comparte esta secuencia autenticada.</summary>
        <value>Objeto <see cref="T:System.Security.Principal.IIdentity" /> que describe la identidad del extremo remoto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se tiene acceso por el cliente, esta propiedad devuelve un <xref:System.Security.Principal.GenericIdentity> que contiene el nombre Principal de servicio (SPN) del servidor y el protocolo de autenticación utilizado. Cuando se tiene acceso el servidor, esta propiedad devuelve un <xref:System.Security.Principal.WindowsIdentity> que describe el cliente. Si el <xref:System.Security.Principal.WindowsIdentity> es no está disponible, se devuelve información del cliente al servidor en un <xref:System.Security.Principal.GenericIdentity>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoAsyncServer#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoAsyncServer/CPP/NclNegoAsyncServer.cpp#2)]
 [!code-csharp[NclNegoAsyncServer#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoAsyncServer/CS/server.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se produjo un error de autenticación o ésta no se produjo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="negotiateStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Este valor se omite.</param>
        <param name="origin">Este valor se omite.</param>
        <summary>Produce <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Siempre inicia una <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No llame a este método. Se hereda, pero no es compatible con <xref:System.Net.Security.NegotiateStream>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La búsqueda no se admite en <see cref="T:System.Net.Security.NegotiateStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="negotiateStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valor de <see cref="T:System.Int64" /> que especifica la longitud de la secuencia.</param>
        <summary>Establece la longitud de la secuencia subyacente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="negotiateStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de <see cref="T:System.Byte" /> que proporciona los bytes escritos en la secuencia.</param>
        <param name="offset">
          <see cref="T:System.Int32" /> que contiene la ubicación de base cero de <paramref name="buffer" /> en la que se va a empezar a leer los bytes que se van a escribir en la secuencia.</param>
        <param name="count">
          <see cref="T:System.Int32" /> que contiene el número de bytes que se van a leer de <paramref name="buffer" />.</param>
        <summary>Escriba el número especificado de <see cref="T:System.Byte" />s en la secuencia subyacente mediante el búfer y el desplazamiento especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si están habilitados el cifrado, firma, o cifrado y firma, este método lee los datos del búfer, cifra, firma o cifra y lo firma y transmite mediante la secuencia subyacente. Si ningún servicio de seguridad, como el cifrado de datos o de firma están en uso, este método invoca <xref:System.IO.Stream.Write%2A> en la secuencia subyacente.  
  
 Este método se bloquea mientras se completa la operación de escritura. Para evitar el bloqueo mientras se completa la operación, use el <xref:System.Net.Security.NegotiateStream.Write%2A> método.  
  
 No se puede llamar este método hasta que se haya autenticado correctamente. Para autenticar, llame a uno de los <xref:System.Net.Security.NegotiateStream.AuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient%2A>, <xref:System.Net.Security.NegotiateStream.AuthenticateAsServer%2A>, o <xref:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer%2A> métodos.  
  
 La <xref:System.Net.Security.NegotiateStream> clase no admite varias operaciones de escritura simultáneas. Si intenta iniciar una operación de escritura cuando ya se está ejecutando otra operación de escritura en la misma secuencia, un <xref:System.NotSupportedException> se producirá la excepción.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo escribir en un <xref:System.Net.Security.NegotiateStream>.  
  
 [!code-cpp[NclNegoSyncClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#4)]
 [!code-csharp[NclNegoSyncClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset is less than 0" />.  
  
\- o - 
 <paramref name="offset" /> es mayor que la longitud de <paramref name="buffer" />.  
  
\- o - 
 La suma de <paramref name="offset" /> y el recuento es mayor que la longitud de <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">No se pudo realizar la operación de escritura.  
  
\- o - 
El cifrado está en uso, pero no se pudieron cifrar los datos.</exception>
        <exception cref="T:System.NotSupportedException">Ya hay una operación de escritura en curso.</exception>
        <exception cref="T:System.ObjectDisposedException">Este objeto se ha cerrado.</exception>
        <exception cref="T:System.InvalidOperationException">No se ha producido la autenticación.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public override int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateStream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.Net.Security.NegotiateStream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el período de tiempo que se bloquea una operación de escritura mientras espera datos.</summary>
        <value>
          <see cref="T:System.Int32" /> que especifica la cantidad de tiempo que pasará antes de que falle una operación de escritura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el valor devuelto al invocar el <xref:System.IO.Stream.WriteTimeout%2A> propiedad en la secuencia subyacente. Para las operaciones de conjunto, Establece el valor especificado la <xref:System.IO.Stream.WriteTimeout%2A> valor en la secuencia subyacente.  
  
 Si la secuencia subyacente es un <xref:System.Net.Sockets.NetworkStream>, <xref:System.Net.Security.NegotiateStream.WriteTimeout%2A> está en milisegundos y se establece en <xref:System.Threading.Timeout.Infinite> de forma predeterminada, por lo que escribir las operaciones no tienen tiempo de espera.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo mostrar el valor de esta propiedad.  
  
 [!code-cpp[NclNegoSyncClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NclNegoSyncClient/CPP/NclNegoSyncClient.cpp#2)]
 [!code-csharp[NclNegoSyncClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NclNegoSyncClient/CS/client.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>