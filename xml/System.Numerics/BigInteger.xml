<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7d0dcda34bb31112c320daec112f3dd4b818dc43" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30471139" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa un entero con signo arbitrariamente grande.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger> tipo es un tipo inmutable que representa un entero arbitrariamente grande cuyo valor en teoría no tiene ningún límite superior o inferior. Los miembros de la <xref:System.Numerics.BigInteger> tipo análogos a los de otros tipos integrales (la <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, y <xref:System.UInt64> tipos). Este tipo difiere de otros tipos integrales en el [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], que tiene un intervalo indicado por sus `MinValue` y `MaxValue` propiedades.  
  
> [!NOTE]
>  Porque el <xref:System.Numerics.BigInteger> tipo es inmutable (vea [mutabilidad y la estructura BigInteger](#mutability)) y porque no tiene ningún límite superior o inferior, una <xref:System.OutOfMemoryException> se puede producir para cualquier operación que hace un <xref:System.Numerics.BigInteger> valor crezca demasiado grande.  
  
## <a name="instantiating-a-biginteger-object"></a>Instancias de un objeto BigInteger  
 Puede crear instancias de un <xref:System.Numerics.BigInteger> objeto de varias maneras:  
  
-   Puede usar el `new` palabra clave y proporcione cualquier valor entero o de punto flotante como un parámetro a la <xref:System.Numerics.BigInteger> constructor. (Se truncan los valores de punto flotante antes de que se asignan a la <xref:System.Numerics.BigInteger>.) En el ejemplo siguiente se muestra cómo utilizar el `new` palabra clave que se va a crear una instancia de <xref:System.Numerics.BigInteger> valores.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   Puede declarar un <xref:System.Numerics.BigInteger> variable y asigne un valor tal y como lo haría cualquier tipo numérico, siempre y cuando dicho valor es un tipo entero. En el ejemplo siguiente se utiliza la asignación para crear un <xref:System.Numerics.BigInteger> valor desde un <xref:System.Int64>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   Puede asignar un valor decimal o de punto flotante a un <xref:System.Numerics.BigInteger> objeto si convierte el valor o convertirla primero. En el ejemplo siguiente se convierte (en C#) o convierte (en Visual Basic) explícitamente un <xref:System.Double> y un <xref:System.Decimal> valor a un <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 Estos métodos permiten crear una instancia de un <xref:System.Numerics.BigInteger> solo tipos de objeto cuyo valor está en el intervalo de uno de los valores numéricos existente. Puede crear instancias de un <xref:System.Numerics.BigInteger> objeto cuyo valor puede superar el intervalo de los tipos numéricos existentes en una de estas tres maneras:  
  
-   Puede usar el `new` (palabra clave) y proporcionar una matriz de bytes de cualquier tamaño la <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> constructor. Por ejemplo:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   Puede llamar a la <xref:System.Numerics.BigInteger.Parse%2A> o <xref:System.Numerics.BigInteger.TryParse%2A> métodos para convertir la representación de cadena de un número en un <xref:System.Numerics.BigInteger>. Por ejemplo:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   Puede llamar a un `static` (`Shared` en Visual Basic) <xref:System.Numerics.BigInteger> método que realiza alguna operación en una expresión numérica y devuelve un calculado <xref:System.Numerics.BigInteger> resultado. En el ejemplo siguiente se hace esto elevando <xref:System.UInt64.MaxValue?displayProperty=nameWithType> y asignar el resultado a un <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 El valor sin inicializar de un <xref:System.Numerics.BigInteger> es <xref:System.Numerics.BigInteger.Zero%2A>.  
  
## <a name="performing-operations-on-biginteger-values"></a>Realizar operaciones en valores BigInteger  
 Puede usar un <xref:System.Numerics.BigInteger> instancia como utilizaría cualquier otro tipo entero. <xref:System.Numerics.BigInteger> sobrecargas de los operadores numéricos estándar para permitirle realizar operaciones matemáticas básicas como suma, resta, división, multiplicación, resta, negación y negación unaria. También puede usar los operadores numéricos estándar para comparar dos <xref:System.Numerics.BigInteger> valores entre sí. Al igual que otros tipos integrales, <xref:System.Numerics.BigInteger> también es compatible con el bit a bit `And`, `Or`, `XOr`, MAYÚS y operadores de desplazamiento a la derecha de apertura. Para los lenguajes que no admiten operadores personalizados, la <xref:System.Numerics.BigInteger> estructura también proporciona métodos equivalentes para realizar operaciones matemáticas. Puede tratarse de <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>y muchas otras personas.  
  
 Muchos miembros de la <xref:System.Numerics.BigInteger> estructura corresponden directamente a los miembros de otros tipos integrales. Además, <xref:System.Numerics.BigInteger> agrega miembros, como los siguientes:  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>, que devuelve un valor que indica el signo de un <xref:System.Numerics.BigInteger> valor.  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>, que devuelve el valor absoluto de un <xref:System.Numerics.BigInteger> valor.  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>, que devuelve el cociente y el resto de una operación de división.  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, que devuelve el máximo común divisor de dos <xref:System.Numerics.BigInteger> valores.  
  
 Muchos de estos miembros adicionales corresponden a los miembros de la <xref:System.Math> (clase), que proporciona la funcionalidad para trabajar con los tipos numéricos primitivos.  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>Mutabilidad y BigInteger (estructura)  
 El ejemplo siguiente crea un <xref:System.Numerics.BigInteger> de objeto y, a continuación, aumenta su valor en uno.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 Aunque este ejemplo parece modificar el valor del objeto existente, no es el caso. <xref:System.Numerics.BigInteger> los objetos son inmutables, lo que significa que internamente, common language runtime realmente crea un nuevo <xref:System.Numerics.BigInteger> de objetos y le asigna un valor una unidad mayor que su valor anterior. Este nuevo objeto, a continuación, se devuelve al llamador.  
  
> [!NOTE]
>  Los demás tipos numéricos en .NET Framework también son inmutables. Sin embargo, dado que el <xref:System.Numerics.BigInteger> tipo no tiene ningún límite superior o inferior, sus valores pueden llegar a ser muy grandes y tiene un impacto cuantificable sobre el rendimiento.  
  
 Aunque este proceso es transparente para el llamador, incurre en una reducción del rendimiento. En algunos casos, especialmente cuando las operaciones repetidas se realizan en un bucle en gran <xref:System.Numerics.BigInteger> valores, esa disminución del rendimiento puede ser considerable. Por ejemplo, en el ejemplo siguiente, se realiza una operación repetidamente hasta un millón de veces y un <xref:System.Numerics.BigInteger> valor se incrementa en uno cada vez que la operación se realiza correctamente.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 En tal caso, puede mejorar el rendimiento mediante la realización de todos los trabajos intermedios en un <xref:System.Int32> variable. El valor final de la variable, a continuación, puede asignarse a la <xref:System.Numerics.BigInteger> objeto cuando se sale del bucle. Esto se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>Trabajar con matrices de bytes y cadenas hexadecimales  
 Si convierte <xref:System.Numerics.BigInteger> valores a las matrices de bytes, o si convierte las matrices de bytes a <xref:System.Numerics.BigInteger> valores, debe tener en cuenta el orden de bytes. El <xref:System.Numerics.BigInteger> estructura espera los bytes individuales en una matriz de bytes que aparezcan en orden little-endian (es decir, los bytes de orden más bajo del valor preceden a los bytes de orden superior). Puede ida y vuelta un <xref:System.Numerics.BigInteger> valor mediante una llamada a la <xref:System.Numerics.BigInteger.ToByteArray%2A> método y, a continuación, pasa el byte resultante de matriz para el <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 Para crear instancias de un <xref:System.Numerics.BigInteger> valor desde una matriz de bytes que representa un valor de algún otro tipo integral, puede pasar el valor entero para la <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> método y, a continuación, pasa el byte resultante de matriz para el <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor. El ejemplo siguiente crea un <xref:System.Numerics.BigInteger> valor de una matriz de bytes que representa un <xref:System.Int16> valor.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 El <xref:System.Numerics.BigInteger> estructura se da por supuesto que los valores negativos se almacenan utilizando dos representación del complemento. Dado que la <xref:System.Numerics.BigInteger> estructura representa un valor numérico sin longitud fija, el <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor siempre interpreta el bit más significativo del último byte de la matriz como un bit de signo. Para evitar la <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor confunda la representación complementaria de dos de un valor negativo con la representación de signo y magnitud de un valor positivo, positivo en el que el bit más significativo del último byte en la matriz de bytes normalmente sería un conjunto de valores deben incluir un byte adicional cuyo valor es 0. Por ejemplo, 0xC0 0xBD 0xF0 0xFF es la representación hexadecimal de little-endian de -1.000.000 o 4.293.967.296. Dado el bit más significativo del último byte en esta matriz está activado, el valor de la matriz de bytes se interpretaría por la <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor como -1.000.000. Para crear instancias de un <xref:System.Numerics.BigInteger> cuyo valor es positivo, una matriz de bytes cuyos elementos son 0xC0 0xBD 0xF0 0xFF 0x00 debe pasarse al constructor. Esto se ilustra en el siguiente ejemplo:  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 Las matrices de bytes creadas por el <xref:System.Numerics.BigInteger.ToByteArray%2A> método desde los valores positivos incluyen este byte del valor cero adicional. Por lo tanto, la <xref:System.Numerics.BigInteger> estructura puede valores de ida y vuelta correctamente mediante la asignación a y, a continuación, restaurarlos desde matrices de bytes, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 Sin embargo, puede que necesite agregar este byte del valor cero adicional a las matrices de bytes que se crean dinámicamente por el desarrollador o que devuelven los métodos que convierten los enteros sin signo en matrices de bytes (como <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, y <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).  
  
 Al analizar una cadena hexadecimal, el <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> y <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> métodos suponen que si se establece el bit más significativo del primer byte de la cadena, o si el primer dígito hexadecimal de la cadena representa los cuatro bits inferiores de un valor de byte, el valor se representa mediante el uso de representación complementaria de dos. Por ejemplo, "FF01" y "F01" representan el valor decimal -255. Para diferenciar positivo de los valores negativos, los valores positivos deben incluir un cero inicial. Las sobrecargas pertinentes de la <xref:System.Numerics.BigInteger.ToString%2A> método, cuando se pasan la cadena de formato "X", agregan un cero inicial a la cadena hexadecimal devuelta para los valores positivos. Esto hace posible ida y vuelta <xref:System.Numerics.BigInteger> valores usando el <xref:System.Numerics.BigInteger.ToString%2A> y <xref:System.Numerics.BigInteger.Parse%2A> métodos, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 Sin embargo, las cadenas hexadecimales se crean mediante una llamada a la `ToString` métodos de los demás tipos enteros o de las sobrecargas de la <xref:System.Convert.ToString%2A> método que incluyen un `toBase` parámetro no indican el signo del valor o el tipo de datos de origen desde el que se derivó la cadena hexadecimal. Crear instancias de correctamente un <xref:System.Numerics.BigInteger> valor de este tipo de cadena requiere alguna lógica adicional. En el ejemplo siguiente se proporciona una posible implementación.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Numerics.BigInteger" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Matriz de valores de byte en orden little-endian.</param>
        <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Numerics.BigInteger" /> utilizando los valores de una matriz de bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los bytes individuales en la `value` matriz debe estar en orden little-endian, desde el byte de orden más bajo hasta el byte de orden superior. Por ejemplo, el valor numérico 1.000.000.000.000 se representa como se muestra en la tabla siguiente:  
  
|||  
|-|-|  
|Cadena hexadecimal|E8D4A51000|  
|Matriz de bytes (el índice inferior en primer lugar)|00 10 A5 D4 E8 00|  
  
 Mayoría de los métodos que convierten valores numéricos en matrices de bytes, como <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> y <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, devolver matrices de bytes en orden little-endian.  
  
 El constructor espera valores positivos en la matriz de bytes para utilizar representación de signo y magnitud y valores negativos para utilizar dos representación del complemento. En otras palabras, si el orden más alto de bits del byte de orden superior de `value` está establecida, resultante <xref:System.Numerics.BigInteger> valor es negativo. Dependiendo del origen de la matriz de bytes, esto puede provocar un valor positivo para interpretar como un valor negativo. Matrices de bytes se generan normalmente de las maneras siguientes:  
  
-   Mediante una llamada a la <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> método. Dado que este método devuelve una matriz de bytes con el bit de orden superior del byte de orden superior en la matriz establecida en cero para los valores positivos, no hay ninguna posibilidad de interpretar un valor positivo como negativo. Sin cambios matrices de bytes creadas por el <xref:System.Numerics.BigInteger.ToByteArray%2A> siempre correctamente ida y vuelta cuando se pasan al método el <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor.  
  
-   Mediante una llamada a la <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> método y pasar un entero con signo como un parámetro. Como enteros con signo administran la representación de signo y magnitud y representación complementaria de dos, no hay ninguna posibilidad de interpretar un valor positivo como negativo.  
  
-   Mediante una llamada a la <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> método y pasar un entero sin signo como un parámetro. Como enteros sin signo se representan mediante su magnitud solo, los valores positivos se pueden interpretar como valores negativos. Para evitar esta interpretación incorrecta, puede agregar un valor de cero bytes al final de la matriz. El ejemplo en la sección siguiente proporciona una ilustración.  
  
-   Mediante la creación de una matriz de bytes o dinámica o estáticamente sin necesariamente una llamada a cualquiera de los métodos anteriores, o mediante la modificación de una matriz de bytes existente. Para evitar que los valores positivos se interprete erróneamente como valores negativos, puede agregar un valor de cero bytes al final de la matriz.  
  
 Si `value` está vacío <xref:System.Byte> matriz, el nuevo <xref:System.Numerics.BigInteger> objeto se inicializa en un valor de <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Si `value` es `null`, el constructor produce una <xref:System.ArgumentNullException>.  
  
   
  
## Examples  
 El ejemplo siguiente crea un <xref:System.Numerics.BigInteger> objeto desde una matriz de bytes de 5 elementos cuyo valor es {5, 4, 3, 2, 1}. A continuación, muestra la <xref:System.Numerics.BigInteger> valor, representado como decimales y hexadecimales los números, en la consola. Una comparación de la matriz de entrada con la salida de texto deja claro por qué esta sobrecarga de la <xref:System.Numerics.BigInteger> constructor de clase crea un <xref:System.Numerics.BigInteger> objeto cuyo valor es 4328719365 (o 0 x 102030405). El primer elemento de la matriz de bytes, cuyo valor es 5, define el valor del byte de orden más bajo de la <xref:System.Numerics.BigInteger> objeto, que es 0 x 05. El segundo elemento de la matriz de bytes, cuyo valor es 4, define el valor del segundo byte de la <xref:System.Numerics.BigInteger> objeto, que es 0 x 04 y así sucesivamente.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 El ejemplo siguiente crea un positivo y negativo <xref:System.Numerics.BigInteger> valor, los pasa a la <xref:System.Numerics.BigInteger.ToByteArray%2A> (método) y, a continuación, se restaura el original <xref:System.Numerics.BigInteger> valores de la matriz de bytes resultante. Tenga en cuenta que los dos valores se representan mediante matrices de bytes idénticas. La única diferencia entre ellos es en el bit más significativo del último elemento de la matriz de bytes. Este bit está establecido (el valor del byte es 0xFF) si la matriz se crea a partir de un negativo <xref:System.Numerics.BigInteger> valor. El bit no está establecido (el valor del byte es cero), si la matriz se crea desde positivo <xref:System.Numerics.BigInteger> valor.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 En el ejemplo siguiente se muestra cómo asegurarse de que un valor positivo no se crea incorrectamente instancias como un valor negativo agregando un byte cuyo valor es cero al final de la matriz.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Número decimal.</param>
        <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Numerics.BigInteger" /> utilizando un valor <see cref="T:System.Decimal" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El resultado de llamar a este constructor es idéntico a asignar explícitamente un <xref:System.Decimal> valor a un <xref:System.Numerics.BigInteger> variable.  
  
 Llamar a este constructor puede provocar la pérdida de datos; la parte fraccionaria del `value` se trunca al crear instancias de un <xref:System.Numerics.BigInteger> objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> constructor para crear instancias de un <xref:System.Numerics.BigInteger> objeto. Define una matriz de <xref:System.Decimal> valores y, a continuación, pasa cada valor a la <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> constructor. Tenga en cuenta que la <xref:System.Decimal> valor se trunca en lugar de redondearse cuando se asigna a la <xref:System.Numerics.BigInteger> objeto.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valor de punto flotante de precisión doble.</param>
        <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Numerics.BigInteger" /> utilizando un valor de punto flotante de precisión doble.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquier parte fraccionaria de los `value` se trunca el parámetro al crear una instancia un <xref:System.Numerics.BigInteger> objeto.  
  
 Debido a la falta de precisión de la <xref:System.Double> tipo de datos, llamar a este constructor puede provocar la pérdida de datos.  
  
 El <xref:System.Numerics.BigInteger> valor que es el resultado de la llamada a este constructor es idéntico al valor que resulta de asignar explícitamente un <xref:System.Double> valor a un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> constructor para crear instancias de un <xref:System.Numerics.BigInteger> objeto. También muestra la pérdida de precisión que se puede producir cuando se usa el <xref:System.Double> tipo de datos. A <xref:System.Double> tiene asignado un valor grande, que, a continuación, se asigna a un <xref:System.Numerics.BigInteger> objeto. Como muestra el resultado, esta asignación implica una pérdida de precisión. Ambos valores, a continuación, se incrementan en uno. El resultado muestra que la <xref:System.Numerics.BigInteger> objeto refleja el valor cambiado, mientras que la <xref:System.Double> objeto no lo hace.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor de <paramref name="value" /> es <see cref="F:System.Double.NaN" />.  
  
 O bien  
  
 El valor de <paramref name="value" /> es <see cref="F:System.Double.NegativeInfinity" />.  
  
 O bien  
  
 El valor de <paramref name="value" /> es <see cref="F:System.Double.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Entero de 32 bits con signo.</param>
        <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Numerics.BigInteger" /> utilizando un valor entero de 32 bits con signo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay ninguna pérdida de precisión al crear instancias de un <xref:System.Numerics.BigInteger> objeto mediante el uso de este constructor.  
  
 El <xref:System.Numerics.BigInteger> valor que es el resultado de la llamada a este constructor es idéntico al valor que resulta de asignar un <xref:System.Int32> valor a un <xref:System.Numerics.BigInteger>.  
  
 El <xref:System.Numerics.BigInteger> estructura no tiene constructores con un parámetro de tipo <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, o <xref:System.UInt16>. Sin embargo, la <xref:System.Int32> tipo admite la conversión implícita de enteros de 8 y 16 bits con signo y sin signo en enteros de 32 bits con signo. Como resultado, se llama a este constructor si `value` es cualquiera de estos cuatro tipos integrales.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> constructor para crear instancias de <xref:System.Numerics.BigInteger> valores de una matriz de enteros de 32 bits. También usa la conversión implícita para asignar cada valor de entero de 32 bits a una <xref:System.Numerics.BigInteger> variable. A continuación, compara los dos valores para establecer que resultante <xref:System.Numerics.BigInteger> valores son los mismos.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Entero de 64 bits con signo.</param>
        <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Numerics.BigInteger" /> usando un valor entero de 64 bits con signo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay ninguna pérdida de precisión al crear instancias de un <xref:System.Numerics.BigInteger> objeto mediante el uso de este constructor.  
  
 El <xref:System.Numerics.BigInteger> valor que es el resultado de la llamada a este constructor es idéntico al valor que resulta de asignar un <xref:System.Int64> valor a un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> constructor para crear instancias de <xref:System.Numerics.BigInteger> valores de una matriz de enteros de 64 bits. También usa la conversión implícita para asignar cada valor de entero de 64 bits a un <xref:System.Numerics.BigInteger> variable. A continuación, compara los dos valores para establecer que resultante <xref:System.Numerics.BigInteger> valores son los mismos.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valor de punto flotante de precisión sencilla.</param>
        <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Numerics.BigInteger" /> utilizando un valor de punto flotante de precisión sencilla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquier parte fraccionaria de los `value` se trunca el parámetro al crear una instancia un <xref:System.Numerics.BigInteger> objeto.  
  
 Debido a la falta de precisión de la <xref:System.Single> tipo de datos, llamar a este constructor puede dar lugar a pérdida de datos.  
  
 El <xref:System.Numerics.BigInteger> valor que es el resultado de la llamada a este constructor es idéntico al valor que resulta de asignar explícitamente un <xref:System.Single> valor a un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> constructor para crear instancias de un <xref:System.Numerics.BigInteger> objeto. También muestra la pérdida de precisión que se puede producir cuando se usa el <xref:System.Single> tipo de datos. A <xref:System.Single> se asigna un valor negativo grande, que, a continuación, se asigna a un <xref:System.Numerics.BigInteger> objeto. Como muestra el resultado, esta asignación implica una pérdida de precisión. Ambos valores, a continuación, se incrementan en uno. El resultado muestra que la <xref:System.Numerics.BigInteger> objeto refleja el valor cambiado, mientras que la <xref:System.Single> objeto no lo hace.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor de <paramref name="value" /> es <see cref="F:System.Single.NaN" />.  
  
 O bien  
  
 El valor de <paramref name="value" /> es <see cref="F:System.Single.NegativeInfinity" />.  
  
 O bien  
  
 El valor de <paramref name="value" /> es <see cref="F:System.Single.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valor entero de 32 bits sin signo.</param>
        <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Numerics.BigInteger" /> utilizando un valor entero de 32 bits sin signo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay ninguna pérdida de precisión al crear instancias de un <xref:System.Numerics.BigInteger> utilizar este constructor.  
  
 El <xref:System.Numerics.BigInteger> valor que es el resultado de la llamada a este constructor es idéntico al valor que resulta de asignar un <xref:System.UInt32> valor a un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> constructor y una instrucción de asignación para inicializar <xref:System.Numerics.BigInteger> valores de una matriz de enteros de 32 bits sin signo. A continuación, compara los dos valores para mostrar que los dos métodos de inicializar un <xref:System.Numerics.BigInteger> valor producir resultados idénticos.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Entero de 64 bits sin signo.</param>
        <summary>Inicializa una nueva instancia de la estructura <see cref="T:System.Numerics.BigInteger" /> con un valor entero de 64 bits sin signo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay ninguna pérdida de precisión al crear instancias de un <xref:System.Numerics.BigInteger> utilizar este constructor.  
  
 El <xref:System.Numerics.BigInteger> valor que es el resultado de la llamada a este constructor es idéntico al valor que resulta de asignar un <xref:System.UInt64> valor a un <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> constructor para crear instancias de un <xref:System.Numerics.BigInteger> objeto cuyo valor es igual a <xref:System.UInt64.MaxValue>.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Un número.</param>
        <summary>Obtiene el valor absoluto de un objeto <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Valor absoluto de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor absoluto de un número es ese número sin signo, como se muestra en la tabla siguiente.  
  
|Parámetro `value`|Valor devuelto|  
|-----------------------|------------------|  
|`value` &gt;= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 El <xref:System.Numerics.BigInteger.Abs%2A> método es equivalente a la <xref:System.Math.Abs%2A?displayProperty=nameWithType> método para los tipos numéricos primitivos.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Numerics.BigInteger.Abs%2A> método para convertir un <xref:System.Numerics.BigInteger> valor de representación complementaria de dos a la representación de signo y magnitud antes de serializar en un archivo. Datos en el archivo, a continuación, se deserializa y se asigna a un nuevo <xref:System.Numerics.BigInteger> objeto.  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a sumar.</param>
        <param name="right">Segundo valor que se va a sumar.</param>
        <summary>Suma dos valores <see cref="T:System.Numerics.BigInteger" /> y devuelve el resultado.</summary>
        <returns>La suma de <paramref name="left" /> y <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los lenguajes que no admiten la sobrecarga de operadores u operadores personalizados pueden usar el <xref:System.Numerics.BigInteger.Add%2A> método que se realizan mediante suma <xref:System.Numerics.BigInteger> valores.  
  
 El <xref:System.Numerics.BigInteger.Add%2A> método es un suplente útil para el operador de suma al crear instancias de un <xref:System.Numerics.BigInteger> variable asignándole una suma que es el resultado de la suma, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Compara dos valores <see cref="T:System.Numerics.BigInteger" /> y devuelve un entero que indica si el primer valor es menor, igual o mayor que el segundo.</summary>
        <returns>Entero con signo que indica los valores relativos de <paramref name="left" /> e <paramref name="right" />, como se muestra en la tabla siguiente.  
  
 <list type="table"><listheader><term> Valor  
  
 </term><description> Condición  
  
 </description></listheader><item><term> Menor que cero  
  
 </term><description><paramref name="left" /> es menor que <paramref name="right" />.  
  
 </description></item><item><term> Cero  
  
 </term><description><paramref name="left" /> es igual a <paramref name="right" />.  
  
 </description></item><item><term> Mayor que cero  
  
 </term><description><paramref name="left" /> es mayor que <paramref name="right" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque la <xref:System.Numerics.BigInteger> tipo no tiene ningún intervalo fijo, las comparaciones de <xref:System.Numerics.BigInteger> valores no se caracterizan por la falta de precisión que caracteriza la comparación de números de punto flotante. En el ejemplo siguiente se comparan dos <xref:System.Numerics.BigInteger> valores que se distinguen por uno y que cada uno tienen 1.896 dígitos. El <xref:System.Numerics.BigInteger.Compare%2A> método informa correctamente de que los dos valores no son iguales.  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compara el valor de esta instancia con otro valor y devuelve un entero que indica si el valor de esta instancia es menor, igual o mayor que el otro valor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Entero de 64 bits con signo que se va a comparar.</param>
        <summary>Compara esta instancia con un entero de 64 bits con signo y devuelve un entero que indica si el valor de esta instancia es menor, igual o mayor que el valor del entero de 64 bits con signo.</summary>
        <returns>Valor entero con signo que indica la relación de esta instancia con <paramref name="other" />, como se muestra en la tabla siguiente.  
  
 <list type="table"><listheader><term> Valor devuelto  
  
 </term><description> Descripción  
  
 </description></listheader><item><term> Menor que cero  
  
 </term><description> La instancia actual es menor que <paramref name="other" />.  
  
 </description></item><item><term> Cero  
  
 </term><description> La instancia actual es igual que <paramref name="other" />.  
  
 </description></item><item><term> Mayor que cero  
  
 </term><description> La instancia actual es mayor que <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `other` es un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, o <xref:System.UInt32> valor, se convierte implícitamente en un <xref:System.Int64> valor cuando el <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> se llama al método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el resultado de llamar al método el <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> método con valores enteros.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Objeto que se va a comparar.</param>
        <summary>Compara esta instancia con una segunda estructura <see cref="T:System.Numerics.BigInteger" /> y devuelve un entero que indica si el valor de esta instancia es menor, igual o mayor que el valor del objeto especificado.</summary>
        <returns>Valor entero con signo que indica la relación de esta instancia con <paramref name="other" />, como se muestra en la tabla siguiente.  
  
 <list type="table"><listheader><term> Valor devuelto  
  
 </term><description> Descripción  
  
 </description></listheader><item><term> Menor que cero  
  
 </term><description> La instancia actual es menor que <paramref name="other" />.  
  
 </description></item><item><term> Cero  
  
 </term><description> La instancia actual es igual que <paramref name="other" />.  
  
 </description></item><item><term> Mayor que cero  
  
 </term><description> La instancia actual es mayor que <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga de la <xref:System.Numerics.BigInteger.CompareTo%2A> método implementa el <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> método. Se utiliza por objetos de colección genéricos para ordenar los elementos de la colección.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> método para ordenar una lista de `StarInfo` objetos. Cada `StarInfo` objeto proporciona información sobre el nombre de una estrella y su distancia desde la tierra en millas. `StarInfo` implementa el <xref:System.IComparable%601> de la interfaz, lo que permite `StarInfo` objetos se ordenen por clases de colección genéricas. Su <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> implementación solo contiene una llamada a <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 El código siguiente se crean instancias cuatro `StarInfo` objetos y los almacena en un tipo genérico <xref:System.Collections.Generic.List%601> objeto. Después de la <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> método se llama, `StarInfo` objetos se muestran en orden de su distancia de la tierra.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar.</param>
        <summary>Compara esta instancia con un objeto especificado y devuelve un entero que indica si el valor de esta instancia es mayor, igual o menor que el valor del objeto especificado.</summary>
        <returns>Entero con signo que indica la relación de la instancia actual con el parámetro <paramref name="obj" />, como se muestra en la tabla siguiente.  
  
 <list type="table"><listheader><term> Valor devuelto  
  
 </term><description> Descripción  
  
 </description></listheader><item><term> Menor que cero  
  
 </term><description> La instancia actual es menor que <paramref name="obj" />.  
  
 </description></item><item><term> Cero  
  
 </term><description> La instancia actual es igual que <paramref name="obj" />.  
  
 </description></item><item><term> Mayor que cero  
  
 </term><description> La instancia actual es mayor que <paramref name="obj" /> o el parámetro <paramref name="obj" /> es <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga de la <xref:System.Numerics.BigInteger.CompareTo%2A> método implementa el <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> método. Se utiliza por objetos de colección no genéricos para ordenar los elementos de la colección.  
  
 El `obj` parámetro debe ser uno de los siguientes:  
  
-   Un objeto cuyo tipo en tiempo de ejecución es <xref:System.Numerics.BigInteger>.  
  
-   Un <xref:System.Object> variable cuyo valor es `null`. Si el valor de la `obj` parámetro es `null`, el método devuelve 1, lo que indica que la instancia actual es mayor que `obj`.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> método para comparar un <xref:System.Numerics.BigInteger> valor con cada elemento de una matriz de objetos  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          El valor de <paramref name="obj" /> no es <see cref="T:System.Numerics.BigInteger" />.</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Entero de 64 bits sin signo que se va a comparar.</param>
        <summary>Compara esta instancia con un entero de 64 bits sin signo y devuelve un entero que indica si el valor de esta instancia es menor, igual o mayor que el valor del entero de 64 bits sin signo.</summary>
        <returns>Entero con signo que indica el valor relativo de esta instancia y <paramref name="other" />, como se muestra en la tabla siguiente.  
  
 <list type="table"><listheader><term> Valor devuelto  
  
 </term><description> Descripción  
  
 </description></listheader><item><term> Menor que cero  
  
 </term><description> La instancia actual es menor que <paramref name="other" />.  
  
 </description></item><item><term> Cero  
  
 </term><description> La instancia actual es igual que <paramref name="other" />.  
  
 </description></item><item><term> Mayor que cero  
  
 </term><description> La instancia actual es mayor que <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valor que se va a dividir.</param>
        <param name="divisor">Valor por el que se va a dividir.</param>
        <summary>Divide un valor <see cref="T:System.Numerics.BigInteger" /> por otro y devuelve el resultado.</summary>
        <returns>Cociente de la división.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.Divide%2A> método realiza la división de enteros; se descarta cualquier resto que se obtiene de la división. Para realizar la división entera conservando el resto, llame a la <xref:System.Numerics.BigInteger.DivRem%2A> método. Para recuperar únicamente el resto, llame a la <xref:System.Numerics.BigInteger.Remainder%2A> método.  
  
 El <xref:System.Numerics.BigInteger.Divide%2A> método se puede utilizar lenguajes que no admiten la sobrecarga de operadores. Su comportamiento es idéntico a la división utilizando el operador de división.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una matriz de <xref:System.Numerics.BigInteger> valores. A continuación, utiliza cada elemento como el cociente en una operación de división que utiliza el <xref:System.Numerics.BigInteger.Divide%2A> método, el operador de división (/) y el <xref:System.Numerics.BigInteger.DivRem%2A> método.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          El valor de <paramref name="divisor" /> es 0 (cero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">Valor que se va a dividir.</param>
        <param name="divisor">Valor por el que se va a dividir.</param>
        <param name="remainder">Cuando este método devuelve un valor, contiene <see cref="T:System.Numerics.BigInteger" />, que representa el resto de la división. Este parámetro se pasa sin inicializar.</param>
        <summary>Divide un valor <see cref="T:System.Numerics.BigInteger" /> por otro, devuelve el resultado y devuelve el resto en un parámetro de salida.</summary>
        <returns>Cociente de la división.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método conserva el cociente y el resto resultante de la división de enteros. Si no está interesado en el resto, use la <xref:System.Numerics.BigInteger.Divide%2A> método o el operador de división; si es que sólo está interesado en el resto, utilice el <xref:System.Numerics.BigInteger.Remainder%2A> método.  
  
 El inicio de sesión de devuelto `remainder` valor es el mismo que el inicio de sesión de la `dividend` parámetro.  
  
 El comportamiento de la <xref:System.Numerics.BigInteger.DivRem%2A> método es idéntico de la <xref:System.Math.DivRem%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una matriz de <xref:System.Numerics.BigInteger> valores. A continuación, utiliza cada elemento como el cociente en una operación de división que utiliza el <xref:System.Numerics.BigInteger.Divide%2A> método, el operador de división (/) y el <xref:System.Numerics.BigInteger.DivRem%2A> método.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          El valor de <paramref name="divisor" /> es 0 (cero).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si dos valores numéricos son iguales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Valor entero de 64 bits con signo que se va a comparar.</param>
        <summary>Devuelve un valor que indica si la instancia actual y un entero de 64 bits con signo tienen el mismo valor.</summary>
        <returns>
          Es <see langword="true" /> si el entero de 64 bits con signo y la instancia actual tienen el mismo valor; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `other` es un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, o <xref:System.UInt32> valor, se convierte implícitamente en un <xref:System.Int64> valor cuando se llama al método.  
  
 Para determinar la relación entre los dos objetos en lugar de simplemente realizar pruebas para la igualdad, llame a la <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 El ejemplo siguiente crea un <xref:System.Numerics.BigInteger> objeto de cada tipo integral excepto <xref:System.UInt64>. A continuación, se llama la <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> método para comparar la <xref:System.Numerics.BigInteger> con el valor entero original que se pasó a la <xref:System.Numerics.BigInteger> constructor. Como muestra el resultado, los valores son iguales en cada caso.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Objeto que se va a comparar.</param>
        <summary>Devuelve un valor que indica si la instancia actual y un objeto <see cref="T:System.Numerics.BigInteger" /> especificado tienen el mismo valor.</summary>
        <returns>
          Es <see langword="true" /> si este objeto <see cref="T:System.Numerics.BigInteger" /> y <paramref name="other" /> tienen el mismo valor; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método implementa el <xref:System.IEquatable%601> interfaz y realiza ligeramente mejor que <xref:System.Numerics.BigInteger.Equals%28System.Object%29> porque no tiene que convertir el `other` parámetro a un <xref:System.Numerics.BigInteger> objeto.  
  
 Para determinar la relación entre los dos <xref:System.Numerics.BigInteger> objetos en lugar de simplemente realizar pruebas para la igualdad, llame a la <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se compara la distancia aproximada de varias estrellas desde la tierra con la distancia de i Epsilon desde la tierra para determinar si son iguales. En el ejemplo se usa cada sobrecarga de la <xref:System.Numerics.BigInteger.Equals%2A> método para comprobar la igualdad.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar.</param>
        <summary>Devuelve un valor que indica si la instancia actual y un objeto especificado tienen el mismo valor.</summary>
        <returns>
          <see langword="true" /> si el argumento <paramref name="obj" /> es un objeto <see cref="T:System.Numerics.BigInteger" /> y su valor es igual al valor de la instancia <see cref="T:System.Numerics.BigInteger" /> actual; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `obj` el argumento no es un <xref:System.Numerics.BigInteger> valor, el método devuelve `false`. El método devuelve `true` solo si `obj` es un <xref:System.Numerics.BigInteger> instancia cuyo valor es igual a la instancia actual.  
  
 Para determinar la relación entre los dos objetos en lugar de simplemente realizar pruebas para la igualdad, llame a la <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se define paralelo <xref:System.Object> y <xref:System.Numerics.BigInteger> matrices. Cada elemento de una matriz tiene el mismo valor que el elemento correspondiente de la segunda matriz. Como la salida se muestra en el ejemplo, la instancia en la <xref:System.Numerics.BigInteger> matriz se considera igual a la instancia en la <xref:System.Object> matriz solo si el segundo es un <xref:System.Numerics.BigInteger> y sus valores son iguales.  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Entero de 64 bits sin signo que se va a comparar.</param>
        <summary>Devuelve un valor que indica si la instancia actual y un entero de 64 bits sin signo tienen el mismo valor.</summary>
        <returns>
          Es <see langword="true" /> si la instancia actual y el entero de 64 bits sin signo tienen el mismo valor; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar la relación entre los dos objetos en lugar de simplemente realizar pruebas para la igualdad, llame a la <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se compara la distancia aproximada de varias estrellas desde la tierra con la distancia de i Epsilon desde la tierra para determinar si son iguales. En el ejemplo se usa cada sobrecarga de la <xref:System.Numerics.BigInteger.Equals%2A> método para comprobar la igualdad.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash del objeto <see cref="T:System.Numerics.BigInteger" /> actual.</summary>
        <returns>Código hash de un entero de 32 bits con signo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor.</param>
        <param name="right">Segundo valor.</param>
        <summary>Busca el máximo común divisor de dos valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Máximo común divisor de <paramref name="left" /> y <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El máximo común divisor es el número más grande en la que los dos <xref:System.Numerics.BigInteger> valores pueden estar divididos sin devolver un resto.  
  
 Si el `left` y `right` parámetros son números distintos de cero, el método devuelve siempre al menos un valor de 1 porque todos los números se pueden dividir en 1. Si alguno de los parámetros es cero, el método devuelve el valor absoluto del parámetro es distinto de cero. Si ambos valores son cero, el método devuelve cero.  
  
> [!NOTE]
>  Calcular el máximo común divisor de valores muy grandes de `left` y `right` puede ser una operación muy lenta.  
  
 El valor devuelto por la <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> método siempre es positivo sin tener en cuenta el inicio de sesión de la `left` y `right` parámetros.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra una llamada a la <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> método y el control de excepciones necesario para proporcionar información útil sobre un <xref:System.ArgumentOutOfRangeException>. El resultado indica que el máximo común divisor de estos dos números es 1.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica si el valor del objeto <see cref="T:System.Numerics.BigInteger" /> actual es un número par.</summary>
        <value>
          Es <see langword="true" /> si el valor del objeto <see cref="T:System.Numerics.BigInteger" /> es un número par; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es una característica de conveniencia que indica si un <xref:System.Numerics.BigInteger> valor es divisible por dos. Es equivalente a la siguiente expresión:  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 Si el valor del elemento actual <xref:System.Numerics.BigInteger> objeto es <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, la propiedad devuelve `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica si el valor del objeto <see cref="T:System.Numerics.BigInteger" /> actual es <see cref="P:System.Numerics.BigInteger.One" />.</summary>
        <value>
          Es <see langword="true" /> si el valor del objeto <see cref="T:System.Numerics.BigInteger" /> es <see cref="P:System.Numerics.BigInteger.One" />; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad ofrece un rendimiento significativamente mejor que otras comparaciones con uno, como `thisBigInteger.Equals(BigInteger.One)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica si el valor del objeto <see cref="T:System.Numerics.BigInteger" /> actual es una potencia de dos.</summary>
        <value>
          Es <see langword="true" /> si el valor del objeto <see cref="T:System.Numerics.BigInteger" /> es una potencia de dos; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad determina si un <xref:System.Numerics.BigInteger> valor tiene un solo bit es distinto de cero establecido. Esto significa que devuelve `true` si el valor del elemento actual <xref:System.Numerics.BigInteger> objeto es 1 (es decir, 2<sup>0</sup>) o cualquier mayor potencia de dos. Devuelve `false` si el valor del elemento actual <xref:System.Numerics.BigInteger> objeto es 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica si el valor del objeto <see cref="T:System.Numerics.BigInteger" /> actual es <see cref="P:System.Numerics.BigInteger.Zero" />.</summary>
        <value>
          Es <see langword="true" /> si el valor del objeto <see cref="T:System.Numerics.BigInteger" /> es <see cref="P:System.Numerics.BigInteger.Zero" />; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad ofrece un rendimiento significativamente mejor que `BigInteger.Equals(BigInteger.Zero)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el logaritmo de un número especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Número cuyo logaritmo se va a calcular.</param>
        <summary>Devuelve el logaritmo natural (en base <see langword="e" />) de un número especificado.</summary>
        <returns>Logaritmo natural (base <see langword="e" />) de <paramref name="value" />, como se muestra en la tabla de la sección Comentarios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `value` parámetro se especifica como un número en base 10.  
  
 La precisión devolver valor de este método depende del signo de `value`, como se muestra en la tabla siguiente.  
  
|La sesión de `value` parámetro|Valor devuelto|  
|-------------------------------|------------------|  
|Positivo|El logaritmo natural de `value`; es decir, ln `value`, o de registro e`value`.|  
|Zero|<xref:System.Double.NegativeInfinity>.|  
|Negativo|<xref:System.Double.NaN>.|  
  
 Para calcular el logaritmo en base 10 de un <xref:System.Numerics.BigInteger> valor, llame a la <xref:System.Numerics.BigInteger.Log10%2A> método. Para calcular el logaritmo de un número en otra base, llame a la <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> método.  
  
 Puede encontrar la raíz cuadrada de un número mediante una llamada a la <xref:System.Numerics.BigInteger.Log%2A> método junto con el <xref:System.Math.Exp%2A?displayProperty=nameWithType> método. Tenga en cuenta que el resultado es <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> si el resultado es mayor que <xref:System.Double.MaxValue?displayProperty=nameWithType>. En el ejemplo siguiente se calcula la raíz cuadrada de cada elemento de una matriz de <xref:System.Numerics.BigInteger> valores.  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 Este método corresponde a la <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> método para los tipos numéricos primitivos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El logaritmo natural de <paramref name="value" /> está fuera del intervalo del tipo de datos <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Número cuyo logaritmo hay que calcular.</param>
        <param name="baseValue">Base del logaritmo.</param>
        <summary>Devuelve el logaritmo de un número especificado en una base determinada.</summary>
        <returns>Logaritmo en base <paramref name="baseValue" /> de <paramref name="value" />, como se muestra en la tabla de la sección Comentarios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `value` y `baseValue` parámetros se especifican como números en base 10.  
  
 Devolver la precisión valor del método depende del signo de `value` y en el inicio de sesión y el valor de `baseValue`, como se muestra en la tabla siguiente.  
  
|Parámetro `value`|Parámetro `baseValue`|Valor devuelto|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1) - o bien-(`baseValue` > 1)|logbaseValue(`value`)|  
|`value` < 0|(cualquier valor)|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(cualquier valor)|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(cualquier valor)|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(cualquier valor)|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 Para calcular el logaritmo en base 10 de un <xref:System.Numerics.BigInteger> valor, llame a la <xref:System.Numerics.BigInteger.Log10%2A> método. Para calcular el logaritmo natural de un número, llame a la <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> método.  
  
 Este método corresponde a la <xref:System.Math.Log%2A?displayProperty=nameWithType> método para los tipos numéricos primitivos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El logaritmo de <paramref name="value" /> está fuera del intervalo del tipo de datos <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Número cuyo logaritmo hay que calcular.</param>
        <summary>Devuelve el logaritmo en base 10 de un número especificado.</summary>
        <returns>Logaritmo en base 10 de <paramref name="value" />, como se muestra en la tabla de la sección Comentarios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `value` parámetro se especifica como un número en base 10.  
  
 Devolver la precisión valor del método depende del signo de `value`, como se muestra en la tabla siguiente.  
  
|Signo del valor del parámetro|Valor devuelto|  
|-----------------------------|------------------|  
|Positivo|El logaritmo en base 10 de `value`; es decir, log10`value`.|  
|Zero|<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.|  
|Negativo|<xref:System.Double.NaN?displayProperty=nameWithType>.|  
  
 Para calcular el logaritmo natural de un <xref:System.Numerics.BigInteger> valor, llame a la <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> método. Para calcular el logaritmo de un número en otra base, llame a la <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> método.  
  
 Este método corresponde a la <xref:System.Math.Log10%2A?displayProperty=nameWithType> método para los tipos numéricos primitivos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El logaritmo en base 10 de <paramref name="value" /> está fuera del intervalo del tipo de datos <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve el mayor de dos valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Parámetro <paramref name="left" /> o <paramref name="right" />, el que sea mayor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método corresponde a la <xref:System.Math.Max%2A?displayProperty=nameWithType> método para los tipos numéricos primitivos.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Numerics.BigInteger.Max%2A> método para seleccionar el número más grande en una matriz de <xref:System.Numerics.BigInteger> valores.  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve el menor de dos valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Parámetro <paramref name="left" /> o <paramref name="right" />, el que sea menor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método corresponde a la <xref:System.Math.Min%2A?displayProperty=nameWithType> método para los tipos numéricos primitivos.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Numerics.BigInteger.Min%2A> método para seleccionar el número más pequeño de una matriz de <xref:System.Numerics.BigInteger> valores.  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que representa menos uno (-1).</summary>
        <value>Entero cuyo valor es menos uno (-1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.MinusOne%2A> propiedad se utiliza para comparar un <xref:System.Numerics.BigInteger> valor-1, o para asignar -1 para un <xref:System.Numerics.BigInteger> objeto.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Número que se va a elevar a la potencia <c>exponent</c>.</param>
        <param name="exponent">Exponente por el que se va a elevar <c>value</c>.</param>
        <param name="modulus">Número por el que se va a dividir el elemento <c>value</c> elevado a la potencia <c>exponent</c>.</param>
        <summary>Realiza una división de módulo en un número elevado a la potencia de otro número.</summary>
        <returns>Resto después de dividir <paramref name="value" /><sup>exponent</sup> por <paramref name="modulus" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.ModPow%2A> método evalúa la expresión siguiente:  
  
 (baseValue ^ exponente) Módulo Mod  
  
 Para realizar la exponenciación en <xref:System.Numerics.BigInteger> valores sin una división de módulo, utilice la <xref:System.Numerics.BigInteger.Pow%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se proporciona una ilustración simple de llamar al método el <xref:System.Numerics.BigInteger.ModPow%2A> método.  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="modulus" /> es cero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          El valor de <paramref name="exponent" /> es negativo.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer número que se va a multiplicar.</param>
        <param name="right">Segundo número que se va a multiplicar.</param>
        <summary>Devuelve el producto de dos valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Producto de los parámetros <paramref name="left" /> y <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.Multiply%2A> método se implementa para idiomas que no admiten la sobrecarga de operadores. Su comportamiento es idéntico a la multiplicación utilizando el operador de multiplicación. Además, el <xref:System.Numerics.BigInteger.Multiply%2A> método es un suplente útil para el operador de multiplicación al crear instancias de un <xref:System.Numerics.BigInteger> variable asignándole un producto que es el resultado de la multiplicación, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 Si es necesario, este método realiza automáticamente la conversión implícita de otros tipos integrales para <xref:System.Numerics.BigInteger> objetos. Esto se ilustra en el ejemplo en la sección siguiente, donde el <xref:System.Numerics.BigInteger.Multiply%2A> se pasa al método dos <xref:System.Int64> valores.  
  
   
  
## Examples  
 En el ejemplo siguiente se intenta realizar la multiplicación con dos enteros largos. Dado que el resultado supera el intervalo de un entero largo, un <xref:System.OverflowException> se produce y el <xref:System.Numerics.BigInteger.Multiply%2A> método se llama para controlar la multiplicación. Tenga en cuenta que C# requiere que utilice la `checked` palabra clave (como en este ejemplo) o el `/checked+` opción del compilador para asegurarse de que se produce una excepción en un desbordamiento numérico.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a negar.</param>
        <summary>Crea el negativo de un valor <see cref="T:System.Numerics.BigInteger" /> especificado.</summary>
        <returns>Resultado del parámetro <paramref name="value" /> multiplicado por menos uno (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La negación Obtiene el inverso aditivo de un número. El inverso aditivo de un número es un número que genera un valor de cero cuando se agrega al número original.  
  
 El <xref:System.Numerics.BigInteger.Negate%2A> método se implementa para idiomas que no admiten operadores personalizados. Su comportamiento es idéntico a la negación usando el operador unario de negación. Además, el <xref:System.Numerics.BigInteger.Negate%2A> método es un suplente útil para el operador de negación al crear instancias de un <xref:System.Numerics.BigInteger> variable, tal y como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra tres maneras para negar el valor de un <xref:System.Numerics.BigInteger> objeto.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que representa el número uno (1).</summary>
        <value>Objeto cuyo valor es uno (1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.One%2A> propiedad normalmente se usa para comparar un <xref:System.Numerics.BigInteger> valor en 1 o para asignar 1 para un <xref:System.Numerics.BigInteger> objeto.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a sumar.</param>
        <param name="right">Segundo valor que se va a sumar.</param>
        <summary>Suma los valores de dos objetos <see cref="T:System.Numerics.BigInteger" /> especificados.</summary>
        <returns>La suma de <paramref name="left" /> y <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Addition%2A> método define la operación de suma para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.Add%2A> método en su lugar.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor.</param>
        <param name="right">Segundo valor.</param>
        <summary>Realiza una operación <see langword="And" /> bit a bit en dos valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Resultado de la operación <see langword="And" /> bit a bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> método define bit a bit `And` operación para <xref:System.Numerics.BigInteger> valores. Bit a bit `And` operación establece los bits correspondientes de un bit sólo si de resultado `left` y `right` también se establecen como se muestra en la tabla siguiente.  
  
|Valor del bit en `left`|Valor del bit en `right`|Bit de resultado|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 El <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> método permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 El <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> método realiza el bit a bit `And` operación con dos <xref:System.Numerics.BigInteger> valores como si fueran dos en la representación del complemento de dos con extensión de signo virtual.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor.</param>
        <param name="right">Segundo valor.</param>
        <summary>Realiza una operación <see langword="Or" /> bit a bit en dos valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Resultado de la operación <see langword="Or" /> bit a bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> método define bit a bit `Or` operación para <xref:System.Numerics.BigInteger> valores. Bit a bit `Or` operación establece un bit sólo si de resultado uno o ambos bits correspondientes de `left` y `right` se establecen, como se muestra en la tabla siguiente.  
  
|Valor del bit en `left`|Valor del bit en `right`|Bit de resultado|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 El <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> método permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 El <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> método realiza el bit a bit `Or` operación con dos <xref:System.Numerics.BigInteger> valores como si fueran dos en la representación del complemento de dos con extensión de signo virtual.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a disminuir.</param>
        <summary>Disminuye un valor <see cref="T:System.Numerics.BigInteger" /> en 1.</summary>
        <returns>Valor del parámetro <paramref name="value" /> disminuido en 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Decrement%2A> método define la operación de decremento de <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.Subtract%2A> método en su lugar. Por ejemplo:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 Dado que <xref:System.Numerics.BigInteger> objetos son inmutables, el <xref:System.Numerics.BigInteger.op_Decrement%2A> crea un nuevo operador <xref:System.Numerics.BigInteger> objeto cuyo valor es uno menor que el <xref:System.Numerics.BigInteger> objeto representado por `value`. Esto significa que las llamadas repetidas a <xref:System.Numerics.BigInteger.op_Decrement%2A> puede resultar costosa.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valor que se va a dividir.</param>
        <param name="divisor">Valor por el que se va a dividir.</param>
        <summary>Divide un valor <see cref="T:System.Numerics.BigInteger" /> especificado por otro valor <see cref="T:System.Numerics.BigInteger" /> indicado utilizando división de enteros.</summary>
        <returns>Resultado entero de la división.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Division%2A> método define la operación de división para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 Los lenguajes que no admiten operadores personalizados ni sobrecarga de operadores pueden llamar el <xref:System.Numerics.BigInteger.Divide%2A> método en su lugar.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 En el ejemplo siguiente se crea una matriz de <xref:System.Numerics.BigInteger> valores. A continuación, utiliza cada elemento como el cociente en una operación de división que utiliza el <xref:System.Numerics.BigInteger.Divide%2A> método, el operador de división (/) y el <xref:System.Numerics.BigInteger.DivRem%2A> método.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          El valor de <paramref name="divisor" /> es 0 (cero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si dos valores son iguales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor entero long con signo y un valor <see cref="T:System.Numerics.BigInteger" /> son iguales.</summary>
        <returns>
          Es <see langword="true" /> si los parámetros <paramref name="left" /> y <paramref name="right" /> tienen el mismo valor; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> método define la operación de comparación de igualdad para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> en su lugar, el método de instancia.  
  
 Si `left` es un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, o <xref:System.UInt32> valor, se convierte implícitamente en un <xref:System.Int64> valor cuando se realiza la operación.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> y un valor entero long con signo son iguales.</summary>
        <returns>
          Es <see langword="true" /> si los parámetros <paramref name="left" /> y <paramref name="right" /> tienen el mismo valor; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> método define la operación de comparación de igualdad para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> en su lugar, el método de instancia.  
  
 Si `right` es un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, o <xref:System.UInt32> valor, se convierte implícitamente en un <xref:System.Int64> valor cuando se realiza la operación.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si los valores de dos objetos <see cref="T:System.Numerics.BigInteger" /> son iguales.</summary>
        <returns>
          Es <see langword="true" /> si los parámetros <paramref name="left" /> y <paramref name="right" /> tienen el mismo valor; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> método define el funcionamiento del operador de igualdad para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> en su lugar, el método de instancia.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> y un valor entero long sin signo son iguales.</summary>
        <returns>
          Es <see langword="true" /> si los parámetros <paramref name="left" /> y <paramref name="right" /> tienen el mismo valor; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> método define la operación de comparación de igualdad para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> en su lugar, el método de instancia.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor entero long sin signo y un valor <see cref="T:System.Numerics.BigInteger" /> son iguales.</summary>
        <returns>
          Es <see langword="true" /> si los parámetros <paramref name="left" /> y <paramref name="right" /> tienen el mismo valor; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> método define la operación de comparación de igualdad para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> en su lugar, el método de instancia.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor.</param>
        <param name="right">Segundo valor.</param>
        <summary>Realiza una operación exclusiva <see langword="Or" /> (<see langword="XOr" />) bit a bit en dos valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Resultado de la operación <see langword="Or" /> bit a bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El resultado de un exclusivo bit a bit `Or` operación es `true` si los valores de los dos bits son diferentes; en caso contrario, es `false`. La tabla siguiente muestra exclusiva `Or` operación.  
  
|Bit x `left`|Bit x `right`|Valor devuelto|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 El <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> método permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 El <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> método realiza la exclusivo bit a bit `Or` operación con dos <xref:System.Numerics.BigInteger> valores como si fueran dos en la representación del complemento de dos con extensión de signo virtual.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define una conversión explícita entre un objeto <see cref="T:System.Numerics.BigInteger" /> y otro tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un tipo <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define una conversión explícita de un objeto <see cref="T:System.Decimal" /> en un valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquier parte fraccionaria de los `value` parámetro se trunca antes de la conversión.

 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definen los tipos a la que o desde el que un <xref:System.Numerics.BigInteger> se puede convertir el objeto. Dado que la conversión de <xref:System.Decimal> a <xref:System.Numerics.BigInteger> puede implicar el truncamiento de cualquier parte fraccionaria de `value`, los compiladores de lenguajes no realizan esta conversión automáticamente. En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` en Visual Basic) se utiliza. En caso contrario, muestra un error del compilador.   

 Para los idiomas que no admiten operadores personalizados, el método alternativo es <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.


## Examples
 El ejemplo siguiente convierte los elementos individuales en una matriz de <xref:System.Decimal> valores <xref:System.Numerics.BigInteger> objetos y, a continuación, muestra el resultado de cada conversión. Tenga en cuenta las fracciones forma parte de un <xref:System.Decimal> se trunca el valor durante la conversión.   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un tipo <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define una conversión explícita de un valor <see cref="T:System.Double" /> en un valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquier parte fraccionaria de los `value` parámetro se trunca antes de la conversión.

 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definen los tipos a la que o desde el que un <xref:System.Numerics.BigInteger> se puede convertir el objeto. Dado que la conversión de <xref:System.Double> a <xref:System.Numerics.BigInteger> puede implicar el truncamiento de cualquier parte fraccionaria de `value`, los compiladores de lenguajes no realizan esta conversión automáticamente. En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` en Visual Basic) se utiliza. En caso contrario, muestra un error del compilador.

 Para los idiomas que no admiten operadores personalizados, el método alternativo es <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.


## Examples
 El ejemplo siguiente convierte los elementos individuales en una matriz de <xref:System.Double> valores <xref:System.Numerics.BigInteger> objetos y, a continuación, muestra el resultado de cada conversión. Tenga en cuenta las fracciones forma parte de un <xref:System.Double> se trunca el valor durante la conversión.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor de <paramref name="value" /> es <see cref="F:System.Double.NaN" />.  
  
 O bien  
  
 El valor de <paramref name="value" /> es <see cref="F:System.Double.PositiveInfinity" />.
  
 O bien  
  
 El valor de <paramref name="value" /> es <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un tipo <see cref="T:System.Byte" />.</param>
        <summary>Define una conversión explícita de un objeto <see cref="T:System.Numerics.BigInteger" /> en un valor de byte sin signo.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definen los tipos a la que o desde el que un <xref:System.Numerics.BigInteger> se puede convertir el objeto. Los compiladores de lenguajes no realizan esta conversión automáticamente porque puede implicar pérdida de datos. En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` o `CByte` en Visual Basic) se utiliza. En caso contrario, muestra un error del compilador.   

 Dado que esta operación define una conversión de restricción, puede producir un <xref:System.OverflowException> en tiempo de ejecución si el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.Byte> tipo de datos. No hay ninguna pérdida de precisión en el cuadro <xref:System.Byte> valor si la conversión se realiza correctamente.

## Examples
 En el ejemplo siguiente se muestra la conversión de <xref:System.Numerics.BigInteger> a <xref:System.Byte> valores. También controla un <xref:System.OverflowException> que se produce porque el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.Byte> tipo de datos.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor de <paramref name="value" /> es menor que <see cref="F:System.Byte.MinValue" />.  
  
 O bien  
  
 El valor de <paramref name="value" /> es mayor que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un tipo <see cref="T:System.Decimal" />.</param>
        <summary>Define una conversión explícita de un objeto <see cref="T:System.Numerics.BigInteger" /> en un valor <see cref="T:System.Decimal" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definen los tipos a la que o desde el que un <xref:System.Numerics.BigInteger> se puede convertir el objeto. Los compiladores de lenguajes no realizan esta conversión automáticamente porque puede implicar pérdida de datos. En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` o `CDec` en Visual Basic) se utiliza.   

 Dado que esta operación define una conversión de restricción, puede producir un <xref:System.OverflowException> en tiempo de ejecución si el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.Decimal> tipo de datos. 

## Examples
 En el ejemplo siguiente se muestra la conversión de <xref:System.Numerics.BigInteger> a <xref:System.Decimal> valores. También controla un <xref:System.OverflowException> que se produce porque el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.Decimal> tipo de datos.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor de <paramref name="value" /> es menor que <see cref="F:System.Decimal.MinValue" />.  
  
 O bien  
  
 El valor de <paramref name="value" /> es mayor que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un tipo <see cref="T:System.Double" />.</param>
        <summary>Define una conversión explícita de un objeto <see cref="T:System.Numerics.BigInteger" /> en un valor <see cref="T:System.Double" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definen los tipos a la que o desde el que un <xref:System.Numerics.BigInteger> se puede convertir el objeto. Los compiladores de lenguajes no realizan esta conversión automáticamente porque puede implicar pérdida de datos. En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` o `CDbl` en Visual Basic) se utiliza.   

 Dado que la <xref:System.Numerics.BigInteger> valor puede estar fuera del intervalo de la <xref:System.Double> de tipo de datos, esta operación es una conversión de restricción. Si la conversión se realiza correctamente, no producen un <xref:System.OverflowException>. En su lugar, si la <xref:System.Numerics.BigInteger> valor es menor que <xref:System.Double.MinValue?displayProperty=nameWithType>, resultante <xref:System.Double> valor es <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Si el <xref:System.Numerics.BigInteger> valor es mayor que <xref:System.Double.MaxValue?displayProperty=nameWithType>, resultante <xref:System.Double> valor es <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.
 
 La conversión de un <xref:System.Numerics.BigInteger> a una <xref:System.Double> puede conllevar una pérdida de precisión. En algunos casos, la pérdida de precisión puede provocar la operación de conversión o lleve a cabo correctamente incluso si la <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.Double> tipo de datos. Esto se muestra en el ejemplo siguiente. Asigna el valor máximo de un <xref:System.Double> a dos <xref:System.Numerics.BigInteger> variables, se incrementa una <xref:System.Numerics.BigInteger> variable 9.999e291 y prueba las dos variables son iguales. Tal y como se esperaba, la llamada a la <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> método muestra que no son iguales. Sin embargo, la conversión de la mayor <xref:System.Numerics.BigInteger> valor nuevo a una <xref:System.Double> se realiza correctamente, aunque la <xref:System.Numerics.BigInteger> ahora supera el valor <xref:System.Double.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 En el ejemplo siguiente se muestra la conversión de <xref:System.Numerics.BigInteger> a <xref:System.Double> valores.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un entero de 16 bits con signo.</param>
        <summary>Define una conversión explícita de un objeto <see cref="T:System.Numerics.BigInteger" /> en un valor entero de 16 bits con signo.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definen los tipos a la que o desde el que un <xref:System.Numerics.BigInteger> se puede convertir el objeto. Los compiladores de lenguajes no realizan esta conversión automáticamente porque puede implicar pérdida de datos. En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` o `CShort` en Visual Basic) se utiliza. En caso contrario, muestra un error del compilador.   

 Dado que esta operación define una conversión de restricción, puede producir un <xref:System.OverflowException> en tiempo de ejecución si el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.Int16> tipo de datos. No hay ninguna pérdida de precisión en el cuadro <xref:System.Int16> valor si la conversión se realiza correctamente.

## Examples
 En el ejemplo siguiente se muestra la conversión de <xref:System.Numerics.BigInteger> a <xref:System.Int16> valores. También controla un <xref:System.OverflowException> que se produce porque el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.Int16> tipo de datos.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor de <paramref name="value" /> es menor que <see cref="F:System.Int16.MinValue" />.  
  
 O bien  
  
 El valor de <paramref name="value" /> es mayor que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un entero de 32 bits con signo.</param>
        <summary>Define una conversión explícita de un objeto <see cref="T:System.Numerics.BigInteger" /> en un valor entero de 32 bits con signo.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definen los tipos a la que o desde el que un <xref:System.Numerics.BigInteger> se puede convertir el objeto. Los compiladores de lenguajes no realizan esta conversión automáticamente porque puede implicar pérdida de datos. En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` o `CInt` en Visual Basic) se utiliza. En caso contrario, muestra un error del compilador.   

 Dado que esta operación define una conversión de restricción, puede producir un <xref:System.OverflowException> en tiempo de ejecución si el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.Int32> tipo de datos. No hay ninguna pérdida de precisión en el cuadro <xref:System.Int16> valor si la conversión se realiza correctamente.

## Examples
 En el ejemplo siguiente se muestra la conversión de <xref:System.Numerics.BigInteger> a <xref:System.Int32> valores. También controla un <xref:System.OverflowException> que se produce porque el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.Int32> tipo de datos.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor de <paramref name="value" /> es menor que <see cref="F:System.Int32.MinValue" />.  
  
 O bien  
  
 El valor de <paramref name="value" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un entero de 64 bits con signo.</param>
        <summary>Define una conversión explícita de un objeto <see cref="T:System.Numerics.BigInteger" /> en un valor entero de 64 bits con signo.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definen los tipos a la que o desde el que un <xref:System.Numerics.BigInteger> se puede convertir el objeto. Los compiladores de lenguajes no realizan esta conversión automáticamente porque puede implicar pérdida de datos. En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` o `CLng` en Visual Basic) se utiliza. En caso contrario, muestra un error del compilador.  

 Dado que esta operación define una conversión de restricción, puede producir un <xref:System.OverflowException> en tiempo de ejecución si el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.Int64> tipo de datos. 

## Examples
 En el ejemplo siguiente se muestra la conversión de <xref:System.Numerics.BigInteger> a <xref:System.Int64> valores. También controla un <xref:System.OverflowException> que se produce porque el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.Int64> tipo de datos.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor de <paramref name="value" /> es menor que <see cref="F:System.Int64.MinValue" />.  
  
 O bien  
  
 El valor de <paramref name="value" /> es mayor que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un valor de 8 bits con signo.</param>
        <summary>Define una conversión explícita de un objeto <see cref="T:System.Numerics.BigInteger" /> en un valor de 8 bits con signo.  
  
 Esta API no es conforme a CLS. La alternativa conforme es <see cref="T:System.Int16" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definen los tipos a la que o desde el que un <xref:System.Numerics.BigInteger> se puede convertir el objeto. Los compiladores de lenguajes no realizan esta conversión automáticamente porque puede implicar pérdida de datos. En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` o `CSByte` en Visual Basic) se utiliza. En caso contrario, muestra un error del compilador.  

 Dado que esta operación define una conversión de restricción, puede producir un <xref:System.OverflowException> en tiempo de ejecución si el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.SByte> tipo de datos. No hay ninguna pérdida de precisión en el cuadro <xref:System.SByte> valor si la conversión se realiza correctamente.

## Examples
 En el ejemplo siguiente se muestra la conversión de <xref:System.Numerics.BigInteger> a <xref:System.SByte> valores. También controla un <xref:System.OverflowException> que se produce porque el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.SByte> tipo de datos.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor de <paramref name="value" /> es menor que <see cref="F:System.SByte.MinValue" />.  
  
 O bien  
  
 El valor de <paramref name="value" /> es mayor que <see cref="F:System.SByte.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un valor de punto flotante de precisión sencilla.</param>
        <summary>Define una conversión explícita de un objeto <see cref="T:System.Numerics.BigInteger" /> en un valor de punto flotante de precisión sencilla.</summary>
        <returns>Objeto que contiene la representación más cercana del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definen los tipos a la que o desde el que un <xref:System.Numerics.BigInteger> se puede convertir el objeto. Los compiladores de lenguajes no realizan esta conversión automáticamente porque puede implicar pérdida de datos o una pérdida de precisión. En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` o `CSng` en Visual Basic) se utiliza. En caso contrario, muestra un error del compilador.    

 Dado que la <xref:System.Numerics.BigInteger> valor puede estar fuera del intervalo de la <xref:System.Single> de tipo de datos, esta operación es una conversión de restricción. Si la conversión se realiza correctamente, no producen un <xref:System.OverflowException>. En su lugar, si la <xref:System.Numerics.BigInteger> valor es menor que <xref:System.Single.MinValue?displayProperty=nameWithType>, resultante <xref:System.Single> valor es <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Si el <xref:System.Numerics.BigInteger> valor es mayor que <xref:System.Single.MaxValue?displayProperty=nameWithType>, resultante <xref:System.Single> valor es <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.

 La conversión de un <xref:System.Numerics.BigInteger> a una <xref:System.Single> puede conllevar una pérdida de precisión. En algunos casos, la pérdida de precisión puede provocar la operación de conversión o lleve a cabo correctamente incluso si la <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.Single> tipo de datos. Esto se muestra en el ejemplo siguiente. Asigna el valor máximo de un <xref:System.Single> a dos <xref:System.Numerics.BigInteger> variables, se incrementa una <xref:System.Numerics.BigInteger> variable 9.999e291 y prueba las dos variables son iguales. Tal y como se esperaba, la llamada a la <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> método muestra que no son iguales. Sin embargo, la conversión de la mayor <xref:System.Numerics.BigInteger> valor nuevo a una <xref:System.Single> se realiza correctamente, aunque la <xref:System.Numerics.BigInteger> ahora supera el valor <xref:System.Single.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 En el ejemplo siguiente se muestra la conversión de <xref:System.Numerics.BigInteger> a <xref:System.Single> valores.   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un entero de 16 bits sin signo.</param>
        <summary>Define una conversión explícita de un objeto <see cref="T:System.Numerics.BigInteger" /> en un valor entero de 16 bits sin signo.  
  
 Esta API no es conforme a CLS. La alternativa conforme es <see cref="T:System.Int32" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definen los tipos a la que o desde el que un <xref:System.Numerics.BigInteger> se puede convertir el objeto. Los compiladores de lenguajes no realizan esta conversión automáticamente porque puede implicar pérdida de datos. En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` o `CUShort` en Visual Basic) se utiliza. En caso contrario, muestra un error del compilador.    

 Dado que esta operación define una conversión de restricción, puede producir un <xref:System.OverflowException> en tiempo de ejecución si el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.UInt16> tipo de datos. No hay ninguna pérdida de precisión en el cuadro <xref:System.UInt16> valor si la conversión se realiza correctamente.

## Examples
 En el ejemplo siguiente se muestra la conversión de <xref:System.Numerics.BigInteger> a <xref:System.UInt16> valores. También controla un <xref:System.OverflowException> que se produce porque el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.UInt16> tipo de datos.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor de <paramref name="value" /> es menor que <see cref="F:System.UInt16.MinValue" />.  
  
 O bien  
  
 El valor de <paramref name="value" /> es mayor que <see cref="F:System.UInt16.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un entero de 32 bits sin signo.</param>
        <summary>Define una conversión explícita de un objeto <see cref="T:System.Numerics.BigInteger" /> en un valor entero de 32 bits sin signo.  
  
 Esta API no es conforme a CLS. La alternativa conforme es <see cref="T:System.Int64" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definen los tipos a la que o desde el que un <xref:System.Numerics.BigInteger> se puede convertir el objeto. Los compiladores de lenguajes no realizan esta conversión automáticamente porque puede implicar pérdida de datos. En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` o `CUInt` en Visual Basic) se utiliza. En caso contrario, muestra un error del compilador.    

 Dado que esta operación define una conversión de restricción, puede producir un <xref:System.OverflowException> en tiempo de ejecución si el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.UInt32> tipo de datos. No hay ninguna pérdida de precisión en el cuadro <xref:System.UInt32> valor si la conversión se realiza correctamente.

## Examples
 En el ejemplo siguiente se muestra la conversión de <xref:System.Numerics.BigInteger> a <xref:System.UInt32> valores. También controla un <xref:System.OverflowException> que se produce porque el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.UInt32> tipo de datos.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor de <paramref name="value" /> es menor que <see cref="F:System.UInt32.MinValue" />.  
  
 O bien  
  
 El valor de <paramref name="value" /> es mayor que <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un entero de 64 bits sin signo.</param>
        <summary>Define una conversión explícita de un objeto <see cref="T:System.Numerics.BigInteger" /> en un valor entero de 64 bits sin signo.  
  
 Esta API no es conforme a CLS. La alternativa conforme es <see cref="T:System.Double" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definen los tipos a la que o desde el que un <xref:System.Numerics.BigInteger> se puede convertir el objeto. Los compiladores de lenguajes no realizan esta conversión automáticamente porque puede implicar pérdida de datos. En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` o `CULng` en Visual Basic) se utiliza. En caso contrario, muestra un error del compilador.    

 Dado que esta operación define una conversión de restricción, puede producir un <xref:System.OverflowException> en tiempo de ejecución si el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.UInt64> tipo de datos. No hay ninguna pérdida de precisión en el cuadro <xref:System.UInt64> valor si la conversión se realiza correctamente.

## Examples
 En el ejemplo siguiente se muestra la conversión de <xref:System.Numerics.BigInteger> a <xref:System.UInt64> valores. También controla un <xref:System.OverflowException> que se produce porque el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.UInt64> tipo de datos.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor de <paramref name="value" /> es menor que <see cref="F:System.UInt64.MinValue" />.  
  
 O bien  
  
 El valor de <paramref name="value" /> es mayor que <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un tipo <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define una conversión explícita de un valor <see cref="T:System.Single" /> en un valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquier parte fraccionaria de los `value` parámetro se trunca antes de la conversión.
 
 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definen los tipos a la que o desde el que un <xref:System.Numerics.BigInteger> se puede convertir el objeto. Dado que la conversión de <xref:System.Single> a <xref:System.Numerics.BigInteger> puede implicar el truncamiento de cualquier parte fraccionaria de `value`, los compiladores de lenguajes no realizan esta conversión automáticamente. En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` en Visual Basic) se utiliza. En caso contrario, muestra un error del compilador.

 Para los idiomas que no admiten operadores personalizados, el método alternativo es <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.


## Examples
 El ejemplo siguiente convierte los elementos individuales en una matriz de <xref:System.Single> valores <xref:System.Numerics.BigInteger> objetos y, a continuación, muestra el resultado de cada conversión. Tenga en cuenta las fracciones forma parte de un <xref:System.Single> se trunca el valor durante la conversión.
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">El valor de <paramref name="value" /> es <see cref="F:System.Single.NaN" />.  
  
 O bien  
  
 El valor de <paramref name="value" /> es <see cref="F:System.Single.PositiveInfinity" />.
  
 O bien  
  
 El valor de <paramref name="value" /> es <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si un valor especificado es mayor que otro valor especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un entero de 64 bits con signo es mayor que un valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es mayor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_GreaterThan%2A> método define el funcionamiento del operador para mayor que <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> en su lugar, el método de instancia. Algunos lenguajes también pueden llamar el <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 Si `left` es un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, o <xref:System.UInt32> valor, se convierte implícitamente en un <xref:System.Int64> valor cuando se realiza la operación.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> es mayor que un valor entero de 64 bits con signo.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es mayor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_GreaterThan%2A> método define el funcionamiento del operador para mayor que <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> método en su lugar. Algunos lenguajes también pueden llamar el <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 Si `right` es un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, o <xref:System.UInt32> valor, se convierte implícitamente en un <xref:System.Int64> valor cuando se realiza la operación.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> es mayor que otro valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es mayor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_GreaterThan%2A> método define el funcionamiento del operador para mayor que <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> método en su lugar. También puede llamar a la <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> es mayor que un entero de 64 bits sin signo.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es mayor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_GreaterThan%2A> método define el funcionamiento del operador para mayor que <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método en su lugar. Algunos lenguajes también pueden llamar el <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> es mayor que un entero de 64 bits sin signo.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es mayor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_GreaterThan%2A> método define el funcionamiento del operador para mayor que <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método en su lugar. Algunos lenguajes también pueden llamar el <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si un valor especificado es mayor o igual que otro valor especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un entero de 64 bits con signo es mayor o igual que un valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es mayor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> método define la operación de mayor o igual que el operador para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> método en su lugar. Algunos lenguajes también pueden llamar el <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 Si `left` es un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, o <xref:System.UInt32> valor, se convierte implícitamente en un <xref:System.Int64> valor cuando se realiza la operación.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> es mayor o igual que un valor entero de 64 bits con signo.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es mayor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> método define la operación de mayor o igual que el operador para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> método en su lugar. Algunos lenguajes también pueden llamar el <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 Si `right` es un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, o <xref:System.UInt32> valor, se convierte implícitamente en un <xref:System.Int64> valor cuando se realiza la operación.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> es mayor o igual que otro valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es mayor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> método define la operación de mayor o igual que el operador para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> método en su lugar. Algunos lenguajes también pueden llamar el <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> es mayor o igual que un valor entero de 64 bits sin signo.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es mayor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> método define la operación de mayor o igual que el operador para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método en su lugar. Algunos lenguajes también pueden llamar el <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un entero de 64 bits sin signo es mayor o igual que un valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es mayor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> método define la operación de mayor o igual que el operador para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método en su lugar. Algunos lenguajes también pueden llamar el <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define una conversión implícita entre un objeto <see cref="T:System.Numerics.BigInteger" /> y otro tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un tipo <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define una conversión implícita de un byte sin signo en un valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquier parte fraccionaria de los `value` parámetro se trunca antes de la conversión.

 Para los idiomas que no admiten operadores implícita, el método alternativo es <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definen los tipos a la que o de que un compilador puede convertir automáticamente un <xref:System.Numerics.BigInteger> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException>. Esta sobrecarga permite al compilador administrar las conversiones de un <xref:System.Byte> valor a un <xref:System.Numerics.BigInteger> valor, como se muestra en el ejemplo siguiente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un tipo <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define una conversión implícita de un entero de 16 bits con signo en un valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para los idiomas que no admiten operadores implícita, el método alternativo es <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definen los tipos a la que o de que un compilador puede convertir automáticamente un <xref:System.Numerics.BigInteger> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException>. Esta sobrecarga permite al compilador administrar las conversiones de un <xref:System.Int16> valor a un <xref:System.Numerics.BigInteger> valor, como se muestra en el ejemplo siguiente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un tipo <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define una conversión implícita de un entero de 32 bits con signo en un valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para los idiomas que no admiten operadores implícita, el método alternativo es <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.  

 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definen los tipos a la que o de que un compilador puede convertir automáticamente un <xref:System.Numerics.BigInteger> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException>. Esta sobrecarga permite al compilador administrar las conversiones de un <xref:System.Int32> valor a un <xref:System.Numerics.BigInteger> valor, como se muestra en el ejemplo siguiente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un tipo <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define una conversión implícita de un entero de 64 bits con signo en un valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para los idiomas que no admiten operadores implícita, el método alternativo es <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.   
 
 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definen los tipos a la que o de que un compilador puede convertir automáticamente un <xref:System.Numerics.BigInteger> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException>. Esta sobrecarga permite al compilador administrar las conversiones de un <xref:System.Int64> valor a un <xref:System.Numerics.BigInteger> valor, como se muestra en el ejemplo siguiente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un tipo <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define una conversión implícita de un entero de 8 bits con signo en un valor <see cref="T:System.Numerics.BigInteger" />.  
  
 Esta API no es conforme a CLS. La alternativa conforme es <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para los idiomas que no admiten operadores implícita, el método alternativo es <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definen los tipos a la que o de que un compilador puede convertir automáticamente un <xref:System.Numerics.BigInteger> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException>. Esta sobrecarga permite al compilador administrar las conversiones de un <xref:System.SByte> valor a un <xref:System.Numerics.BigInteger> valor, como se muestra en el ejemplo siguiente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un tipo <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define una conversión implícita de un entero de 16 bits sin signo en un valor <see cref="T:System.Numerics.BigInteger" />.  
  
 Esta API no es conforme a CLS. La alternativa conforme es <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para los idiomas que no admiten operadores implícita, el método alternativo es <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definen los tipos a la que o de que un compilador puede convertir automáticamente un <xref:System.Numerics.BigInteger> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException>. Esta sobrecarga permite al compilador administrar las conversiones de un <xref:System.UInt16> valor a un <xref:System.Numerics.BigInteger> valor, como se muestra en el ejemplo siguiente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un tipo <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define una conversión implícita de un entero de 32 bits sin signo en un valor <see cref="T:System.Numerics.BigInteger" />.  
  
 Esta API no es conforme a CLS. La alternativa conforme es <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para los idiomas que no admiten operadores implícita, el método alternativo es <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definen los tipos a la que o de que un compilador puede convertir automáticamente un <xref:System.Numerics.BigInteger> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException>. Esta sobrecarga permite al compilador administrar las conversiones de un <xref:System.UInt32> valor a un <xref:System.Numerics.BigInteger> valor, como se muestra en el ejemplo siguiente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a convertir en un tipo <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define una conversión implícita de un entero de 64 bits sin signo en un valor <see cref="T:System.Numerics.BigInteger" />.  
  
 Esta API no es conforme a CLS. La alternativa conforme es <see cref="T:System.Double" />.</summary>
        <returns>Objeto que contiene el valor del parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para los idiomas que no admiten operadores implícita, el método alternativo es <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.   

 Las sobrecargas de la <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definen los tipos a la que o de que un compilador puede convertir automáticamente un <xref:System.Numerics.BigInteger> valor sin un operador de conversión explícito (en C#) o una llamada a una función de conversión (en Visual Basic). Son conversiones de ampliación que no implican la pérdida de datos y no producen un <xref:System.OverflowException>. Esta sobrecarga permite al compilador administrar las conversiones de un <xref:System.UInt64> valor a un <xref:System.Numerics.BigInteger> valor, como se muestra en el ejemplo siguiente.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a aumentar.</param>
        <summary>Aumenta un valor <see cref="T:System.Numerics.BigInteger" /> en 1.</summary>
        <returns>Valor del parámetro <paramref name="value" /> aumentado en 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Increment%2A> método define la operación de incremento de <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 Algunos lenguajes (como Visual Basic) que carecen de un operador de incremento o que no admiten la sobrecarga de operadores pueden llamar el <xref:System.Numerics.BigInteger.op_Increment%2A> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 Dado que <xref:System.Numerics.BigInteger> objetos son inmutables, el <xref:System.Numerics.BigInteger.op_Increment%2A> crea un nuevo operador <xref:System.Numerics.BigInteger> objeto cuyo valor es uno más que los <xref:System.Numerics.BigInteger> objeto representado por `value`. Por lo tanto, las llamadas repetidas a <xref:System.Numerics.BigInteger.op_Increment%2A> puede resultar costosa.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si dos valores numéricos no son iguales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un entero de 64 bits con signo y un valor <see cref="T:System.Numerics.BigInteger" /> no son iguales.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> y <paramref name="right" /> no son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Inequality%2A> método define el funcionamiento del operador de desigualdad para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 Los lenguajes que no admiten operadores personalizados pueden comprobar la desigualdad mediante una de las siguientes técnicas:  
  
-   Llamar a la <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> instancia de método, que indica la relación entre un <xref:System.Numerics.BigInteger> y un valor entero long con signo.  
  
-   Llamar a la <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> la instancia de método e invertir su valor.  
  
 Si `left` es un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, o <xref:System.UInt32> valor, se convierte implícitamente en un <xref:System.Int64> valor cuando se realiza la operación.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> y un valor de 64 bits con signo no son iguales.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> y <paramref name="right" /> no son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Inequality%2A> método define el funcionamiento del operador de desigualdad para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 Los lenguajes que no admiten operadores personalizados pueden comprobar la desigualdad mediante una de las siguientes técnicas:  
  
-   Llamar a la <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> método, que indica la relación entre un <xref:System.Numerics.BigInteger> y un valor entero long con signo.  
  
-   Llamar a la <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> método e invertir su valor.  
  
 Si `right` es un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, o <xref:System.UInt32> valor, se convierte implícitamente en un <xref:System.Int64> valor cuando se realiza la operación.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si dos objetos <see cref="T:System.Numerics.BigInteger" /> tienen valores diferentes.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> y <paramref name="right" /> no son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Inequality%2A> método define el funcionamiento del operador de desigualdad para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 Los lenguajes que no admiten operadores personalizados pueden comprobar la desigualdad mediante una de las siguientes técnicas:  
  
-   Llamar a la <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> método, que indica la relación entre dos <xref:System.Numerics.BigInteger> objetos.  
  
-   Llamar a la <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> método e invertir su valor.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> y un valor de 64 bits sin signo no son iguales.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> y <paramref name="right" /> no son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Inequality%2A> método define el funcionamiento del operador de desigualdad para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 Los lenguajes que no admiten operadores personalizados pueden comprobar la desigualdad mediante una de las siguientes técnicas:  
  
-   Llamar a la <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método, que indica la relación entre un <xref:System.Numerics.BigInteger> y un valor entero long sin signo.  
  
-   Llamar a la <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> método e invertir su valor.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un entero de 64 bits sin signo y un valor <see cref="T:System.Numerics.BigInteger" /> no son iguales.</summary>
        <returns>
          <see langword="true" /> si <paramref name="left" /> y <paramref name="right" /> no son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Inequality%2A> método define el funcionamiento del operador de desigualdad para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 Los lenguajes que no admiten operadores personalizados pueden comprobar la desigualdad mediante una de las siguientes técnicas:  
  
-   Llamar a la <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método, que indica la relación entre un <xref:System.Numerics.BigInteger> y un valor entero long sin signo.  
  
-   Llamar a la <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> método e invertir su valor.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valor cuyos bits se van a desplazar.</param>
        <param name="shift">Número de bits que se va a desplazar <c>value</c> a la izquierda.</param>
        <summary>Desplaza un valor <see cref="T:System.Numerics.BigInteger" /> un número especificado de bits a la izquierda.</summary>
        <returns>Valor que se ha desplazado a la izquierda el número especificado de bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_LeftShift%2A> método define el funcionamiento del operador de desplazamiento a la izquierda bit a bit de <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  A diferencia de la operación de desplazamiento a la izquierda bit a bit con primitivos enteros, el <xref:System.Numerics.BigInteger.op_LeftShift%2A> método conserva el signo del original <xref:System.Numerics.BigInteger> valor.  
  
 Lenguajes que no admiten operadores personalizados pueden realizar una operación de desplazamiento a la izquierda bit a bit multiplicando `value` por `BigInteger.Pow(2, shift)`. En el ejemplo siguiente se muestra que los resultados son idénticos a los resultados del uso de este operador.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si un valor especificado es menor que un segundo valor especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un entero de 64 bits con signo es menor que un valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es menor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_LessThan%2A> método define el funcionamiento del operador para menor que <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> método en su lugar. Algunos lenguajes también pueden llamar el <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 Si `left` es un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, o <xref:System.UInt32> valor, se convierte implícitamente en un <xref:System.Int64> valor cuando se realiza la operación.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> es menor que un entero de 64 bits con signo.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es menor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_LessThan%2A> método define el funcionamiento del operador para menor que <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> método en su lugar. Algunos lenguajes también pueden llamar el <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 Si `right` es un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, o <xref:System.UInt32> valor, se convierte implícitamente en un <xref:System.Int64> valor cuando se realiza la operación.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> es menor que otro valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es menor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_LessThan%2A> método define el funcionamiento del operador para menor que <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> método en su lugar. Algunos lenguajes también pueden llamar el <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> es menor que un entero de 64 bits sin signo.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es menor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_LessThan%2A> método define el funcionamiento del operador para menor que <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método en su lugar. También puede llamar a la <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un entero de 64 bits sin signo es menor que un valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es menor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_LessThan%2A> método define el funcionamiento del operador para menor que <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método en su lugar. También puede llamar a la <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si un valor especificado es menor o igual que otro valor especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un entero de 64 bits con signo es menor o igual que un valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es menor o igual que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> método define la operación de la menor o igual al operador para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> método en su lugar. También puede llamar a la <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 Si `left` es un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, o <xref:System.UInt32> valor, se convierte implícitamente en un <xref:System.Int64> valor cuando se realiza la operación.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> es menor o igual que un entero de 64 bits con signo.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es menor o igual que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> método define la operación de la menor o igual al operador para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> método en su lugar. También puede llamar a la <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 Si `right` es un <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, o <xref:System.UInt32> valor, se convierte implícitamente en un <xref:System.Int64> valor cuando se realiza la operación.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> es menor o igual que otro valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es menor o igual que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> método define la operación de la menor o igual al operador para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.Compare%2A> método en su lugar. También puede llamar a la <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Numerics.BigInteger" /> es menor o igual que un entero de 64 bits sin signo.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es menor o igual que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> método define la operación de la menor o igual al operador para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método en su lugar. También puede llamar a la <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un entero de 64 bits sin signo es menor o igual que un valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="left" /> es menor o igual que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> método define la operación de la menor o igual al operador para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método en su lugar. También puede llamar a la <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> método directamente, como en el ejemplo siguiente se muestra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valor que se va a dividir.</param>
        <param name="divisor">Valor por el que se va a dividir.</param>
        <summary>Devuelve el resto que se obtiene al dividir dos valores <see cref="T:System.Numerics.BigInteger" /> especificados.</summary>
        <returns>Resto que es el resultado de la división.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Modulus%2A> método define el funcionamiento del operador de módulo para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> método en su lugar.  
  
 El signo del valor devuelto por la operación de módulo depende del signo de `dividend`: si `dividend` es positivo, la operación de módulo devuelve un resultado positivo; si es negativo, la operación de módulo devuelve un resultado negativo. El comportamiento de la operación de módulo con <xref:System.Numerics.BigInteger> valores es idéntica a la operación de módulo con otros tipos integrales.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          El valor de <paramref name="divisor" /> es 0 (cero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a multiplicar.</param>
        <param name="right">Segundo valor que se va a multiplicar.</param>
        <summary>Multiplica dos valores <see cref="T:System.Numerics.BigInteger" /> especificados.</summary>
        <returns>Producto de <paramref name="left" /> y <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Multiply%2A> método define el funcionamiento del operador de multiplicación para <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor de entero.</param>
        <summary>Devuelve el complemento a unos bit a bit de un valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Complemento a unos bit a bit de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_OnesComplement%2A> método define la operación bit a bit operador de complemento de uno para <xref:System.Numerics.BigInteger> valores. Bit a bit invierte el operador de complemento de uno cada bit en un valor numérico. Es decir, bits en `value` que son 0 se establecen en 1 en el resultado y los bits 1 se establecen en 0 en el resultado. El <xref:System.Numerics.BigInteger.op_OnesComplement%2A> método permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 Lenguajes que no admiten operadores personalizados pueden llamar a la <xref:System.Numerics.BigInteger.op_OnesComplement%2A> método directamente al realizar un bit a bit de uno de operación de complemento. Por ejemplo:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valor cuyos bits se van a desplazar.</param>
        <param name="shift">Número de bits que se va a desplazar <c>value</c> a la derecha.</param>
        <summary>Desplaza un valor <see cref="T:System.Numerics.BigInteger" /> un número especificado de bits a la derecha.</summary>
        <returns>Valor que se ha desplazado a la derecha el número especificado de bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_RightShift%2A> método define el funcionamiento del operador de desplazamiento a la derecha bit a bit de <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 Lenguajes que no admiten operadores personalizados pueden realizar una operación de desplazamiento a la derecha bit a bit dividiendo `value` por `BigInteger.Pow(2, shift)` y restar 1 veces `shift` para los valores negativos. En el ejemplo siguiente se muestra que los resultados son idénticos a los resultados del uso de este operador.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 Si `shift` es mayor o igual que el número de bits de positivo <xref:System.Numerics.BigInteger> valor, el resultado de la operación de desplazamiento a la derecha es <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Si `shift` es mayor que el número de bits de un negativo <xref:System.Numerics.BigInteger> valor, el resultado de la operación de desplazamiento a la derecha es <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Valor del que se va a restar (minuendo).</param>
        <param name="right">Valor que se va a restar (sustraendo).</param>
        <summary>Resta un valor <see cref="T:System.Numerics.BigInteger" /> de otro valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Resultado de restar <paramref name="right" /> de <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_Subtraction%2A> método define el funcionamiento del operador de sustracción de <xref:System.Numerics.BigInteger> valores. Permite que el código como el siguiente:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> método en su lugar.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a negar.</param>
        <summary>Crea el negativo de un valor BigInteger especificado.</summary>
        <returns>Resultado del parámetro <paramref name="value" /> multiplicado por menos uno (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> método define el funcionamiento del operador unario de negación (o el operador inverso aditivo) para <xref:System.Numerics.BigInteger> valores. La operación genera un valor que se obtiene en 0 (cero) cuando se agrega al número original. Los lenguajes que no admiten operadores personalizados pueden llamar el <xref:System.Numerics.BigInteger.Negate%2A> método en su lugar.  
  
 El método equivalente para este operador es <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 En el ejemplo siguiente se muestra tres maneras diferentes para negar el valor de un <xref:System.Numerics.BigInteger> objeto.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Valor de entero.</param>
        <summary>Devuelve el valor del operando <see cref="T:System.Numerics.BigInteger" />. (El signo del operando no cambia.)</summary>
        <returns>Valor del operando <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> método define el funcionamiento del operador unario positivo para <xref:System.Numerics.BigInteger> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte la representación en forma de cadena de un número en su <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que contiene el número que se va a convertir.</param>
        <summary>Convierte la representación en forma de cadena de un número en su <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Valor equivalente al número especificado en el parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `value` parámetro debe ser la representación de cadena de un número con el formato siguiente.  
  
 [*ws*][*sign*]*digits*[*ws*]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En la tabla siguiente describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Espacio en blanco opcional.|  
|*sign*|Un signo opcional. Caracteres de signo válidos se determinan mediante la <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> y <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> propiedades de la referencia cultural actual.|  
|*digits*|Una secuencia de dígitos que comprende del 0 al 9. Se omiten los ceros a la izquierda.|  
  
> [!NOTE]
>  La cadena especificada por el `value` parámetro se interpreta usando el <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> estilo. No puede contener cualquier separador de grupo o separador decimal y no puede tener una parte decimal.  
  
 El `value` parámetro se analiza utilizando la información de formato en un <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> objeto que se inicializa para la referencia cultural del sistema actual. Para obtener más información, vea <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Para analizar una cadena mediante el uso de la información de formato de una referencia cultural concreta, use la <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> método.  
  
> [!IMPORTANT]
>  Si usa el <xref:System.Numerics.BigInteger.Parse%2A> método a la representación de cadena de ida y vuelta de un <xref:System.Numerics.BigInteger> valor que se generan mediante la <xref:System.Numerics.BigInteger.ToString%2A> método, debe utilizar el <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> método con el especificador de formato "R" para generar la representación de cadena de la <xref:System.Numerics.BigInteger> valor. En caso contrario, la representación de cadena de la <xref:System.Numerics.BigInteger> conserva solo los 50 dígitos más significativos del valor original y los datos podrían perderse cuando se usa el <xref:System.Numerics.BigInteger.Parse%2A> método para restaurar la <xref:System.Numerics.BigInteger> valor.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Numerics.BigInteger.Parse%28System.String%29> método para crear instancias de dos <xref:System.Numerics.BigInteger> objetos. Multiplica cada objeto por otro número y, a continuación, llama el <xref:System.Numerics.BigInteger.Compare%2A> método para determinar la relación entre los dos valores.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> no tiene el formato correcto.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que contiene un número que se va a convertir.</param>
        <param name="style">Combinación bit a bit de los valores de enumeración que especifican el formato permitido de <c>value</c>.</param>
        <summary>Convierte la representación de cadena de un número con un estilo especificado en su <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Valor equivalente al número especificado en el parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `style` parámetro define los elementos de estilo (como espacios en blanco, el símbolo de signo positivo o negativo, el símbolo de separador de grupos o el símbolo de separador decimal) que se permiten en la `value` parámetro para la operación de análisis se realice correctamente. `styles` debe ser una combinación de marcadores de bits de la <xref:System.Globalization.NumberStyles> enumeración. El `style` parámetro hace que este método de sobrecarga útil cuando `value` contiene la representación de cadena de un valor hexadecimal, cuando el sistema de numeración (decimal o hexadecimal) representado por `value` se conoce en tiempo de ejecución o cuando desee denegar espacio en blanco o un inicio de sesión de símbolos en `value`.  
  
 Dependiendo del valor de `style`, el `value` parámetro puede incluir los siguientes elementos:  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 Si `style` incluye <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, el `value` parámetro puede contener los siguientes elementos:  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En la tabla siguiente describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Espacio en blanco opcional. Espacio en blanco puede aparecer al principio de `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> marca y pueden aparecer al final de `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> marca.|  
|*$*|Un símbolo de moneda específico de la referencia cultural. Su posición en la cadena viene definida por el <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> y <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propiedades de la referencia cultural actual. Símbolo de divisa de la referencia cultural actual puede aparecer en `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> marca.|  
|*sign*|Un signo opcional. El signo puede aparecer al principio de `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> marca y pueden aparecer al final de `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> marca. Se pueden utilizar paréntesis en `value` para indicar un valor negativo si `style` incluye la <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> marca.|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Una secuencia de dígitos comprendido entre 0 y 9. Para *dígitos fraccionarios*, solo el dígito 0 es válido.|  
|*,*|Un símbolo de separador de grupo específicas de referencias culturales. Separador de grupos de la referencia cultural actual puede aparecer en `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marca.|  
|*.*|Un símbolo de separador decimal de referencias culturales específicas. Símbolo de separador decimal de la referencia cultural actual puede aparecer en `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca. Puede aparecer el dígito 0 como un dígito fraccionario para que la operación de análisis se realice correctamente; Si *dígitos fraccionarios* incluye cualquier otro dígito, un <xref:System.FormatException> se produce.|  
|E|La "e" o el carácter "E", lo que indica que el valor se representa en notación exponencial (científica). El `value` parámetro puede representar un número en notación exponencial si `style` incluye la <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> marca.|  
|*dígitos hexadecimales*|Una secuencia de dígitos hexadecimales de 0 a f o 0 hasta la f el.|  
  
 Una cadena formada únicamente por dígitos (que corresponde a la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> estilo) siempre se analiza correctamente. La mayoría de las restantes <xref:System.Globalization.NumberStyles> miembros controlan los elementos que pueden estar presentes, pero no tienen que estar presentes en la cadena de entrada. La tabla siguiente se indica cómo individuales <xref:System.Globalization.NumberStyles> miembros afectan a los elementos que pueden estar presentes en `value`.  
  
|Valor de `NumberStyles`|Elementos permitidos en `value` además de dígitos|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|El *dígitos* solo el elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|El separador decimal (.) y *dígitos fraccionarios* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|La "e" o el carácter "E", que indica notación exponencial, junto con *dígitos exponenciales*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|El *ws* elemento situado al principio de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|El *ws* elemento situado al final de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|El *inicio de sesión* elemento situado al principio de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|El *inicio de sesión* elemento situado al final de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|El *inicio de sesión* elemento en forma de paréntesis delimitando el valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|El elemento separador de grupos.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|El elemento de moneda ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos los elementos. Sin embargo, `value` no puede representar un número hexadecimal o un número en notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|El *ws* elemento al principio o al final de `value`, *inicio de sesión* al principio de `value`y el separador decimal (*.*) símbolo. El `value` parámetro también puede utilizar la notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|El `ws`, `sign`, separador de grupos (*,*) y el separador decimal (*.*) elementos.|  
|<xref:System.Globalization.NumberStyles.Any>|Todos los elementos. Sin embargo, `value` no puede representar un número hexadecimal.|  
  
> [!IMPORTANT]
>  Si usa el <xref:System.Numerics.BigInteger.Parse%2A> método a la representación de cadena de ida y vuelta de un <xref:System.Numerics.BigInteger> valor que se generan mediante la <xref:System.Numerics.BigInteger.ToString%2A> método, debe utilizar el <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> método con el especificador de formato "R" para generar la representación de cadena de la <xref:System.Numerics.BigInteger> valor. En caso contrario, la representación de cadena de la <xref:System.Numerics.BigInteger> conserva solo los 50 dígitos más significativos del valor original y los datos podrían perderse cuando se usa el <xref:System.Numerics.BigInteger.Parse%2A> método para restaurar la <xref:System.Numerics.BigInteger> valor.  
  
 A diferencia de otros <xref:System.Globalization.NumberStyles> valores, que permiten, pero que no requieren la presencia de elementos de estilo determinada de `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> valor de estilo significa que los caracteres numéricos individuales de `value` siempre se interpretan como caracteres hexadecimales. Los caracteres hexadecimales válidos son 0-9, A-f y a-f. Los únicos otros marcadores que se pueden combinar con la `style` parámetro <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> y <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (El <xref:System.Globalization.NumberStyles> enumeración incluye un estilo de número compuesto, <xref:System.Globalization.NumberStyles.HexNumber>, que incluye ambos marcadores de espacio en blanco.)  
  
> [!NOTE]
>  Si `value` es la representación de cadena de un número hexadecimal, no se puede ir precedido de ninguna decoración (como `0x` o `&h`) que lo diferencie como un número hexadecimal. Esto provoca un error de conversión.  
  
 Si `value` es una cadena hexadecimal, el <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> método interpreta `value` como un número negativo que se almacenan utilizando dos representación del complemento si los primero de dos dígitos hexadecimales son mayores que o igual a `0x80`. En otras palabras, el método interpreta el bit de orden superior del primer byte de `value` como el bit de signo. Para asegurarse de que una cadena hexadecimal se interpreta correctamente como un número positivo, el primer dígito de `value` debe tener un valor de cero. Por ejemplo, el método interpreta `0x80` como un valor negativo, pero interpreta cualquiera `0x080` o `0x0080` como un valor positivo. En el ejemplo siguiente se ilustra la diferencia entre las cadenas hexadecimales que representan valores positivos y negativos.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 El `value` parámetro se analiza utilizando la información de formato en un <xref:System.Globalization.NumberFormatInfo> objeto que se inicializa para la referencia cultural del sistema actual. Para especificar la referencia cultural cuya información de formato se utiliza para la operación de análisis, llame a la <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> de sobrecarga.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra las llamadas a la <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> método con varios valores posibles para el `style` parámetro. Ilustra cómo se interpreta una cadena como un valor hexadecimal y cómo denegar los espacios y firmar los símbolos.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> no es un valor de <see cref="T:System.Globalization.NumberStyles" />.  
  
 O bien  
  
 <paramref name="style" /> incluye la marca <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> o <see cref="F:System.Globalization.NumberStyles.HexNumber" /> junto con otro valor.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> no cumple el modelo de entrada especificado por <see cref="T:System.Globalization.NumberStyles" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que contiene un número que se va a convertir.</param>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural sobre <c>value</c>.</param>
        <summary>Convierte la representación en forma de cadena de un número con el formato específico de la referencia cultural indicada en su <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Valor equivalente al número especificado en el parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `value` parámetro debe ser la representación de cadena de un número con el formato siguiente:  
  
 [*ws*][*sign*]*digits*[*ws*]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En la tabla siguiente describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Espacio en blanco opcional.|  
|*sign*|Un signo opcional. Caracteres de signo válidos se determinan mediante la <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> y <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> propiedades de la <xref:System.Globalization.NumberFormatInfo> objeto devuelto por la `provider` del objeto <xref:System.IFormatProvider.GetFormat%2A> método.|  
|*digits*|Una secuencia de dígitos que comprende del 0 al 9. Se omiten los ceros a la izquierda.|  
  
> [!NOTE]
>  La cadena especificada por el `value` parámetro se interpreta usando el <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> estilo. No puede contener cualquier separador de grupo o separador decimal y no puede tener una parte decimal.  
  
> [!IMPORTANT]
>  Si usa el <xref:System.Numerics.BigInteger.Parse%2A> método a la representación de cadena de ida y vuelta de un <xref:System.Numerics.BigInteger> valor que se generan mediante la <xref:System.Numerics.BigInteger.ToString%2A> método, debe utilizar el <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> método con el especificador de formato "R" para generar la representación de cadena de la <xref:System.Numerics.BigInteger> valor. En caso contrario, la representación de cadena de la <xref:System.Numerics.BigInteger> conserva solo los 50 dígitos más significativos del valor original y los datos podrían perderse cuando se usa el <xref:System.Numerics.BigInteger.Parse%2A> método para restaurar la <xref:System.Numerics.BigInteger> valor.  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación cuyo <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato específica de la referencia cultural. Cuando el <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> se invoca el método, llama la `provider` del parámetro <xref:System.IFormatProvider.GetFormat%2A> método y le pasa un <xref:System.Type> objeto que representa el <xref:System.Globalization.NumberFormatInfo> tipo. El <xref:System.IFormatProvider.GetFormat%2A> método, a continuación, devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información acerca del formato de la `value` parámetro. Hay tres formas de utilizar el `provider` parámetro para proporcionar información de formato personalizado para la operación de análisis:  
  
-   Puede pasar un <xref:System.Globalization.CultureInfo> objeto que representa la referencia cultural que proporciona información de formato. Su <xref:System.Globalization.CultureInfo.GetFormat%2A> método devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato numérico para esa referencia cultural.  
  
-   Puede pasar los datos reales <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato numérico. (Su implementación de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> simplemente devuelve a sí mismo.)  
  
-   Puede pasar un objeto personalizado que implementa <xref:System.IFormatProvider>. Su <xref:System.IFormatProvider.GetFormat%2A> método crea y devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.  
  
 Si `provider` es `null`, el formato de `value` se interpreta basándose en la <xref:System.Globalization.NumberFormatInfo> objeto de la referencia cultural actual.  
  
   
  
## Examples  
 Los ejemplos siguientes muestran dos maneras de definir la tilde (~) como un signo negativo para dar formato a <xref:System.Numerics.BigInteger> valores. Tenga en cuenta que para mostrar el <xref:System.Numerics.BigInteger> valores en el mismo formato que las cadenas originales, el código debe llamar el <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método y pásele el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.  
  
 El primer ejemplo define una clase que implementa <xref:System.IFormatProvider> y usa el <xref:System.IFormatProvider.GetFormat%2A> método para devolver el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 Un <xref:System.Numerics.BigInteger> , a continuación, se puede crear instancias de objeto con el código siguiente:  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 El segundo ejemplo es más sencillo. Pasa la <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato para el `provider` parámetro.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> no tiene el formato correcto.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que contiene un número que se va a convertir.</param>
        <param name="style">Combinación bit a bit de los valores de enumeración que especifican el formato permitido de <c>value</c>.</param>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural sobre <c>value</c>.</param>
        <summary>Convierte la representación en forma de cadena de un número con el estilo y el formato específico de la referencia cultural que se hayan especificado en su <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Valor equivalente al número especificado en el parámetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `style` parámetro define los elementos de estilo (como espacios en blanco, el símbolo de signo positivo o negativo, el símbolo de separador de grupos o el símbolo de separador decimal) que se permiten en la `value` parámetro para la operación de análisis se realice correctamente. `styles` debe ser una combinación de marcadores de bits de la <xref:System.Globalization.NumberStyles> enumeración. El `style` parámetro hace que este método de sobrecarga útil cuando `value` contiene la representación de cadena de un valor hexadecimal, cuando el sistema de numeración (decimal o hexadecimal) representado por `value` se conoce en tiempo de ejecución o cuando desee denegar espacio en blanco o un inicio de sesión de símbolos en `value`.  
  
 Dependiendo del valor de `style`, el `value` parámetro puede incluir los siguientes elementos:  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[*.fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 Si `style` incluye <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, el `value` parámetro puede incluir los siguientes elementos:  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En la tabla siguiente describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Espacio en blanco opcional. Espacio en blanco puede aparecer al principio de `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> marca y pueden aparecer al final de `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> marca.|  
|*$*|Un símbolo de moneda específico de la referencia cultural. Su posición en la cadena viene definida por el <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> y <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propiedades de la referencia cultural indican por el `provider` parámetro. Símbolo de divisa de la referencia cultural actual puede aparecer en `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> marca.|  
|*sign*|Un signo opcional. El signo puede aparecer al principio de `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> marca y pueden aparecer al final de `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> marca. Se pueden utilizar paréntesis en `value` para indicar un valor negativo si `style` incluye la <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> marca.|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Una secuencia de dígitos comprendido entre 0 y 9. Para *dígitos fraccionarios*, solo el dígito 0 es válido.|  
|*,*|Un símbolo de separador de grupo específicas de referencias culturales. El símbolo de separador de grupos de la referencia cultural especificada por `provider` pueden aparecer en `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marca.|  
|*.*|Un símbolo de separador decimal de referencias culturales específicas. El símbolo de separador decimal de la referencia cultural designada por `provider` pueden aparecer en `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca. Puede aparecer el dígito 0 como un dígito fraccionario para que la operación de análisis se realice correctamente; Si *dígitos fraccionarios* incluye cualquier otro dígito, un <xref:System.FormatException> se produce.|  
|E|La "e" o el carácter "E", lo que indica que el valor se representa en notación exponencial (científica). El `value` parámetro puede representar un número en notación exponencial si `style` incluye la <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> marca.|  
|*dígitos hexadecimales*|Una secuencia de dígitos hexadecimales de 0 a f o 0 hasta la f el.|  
  
 Una cadena formada únicamente por dígitos (que corresponde a la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> estilo) siempre se analiza correctamente. La mayoría de las restantes <xref:System.Globalization.NumberStyles> miembros controlan los elementos que pueden estar presentes, pero no tienen que estar presentes en la cadena de entrada. La tabla siguiente se indica cómo individuales <xref:System.Globalization.NumberStyles> miembros afectan a los elementos que pueden estar presentes en `value`.  
  
|Valor NumberStyles|Elementos permitidos en valor además de dígitos|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|El *dígitos* solo el elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|El separador decimal (.) y *dígitos fraccionarios* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|La "e" o el carácter "E", que indica notación exponencial. junto con *dígitos exponenciales*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|El *ws* elemento situado al principio de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|El *ws* elemento situado al final de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|El *inicio de sesión* elemento situado al principio de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|El *inicio de sesión* elemento situado al final de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|El *inicio de sesión* elemento en forma de paréntesis delimitando el valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|El elemento separador de grupos.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|El elemento de moneda ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos los elementos. Sin embargo, `value` no puede representar un número hexadecimal o un número en notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|El *ws* elemento al principio o al final de `value`, *inicio de sesión* al principio de `value`y el símbolo de separador decimal (.). El `value` parámetro también puede utilizar la notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|El `ws`, `sign`, separador de grupos (,) y los elementos de punto decimal (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Todos los elementos. Sin embargo, `value` no puede representar un número hexadecimal.|  
  
> [!IMPORTANT]
>  Si usa el <xref:System.Numerics.BigInteger.Parse%2A> método a la representación de cadena de ida y vuelta de un <xref:System.Numerics.BigInteger> valor que se generan mediante la <xref:System.Numerics.BigInteger.ToString%2A> método, debe utilizar el <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> método con el especificador de formato "R" para generar la representación de cadena de la <xref:System.Numerics.BigInteger> valor. En caso contrario, la representación de cadena de la <xref:System.Numerics.BigInteger> conserva solo los 50 dígitos más significativos del valor original y los datos podrían perderse cuando se usa el <xref:System.Numerics.BigInteger.Parse%2A> método para restaurar la <xref:System.Numerics.BigInteger> valor.  
  
 A diferencia de otros <xref:System.Globalization.NumberStyles> valores, que permiten pero no requieren la presencia de elementos de estilo determinada de `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> valor de estilo significa que los caracteres numéricos individuales de `value` siempre se interpretan como caracteres hexadecimales. Los caracteres hexadecimales válidos son 0-9, A-f y a-f. Los únicos otros marcadores que se pueden combinar con la `style` parámetro <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> y <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (El <xref:System.Globalization.NumberStyles> enumeración incluye un estilo de número compuesto, <xref:System.Globalization.NumberStyles.HexNumber>, que incluye ambos marcadores de espacio en blanco.)  
  
> [!NOTE]
>  Si `value` es la representación de cadena de un número hexadecimal, no se puede ir precedido de ninguna decoración (como `0x` o `&h`) que lo diferencie como un número hexadecimal. Esto provoca un error de conversión.  
  
 Si `value` es una cadena hexadecimal, el <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> método interpreta `value` como un número negativo que se almacenan utilizando dos representación del complemento si los primero de dos dígitos hexadecimales son mayores que o igual a `0x80`. En otras palabras, el método interpreta el bit de orden superior del primer byte de `value` como el bit de signo. Para asegurarse de que una cadena hexadecimal se interpreta correctamente como un número positivo, el primer dígito de `value` debe tener un valor de cero. Por ejemplo, el método interpreta `0x80` como un valor negativo, pero interpreta cualquiera `0x080` o `0x0080` como un valor positivo. En el ejemplo siguiente se ilustra la diferencia entre las cadenas hexadecimales que representan valores positivos y negativos.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación. Su <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información específica de la referencia cultural acerca del formato de `value`. Por lo general, `provider` puede ser cualquiera de las siguientes acciones:  
  
-   Un <xref:System.Globalization.CultureInfo> objeto que representa la referencia cultural que proporciona información de formato numérico. Su <xref:System.Globalization.CultureInfo.GetFormat%2A> método devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato numérico.  
  
-   Un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato. (Su implementación de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> simplemente devuelve a sí mismo.)  
  
-   Un objeto personalizado que implementa <xref:System.IFormatProvider> y usa el <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> método para crear instancias y devolver el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.  
  
 Si `provider` es `null`, el <xref:System.Globalization.NumberFormatInfo> se usa la referencia cultural actual del objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se realiza algunas llamadas a la <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método utilizando varias combinaciones de valores para la `style` y `provider` parámetros.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 Un número de las llamadas individuales a la <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método pasa una instancia de las siguientes acciones `BigIntegerFormatProvider` (clase), que define una tilde (~) como el signo negativo.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> no es un valor de <see cref="T:System.Globalization.NumberStyles" />.  
  
 O bien  
  
 <paramref name="style" /> incluye la marca <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> o <see cref="F:System.Globalization.NumberStyles.HexNumber" /> junto con otro valor.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> no cumple el modelo de entrada especificado por <paramref name="style" />.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Número que se va a elevar a la potencia <c>exponent</c>.</param>
        <param name="exponent">Exponente por el que se va a elevar <c>value</c>.</param>
        <summary>Eleva un valor <see cref="T:System.Numerics.BigInteger" /> a la potencia del valor especificado.</summary>
        <returns>Resultado de elevar <paramref name="value" /> a la potencia <paramref name="exponent" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.Pow%2A> método devuelve 1 si el valor del parámetro exponente es 0, o si los valores de la `value` y `exponent` parámetros son 0. Si `exponent` es 1, el <xref:System.Numerics.BigInteger.Pow%2A> método `value`. Si `value` es negativo, el método devuelve un resultado negativo.  
  
 Este método corresponde a la <xref:System.Math.Pow%2A?displayProperty=nameWithType> método para los tipos numéricos primitivos.  
  
   
  
## Examples  
 En el ejemplo siguiente se ilustra el uso de exponenciación un <xref:System.Numerics.BigInteger> valor y un exponente cuyo valor comprendido entre 0 y 10.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor del parámetro <paramref name="exponent" /> es negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Valor que se va a dividir.</param>
        <param name="divisor">Valor por el que se va a dividir.</param>
        <summary>Realiza la división entera en dos valores <see cref="T:System.Numerics.BigInteger" /> y devuelve el resto.</summary>
        <returns>Resto después de dividir <paramref name="dividend" /> por <paramref name="divisor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El signo del resto es el signo de la `dividend` parámetro.  
  
 El <xref:System.Numerics.BigInteger.Remainder%2A> método se implementa para idiomas que no admiten operadores personalizados. Su comportamiento es idéntico a la división utilizando el operador de módulo.  
  
 Si es necesario, el método realiza automáticamente la conversión implícita de otros tipos integrales para <xref:System.Numerics.BigInteger> objetos antes de realizar la operación de módulo.  
  
   
  
## Examples  
 En el ejemplo siguiente se compara el resto de la <xref:System.Numerics.BigInteger.DivRem%2A> método con el resto devuelto por la <xref:System.Numerics.BigInteger.Remainder%2A> método para establecer que los dos métodos calculan restos idénticos.  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          El valor de <paramref name="divisor" /> es 0 (cero).</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un número que indica el signo (negativo, positivo o cero) del objeto <see cref="T:System.Numerics.BigInteger" /> actual.</summary>
        <value>Número que indica el signo del objeto <see cref="T:System.Numerics.BigInteger" />, como se muestra en la tabla siguiente.  
  
 <list type="table"><listheader><term> Número  
  
 </term><description> Descripción  
  
 </description></listheader><item><term> -1  
  
 </term><description> El valor de este objeto es negativo.  
  
 </description></item><item><term> 0  
  
 </term><description> El valor de este objeto es 0 (cero).  
  
 </description></item><item><term> 1  
  
 </term><description> El valor de este objeto es positivo.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.Sign%2A> propiedad es equivalente a la <xref:System.Math.Sign%2A?displayProperty=nameWithType> método para los tipos numéricos primitivos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Valor del que se va a restar (minuendo).</param>
        <param name="right">Valor que se va a restar (sustraendo).</param>
        <summary>Resta un valor <see cref="T:System.Numerics.BigInteger" /> de otro y devuelve el resultado.</summary>
        <returns>Resultado de restar <paramref name="right" /> de <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los lenguajes que no admiten operadores personalizados pueden usar el <xref:System.Numerics.BigInteger.Subtract%2A> método que se realizan mediante resta <xref:System.Numerics.BigInteger> valores.  
  
 El <xref:System.Numerics.BigInteger.Subtract%2A> método es un suplente útil para el operador de resta al crear instancias de un <xref:System.Numerics.BigInteger> variable asignándole la diferencia que es el resultado de la resta, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convierte un valor <see cref="T:System.Numerics.BigInteger" /> en una matriz de bytes.</summary>
        <returns>Valor del objeto <see cref="T:System.Numerics.BigInteger" /> actual convertido en una matriz de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los bytes individuales en la matriz devuelta por este método aparecen en orden little-endian. Es decir, los bytes de orden más bajo del valor preceden a los bytes de orden superior. El primer byte de la matriz refleja los primeros ocho bits de la <xref:System.Numerics.BigInteger> valor, el segundo byte refleja los siguientes ocho bits y así sucesivamente. Por ejemplo, el valor 1024 o 0 x 0400, se almacena como la siguiente matriz de dos bytes:  
  
|Elemento|Valor de byte|  
|-------------|----------------|  
|0|0x00|  
|1|0x04|  
  
 Los valores negativos se escriben en la matriz utilizando dos representación del complemento en el formulario más compacto posible. Por ejemplo, -1 se representa como un byte único cuyo valor es `0xFF` en lugar de como una matriz con varios elementos, como `0xFF`, `0xFF` o `0xFF`, `0xFF`, `0xFF`, `0xFF`.  
  
 Porque del complemento a dos representación siempre interpreta el bit de orden superior del último byte de la matriz (el byte en la posición <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) como el bit de signo, el método devuelve una matriz de bytes con un elemento adicional cuyo valor es cero para eliminar la ambigüedad de valores positivos que de lo contrario pudieron interpretarse como si tuviera sus bits de inicio de sesión a establecer. Por ejemplo, el valor 120 o `0x78` se representa como una matriz de un solo byte: `0x78`. Sin embargo, 128, o `0x80`, se representa como una matriz de bytes de dos: `0x80`, `0x00`.  
  
 Puede ida y vuelta un <xref:System.Numerics.BigInteger> valor almacenando en una matriz de bytes y, a continuación, restaurarlo mediante el <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> constructor.  
  
> [!CAUTION]
>  Si el código modifica el valor de bytes individuales en la matriz devuelta por este método antes de restaura el valor, debe asegurarse de que no cambian involuntariamente el bit de signo. Por ejemplo, si sus modificaciones aumentan un valor positivo para que el orden más alto de bits en el último elemento de la matriz de bytes se establece, que puede agregar un nuevo byte cuyo valor es cero al final de la matriz.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo algunas <xref:System.Numerics.BigInteger> valores se representan en matrices de bytes.  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte el valor numérico del objeto <see cref="T:System.Numerics.BigInteger" /> actual en su representación de cadena equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convierte el valor numérico del objeto <see cref="T:System.Numerics.BigInteger" /> actual en su representación de cadena equivalente.</summary>
        <returns>Representación de cadena del valor <see cref="T:System.Numerics.BigInteger" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.ToString> método formatos un <xref:System.Numerics.BigInteger> valor de la "R" o el envío y recepción, formato de la referencia cultural actual. Si desea especificar un formato diferente o la referencia cultural, use las otras sobrecargas de la <xref:System.Numerics.BigInteger.ToString%2A> método, tal como se indica a continuación:  
  
|Usar formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato de Round-Trip ("R")|Una referencia cultural específica|<xref:System.Numerics.BigInteger.ToString%2A>|  
|Un formato concreto|Referencia cultural predeterminada de (actual).|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Un formato concreto|Una referencia cultural específica|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 La representación de cadena de la <xref:System.Numerics.BigInteger> valor incluye un signo menos si su valor es negativo y una secuencia de dígitos que comprende del 0 al 9 sin ceros a la izquierda. El signo negativo está definido por el <xref:System.Globalization.NumberFormatInfo> objeto para la referencia cultural actual.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un <xref:System.Numerics.BigInteger> valor utilizando el valor predeterminado <xref:System.Numerics.BigInteger.ToString> método. También muestra las representaciones de cadena de la <xref:System.Numerics.BigInteger> valor resultante de usar algunos especificadores de formato estándar. Los ejemplos se muestran utilizando las convenciones de formato de la referencia cultural en-US.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor numérico del objeto <see cref="T:System.Numerics.BigInteger" /> actual en su representación de cadena equivalente usando la información de formato específica de la referencia cultural indicada.</summary>
        <returns>Representación de cadena del valor <see cref="T:System.Numerics.BigInteger" /> actual en el formato especificado por el parámetro <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> método formatos un <xref:System.Numerics.BigInteger> valor en la "R", o el envío y recepción, dar formato mediante la <xref:System.Globalization.NumberFormatInfo> objeto de una referencia cultural especificada. Si desea especificar un formato diferente o la referencia cultural actual, use las otras sobrecargas de la <xref:System.Numerics.BigInteger.ToString%2A> método, tal como se indica a continuación:  
  
|Usar formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato de Round-Trip ("R")|Referencia cultural predeterminada de (actual).|<xref:System.Numerics.BigInteger.ToString>|  
|Un formato concreto|Referencia cultural predeterminada de (actual).|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Un formato concreto|Una referencia cultural específica|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación. Su <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información específica de la referencia cultural acerca del formato de la cadena devuelta por este método. Si `provider` es `null`, <xref:System.Numerics.BigInteger> valor se representa con la <xref:System.Globalization.NumberFormatInfo> objeto de la referencia cultural actual. La única propiedad de la <xref:System.Globalization.NumberFormatInfo> objeto que controla la representación de cadena de la <xref:System.Numerics.BigInteger> valor mediante el especificador de formato general es <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, que define el carácter que representa el signo negativo.  
  
 El `provider` parámetro puede ser uno de los siguientes:  
  
-   Un <xref:System.Globalization.CultureInfo> objeto que representa la referencia cultural que proporciona información de formato.  
  
-   La <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.  
  
-   Un objeto personalizado que implementa <xref:System.IFormatProvider>. Su <xref:System.IFormatProvider.GetFormat%2A> método devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.  
  
   
  
## Examples  
 El ejemplo siguiente crea un personalizado <xref:System.Globalization.NumberFormatInfo> objeto que define la tilde (~) como un signo negativo. El <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> método, a continuación, usa la opción de instalación <xref:System.Globalization.NumberFormatInfo> objeto que se va a mostrar negativo <xref:System.Numerics.BigInteger> valor.  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato numérico estándar o personalizada.</param>
        <summary>Convierte el valor numérico del objeto <see cref="T:System.Numerics.BigInteger" /> actual en su representación de cadena equivalente con el formato especificado.</summary>
        <returns>Representación de cadena del valor <see cref="T:System.Numerics.BigInteger" /> actual en el formato especificado por el parámetro <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.ToString%28System.String%29> método formatos un <xref:System.Numerics.BigInteger> valor en un formato especificado mediante el uso de un <xref:System.Globalization.NumberFormatInfo> objeto que representa las convenciones de la referencia cultural actual. Si desea usar la "R" o el envío y recepción, dar formato o especificar una referencia cultural diferente, use las otras sobrecargas de la <xref:System.Numerics.BigInteger.ToString%2A> método, tal como se indica a continuación:  
  
|Usar formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato de Round-Trip ("R")|Referencia cultural predeterminada de (actual).|<xref:System.Numerics.BigInteger.ToString>|  
|Formato de Round-Trip ("R")|Una referencia cultural específica|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Un formato concreto|Una referencia cultural específica|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 El `format` parámetro puede ser cualquier [cadena numérica estándar](~/docs/standard/base-types/standard-numeric-format-strings.md), o cualquier combinación de [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Si `format` es igual a <xref:System.String.Empty?displayProperty=nameWithType> o `null`, el valor devuelto de la actual <xref:System.Numerics.BigInteger> objeto está formateado con el especificador de formato de ida y vuelta ("R"). Si `format` es cualquier otro valor, el método produce una <xref:System.FormatException>.  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas de formato siguientes:  
  
-   Para obtener más información acerca de los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información sobre la compatibilidad con el formato de .NET Framework, vea [Formatting Types](~/docs/standard/base-types/formatting-types.md).  
  
 El formato de la cadena devuelta está determinado por la <xref:System.Globalization.NumberFormatInfo> objeto para la referencia cultural actual. En función de la `format` parámetro, este objeto controla símbolos como el signo negativo, el separador de grupos y el símbolo de separador decimal en la cadena de salida. Para proporcionar información de formato para las referencias culturales distintas de la referencia cultural actual, llame a la <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> de sobrecarga.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicializa un <xref:System.Numerics.BigInteger> valor y se muestra mediante el uso de las cadenas de formato estándar y algunas cadenas de formato personalizado.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> no es una cadena de formato válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato numérico estándar o personalizada.</param>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor numérico del objeto <see cref="T:System.Numerics.BigInteger" /> actual en su representación de cadena equivalente usando el formato especificado y la información de formato específica de la referencia cultural.</summary>
        <returns>Representación de cadena del valor <see cref="T:System.Numerics.BigInteger" /> actual, tal como la especifican los parámetros <paramref name="format" /> y <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> método formatos un <xref:System.Numerics.BigInteger> valor en un formato especificado mediante el uso de la <xref:System.Globalization.NumberFormatInfo> objeto de una referencia cultural especificada. Si desea utilizar el formato de ida y vuelta o la configuración de referencia cultural predeterminada, use las otras sobrecargas de la <xref:System.Numerics.BigInteger.ToString%2A> método, tal como se indica a continuación:  
  
|Usar formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato de Round-Trip ("R")|Referencia cultural predeterminada de (actual).|<xref:System.Numerics.BigInteger.ToString>|  
|Formato de Round-Trip ("R")|Una referencia cultural específica|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Un formato concreto|Referencia cultural predeterminada de (actual).|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 El `format` parámetro puede ser cualquier [cadena numérica estándar](~/docs/standard/base-types/standard-numeric-format-strings.md), o cualquier combinación de [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Si `format` es igual a <xref:System.String.Empty?displayProperty=nameWithType> o `null`, el valor devuelto de la actual <xref:System.Numerics.BigInteger> objeto está formateado con el especificador de formato de ida y vuelta ("R"). Si `format` es cualquier otro valor, el método produce una <xref:System.FormatException>.  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas de formato siguientes:  
  
-   Para obtener más información acerca de los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información sobre la compatibilidad con el formato de .NET Framework, vea [Formatting Types](~/docs/standard/base-types/formatting-types.md).  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación. Su <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información específica de la referencia cultural acerca del formato de la cadena devuelta por este método. Cuando el <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> se invoca el método, llama la `provider` del parámetro <xref:System.IFormatProvider.GetFormat%2A> método y le pasa un <xref:System.Type> objeto que representa el <xref:System.Globalization.NumberFormatInfo> tipo. El <xref:System.IFormatProvider.GetFormat%2A> método, a continuación, devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información para dar formato a la `value` parámetro, como el símbolo de signo negativo, el símbolo de separador de grupos o el símbolo de separador decimal. Hay tres formas de utilizar el `provider` parámetro para proporcionar información de formato para el <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> método:  
  
-   Puede pasar un <xref:System.Globalization.CultureInfo> objeto que representa la referencia cultural que proporciona información de formato. Su <xref:System.Globalization.CultureInfo.GetFormat%2A> método devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato numérico para esa referencia cultural.  
  
-   Puede pasar los datos reales <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato numérico. (Su implementación de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> simplemente devuelve a sí mismo.)  
  
-   Puede pasar un objeto personalizado que implementa <xref:System.IFormatProvider>. Su <xref:System.IFormatProvider.GetFormat%2A> método crea y devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.  
  
 Si `provider` es `null`, el formato de la cadena devuelta se basa en la <xref:System.Globalization.NumberFormatInfo> objeto de la referencia cultural actual.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicializa un <xref:System.Numerics.BigInteger> valor y lo muestra en la consola mediante una cadena de formato estándar y un <xref:System.Globalization.NumberFormatInfo> objeto que define la tilde (~) como un signo negativo.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> no es una cadena de formato válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Intenta convertir la representación en forma de cadena de un número en su equivalente <see cref="T:System.Numerics.BigInteger" /> y devuelve un valor que indica si la conversión tuvo éxito.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Representación de cadena de un número.</param>
        <param name="result">Cuando este método finaliza, contiene el equivalente <see cref="T:System.Numerics.BigInteger" /> al número incluido en <c>value</c> o cero (0) si se produce un error en la conversión. Se produce un error en la conversión si el parámetro <c>value</c> es <see langword="null" /> o no tiene el formato correcto. Este parámetro se pasa sin inicializar.</param>
        <summary>Intenta convertir la representación en forma de cadena de un número en su equivalente <see cref="T:System.Numerics.BigInteger" /> y devuelve un valor que indica si la conversión tuvo éxito.</summary>
        <returns>
          <see langword="true" /> si <paramref name="value" /> se convirtió correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> método es similar a la <xref:System.Numerics.BigInteger.Parse%28System.String%29> método, salvo que TI no produce una excepción si se produce un error en la conversión. Este método elimina la necesidad de utilizar el control de excepciones para probar una <xref:System.FormatException> si `value` no es válido y no se puede analizar correctamente.  
  
 El `value` parámetro debe ser la representación de cadena de un número decimal en el formato siguiente:  
  
 [*ws*][*sign*]*digits*[*ws*]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En la tabla siguiente describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Espacio en blanco opcional.|  
|*sign*|Un signo opcional. Caracteres de signo válidos se determinan mediante la <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> y <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> propiedades de la referencia cultural actual.|  
|*digits*|Una secuencia de dígitos decimales comprendidos entre 0 y 9.|  
  
> [!NOTE]
>  La cadena especificada por el `value` parámetro no puede contener cualquier separador de grupo o separador decimal y no puede tener una parte decimal.  
  
 El `value` parámetro se interpreta usando el <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> estilo. Además de los dígitos decimales, se permiten solo espacios iniciales y finales con un signo inicial. Para definir explícitamente los elementos de estilo con la información de formato específica de la referencia cultural que pueden estar presentes en `value`, llame a la <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> método.  
  
 El `value` parámetro se analiza utilizando la información de formato en un <xref:System.Globalization.NumberFormatInfo> objeto para la referencia cultural actual. Para obtener más información, vea <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.  
  
 Esta sobrecarga interpreta todos los dígitos en el `value` parámetro como dígitos decimales. Para analizar la representación de cadena de un número hexadecimal, llame a la <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> sobrecarga en su lugar.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> método para crear instancias de dos <xref:System.Numerics.BigInteger> objetos. Si las conversiones se realizan correctamente, multiplica cada objeto por otro número y, a continuación, llama a la <xref:System.Numerics.BigInteger.Compare%2A> método para determinar la relación entre los dos objetos.  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Representación de cadena de un número. La cadena se interpreta mediante el estilo especificado por <c>style</c>.</param>
        <param name="style">Combinación bit a bit de valores de enumeración que indica los elementos de estilo que pueden estar presentes en <c>value</c>. Un valor que se especifica de forma habitual es <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural sobre <c>value</c>.</param>
        <param name="result">Cuando este método finaliza, contiene el equivalente <see cref="T:System.Numerics.BigInteger" /> al número incluido en <c>value</c> o <see cref="P:System.Numerics.BigInteger.Zero" /> si se ha producido un error en la conversión. Se produce un error en la conversión si el parámetro <c>value</c> es <see langword="null" /> o no tiene un formato conforme con <c>style</c>. Este parámetro se pasa sin inicializar.</param>
        <summary>Intenta convertir la representación de cadena especificada de un número con un estilo específico y un formato específico de la referencia cultural en su <see cref="T:System.Numerics.BigInteger" /> equivalente y devuelve un valor que indica si la conversión fue correcta.</summary>
        <returns>
          <see langword="true" /> si el parámetro <paramref name="value" /> se convierte correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> método es similar a la <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método, salvo que TI no produce una excepción si se produce un error en la conversión. Este método elimina la necesidad de utilizar el control de excepciones para probar una <xref:System.FormatException> si `value` no es válido y no se puede analizar correctamente.  
  
 El `style` parámetro define los elementos de estilo (como espacios en blanco o un signo positivo o negativo) que se permiten en la `value` parámetro para la operación de análisis se realice correctamente. Debe ser una combinación de marcadores de bits de la <xref:System.Globalization.NumberStyles> enumeración. Dependiendo del valor de `style`, el `value` parámetro puede incluir los siguientes elementos:  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[.*fractional_digits*][E[*sign*]*exponential_digits*][*ws*]  
  
 Si el `style` parámetro incluye <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, el `value` parámetro puede incluir los siguientes elementos:  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En la tabla siguiente describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Espacio en blanco opcional. Espacio en blanco puede aparecer al principio de `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> marca, o al final de `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> marca.|  
|*$*|Un símbolo de moneda específico de la referencia cultural. Su posición en la cadena viene definida por el <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> propiedad de la <xref:System.Globalization.NumberFormatInfo> objeto devuelto por la <xref:System.IFormatProvider.GetFormat%2A> método de la `provider` parámetro. El símbolo de moneda puede aparecer en `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> marca.|  
|*sign*|Un signo opcional. El signo puede aparecer al principio de `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> marca y pueden aparecer al final de `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> marca. Se pueden utilizar paréntesis en `value` para indicar un valor negativo si `style` incluye la <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> marca.|  
|*digits*|Una secuencia de dígitos comprendido entre 0 y 9.|  
|*,*|Separador de grupos de referencias culturales específicas. El separador de grupos de la referencia cultural especificada por `provider` pueden aparecer en `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marca.|  
|*.*|Un símbolo de separador decimal de referencias culturales específicas. El símbolo de separador decimal de la referencia cultural especificada por `provider` pueden aparecer en `value` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|*fractional_digits*|Una o más apariciones del dígito 0. Pueden aparecer dígitos fraccionarios en `value` solo si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|E|La "e" o el carácter "E", lo que indica que el valor se representa en notación exponencial (científica). El `value` parámetro puede representar un número en notación exponencial si `style` incluye la <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> marca.|  
|*exponential_digits*|Una secuencia de dígitos comprendido entre 0 y 9. El `value` parámetro puede representar un número en notación exponencial si `style` incluye la <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> marca.|  
|*dígitos hexadecimales*|Una secuencia de dígitos hexadecimales de 0 a f o 0 hasta la f el.|  
  
 Una cadena únicamente por dígitos decimales (que corresponde a la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> marca) siempre se analiza correctamente. La mayoría de las restantes <xref:System.Globalization.NumberStyles> miembros controlan los elementos que pueden estar presentes, pero no tienen que estar presentes en esta cadena de entrada. La tabla siguiente se indica cómo individuales <xref:System.Globalization.NumberStyles> miembros afectan a los elementos que pueden estar presentes en `value`.  
  
|No compuestos `NumberStyles` valores|Elementos permitidos en valor además de dígitos|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Dígitos decimales.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|El separador decimal (*.*) y *dígitos fraccionarios* elementos. Sin embargo, *dígitos fraccionarios* debe constar de uno o más dígitos 0 o el método devuelve `false`.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|La "e" o el carácter "E", que indica notación exponencial, junto con *dígitos exponenciales*. Si `value` representa un número en notación exponencial, no puede tener un componente fraccionario distinto de cero.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|El *ws* elemento situado al principio de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|El *ws* elemento situado al final de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|El *inicio de sesión* elemento antes de *dígitos*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|El *inicio de sesión* elemento tras *dígitos*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|El *inicio de sesión* elemento en forma de paréntesis delimitando el valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|El separador de grupos (*,*) elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|La moneda (*$*) elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos los elementos. Sin embargo, `value` no puede representar un número hexadecimal o un número en notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|El *ws* elemento al principio o al final de `value`, *inicio de sesión* al principio de `value`y el separador decimal (*.*) símbolo. El `value` parámetro también puede utilizar la notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|El *ws*, *inicio de sesión*, separador de grupos (*,*) y el separador decimal (*.*) elementos.|  
|<xref:System.Globalization.NumberStyles.Any>|Todos los elementos. Sin embargo, `value` no puede representar un número hexadecimal.|  
  
> [!IMPORTANT]
>  Si usa el <xref:System.Numerics.BigInteger.TryParse%2A> método a la representación de cadena de ida y vuelta de un <xref:System.Numerics.BigInteger> valor que se generan mediante la <xref:System.Numerics.BigInteger.ToString%2A> método, debe utilizar el <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> método con el especificador de formato "R" para generar la representación de cadena de la <xref:System.Numerics.BigInteger> valor. En caso contrario, la representación de cadena de la <xref:System.Numerics.BigInteger> conserva solo los 50 dígitos más significativos del valor original y los datos podrían perderse cuando se usa el <xref:System.Numerics.BigInteger.TryParse%2A> método para restaurar la <xref:System.Numerics.BigInteger> valor.  
  
 Si el <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> se utiliza la marca, `value` debe ser un valor hexadecimal. Los únicos otros marcadores que pueden estar presentes en `style` son <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> y <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (El <xref:System.Globalization.NumberStyles> enumeración tiene un estilo compuesto, <xref:System.Globalization.NumberStyles.HexNumber>, que incluye ambos marcadores de espacio en blanco.)  
  
> [!NOTE]
>  Si `value` es la representación de cadena de un número hexadecimal, no se puede ir precedido de ninguna decoración (como `0x` o `&h`) que lo diferencie como un número hexadecimal. Esto provoca un error de conversión.  
  
 Si `value` es una cadena hexadecimal, el <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> método interpreta `value` como un número negativo que se almacenan utilizando dos representación del complemento si los primero de dos dígitos hexadecimales son mayores que o igual a `0x80`. En otras palabras, el método interpreta el bit de orden superior del primer byte de `value` como el bit de signo. Para asegurarse de que una cadena hexadecimal se interpreta correctamente como un número positivo, el primer dígito de `value` debe tener un valor de cero. Por ejemplo, el método interpreta `0x80` como un valor negativo, pero interpreta cualquiera `0x080` o `0x0080` como un valor positivo. En el ejemplo siguiente se ilustra la diferencia entre las cadenas hexadecimales que representan valores positivos y negativos.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación. Su <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información específica de la referencia cultural acerca del formato de `value`. El `provider` parámetro puede ser cualquiera de las siguientes acciones:  
  
-   Un <xref:System.Globalization.CultureInfo> objeto que representa la referencia cultural que proporciona información de formato. Su <xref:System.Globalization.CultureInfo.GetFormat%2A> método devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato numérico para esa referencia cultural.  
  
-   Un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato numérico. (Su implementación de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> simplemente devuelve a sí mismo.)  
  
-   Un objeto personalizado que implementa <xref:System.IFormatProvider>. Su <xref:System.IFormatProvider.GetFormat%2A> método crea y devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.  
  
 Si `provider` es `null`, el <xref:System.Globalization.NumberFormatInfo> se usa la referencia cultural actual del objeto.  
  
   
  
## Examples  
 En el siguiente ejemplo se realiza algunas llamadas a la <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> método utilizando varias combinaciones de valores para la `style` y `provider` parámetros.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 Un número de las llamadas individuales a la <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> método pasa una instancia de las siguientes acciones `BigIntegerFormatProvider` (clase), que define una tilde (~) como el signo negativo.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> no es un valor de <see cref="T:System.Globalization.NumberStyles" />.  
  
 O bien  
  
 <paramref name="style" /> incluye la marca <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> o <see cref="F:System.Globalization.NumberStyles.HexNumber" /> junto con otro valor.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que representa el número 0 (cero).</summary>
        <value>Entero cuyo valor es 0 (cero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Numerics.BigInteger> objeto devuelto por esta propiedad proporciona un origen conveniente de un valor de cero para su uso en las asignaciones y comparaciones.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>