<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="45aed4a95edff1e825b957b2993f72dc022d64ea" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39754213" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="53a23-101">Representa un número complejo.</span>
      <span class="sxs-lookup">
        <span data-stu-id="53a23-101">Represents a complex number.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-102">Un número complejo es un número que consta de un número real y un elemento de número imaginario.</span><span class="sxs-lookup"><span data-stu-id="53a23-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="53a23-103">Una número complejo de z se escribe normalmente en forma de z = x + yi, donde *x* y *y* son números reales, y ** es la unidad imaginaria que tiene la propiedad *i* <sup>2</sup> = -1.</span><span class="sxs-lookup"><span data-stu-id="53a23-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="53a23-104">La parte real del número complejo que se representa mediante *x*, y la parte imaginaria del número complejo que se representa mediante *y*.</span><span class="sxs-lookup"><span data-stu-id="53a23-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="53a23-105">El <xref:System.Numerics.Complex> tipo utiliza el sistema de coordenadas cartesiano (real, imaginario) al crear instancias y manipular números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="53a23-106">Un número complejo se puede representar como un punto en un sistema de coordenadas bidimensional, que se conoce como el plano complejo.</span><span class="sxs-lookup"><span data-stu-id="53a23-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="53a23-107">La parte real del número complejo se coloca en el eje x (el eje horizontal) y la parte imaginaria se coloca en el eje y (el eje vertical).</span><span class="sxs-lookup"><span data-stu-id="53a23-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="53a23-108">También se puede expresar cualquier punto en el plano complejo basado en su valor absoluto, mediante la polar sistema de coordenadas., en coordenadas polares, un punto se caracteriza por dos números:</span><span class="sxs-lookup"><span data-stu-id="53a23-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system., In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="53a23-109">Su magnitud, que es la distancia del punto desde el origen (es decir, 0,0 o punto en el que se cortan el eje x y el eje y).</span><span class="sxs-lookup"><span data-stu-id="53a23-109">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="53a23-110">La fase, que es el ángulo entre el eje real y la línea que se dibuja desde el origen hasta el punto.</span><span class="sxs-lookup"><span data-stu-id="53a23-110">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="53a23-111">Crear instancias de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="53a23-111">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="53a23-112">Puede asignar un valor a un número complejo en una de las maneras siguientes:</span><span class="sxs-lookup"><span data-stu-id="53a23-112">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="53a23-113">Pasando dos <xref:System.Double> valores a su constructor.</span><span class="sxs-lookup"><span data-stu-id="53a23-113">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="53a23-114">El primer valor representa la parte real del número complejo y el segundo valor representa su parte imaginaria.</span><span class="sxs-lookup"><span data-stu-id="53a23-114">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="53a23-115">Estos valores representan la posición del número complejo en el sistema de coordenadas cartesiano bidimensional.</span><span class="sxs-lookup"><span data-stu-id="53a23-115">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="53a23-116">Mediante una llamada a estático (`Shared` en Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> método para crear un número complejo a partir de sus coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="53a23-116">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="53a23-117">Asignando un <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, o <xref:System.Double> valor a un <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="53a23-117">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="53a23-118">El valor se convierte en la parte real del número complejo y su parte imaginaria es igual a 0.</span><span class="sxs-lookup"><span data-stu-id="53a23-118">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="53a23-119">Conversión (en C#) o convirtiendo (en Visual Basic) un <xref:System.Decimal> o <xref:System.Numerics.BigInteger> valor a un <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="53a23-119">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="53a23-120">El valor se convierte en la parte real del número complejo y su parte imaginaria es igual a 0.</span><span class="sxs-lookup"><span data-stu-id="53a23-120">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="53a23-121">Asignando el número complejo que es devuelto por un método u operador para un <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="53a23-121">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="53a23-122">Por ejemplo, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> es un método estático que devuelve un número complejo que es la suma de dos números complejos, y el <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operador agrega dos números complejos y devuelve el resultado.</span><span class="sxs-lookup"><span data-stu-id="53a23-122">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="53a23-123">En el ejemplo siguiente se muestra cada una de estas cinco formas de asignar un valor a un número complejo.</span><span class="sxs-lookup"><span data-stu-id="53a23-123">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="53a23-124">Operaciones con números complejos</span><span class="sxs-lookup"><span data-stu-id="53a23-124">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="53a23-125">El <xref:System.Numerics.Complex> estructura en .NET Framework incluye miembros que proporcionan la funcionalidad siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-125">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="53a23-126">Métodos para comparar dos números complejos para determinar si son iguales.</span><span class="sxs-lookup"><span data-stu-id="53a23-126">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="53a23-127">Operadores para realizar operaciones aritméticas en números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-127">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="53a23-128"><xref:System.Numerics.Complex> los operadores permiten realizar suma, resta, multiplicación, división y negación unaria con números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-128"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="53a23-129">Métodos para realizar otras operaciones numéricas en números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-129">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="53a23-130">Además de las cuatro operaciones aritméticas básicas, puede elevar un número complejo a una potencia especificada, encontrar la raíz cuadrada de un número complejo y obtener el valor absoluto de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="53a23-130">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="53a23-131">Métodos para realizar operaciones trigonométricas en números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-131">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="53a23-132">Por ejemplo, puede calcular la tangente de un ángulo representado por un número complejo.</span><span class="sxs-lookup"><span data-stu-id="53a23-132">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="53a23-133">Tenga en cuenta que, dado el <xref:System.Numerics.Complex.Real%2A> y <xref:System.Numerics.Complex.Imaginary%2A> propiedades son de solo lectura, no se puede modificar el valor de una existente <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="53a23-133">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="53a23-134">Todos los métodos que realizan una operación en un <xref:System.Numerics.Complex> número, si su valor devuelto es de tipo <xref:System.Numerics.Complex>, devuelven un nuevo <xref:System.Numerics.Complex> número.</span><span class="sxs-lookup"><span data-stu-id="53a23-134">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="53a23-135">Precisión y números complejos</span><span class="sxs-lookup"><span data-stu-id="53a23-135">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="53a23-136">Las partes reales e imaginarias de un número complejo se representan mediante dos valores de punto flotante de precisión doble.</span><span class="sxs-lookup"><span data-stu-id="53a23-136">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="53a23-137">Esto significa que <xref:System.Numerics.Complex> valores como valores de punto flotante de precisión doble, pueden perder precisión como resultado de las operaciones numéricas.</span><span class="sxs-lookup"><span data-stu-id="53a23-137">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="53a23-138">Esto significa que estricta las comparaciones de igualdad de dos <xref:System.Numerics.Complex> valores pueden fallar, incluso si la diferencia entre los dos valores es debido a una pérdida de precisión.</span><span class="sxs-lookup"><span data-stu-id="53a23-138">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="53a23-139">Para obtener más información, vea <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="53a23-139">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="53a23-140">Por ejemplo, al realizar la exponenciación en el logaritmo de un número debe devolver el número original.</span><span class="sxs-lookup"><span data-stu-id="53a23-140">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="53a23-141">Sin embargo, en algunos casos, la pérdida de precisión de los valores de punto flotante puede producir ligeras diferencias entre los dos valores, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="53a23-141">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="53a23-142">De forma similar, el ejemplo siguiente, que calcula la raíz cuadrada de un <xref:System.Numerics.Complex> número, genera resultados ligeramente diferentes en las versiones de IA64 de .NET Framework y de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="53a23-142">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="53a23-143">Números complejos, Infinity y NaN</span><span class="sxs-lookup"><span data-stu-id="53a23-143">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="53a23-144">Las partes reales e imaginarias de un número complejo que se representan mediante <xref:System.Double> valores.</span><span class="sxs-lookup"><span data-stu-id="53a23-144">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="53a23-145">Además de que abarcan desde <xref:System.Double.MinValue?displayProperty=nameWithType> a <xref:System.Double.MaxValue?displayProperty=nameWithType>, la parte real o imaginaria de un número complejo puede tener un valor de <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, o <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-145">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="53a23-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, y <xref:System.Double.NaN?displayProperty=nameWithType> todos se propagan en cualquier operación aritmética o trigonométrica.</span><span class="sxs-lookup"><span data-stu-id="53a23-146"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="53a23-147">En el ejemplo siguiente, la división por <xref:System.Numerics.Complex.Zero> genera un número complejo cuyas partes reales e imaginarias son ambos <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-147">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="53a23-148">Como resultado, realizar la multiplicación con este valor también genera un número complejo cuyas partes reales e imaginarias son <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-148">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="53a23-149">De forma similar, realizar una multiplicación que desborda el intervalo de la <xref:System.Double> tipo genera un número complejo cuya parte real es <xref:System.Double.NaN?displayProperty=nameWithType> y cuya parte imaginaria es <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-149">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="53a23-150">Al realizar la división con este número complejo a continuación devuelve un número complejo cuya parte real es <xref:System.Double.NaN?displayProperty=nameWithType> y cuya parte imaginaria es <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-150">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="53a23-151">Operaciones matemáticas con números complejos que no son válidos o que desbordara el intervalo de la <xref:System.Double> tipo de datos no producen una excepción.</span><span class="sxs-lookup"><span data-stu-id="53a23-151">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="53a23-152">En su lugar, devuelven un <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, o <xref:System.Double.NaN?displayProperty=nameWithType> en las siguientes condiciones:</span><span class="sxs-lookup"><span data-stu-id="53a23-152">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="53a23-153">La división de un número positivo por cero devuelve <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-153">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="53a23-154">Cualquier operación que desborda el límite superior de la <xref:System.Double> del tipo de datos devuelve <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-154">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="53a23-155">La división de un número negativo por cero devuelve <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-155">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="53a23-156">Cualquier operación que desborde el límite inferior de la <xref:System.Double> del tipo de datos devuelve <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-156">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="53a23-157">Devuelve la división del cero por cero <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-157">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="53a23-158">Cualquier operación que se realiza en operandos cuyos valores son <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, o <xref:System.Double.NaN?displayProperty=nameWithType> devuelve <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, o <xref:System.Double.NaN?displayProperty=nameWithType>, dependiendo de la operación específica.</span><span class="sxs-lookup"><span data-stu-id="53a23-158">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="53a23-159">Tenga en cuenta que esto se aplica a cualquier cálculo intermedio realizada por un método.</span><span class="sxs-lookup"><span data-stu-id="53a23-159">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="53a23-160">Por ejemplo, la multiplicación de `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` utiliza la fórmula (ac - bd) + (ad + bc).</span><span class="sxs-lookup"><span data-stu-id="53a23-160">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="53a23-161">El cálculo del componente real que es el resultado de la multiplicación evalúa la expresión 9e308 * 2.5 - 9e308 * 3.5.</span><span class="sxs-lookup"><span data-stu-id="53a23-161">The calculation of the real component that results from the multiplication evaluates the expression 9e308 * 2.5 - 9e308 * 3.5.</span></span> <span data-ttu-id="53a23-162">Cada multiplicación intermedia en esta expresión devuelve <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>y el intento para restar <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> desde <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> devuelve <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-162">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="53a23-163">Aplicar formato a un número complejo.</span><span class="sxs-lookup"><span data-stu-id="53a23-163">Formatting a Complex Number</span></span>  
 <span data-ttu-id="53a23-164">De forma predeterminada, la representación de cadena de un número complejo toma la forma `(` *real* `,` *imaginaria*`)`, donde *real* y *imaginaria* son las representaciones de cadena de la <xref:System.Double> valores que forman los componentes reales e imaginarias del número complejo.</span><span class="sxs-lookup"><span data-stu-id="53a23-164">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="53a23-165">Algunas sobrecargas de los <xref:System.Numerics.Complex.ToString%2A> método permite la personalización de las representaciones de cadena de estos <xref:System.Double> valores para reflejar las convenciones de formato de una referencia cultural determinada o que aparezcan en un formato determinado definido por un valor numérico estándar o personalizado cadena de formato.</span><span class="sxs-lookup"><span data-stu-id="53a23-165">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="53a23-166">(Para obtener más información, consulte [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="53a23-166">(For more information, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
 <span data-ttu-id="53a23-167">Una de las maneras más comunes de expresar la representación de cadena de un número complejo toma la forma a + bi, donde una es el componente real del número complejo y b es el componente imaginario del número complejo.</span><span class="sxs-lookup"><span data-stu-id="53a23-167">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="53a23-168">En ingeniería eléctrica, un número complejo con más frecuencia se expresa como un + bj.</span><span class="sxs-lookup"><span data-stu-id="53a23-168">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="53a23-169">Puede devolver la representación de cadena de un número complejo de cualquiera de estas dos formas.</span><span class="sxs-lookup"><span data-stu-id="53a23-169">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="53a23-170">Para ello, defina un proveedor de formato personalizado implementando la <xref:System.ICustomFormatter> y <xref:System.IFormatProvider> interfaces y, a continuación, llame el <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="53a23-170">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="53a23-171">En el ejemplo siguiente se define un `ComplexFormatter` clase que representa un número complejo como una cadena en formato de a + bi o + bj.</span><span class="sxs-lookup"><span data-stu-id="53a23-171">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="53a23-172">En el siguiente ejemplo, a continuación, usa a este formateador personalizado para mostrar la representación de cadena de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="53a23-172">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real">
          <span data-ttu-id="53a23-173">Parte real del número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-173">The real part of the complex number.</span>
          </span>
        </param>
        <param name="imaginary">
          <span data-ttu-id="53a23-174">Parte imaginaria del número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-174">The imaginary part of the complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-175">Inicializa una nueva instancia de la estructura <see cref="T:System.Numerics.Complex" /> utilizando el valor real y el valor imaginario especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-175">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-176">El `real` o `imaginary` argumentos pueden perder precisión si son tipos de datos que requieren una conversión explícita a <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="53a23-176">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-177">El ejemplo siguiente se crea una instancia de dos números complejos y, a continuación, utiliza en operaciones de suma, resta, multiplicación y división.</span><span class="sxs-lookup"><span data-stu-id="53a23-177">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-178">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-178">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-179">Obtiene el valor absoluto (o magnitud) de un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-179">Gets the absolute value (or magnitude) of a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-180">Valor absoluto de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-180">The absolute value of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-181">El valor absoluto de un número complejo es equivalente a su <xref:System.Numerics.Complex.Magnitude%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="53a23-181">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="53a23-182">El valor absoluto de un número real un + bi se calcula como sigue:</span><span class="sxs-lookup"><span data-stu-id="53a23-182">The absolute value of a real number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="53a23-183">Si b = 0, el resultado es 0.</span><span class="sxs-lookup"><span data-stu-id="53a23-183">If b = 0, the result is 0.</span></span>  
  
-   <span data-ttu-id="53a23-184">Si un > b, el resultado es un \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="53a23-184">If a > b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="53a23-185">Si b >, el resultado es b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="53a23-185">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="53a23-186">Si el cálculo del valor absoluto da como resultado un desbordamiento, el método devuelve <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-186">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="53a23-187">Si el <xref:System.Numerics.Complex.Real%2A> o <xref:System.Numerics.Complex.Imaginary%2A> propiedad es <xref:System.Double.NaN?displayProperty=nameWithType> y la otra propiedad no es ni <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ni <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, el método devuelve <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-187">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-188">El ejemplo siguiente se calcula el valor absoluto de un número complejo y demuestra que es equivalente al valor de la <xref:System.Numerics.Complex.Magnitude%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="53a23-188">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-189">Número complejo que representa un coseno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-189">A complex number that represents a cosine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-190">Devuelve el ángulo que es el arco coseno del número complejo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-190">Returns the angle that is the arc cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-191">Ángulo, medido en radianes, que es el arco coseno de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-191">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-192">El <xref:System.Numerics.Complex.Acos%2A> método para los números complejos corresponde a la <xref:System.Math.Acos%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="53a23-192">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53a23-193">El <xref:System.Numerics.Complex.Acos%2A> método utiliza la fórmula siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-193">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="53a23-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="53a23-194">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="53a23-195">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Acos%2A> método.</span><span class="sxs-lookup"><span data-stu-id="53a23-195">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="53a23-196">Muestra lo que pasa el valor devuelto por la <xref:System.Numerics.Complex.Acos%2A> método a la <xref:System.Numerics.Complex.Cos%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="53a23-196">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="53a23-197">Primer número complejo que se va a sumar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-197">The first complex number to add.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="53a23-198">Segundo número complejo que se va a sumar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-198">The second complex number to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-199">Suma dos valores complejos y devuelve el resultado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-199">Adds two complex numbers and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-200">La suma de <paramref name="left" /> y <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-200">The sum of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-201">La adición de un complejo número a + bi, y un segundo número complejo, c + inserción de dependencias, adopta la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-201">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="53a23-202">(a + c) + (b + d).</span><span class="sxs-lookup"><span data-stu-id="53a23-202">(a + c) + (b + d)i.</span></span>  
  
 <span data-ttu-id="53a23-203">Si la llamada al método produce un desbordamiento en el componente real o imaginario, el valor del componente es <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-203">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="53a23-204">Los lenguajes que no admiten operadores personalizados pueden usar el <xref:System.Numerics.Complex.Add%2A> método para sumar con números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-204">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-205">El ejemplo siguiente muestra la suma con números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-205">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-206">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-206">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-207">Devuelve el ángulo que es el arco seno del número complejo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-207">Returns the angle that is the arc sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-208">Ángulo que es el arco seno de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-208">The angle which is the arc sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-209">El <xref:System.Numerics.Complex.Asin%2A> método para los números complejos corresponde a la <xref:System.Math.Asin%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="53a23-209">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53a23-210">El <xref:System.Numerics.Complex.Asin%2A> método utiliza la fórmula siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-210">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="53a23-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* valor + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -valor \* valor))</span><span class="sxs-lookup"><span data-stu-id="53a23-211">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="53a23-212">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Asin%2A> método.</span><span class="sxs-lookup"><span data-stu-id="53a23-212">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="53a23-213">Muestra lo que pasa el valor devuelto por la <xref:System.Numerics.Complex.Asin%2A> método a la <xref:System.Numerics.Complex.Sin%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="53a23-213">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-214">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-214">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-215">Devuelve el ángulo que es el arco tangente del número complejo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-215">Returns the angle that is the arc tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-216">Ángulo que es el arco tangente de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-216">The angle that is the arc tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-217">El <xref:System.Numerics.Complex.Atan%2A> método para los números complejos corresponde a la <xref:System.Math.Atan%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="53a23-217">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53a23-218">El <xref:System.Numerics.Complex.Atan%2A> método utiliza la fórmula siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-218">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="53a23-219"><xref:System.Numerics.Complex.ImaginaryOne> / nuevo complejo (2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> \* valor)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* valor)</span><span class="sxs-lookup"><span data-stu-id="53a23-219"><xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value)</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="53a23-220">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Atan%2A> método.</span><span class="sxs-lookup"><span data-stu-id="53a23-220">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="53a23-221">Muestra lo que pasa el valor devuelto por la <xref:System.Numerics.Complex.Atan%2A> método a la <xref:System.Numerics.Complex.Tan%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="53a23-221">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-222">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-222">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-223">Calcula el conjugado de un número complejo y devuelve el resultado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-223">Computes the conjugate of a complex number and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-224">Conjugado de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-224">The conjugate of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-225">El conjugado de un número complejo invierte el signo del componente imaginario; es decir, negación unaria se aplica al componente imaginario.</span><span class="sxs-lookup"><span data-stu-id="53a23-225">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="53a23-226">Si un + bi es un número complejo, su conjugado es a - bi.</span><span class="sxs-lookup"><span data-stu-id="53a23-226">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-227">El ejemplo siguiente muestra el conjugado de dos números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-227">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-228">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-228">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-229">Devuelve el coseno del número complejo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-229">Returns the cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-230">Coseno de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-230">The cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-231">El <xref:System.Numerics.Complex.Cos%2A> método para los números complejos corresponde a la <xref:System.Math.Cos%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="53a23-231">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53a23-232">El <xref:System.Numerics.Complex.Cos%2A> método usa la siguiente fórmula para calcular el coseno del número complejo a + bi:</span><span class="sxs-lookup"><span data-stu-id="53a23-232">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="53a23-233">(<xref:System.Math.Cos%2A>(a) * <xref:System.Math.Cosh%2A>(b),-(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))</span><span class="sxs-lookup"><span data-stu-id="53a23-233">(<xref:System.Math.Cos%2A>(a) * <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-234">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Acos%2A> método.</span><span class="sxs-lookup"><span data-stu-id="53a23-234">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="53a23-235">Muestra lo que pasa el valor devuelto por la <xref:System.Numerics.Complex.Acos%2A> método a la <xref:System.Numerics.Complex.Cos%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="53a23-235">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-236">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-236">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-237">Devuelve el coseno hiperbólico del número complejo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-237">Returns the hyperbolic cosine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-238">Coseno hiperbólico de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-238">The hyperbolic cosine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-239">El <xref:System.Numerics.Complex.Cosh%2A> método para los números complejos corresponde a la <xref:System.Math.Cosh%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="53a23-239">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53a23-240">El <xref:System.Numerics.Complex.Cosh%2A> método usa la siguiente fórmula para calcular el coseno hiperbólico del número complejo a + bi:</span><span class="sxs-lookup"><span data-stu-id="53a23-240">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="53a23-241">(<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="53a23-241">(<xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend">
          <span data-ttu-id="53a23-242">Número complejo que se va a dividir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-242">The complex number to be divided.</span>
          </span>
        </param>
        <param name="divisor">
          <span data-ttu-id="53a23-243">Número complejo por el cual se va a dividir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-243">The complex number to divide by.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-244">Divide un número complejo por otro y devuelve el resultado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-244">Divides one complex number by another and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-245">Cociente de la división.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-245">The quotient of the division.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-246">La división de un número complejo, un + bi, por un segundo número complejo, número, c + di, toma la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-246">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="53a23-247">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>)</span><span class="sxs-lookup"><span data-stu-id="53a23-247">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="53a23-248">Si el cálculo del cociente provoca un desbordamiento en el componente real o imaginario, el valor de ese componente sea <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-248">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="53a23-249">El <xref:System.Numerics.Complex.Divide%2A> método puede usarse por los lenguajes que no admiten operadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="53a23-249">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="53a23-250">Su comportamiento es idéntico a la división utilizando el operador de división.</span><span class="sxs-lookup"><span data-stu-id="53a23-250">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-251">El ejemplo siguiente divide un número complejo por cada elemento de una matriz de números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-251">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="53a23-252">Devuelve un valor que indica si dos números complejos son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-252">Returns a value that indicates whether two complex numbers are equal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-253">Número complejo que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-253">The complex number to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-254">Devuelve un valor que indica si la instancia actual y el número complejo especificado tienen el mismo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-254">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-255">Es <see langword="true" /> si este número complejo y <paramref name="value" /> tienen el mismo valor; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-255">
              <see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-256">El <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método proporciona la <xref:System.IEquatable%601> implementación para el <xref:System.Numerics.Complex> estructura.</span><span class="sxs-lookup"><span data-stu-id="53a23-256">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="53a23-257">Tiene un rendimiento ligeramente mejor que <xref:System.Numerics.Complex.Equals%28System.Object%29> método porque no tiene que convertir el parámetro en un número complejo.</span><span class="sxs-lookup"><span data-stu-id="53a23-257">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="53a23-258">Dos números complejos son iguales si sus partes reales son iguales y sus partes imaginarias también son iguales.</span><span class="sxs-lookup"><span data-stu-id="53a23-258">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="53a23-259">El <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método es equivalente a la siguiente expresión:</span><span class="sxs-lookup"><span data-stu-id="53a23-259">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="53a23-260">
            <para>Use el <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> método con precaución, porque dos valores que son aparentemente equivalentes pueden considerarse iguales debido a la precisión diferente de sus componentes reales e imaginarias. En el ejemplo siguiente se notifica que <c>(3.33333, 0.142857)</c> y <c>(10/3, 1/7)</c> no son iguales.  [! código csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [! código vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)] una técnica recomendada consiste en definir un margen aceptable de diferencia entre los dos valores (como. 01% de uno de los componentes de los valores reales e imaginarias) en lugar de comparar los valores para la igualdad. Si el valor absoluto de la diferencia entre los dos valores es menor o igual que el margen, la diferencia es probable que sea debido a una diferencia en precisión y, por lo tanto, los valores suelen ser iguales. En el ejemplo siguiente se usa esta técnica para comparar los dos valores complejos que en el ejemplo de código anterior se consideran iguales. Busca los dos números complejos son iguales.  [! código csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [! código vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-260">
              <para>Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components. The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.  [!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]  One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality. If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal. The following example uses this technique to compare the two complex values that the previous code example found to be unequal. It finds the two complex numbers to be equal.  [!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="53a23-261">Objeto que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-261">The object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-262">Devuelve un valor que indica si la instancia actual y un objeto especificado tienen el mismo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-262">Returns a value that indicates whether the current instance and a specified object have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-263">Es <see langword="true" /> si el parámetro <paramref name="obj" /> es un objeto <see cref="T:System.Numerics.Complex" /> o un tipo capaz de realizar una conversión implícita a un objeto <see cref="T:System.Numerics.Complex" />, y su valor es igual al valor del objeto <see cref="T:System.Numerics.Complex" /> actual; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-263">
              <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-264">Dos números complejos son iguales si sus partes reales son iguales y sus partes imaginarias también son iguales.</span><span class="sxs-lookup"><span data-stu-id="53a23-264">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="53a23-265">El <xref:System.Numerics.Complex.Equals%28System.Object%29> método es equivalente a la siguiente expresión:</span><span class="sxs-lookup"><span data-stu-id="53a23-265">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="53a23-266">Si el `obj` parámetro no es un <xref:System.Numerics.Complex> objeto, pero es un tipo de datos para el que se define una conversión implícita, el <xref:System.Numerics.Complex.Equals%28System.Object%29> método convierte `obj` a un <xref:System.Numerics.Complex> objeto cuya parte real es igual al valor de `obj`y cuya parte imaginaria es igual a cero antes de realizar la comparación.</span><span class="sxs-lookup"><span data-stu-id="53a23-266">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="53a23-267">El ejemplo siguiente ilustra esto mediante la búsqueda de que un número complejo y un valor de punto flotante de doble precisión son iguales.</span><span class="sxs-lookup"><span data-stu-id="53a23-267">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="53a23-268">
            <para>Use el <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> método con precaución, porque dos valores que son aparentemente equivalentes pueden considerarse iguales debido a la precisión diferente de sus componentes reales e imaginarias. El problema puede ser acentúa si <paramref name="obj" /> deben convertirse a un <see cref="T:System.Double" /> antes de realizar la comparación. En el ejemplo siguiente se compara un número complejo cuyo componente real parece ser igual que un <see cref="T:System.Single" /> valor con el que <see cref="T:System.Single" /> valor. Como se muestra en la salida, la comparación de igualdad devuelve <see langword="False" />.  [! código csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [! código vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)] una técnica recomendada consiste en definir un margen aceptable de diferencia entre los dos valores (como. 01% de uno de los componentes de los valores reales e imaginarias) en lugar de comparar los valores para la igualdad. Si el valor absoluto de la diferencia entre los dos valores es menor o igual que el margen, la diferencia es probable que sea debido a una diferencia en precisión y, por lo tanto, los valores suelen ser iguales. El ejemplo siguiente utiliza esta técnica para comparar los dos valores que en el ejemplo de código anterior se consideran iguales. Ahora busca que son iguales.  [! código csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [! código vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-268">
              <para>Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components. The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison. The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value. As the output shows, the comparison for equality returns <see langword="False" />.  [!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]  One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality. If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal. The following example uses this technique to compare the two values that the previous code example found to be unequal. It now finds them to be equal.  [!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-269">Número complejo que especifica una potencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-269">A complex number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-270">Devuelve un <see langword="e" /> elevado a la potencia especificada por un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-270">Returns <see langword="e" /> raised to the power specified by a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-271">Número <see langword="e" /> elevado a la potencia <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-271">The number <see langword="e" /> raised to the power <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-272">Use el <xref:System.Numerics.Complex.Pow%2A> método para calcular las potencias de otras bases.</span><span class="sxs-lookup"><span data-stu-id="53a23-272">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="53a23-273">El <xref:System.Numerics.Complex.Exp%2A> método para los números complejos corresponde a la <xref:System.Math.Exp%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="53a23-273">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="53a23-274"><xref:System.Numerics.Complex.Exp%2A> es el inverso de <xref:System.Numerics.Complex.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="53a23-274"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-275">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Exp%2A> método.</span><span class="sxs-lookup"><span data-stu-id="53a23-275">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="53a23-276">Muestra que, con algunas máximo permitido de la falta de precisión de la <xref:System.Double> tipo de datos, pasando el valor devuelto por la <xref:System.Numerics.Complex.Log%2A> método a la <xref:System.Numerics.Complex.Exp%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="53a23-276">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude">
          <span data-ttu-id="53a23-277">Magnitud, que es la distancia del origen (la intersección de los ejes X e Y) al número.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-277">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span>
          </span>
        </param>
        <param name="phase">
          <span data-ttu-id="53a23-278">Fase, que es el ángulo desde la línea al eje horizontal, medido en radianes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-278">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-279">Crea un número complejo a partir de las coordenadas polares de un punto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-279">Creates a complex number from a point's polar coordinates.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-280">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-280">A complex number.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-281">El <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método crea una instancia de un número complejo según sus coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="53a23-281">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="53a23-282">Dado que hay varias representaciones de un punto en un plano complejo, el valor devuelto de la <xref:System.Numerics.Complex.FromPolarCoordinates%2A> se normaliza el método.</span><span class="sxs-lookup"><span data-stu-id="53a23-282">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="53a23-283">La magnitud se normaliza a un número positivo, y la fase se normaliza a un valor en el intervalo de -<xref:System.Math.PI> a <xref:System.Math.PI>.</span><span class="sxs-lookup"><span data-stu-id="53a23-283">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="53a23-284">Como resultado, los valores de la <xref:System.Numerics.Complex.Phase%2A> y <xref:System.Numerics.Complex.Magnitude%2A> propiedades del número complejo resultante no puede ser igual a los valores originales de la `magnitude` y `phase` parámetros.</span><span class="sxs-lookup"><span data-stu-id="53a23-284">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="53a23-285">Para convertir un valor de grados en radianes para el `phase` parámetro, multiplicar, por  <xref:System.Math.PI?displayProperty=nameWithType> /180.</span><span class="sxs-lookup"><span data-stu-id="53a23-285">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-286">En el ejemplo siguiente se usa el <xref:System.Numerics.Complex.FromPolarCoordinates%2A> según sus coordenadas polares de método para crear instancias de un número complejo y, a continuación, muestra el valor de su <xref:System.Numerics.Complex.Magnitude%2A> y <xref:System.Numerics.Complex.Phase%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="53a23-286">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="53a23-287">Devuelve el código hash del objeto <see cref="T:System.Numerics.Complex" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-287">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-288">Código hash de un entero de 32 bits con signo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-288">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="53a23-289">Obtiene el componente imaginario del objeto <see cref="T:System.Numerics.Complex" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-289">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="53a23-290">Componente imaginario de un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-290">The imaginary component of a complex number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-291">Dado un número complejo a + bi, el <xref:System.Numerics.Complex.Imaginary%2A> propiedad devuelve el valor de b.</span><span class="sxs-lookup"><span data-stu-id="53a23-291">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-292">El ejemplo siguiente crea una matriz de <xref:System.Numerics.Complex> objetos y se muestran los componentes reales e imaginarios de cada uno en el formulario a + bi.</span><span class="sxs-lookup"><span data-stu-id="53a23-292">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="53a23-293">Devuelve una nueva instancia de <see cref="T:System.Numerics.Complex" /> con un número real igual a cero y un número imaginario igual a uno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-293">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="53a23-294">El ejemplo siguiente crea un <xref:System.Numerics.Complex> valor utilizando la <xref:System.Numerics.Complex.ImaginaryOne> propiedad.</span><span class="sxs-lookup"><span data-stu-id="53a23-294">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="53a23-295">A continuación, compara este valor con otro valor que se crea una instancia mediante una llamada a la <xref:System.Numerics.Complex> constructor con una parte real igual a cero y una parte imaginaria igual a uno.</span><span class="sxs-lookup"><span data-stu-id="53a23-295">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="53a23-296">Como se muestra el resultado del ejemplo, los dos valores son iguales.</span><span class="sxs-lookup"><span data-stu-id="53a23-296">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="53a23-297">Devuelve el logaritmo de un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-297">Returns the logarithm of a complex number.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-298">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-298">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-299">Devuelve el logaritmo natural (en la base <see langword="e" />) del número complejo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-299">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-300">Logaritmo natural (en la base <see langword="e" />) de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-300">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-301">El <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> método para los números complejos corresponde a la <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="53a23-301">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-302">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Log%2A> método.</span><span class="sxs-lookup"><span data-stu-id="53a23-302">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="53a23-303">Muestra que, con algunas máximo permitido de la falta de precisión de la <xref:System.Double> tipo de datos, pasando el valor devuelto por la <xref:System.Numerics.Complex.Log%2A> método a la <xref:System.Numerics.Complex.Exp%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="53a23-303">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-304">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-304">A complex number.</span>
          </span>
        </param>
        <param name="baseValue">
          <span data-ttu-id="53a23-305">Base del logaritmo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-305">The base of the logarithm.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-306">Devuelve el logaritmo del número complejo especificado en la base especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-306">Returns the logarithm of a specified complex number in a specified base.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-307">Logaritmo de <paramref name="value" /> en la base <paramref name="baseValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-307">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-308">El <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> método para los números complejos corresponde a la <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="53a23-308">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-309">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-309">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-310">Devuelve el logaritmo en la base 10 del número complejo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-310">Returns the base-10 logarithm of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-311">Logaritmo en base 10 de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-311">The base-10 logarithm of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-312">El <xref:System.Numerics.Complex.Log10%2A> método para los números complejos corresponde a la <xref:System.Math.Log10%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="53a23-312">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="53a23-313">Obtiene la magnitud (o valor absoluto) de un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-313">Gets the magnitude (or absolute value) of a complex number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="53a23-314">Magnitud de la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-314">The magnitude of the current instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-315">El <xref:System.Numerics.Complex.Magnitude%2A> propiedad es equivalente al valor absoluto de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="53a23-315">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="53a23-316">Especifica la distancia desde el origen (la intersección del eje x y el eje y en el sistema de coordenadas cartesiano) al punto bidimensional representado por un número complejo.</span><span class="sxs-lookup"><span data-stu-id="53a23-316">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="53a23-317">El valor absoluto se calcula como sigue:</span><span class="sxs-lookup"><span data-stu-id="53a23-317">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="53a23-318">&#124;a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(un * un + b * b)</span><span class="sxs-lookup"><span data-stu-id="53a23-318">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a * a + b * b)</span></span>  
  
 <span data-ttu-id="53a23-319">Si el cálculo del valor absoluto da como resultado un desbordamiento, esta propiedad devuelve <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-319">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="53a23-320">El <xref:System.Numerics.Complex.Magnitude%2A> y <xref:System.Numerics.Complex.Phase%2A> propiedades definen la posición de un punto que representa un número complejo en el sistema de coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="53a23-320">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="53a23-321">Puede crear una instancia de un número complejo según sus coordenadas polares, en lugar de sus coordenadas cartesianas mediante una llamada a la <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método.</span><span class="sxs-lookup"><span data-stu-id="53a23-321">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-322">El ejemplo siguiente se calcula el valor absoluto de un número complejo y demuestra que es equivalente al valor de la <xref:System.Numerics.Complex.Magnitude%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="53a23-322">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="53a23-323">Primer número complejo que se va a multiplicar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-323">The first complex number to multiply.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="53a23-324">Segundo número complejo que se va a multiplicar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-324">The second complex number to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-325">Devuelve el producto de dos números complejos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-325">Returns the product of two complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-326">Producto de los parámetros <paramref name="left" /> y <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-326">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-327">La multiplicación de un complejo número a + bi, y un segundo número complejo, c + inserción de dependencias, adopta la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-327">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="53a23-328">(ac - bd) + (ad + bc)</span><span class="sxs-lookup"><span data-stu-id="53a23-328">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="53a23-329">Si la multiplicación provoca un desbordamiento en el componente real o imaginario, el valor de ese componente sea <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-329">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="53a23-330">El <xref:System.Numerics.Complex.Multiply%2A> método se implementa para los idiomas que no admiten operadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="53a23-330">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="53a23-331">Su comportamiento es idéntico a la multiplicación utilizando el operador de multiplicación.</span><span class="sxs-lookup"><span data-stu-id="53a23-331">Its behavior is identical to multiplication using the multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-332">El ejemplo siguiente se multiplica un número complejo por cada elemento de una matriz de números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-332">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-333">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-333">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-334">Devuelve el inverso aditivo de un número complejo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-334">Returns the additive inverse of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-335">Resultado de multiplicar por -1 los componentes <see cref="P:System.Numerics.Complex.Real" /> e <see cref="P:System.Numerics.Complex.Imaginary" /> del parámetro <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-335">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-336">El inverso aditivo de un número complejo es un número complejo que genera un valor de <xref:System.Numerics.Complex> cuando se agrega al número complejo original.</span><span class="sxs-lookup"><span data-stu-id="53a23-336">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex> when it is added to the original complex number.</span></span> <span data-ttu-id="53a23-337">Este método devuelve un número complejo en el que los componentes reales e imaginarios del número complejo original se multiplican por -1.</span><span class="sxs-lookup"><span data-stu-id="53a23-337">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="53a23-338">El <xref:System.Numerics.Complex.Negate%2A> método se implementa para los idiomas que no admiten operadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="53a23-338">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="53a23-339">Su comportamiento es idéntico a la negación utilizando el operador unario de negación, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span><span class="sxs-lookup"><span data-stu-id="53a23-339">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-340">El ejemplo siguiente obtiene el inverso aditivo de cada elemento de una matriz de números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-340">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="53a23-341">Devuelve una nueva instancia de <see cref="T:System.Numerics.Complex" /> con un número real igual a uno y un número imaginario igual a cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-341">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="53a23-342">El ejemplo siguiente crea un <xref:System.Numerics.Complex> valor utilizando la <xref:System.Numerics.Complex.One> propiedad.</span><span class="sxs-lookup"><span data-stu-id="53a23-342">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="53a23-343">A continuación, compara este valor con otro valor que se crea una instancia mediante una llamada a la <xref:System.Numerics.Complex> constructor con una parte real igual a uno y una parte imaginaria igual a cero.</span><span class="sxs-lookup"><span data-stu-id="53a23-343">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="53a23-344">Como se muestra el resultado del ejemplo, los dos valores son iguales.</span><span class="sxs-lookup"><span data-stu-id="53a23-344">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="53a23-345">Primer valor que se va a sumar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-345">The first value to add.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="53a23-346">Segundo valor que se va a sumar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-346">The second value to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-347">Suma dos números complejos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-347">Adds two complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-348">La suma de <paramref name="left" /> y <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-348">The sum of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-349">El <xref:System.Numerics.Complex.op_Addition%2A> método define la operación de suma de números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-349">The <xref:System.Numerics.Complex.op_Addition%2A> method defines the addition operation for complex numbers.</span></span> <span data-ttu-id="53a23-350">Permite código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-350">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 <span data-ttu-id="53a23-351">La adición de un complejo número a + bi, y un segundo número complejo, c + inserción de dependencias, adopta la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-351">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="53a23-352">(a + c) + (b + d)</span><span class="sxs-lookup"><span data-stu-id="53a23-352">(a + c) + (b + d)i</span></span>  
  
 <span data-ttu-id="53a23-353">Si la llamada al método produce un desbordamiento en el componente real o imaginario, el valor de ese componente sea <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-353">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="53a23-354">Los lenguajes que no admiten operadores personalizados pueden llamar los <xref:System.Numerics.Complex.Add%2A> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="53a23-354">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="53a23-355">Es el método equivalente para este operador <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="53a23-355">The equivalent method for this operator is <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="53a23-356">El ejemplo siguiente muestra la suma con números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-356">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="53a23-357">Valor que se va a dividir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-357">The value to be divided.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="53a23-358">Valor por el que se va a dividir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-358">The value to divide by.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-359">Divide el número complejo especificado por otro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-359">Divides a specified complex number by another specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-360">Resultado de dividir <paramref name="left" /> entre <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-360">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-361">El <xref:System.Numerics.Complex.op_Division%2A> método define la operación de división de números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-361">The <xref:System.Numerics.Complex.op_Division%2A> method defines the division operation for complex numbers.</span></span> <span data-ttu-id="53a23-362">Permite código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-362">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 <span data-ttu-id="53a23-363">La división de un complejo número a + bi, y un segundo número complejo, c + inserción de dependencias, adopta la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-363">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="53a23-364">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>)</span><span class="sxs-lookup"><span data-stu-id="53a23-364">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="53a23-365">Si la división provoca un desbordamiento en el componente real o imaginario, el valor de ese componente sea <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-365">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="53a23-366">Los lenguajes que no admiten la sobrecarga de operadores y los operadores personalizados pueden llamar los <xref:System.Numerics.Complex.Divide%2A> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="53a23-366">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="53a23-367">Es el método equivalente para este operador <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="53a23-367">The equivalent method for this operator is <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="53a23-368">Primer número complejo que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-368">The first complex number to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="53a23-369">Segundo número complejo que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-369">The second complex number to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-370">Devuelve un valor que indica si dos números complejos son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-370">Returns a value that indicates whether two complex numbers are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-371">Es <see langword="true" /> si los parámetros <paramref name="left" /> y <paramref name="right" /> tienen el mismo valor; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-371">
              <see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-372">El <xref:System.Numerics.Complex.op_Equality%2A> método define la operación del operador de igualdad para <xref:System.Numerics.Complex> valores.</span><span class="sxs-lookup"><span data-stu-id="53a23-372">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="53a23-373">Permite código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-373">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="53a23-374">Los lenguajes que no admiten operadores personalizados pueden llamar los <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="53a23-374">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="53a23-375">Dos números complejos son iguales si sus partes reales son iguales y sus partes imaginarias también son iguales.</span><span class="sxs-lookup"><span data-stu-id="53a23-375">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="53a23-376">El <xref:System.Numerics.Complex.op_Equality%2A> método es equivalente a la siguiente expresión:</span><span class="sxs-lookup"><span data-stu-id="53a23-376">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="53a23-377">Tenga en cuenta que, debido a diferencias en precisión, dos números complejos que son aparentemente equivalentes pueden considerarse iguales.</span><span class="sxs-lookup"><span data-stu-id="53a23-377">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="53a23-378">Para obtener más información y una posible solución alternativa, vea el <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método.</span><span class="sxs-lookup"><span data-stu-id="53a23-378">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="53a23-379">Es el método equivalente para este operador <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="53a23-379">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="53a23-380">Define una conversión explícita entre un objeto <see cref="T:System.Numerics.Complex" /> y otro tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-380">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span>
          </span>
        </summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-381">Valor que se va a convertir en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-381">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-382">Define una conversión explícita de un valor <see cref="T:System.Decimal" /> a un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-382">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-383">Número complejo con un componente real igual a <paramref name="value" /> y un componente imaginario igual a cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-383">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-384">Operadores de conversión explícitos definen tipos que se pueden convertir en un <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="53a23-384">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="53a23-385">Los compiladores de lenguaje no realizan esta conversión automáticamente porque puede implicar pérdida de datos.</span><span class="sxs-lookup"><span data-stu-id="53a23-385">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="53a23-386">En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` en Visual Basic) se utiliza.</span><span class="sxs-lookup"><span data-stu-id="53a23-386">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="53a23-387">En caso contrario, muestra un error del compilador.</span><span class="sxs-lookup"><span data-stu-id="53a23-387">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="53a23-388">La conversión de un <xref:System.Decimal> valor a la parte real de un número complejo puede provocar una pérdida de precisión porque un <xref:System.Double>, que es el tipo del número complejo <xref:System.Numerics.Complex.Real%2A> propiedad, tiene menos dígitos significativos que un <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="53a23-388">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="53a23-389">El ejemplo siguiente muestra la conversión explícita de <xref:System.Decimal> valores <xref:System.Numerics.Complex> valores.</span><span class="sxs-lookup"><span data-stu-id="53a23-389">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-390">Valor que se va a convertir en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-390">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-391">Define una conversión explícita de un valor <see cref="T:System.Numerics.BigInteger" /> a un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-391">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-392">Número complejo con un componente real igual a <paramref name="value" /> y un componente imaginario igual a cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-392">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-393">Operadores de conversión explícitos definen tipos que se pueden convertir en un <xref:System.Numerics.Complex> objeto.</span><span class="sxs-lookup"><span data-stu-id="53a23-393">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="53a23-394">Los compiladores de lenguaje no realizan esta conversión automáticamente porque puede implicar pérdida de datos.</span><span class="sxs-lookup"><span data-stu-id="53a23-394">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="53a23-395">En su lugar, realizan la conversión solo si un operador de conversión (en C#) o una función de conversión (como `CType` en Visual Basic) se utiliza.</span><span class="sxs-lookup"><span data-stu-id="53a23-395">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="53a23-396">En caso contrario, muestra un error del compilador.</span><span class="sxs-lookup"><span data-stu-id="53a23-396">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="53a23-397">La conversión de un <xref:System.Numerics.BigInteger> valor a la parte real de un número complejo puede provocar una pérdida de precisión porque un <xref:System.Double>, que es el tipo del número complejo <xref:System.Numerics.Complex.Real%2A> propiedad, tiene menos dígitos significativos que un <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="53a23-397">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="53a23-398">Si la conversión se realiza correctamente porque el <xref:System.Numerics.BigInteger> valor está fuera del intervalo de la <xref:System.Double> tipo, la operación no se produce un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="53a23-398">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="53a23-399">En su lugar, si `value` es menor que <xref:System.Double.MinValue>, el resultado es un número complejo que tiene un <xref:System.Numerics.Complex.Real%2A> igual al valor de la propiedad <xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="53a23-399">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="53a23-400">Si `value` es mayor que <xref:System.Double.MaxValue>, el resultado es un número complejo que tiene un <xref:System.Numerics.Complex.Real%2A> igual al valor de la propiedad <xref:System.Double.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="53a23-400">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="53a23-401">El ejemplo siguiente muestra la conversión explícita de <xref:System.Numerics.BigInteger> valores <xref:System.Numerics.Complex> valores.</span><span class="sxs-lookup"><span data-stu-id="53a23-401">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="53a23-402">Define una conversión implícita entre un objeto <see cref="T:System.Numerics.Complex" /> y otro tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-402">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-403">Valor que se va a convertir en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-403">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-404">Define una conversión implícita de un byte sin signo en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-404">Defines an implicit conversion of an unsigned byte to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-405">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-405">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-406">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="53a23-406">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53a23-407">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="53a23-407">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53a23-408">Esta sobrecarga permite al compilador administrar las conversiones de un <xref:System.Byte> valor en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="53a23-408">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="53a23-409">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual a la <xref:System.Byte> valor y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="53a23-409">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-410">Valor que se va a convertir en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-410">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-411">Define una conversión implícita de un número de punto flotante de precisión doble en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-411">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-412">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-412">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-413">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="53a23-413">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53a23-414">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="53a23-414">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53a23-415">Esta sobrecarga permite al compilador administrar las conversiones de un <xref:System.Double> valor en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="53a23-415">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="53a23-416">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual a la <xref:System.Double> valor y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="53a23-416">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-417">Valor que se va a convertir en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-417">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-418">Define una conversión implícita de un entero de 16 bits con signo en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-418">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-419">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-419">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-420">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="53a23-420">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53a23-421">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="53a23-421">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53a23-422">Esta sobrecarga permite al compilador administrar las conversiones de un entero de 16 bits con signo en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="53a23-422">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="53a23-423">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual que el entero de 16 bits con signo y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="53a23-423">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-424">Valor que se va a convertir en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-424">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-425">Define una conversión implícita de un entero de 32 bits con signo en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-425">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-426">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-426">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-427">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="53a23-427">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53a23-428">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="53a23-428">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53a23-429">Esta sobrecarga permite al compilador administrar las conversiones de un entero de 32 bits con signo en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="53a23-429">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="53a23-430">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual que el entero de 32 bits con signo y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="53a23-430">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-431">Valor que se va a convertir en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-431">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-432">Define una conversión implícita de un entero de 64 bits con signo en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-432">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-433">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-433">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-434">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="53a23-434">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53a23-435">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="53a23-435">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53a23-436">Esta sobrecarga permite al compilador administrar las conversiones de un entero de 64 bits con signo en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="53a23-436">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="53a23-437">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual que el entero de 64 bits con signo y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="53a23-437">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-438">Valor que se va a convertir en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-438">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-439">Define una conversión implícita de un byte con signo en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-439">Defines an implicit conversion of a signed byte to a complex number.</span>
          </span>
          <span data-ttu-id="53a23-440">Esta API no es conforme a CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-440">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-441">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-441">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-442">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="53a23-442">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53a23-443">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="53a23-443">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53a23-444">Esta sobrecarga permite al compilador administrar las conversiones de un byte con signo en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="53a23-444">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="53a23-445">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual a byte con signo y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="53a23-445">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-446">Valor que se va a convertir en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-446">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-447">Define una conversión implícita de un número de punto flotante de precisión sencilla en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-447">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-448">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-448">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-449">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="53a23-449">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53a23-450">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="53a23-450">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53a23-451">Esta sobrecarga permite al compilador administrar las conversiones de un <xref:System.Single> valor en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="53a23-451">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="53a23-452">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual a la <xref:System.Single> valor y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="53a23-452">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-453">Valor que se va a convertir en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-453">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-454">Define una conversión implícita de un entero de 16 bits sin signo en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-454">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="53a23-455">Esta API no es conforme a CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-455">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-456">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-456">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-457">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="53a23-457">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53a23-458">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="53a23-458">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53a23-459">Esta sobrecarga permite al compilador administrar las conversiones de un entero de 16 bits sin signo en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="53a23-459">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="53a23-460">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual que el entero de 16 bits sin signo y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="53a23-460">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-461">Valor que se va a convertir en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-461">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-462">Define una conversión implícita de un entero de 32 bits sin signo en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-462">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="53a23-463">Esta API no es conforme a CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-463">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-464">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-464">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-465">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="53a23-465">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53a23-466">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="53a23-466">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53a23-467">Esta sobrecarga permite al compilador administrar las conversiones de un entero de 32 bits sin signo en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="53a23-467">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="53a23-468">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual que el entero sin signo de 32 bits y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="53a23-468">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-469">Valor que se va a convertir en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-469">The value to convert to a complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-470">Define una conversión implícita de un entero de 64 bits sin signo en un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-470">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span>
          </span>
          <span data-ttu-id="53a23-471">Esta API no es conforme a CLS.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-471">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-472">Objeto que contiene el valor del parámetro <paramref name="value" /> como número real y cero como número imaginario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-472">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-473">Las sobrecargas de los <xref:System.Numerics.Complex.op_Implicit%2A> operador definen los tipos desde el que un compilador puede convertir automáticamente un <xref:System.Numerics.Complex> objeto sin un operador de conversión explícita (en C#) o una llamada a una función de conversión (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="53a23-473">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="53a23-474">Son conversiones de ampliación que implican la pérdida de datos y no producen un <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="53a23-474">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="53a23-475">Esta sobrecarga permite al compilador administrar las conversiones de un entero de 64 bits sin signo en un número complejo, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="53a23-475">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="53a23-476">Tenga en cuenta que el resultado de la conversión es un número complejo cuya parte real es igual que el entero de 64 bits sin signo y cuya parte imaginaria es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="53a23-476">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="53a23-477">Primer valor que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-477">The first value to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="53a23-478">Segundo valor que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-478">The second value to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-479">Devuelve un valor que indica si dos números complejos no son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-479">Returns a value that indicates whether two complex numbers are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-480">
            <see langword="true" /> si <paramref name="left" /> y <paramref name="right" /> no son iguales; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-480">
              <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-481">El <xref:System.Numerics.Complex.op_Equality%2A> método define la operación del operador de desigualdad para los números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-481">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="53a23-482">Permite código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-482">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="53a23-483">Los lenguajes que no admiten operadores personalizados pueden probar la desigualdad mediante una llamada a la <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> método e invertir su valor.</span><span class="sxs-lookup"><span data-stu-id="53a23-483">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="53a23-484">Tenga en cuenta que, debido a diferencias en precisión, dos números complejos que son aparentemente equivalentes pueden considerarse iguales.</span><span class="sxs-lookup"><span data-stu-id="53a23-484">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="53a23-485">Una posible solución consiste en implementar un método de comparación devuelve `true` solo si la diferencia entre las dos partes reales e imaginarias de los números complejos supera un umbral determinado (como. 01% del valor del componente real o imaginario de uno de los números complejos).</span><span class="sxs-lookup"><span data-stu-id="53a23-485">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="53a23-486">Para obtener más información, vea el método <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>.</span><span class="sxs-lookup"><span data-stu-id="53a23-486">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="53a23-487">Primer valor que se va a multiplicar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-487">The first value to multiply.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="53a23-488">Segundo valor que se va a multiplicar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-488">The second value to multiply.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-489">Multiplica los dos números complejos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-489">Multiplies two specified complex numbers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-490">Producto de <paramref name="left" /> y <paramref name="right" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-490">The product of <paramref name="left" /> and <paramref name="right" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-491">El <xref:System.Numerics.Complex.op_Multiply%2A> método define la operación del operador de multiplicación de números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-491">The <xref:System.Numerics.Complex.op_Multiply%2A> method defines the operation of the multiplication operator for complex numbers.</span></span> <span data-ttu-id="53a23-492">Permite código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-492">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 <span data-ttu-id="53a23-493">La multiplicación de un complejo número a + bi, y un segundo número complejo, c + inserción de dependencias, adopta la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-493">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="53a23-494">(ac - bd) + (ad + bc)</span><span class="sxs-lookup"><span data-stu-id="53a23-494">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="53a23-495">Si la multiplicación provoca un desbordamiento en el componente real o imaginario, el valor de ese componente sea <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-495">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="53a23-496">Los lenguajes que no admiten operadores personalizados pueden llamar los <xref:System.Numerics.Complex.Multiply%2A> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="53a23-496">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> method instead.</span></span>  
  
 <span data-ttu-id="53a23-497">Es el método equivalente para este operador <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="53a23-497">The equivalent method for this operator is <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="53a23-498">Valor del que se va a restar (minuendo).</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-498">The value to subtract from (the minuend).</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="53a23-499">Valor que se va a restar (sustraendo).</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-499">The value to subtract (the subtrahend).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-500">Resta un número complejo de otro número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-500">Subtracts a complex number from another complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-501">Resultado de restar <paramref name="right" /> de <paramref name="left" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-501">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-502">El <xref:System.Numerics.Complex.op_Subtraction%2A> método define la operación del operador de sustracción de números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-502">The <xref:System.Numerics.Complex.op_Subtraction%2A> method defines the operation of the subtraction operator for complex numbers.</span></span> <span data-ttu-id="53a23-503">Permite código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-503">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 <span data-ttu-id="53a23-504">Si la llamada al método produce un desbordamiento en el componente real o imaginario, el valor de ese componente sea <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-504">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="53a23-505">El resultado de restar un número complejo, c + di, de otro número complejo, un + bi, toma la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-505">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="53a23-506">(a - c) + (b - d.)</span><span class="sxs-lookup"><span data-stu-id="53a23-506">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="53a23-507">Los lenguajes que no admiten operadores personalizados pueden llamar los <xref:System.Numerics.Complex.Subtract%2A> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="53a23-507">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="53a23-508">Es el método equivalente para este operador <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="53a23-508">The equivalent method for this operator is <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-509">Valor que se va a negar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-509">The value to negate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-510">Devuelve el inverso aditivo de un número complejo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-510">Returns the additive inverse of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-511">Resultado de multiplicar por -1 los componentes <see cref="P:System.Numerics.Complex.Real" /> e <see cref="P:System.Numerics.Complex.Imaginary" /> del parámetro <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-511">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-512">El <xref:System.Numerics.Complex.op_UnaryNegation%2A> método define el funcionamiento del operador unario de negación (inverso aditivo) para los números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-512">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="53a23-513">Permite código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-513">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="53a23-514">El número complejo resultante genera un valor de <xref:System.Numerics.Complex> 0 (cero) cuando se agrega al número complejo original.</span><span class="sxs-lookup"><span data-stu-id="53a23-514">The resulting complex number produces a value of <xref:System.Numerics.Complex> 0 (zero) when it is added to the original complex number.</span></span> <span data-ttu-id="53a23-515">Los lenguajes que no admiten operadores personalizados pueden llamar los <xref:System.Numerics.Complex.Negate%2A> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="53a23-515">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="53a23-516">Es el método equivalente para este operador <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="53a23-516">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="53a23-517">Obtiene la fase de un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-517">Gets the phase of a complex number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="53a23-518">Fase de un número complejo, en radianes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-518">The phase of a complex number, in radians.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-519">Para un número complejo un + bi, la fase se calcula como <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, una).</span><span class="sxs-lookup"><span data-stu-id="53a23-519">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="53a23-520">Puede identificar un número complejo por sus coordenadas cartesianas en el plano complejo o por sus coordenadas polares.</span><span class="sxs-lookup"><span data-stu-id="53a23-520">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="53a23-521">La fase (argumento) de un número complejo es el ángulo en el eje real de una línea trazada desde el punto de origen (la intersección del eje x y el eje y) para el punto representado por el número complejo.</span><span class="sxs-lookup"><span data-stu-id="53a23-521">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="53a23-522">La magnitud (representado por la <xref:System.Numerics.Complex.Magnitude%2A> propiedad) es la distancia desde el punto de origen hasta el punto que representa el número complejo.</span><span class="sxs-lookup"><span data-stu-id="53a23-522">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="53a23-523">Puede crear una instancia de un número complejo según sus coordenadas polares, en lugar de sus coordenadas cartesianas mediante una llamada a la <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método.</span><span class="sxs-lookup"><span data-stu-id="53a23-523">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="53a23-524">Para convertir la fase de radianes en grados, multiplíquelo por 180 /<xref:System.Math.PI?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-524">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-525">En el ejemplo siguiente se usa el <xref:System.Numerics.Complex.FromPolarCoordinates%2A> método para crear instancias de un número complejo según sus coordenadas polares y, a continuación, muestra el valor de su <xref:System.Numerics.Complex.Magnitude%2A> y <xref:System.Numerics.Complex.Phase%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="53a23-525">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="53a23-526">Devuelve el número complejo especificado elevado a la potencia especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-526">Returns a specified complex number raised to a specified power.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-527">Número complejo que se va a elevar a una potencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-527">A complex number to be raised to a power.</span>
          </span>
        </param>
        <param name="power">
          <span data-ttu-id="53a23-528">Número de punto flotante de precisión doble que especifica una potencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-528">A double-precision floating-point number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-529">Devuelve un número complejo especificado elevado a la potencia indicada por un número de punto flotante de precisión doble.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-529">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-530">Número complejo <paramref name="value" /> elevado a la potencia indicada por <paramref name="power" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-530">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-531">Si el valor de `value` es <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, el método devuelve <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-531">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="53a23-532">Para otros valores, si `power` es 0, el método devuelve <xref:System.Numerics.Complex.One?displayProperty=nameWithType>y si `power` es 1, devuelve `value`.</span><span class="sxs-lookup"><span data-stu-id="53a23-532">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="53a23-533">Este método corresponde a la <xref:System.Math.Pow%2A?displayProperty=nameWithType> método para tipos numéricos primitivos.</span><span class="sxs-lookup"><span data-stu-id="53a23-533">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-534">En el siguiente ejemplo se muestra exponenciación mediante un número complejo y un exponente cuyo valor varía entre -1 y 10.</span><span class="sxs-lookup"><span data-stu-id="53a23-534">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-535">Número complejo que se va a elevar a una potencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-535">A complex number to be raised to a power.</span>
          </span>
        </param>
        <param name="power">
          <span data-ttu-id="53a23-536">Número complejo que especifica una potencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-536">A complex number that specifies a power.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-537">Devuelve el número complejo especificado elevado a la potencia indicada por un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-537">Returns a specified complex number raised to a power specified by a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-538">Número complejo <paramref name="value" /> elevado a la potencia indicada por <paramref name="power" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-538">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="53a23-539">Obtiene el componente real del objeto <see cref="T:System.Numerics.Complex" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-539">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="53a23-540">Componente real de un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-540">The real component of a complex number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-541">Dado un número complejo a + bi, el <xref:System.Numerics.Complex.Real%2A> propiedad devuelve el valor de una.</span><span class="sxs-lookup"><span data-stu-id="53a23-541">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-542">El ejemplo siguiente crea una matriz de <xref:System.Numerics.Complex> objetos y se muestran los componentes reales e imaginarios de cada uno en el formulario a + bi.</span><span class="sxs-lookup"><span data-stu-id="53a23-542">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-543">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-543">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-544">Devuelve el inverso multiplicativo de un número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-544">Returns the multiplicative inverse of a complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-545">Recíproco de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-545">The reciprocal of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-546">El recíproco, o inverso multiplicativo, de un número *x* es un número *y* donde *x* multiplicado por *y* da como resultado 1.</span><span class="sxs-lookup"><span data-stu-id="53a23-546">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="53a23-547">El recíproco de un número complejo es el número complejo que genera <xref:System.Numerics.Complex.One?displayProperty=nameWithType> cuando se multiplican los dos números.</span><span class="sxs-lookup"><span data-stu-id="53a23-547">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="53a23-548">Si se representa un número complejo a + bi, su recíproco representado por la expresión un / (un<sup>2</sup>+ b<sup>2</sup>) + b-/ (un<sup>2</sup> + b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="53a23-548">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="53a23-549">Si el valor es <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, el método devuelve <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-549">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="53a23-550">En caso contrario, devuelve el resultado de la expresión <xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`.</span><span class="sxs-lookup"><span data-stu-id="53a23-550">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-551">En el ejemplo siguiente se usa el <xref:System.Numerics.Complex.Reciprocal%2A> método para calcular los valores recíprocos de varios números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-551">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="53a23-552">También se muestra que es el resultado de multiplicar un número complejo por su recíproco <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-552">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-553">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-553">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-554">Devuelve el seno del número complejo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-554">Returns the sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-555">Seno de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-555">The sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-556">El <xref:System.Numerics.Complex.Sin%2A> método para los números complejos corresponde a la <xref:System.Math.Sin%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="53a23-556">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53a23-557">El <xref:System.Numerics.Complex.Sin%2A> método usa la siguiente fórmula para calcular el seno del número complejo a + bi:</span><span class="sxs-lookup"><span data-stu-id="53a23-557">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="53a23-558">(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="53a23-558">(<xref:System.Math.Sin%2A>(a) * <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) * <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-559">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Sin%2A> método.</span><span class="sxs-lookup"><span data-stu-id="53a23-559">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="53a23-560">Muestra lo que pasa el valor devuelto por la <xref:System.Numerics.Complex.Asin%2A> método a la <xref:System.Numerics.Complex.Sin%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="53a23-560">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-561">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-561">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-562">Devuelve el seno hiperbólico del número complejo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-562">Returns the hyperbolic sine of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-563">Seno hiperbólico de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-563">The hyperbolic sine of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-564">El <xref:System.Numerics.Complex.Sinh%2A> método para los números complejos corresponde a la <xref:System.Math.Sinh%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="53a23-564">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53a23-565">El <xref:System.Numerics.Complex.Sinh%2A> método usa la siguiente fórmula para calcular el seno hiperbólico del número complejo a + bi:</span><span class="sxs-lookup"><span data-stu-id="53a23-565">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="53a23-566">(<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="53a23-566">(<xref:System.Math.Sinh%2A>(a) * <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) * <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-567">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-567">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-568">Devuelve la raíz cuadrada del número complejo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-568">Returns the square root of a specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-569">Raíz cuadrada de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-569">The square root of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-570">La raíz cuadrada del número complejo `value` se calcula mediante la fórmula siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-570">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="53a23-571"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A> / 2.0)</span><span class="sxs-lookup"><span data-stu-id="53a23-571"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="53a23-572">El <xref:System.Numerics.Complex.Sqrt%2A> método para los números complejos corresponde a la <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="53a23-572">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="53a23-573">Valor del que se va a restar (minuendo).</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-573">The value to subtract from (the minuend).</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="53a23-574">Valor que se va a restar (sustraendo).</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-574">The value to subtract (the subtrahend).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-575">Resta un número complejo de otro y devuelve el resultado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-575">Subtracts one complex number from another and returns the result.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-576">Resultado de restar <paramref name="right" /> de <paramref name="left" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-576">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-577">El resultado de restar un número complejo, c + di, de otro número complejo, un + bi, toma la forma siguiente:</span><span class="sxs-lookup"><span data-stu-id="53a23-577">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="53a23-578">(a - c) + (b - d.)</span><span class="sxs-lookup"><span data-stu-id="53a23-578">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="53a23-579">Si la llamada al método produce un desbordamiento en el componente real o imaginario, el valor de ese componente sea <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="53a23-579">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="53a23-580">Los lenguajes que no admiten operadores personalizados pueden usar el <xref:System.Numerics.Complex.Subtract%2A> método para realizar la resta con números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-580">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Subtract%2A> method to perform subtraction using complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-581">El ejemplo siguiente resta cada número complejo en una matriz a partir de un número complejo.</span><span class="sxs-lookup"><span data-stu-id="53a23-581">The following example subtracts each complex number in an array from a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-582">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-582">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-583">Devuelve la tangente del número complejo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-583">Returns the tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-584">Tangente de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-584">The tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-585">El <xref:System.Numerics.Complex.Tan%2A> método para los números complejos corresponde a la <xref:System.Math.Tan%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="53a23-585">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53a23-586">El <xref:System.Numerics.Complex.Tan%2A> método utiliza la siguiente fórmula para calcular la tangente del número complejo `value`:</span><span class="sxs-lookup"><span data-stu-id="53a23-586">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="53a23-587"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="53a23-587"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-588">El ejemplo siguiente ilustra la <xref:System.Numerics.Complex.Tan%2A> método.</span><span class="sxs-lookup"><span data-stu-id="53a23-588">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="53a23-589">Muestra lo que pasa el valor devuelto por la <xref:System.Numerics.Complex.Atan%2A> método a la <xref:System.Numerics.Complex.Tan%2A> devuelve del método original <xref:System.Numerics.Complex> valor.</span><span class="sxs-lookup"><span data-stu-id="53a23-589">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="53a23-590">Número complejo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-590">A complex number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-591">Devuelve la tangente hiperbólica del número complejo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-591">Returns the hyperbolic tangent of the specified complex number.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-592">Tangente hiperbólica de <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-592">The hyperbolic tangent of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-593">El <xref:System.Numerics.Complex.Tanh%2A> método para los números complejos corresponde a la <xref:System.Math.Tanh%2A?displayProperty=nameWithType> método para números reales.</span><span class="sxs-lookup"><span data-stu-id="53a23-593">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="53a23-594">El <xref:System.Numerics.Complex.Tanh%2A> método utiliza la siguiente fórmula para calcular la tangente hiperbólica del número complejo `value`:</span><span class="sxs-lookup"><span data-stu-id="53a23-594">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="53a23-595"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="53a23-595"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="53a23-596">Convierte el valor de un número complejo en su representación de cadena equivalente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-596">Converts the value of a complex number to its equivalent string representation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="53a23-597">Convierte el valor del actual número complejo a su representación de cadena equivalente en formato cartesiano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-597">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-598">Representación de cadena de la instancia actual en formato cartesiano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-598">The string representation of the current instance in Cartesian form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-599">La representación de cadena del valor predeterminado de un número complejo muestra el número usando sus coordenadas cartesianas en el formulario `(` *un* `,` *b*`)`, donde *un* es la parte real del número complejo, y *b* es su parte imaginaria.</span><span class="sxs-lookup"><span data-stu-id="53a23-599">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="53a23-600">Ambos *un* y *b* formateados con el especificador de formato general ("G") y las convenciones de la referencia cultural actual del sistema.</span><span class="sxs-lookup"><span data-stu-id="53a23-600">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-601">El ejemplo siguiente muestra la representación de cadena de varios números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-601">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="53a23-602">La salida usa las convenciones de formato de inglés - referencia cultural de Estados Unidos ("en-US"), que, en este caso, es la referencia cultural actual del sistema.</span><span class="sxs-lookup"><span data-stu-id="53a23-602">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="53a23-603">Objeto que proporciona información de formato específica de la referencia cultural.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-603">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-604">Convierte el valor del actual número complejo a su representación de cadena equivalente en formato cartesiano utilizando la información de formato específica de la referencia cultural indicada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-604">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-605">Representación de cadena de la instancia actual en formato cartesiano, tal como especifica <paramref name="provider" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-605">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-606">La representación de cadena del número complejo que devuelve este método muestra el número usando sus coordenadas cartesianas en el formulario `(` *un* `,` *b*`)`, donde *un* es la parte real del número complejo, y *b* es su parte imaginaria.</span><span class="sxs-lookup"><span data-stu-id="53a23-606">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="53a23-607">Ambos *un* y *b* formateados con el especificador de formato general ("G") y las convenciones de la referencia cultural definida por `provider`.</span><span class="sxs-lookup"><span data-stu-id="53a23-607">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="53a23-608">El `provider` parámetro es un <xref:System.IFormatProvider> implementación.</span><span class="sxs-lookup"><span data-stu-id="53a23-608">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="53a23-609">Su <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información específica de la referencia cultural sobre el formato de los números reales e imaginarios en la cadena devuelta.</span><span class="sxs-lookup"><span data-stu-id="53a23-609">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="53a23-610">Si `provider` es `null`, la cadena devuelta se da formato mediante el <xref:System.Globalization.NumberFormatInfo> objeto de la referencia cultural actual.</span><span class="sxs-lookup"><span data-stu-id="53a23-610">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="53a23-611">El `provider` parámetro puede ser uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="53a23-611">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="53a23-612">Un <xref:System.Globalization.CultureInfo> objeto que representa la referencia cultural que proporciona información de formato</span><span class="sxs-lookup"><span data-stu-id="53a23-612">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="53a23-613">La <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.</span><span class="sxs-lookup"><span data-stu-id="53a23-613">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="53a23-614">Un objeto personalizado que implementa el <xref:System.IFormatProvider> interfaz.</span><span class="sxs-lookup"><span data-stu-id="53a23-614">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="53a23-615">Su <xref:System.IFormatProvider.GetFormat%2A> método devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.</span><span class="sxs-lookup"><span data-stu-id="53a23-615">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-616">El ejemplo siguiente muestra la representación de cadena de varios números complejos.</span><span class="sxs-lookup"><span data-stu-id="53a23-616">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="53a23-617">El resultado usa las convenciones de formato del inglés - Estados Unidos ("en-US") y francés - referencias culturales de Francia ("fr-FR").</span><span class="sxs-lookup"><span data-stu-id="53a23-617">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="53a23-618">Cadena de formato numérico estándar o personalizada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-618">A standard or custom numeric format string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-619">Convierte el valor del actual número complejo a su representación de cadena equivalente en formato cartesiano utilizando el formato especificado para la parte real y la parte imaginaria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-619">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-620">Representación de cadena de la instancia actual en formato cartesiano.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-620">The string representation of the current instance in Cartesian form.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-621">La representación de cadena del número complejo que devuelve este método muestra el número usando sus coordenadas cartesianas en el formulario `(` *un* `,` *b*`)`, donde *un* es la parte real del número complejo, y *b* es su parte imaginaria.</span><span class="sxs-lookup"><span data-stu-id="53a23-621">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="53a23-622">Ambos *un* y *b* tienen el formato especificada por la cadena de formato `format`.</span><span class="sxs-lookup"><span data-stu-id="53a23-622">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="53a23-623">El `format` parámetro puede ser cualquier especificador de formato numérico estándar válido, o cualquier combinación de especificadores de formato numérico personalizado.</span><span class="sxs-lookup"><span data-stu-id="53a23-623">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="53a23-624">Si `format` es igual a <xref:System.String.Empty?displayProperty=nameWithType> o es `null`, se da formato a las partes reales e imaginarias del número complejo con el especificador de formato general ("G").</span><span class="sxs-lookup"><span data-stu-id="53a23-624">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="53a23-625">Si `format` es cualquier otro valor, el método inicia una <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="53a23-625">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="53a23-626">.NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas siguientes:</span><span class="sxs-lookup"><span data-stu-id="53a23-626">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="53a23-627">Para obtener más información acerca de las cadenas de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="53a23-627">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="53a23-628">Para obtener más información sobre el formato de .NET Framework, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="53a23-628">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="53a23-629">El formato de la cadena devuelta viene determinada por la <xref:System.Globalization.NumberFormatInfo> objeto para la referencia cultural actual.</span><span class="sxs-lookup"><span data-stu-id="53a23-629">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="53a23-630">En función de la `format` parámetro, este objeto controla símbolos como el signo negativo, el separador de grupos y el símbolo de separador decimal en la cadena de salida.</span><span class="sxs-lookup"><span data-stu-id="53a23-630">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="53a23-631">Para proporcionar información de formato para las referencias culturales distintas de la referencia cultural actual, llame a la <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> de sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="53a23-631">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-632">El ejemplo siguiente inicializa un número complejo y lo muestra mediante varias cadenas de formato estándar.</span><span class="sxs-lookup"><span data-stu-id="53a23-632">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="53a23-633">
            <paramref name="format" /> no es una cadena de formato válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-633">
              <paramref name="format" /> is not a valid format string.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="53a23-634">Cadena de formato numérico estándar o personalizada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-634">A standard or custom numeric format string.</span>
          </span>
        </param>
        <param name="provider">
          <span data-ttu-id="53a23-635">Objeto que proporciona información de formato específica de la referencia cultural.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-635">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="53a23-636">Convierte el valor del actual número complejo a su representación de cadena equivalente en formato cartesiano utilizando el formato especificado y la información de formato específica de la referencia cultural indicada para la parte real y la parte imaginaria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-636">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="53a23-637">Representación de cadena de la instancia actual en formato cartesiano, tal como especifican <paramref name="format" /> y <paramref name="provider" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-637">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-638">La representación de cadena del número complejo que devuelve este método muestra el número usando sus coordenadas cartesianas en el formulario `(` *un* `,` *b*`)`, donde *un* es la parte real del número complejo, y *b* es su parte imaginaria.</span><span class="sxs-lookup"><span data-stu-id="53a23-638">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="53a23-639">Ambos *un* y *b* tienen el formato especificada por la cadena de formato `format`.</span><span class="sxs-lookup"><span data-stu-id="53a23-639">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="53a23-640">El `format` parámetro puede ser cualquier especificador de formato numérico estándar válido, o cualquier combinación de especificadores de formato numérico personalizado.</span><span class="sxs-lookup"><span data-stu-id="53a23-640">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="53a23-641">Si `format` es igual a <xref:System.String.Empty?displayProperty=nameWithType> o es `null`, se da formato a las partes reales e imaginarias del número complejo con el especificador de formato general ("G").</span><span class="sxs-lookup"><span data-stu-id="53a23-641">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="53a23-642">Si `format` es cualquier otro valor, el método inicia una <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="53a23-642">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="53a23-643">.NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas siguientes:</span><span class="sxs-lookup"><span data-stu-id="53a23-643">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="53a23-644">Para obtener más información acerca de las cadenas de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="53a23-644">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="53a23-645">Para obtener más información sobre el formato de .NET Framework, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="53a23-645">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="53a23-646">El `provider` parámetro es un <xref:System.IFormatProvider> implementación.</span><span class="sxs-lookup"><span data-stu-id="53a23-646">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="53a23-647">Su <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información específica de la referencia cultural sobre el formato de los números reales e imaginarios en la cadena devuelta.</span><span class="sxs-lookup"><span data-stu-id="53a23-647">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="53a23-648">En función de la `format` parámetro, este objeto controla símbolos como el signo negativo, el separador de grupos y el símbolo de separador decimal en la cadena de salida.</span><span class="sxs-lookup"><span data-stu-id="53a23-648">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="53a23-649">Si `provider` es `null`, la cadena devuelta se da formato mediante el <xref:System.Globalization.NumberFormatInfo> objeto de la referencia cultural actual.</span><span class="sxs-lookup"><span data-stu-id="53a23-649">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="53a23-650">El `provider` parámetro puede ser uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="53a23-650">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="53a23-651">Un <xref:System.Globalization.CultureInfo> objeto que representa la referencia cultural que proporciona información de formato</span><span class="sxs-lookup"><span data-stu-id="53a23-651">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="53a23-652">La <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.</span><span class="sxs-lookup"><span data-stu-id="53a23-652">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="53a23-653">Un objeto personalizado que implementa el <xref:System.IFormatProvider> interfaz.</span><span class="sxs-lookup"><span data-stu-id="53a23-653">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="53a23-654">Su <xref:System.IFormatProvider.GetFormat%2A> método devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.</span><span class="sxs-lookup"><span data-stu-id="53a23-654">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-655">En el ejemplo siguiente se crea una matriz de números complejos y muestra cada una con varias cadenas de formato estándar, así como <xref:System.Globalization.CultureInfo> objetos que representan las referencias culturales de inglés - Estados Unidos ("en-US") y Francés - Francia ("fr-FR").</span><span class="sxs-lookup"><span data-stu-id="53a23-655">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="53a23-656">
            <paramref name="format" /> no es una cadena de formato válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-656">
              <paramref name="format" /> is not a valid format string.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="53a23-657">Devuelve una nueva instancia de <see cref="T:System.Numerics.Complex" /> con un número real igual a cero y un número imaginario igual a cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="53a23-657">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53a23-658">El <xref:System.Numerics.Complex.Zero> propiedad se utiliza con más frecuencia para comparar un <xref:System.Numerics.Complex> valor en cero.</span><span class="sxs-lookup"><span data-stu-id="53a23-658">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="53a23-659">El ejemplo siguiente crea un <xref:System.Numerics.Complex> valor utilizando la <xref:System.Numerics.Complex.Zero> propiedad.</span><span class="sxs-lookup"><span data-stu-id="53a23-659">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="53a23-660">A continuación, compara este valor con otro valor que se crea una instancia mediante una llamada a la <xref:System.Numerics.Complex> constructor con una parte real igual a cero y una parte imaginaria igual a cero.</span><span class="sxs-lookup"><span data-stu-id="53a23-660">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="53a23-661">Como se muestra el resultado del ejemplo, los dos valores son iguales.</span><span class="sxs-lookup"><span data-stu-id="53a23-661">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>