<Type Name="ContextItemManager" FullName="System.Activities.Presentation.ContextItemManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d4c008e573670c163370fd256d7a1d503eeac114" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30359629" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ContextItemManager : System.Collections.Generic.IEnumerable&lt;System.Activities.Presentation.ContextItem&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ContextItemManager extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;class System.Activities.Presentation.ContextItem&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Activities.Presentation.ContextItemManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ContextItemManager&#xA;Implements IEnumerable(Of ContextItem)" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContextItemManager abstract : System::Collections::Generic::IEnumerable&lt;System::Activities::Presentation::ContextItem ^&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Activities.Presentation</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Activities.Presentation.ContextItem&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa una clase que mantiene un conjunto de elementos de contexto publicados en el diseñador que edita el contexto. Esta clase es abstracta.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento <xref:System.Activities.Presentation.ContextItem> contenido en la clase <xref:System.Activities.Presentation.ContextItemManager> representa una parte de estado transitorio en una clase <xref:System.Activities.Presentation.WorkflowDesigner>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ContextItemManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Presentation.ContextItemManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ContextItemManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities.Presentation</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Activities.Presentation.ContextItemManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public abstract bool Contains (Type itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(class System.Type itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Presentation.ContextItemManager.Contains(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Contains (itemType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Contains(Type ^ itemType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities.Presentation</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="itemType">Tipo de elemento cuya existencia comprobar.</param>
        <summary>Cuando se invalida en una clase derivada, devuelve un valor que indica si el administrador de elementos contiene un elemento del tipo especificado.</summary>
        <returns>
          <see langword="true" /> si el contexto contiene una instancia del tipo de elemento especificado; de lo contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="itemType" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TItemType&gt;">
      <MemberSignature Language="C#" Value="public bool Contains&lt;TItemType&gt; () where TItemType : System.Activities.Presentation.ContextItem;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains&lt;(class System.Activities.Presentation.ContextItem) TItemType&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Presentation.ContextItemManager.Contains``1" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains(Of TItemType As ContextItem) () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TItemType&gt;&#xA; where TItemType : System::Activities::Presentation::ContextItem bool Contains();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities.Presentation</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TItemType">
          <Constraints>
            <BaseTypeName>System.Activities.Presentation.ContextItem</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TItemType">Tipo de elemento cuya existencia comprobar.</typeparam>
        <summary>Devuelve un valor que indica si el administrador de elementos contiene un elemento del tipo especificado.</summary>
        <returns>
          <see langword="true" /> si el contexto contiene una instancia del tipo de elemento especificado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método genérico invoca el método abstracto <xref:System.Activities.Presentation.ContextItemManager.Contains%2A>, que se debe implementar para que este método proporcione la funcionalidad de comprobación de tipos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IEnumerator&lt;System.Activities.Presentation.ContextItem&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;class System.Activities.Presentation.ContextItem&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Presentation.ContextItemManager.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEnumerator () As IEnumerator(Of ContextItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Collections::Generic::IEnumerator&lt;System::Activities::Presentation::ContextItem ^&gt; ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Activities.Presentation</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Activities.Presentation.ContextItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, enumera los elementos de contexto del contexto de edición. Esta enumeración incluye las capas anteriores a menos que el enumerador encuentre una capa aislada.</summary>
        <returns>Devuelve una interfaz <see cref="T:System.Collections.Generic.IEnumerator`1" />, que contiene una enumeración de elementos de contexto.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTarget">
      <MemberSignature Language="C#" Value="protected static object GetTarget (Delegate callback);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig object GetTarget(class System.Delegate callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Presentation.ContextItemManager.GetTarget(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetTarget (callback As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Object ^ GetTarget(Delegate ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities.Presentation</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="callback">Devolución de llamada del destino deseado.</param>
        <summary>Representa un método auxiliar que devuelve el objeto de destino para un delegado. Si el delegado se creó para actuar como proxy de un delegado genérico, este método devuelve el objeto original, no el proxy.</summary>
        <returns>Devuelve un objeto <see cref="T:System.Object" />, que contiene el objeto de destino de la devolución de llamada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public abstract System.Activities.Presentation.ContextItem GetValue (Type itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Activities.Presentation.ContextItem GetValue(class System.Type itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Presentation.ContextItemManager.GetValue(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValue (itemType As Type) As ContextItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Activities::Presentation::ContextItem ^ GetValue(Type ^ itemType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities.Presentation</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.Presentation.ContextItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="itemType">Tipo de elemento que se va a devolver.</param>
        <summary>Cuando se invalida en una clase derivada, devuelve una instancia del tipo de elemento solicitado. Si no hay ningún elemento de contexto con el tipo dado, se creará un elemento vacío.</summary>
        <returns>Devuelve la clase <see cref="T:System.Activities.Presentation.ContextItem" />, que contiene un elemento de contexto del tipo solicitado. Si no hay ningún elemento en el contexto de este tipo, se crea uno predeterminado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="itemType" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue&lt;TItemType&gt;">
      <MemberSignature Language="C#" Value="public TItemType GetValue&lt;TItemType&gt; () where TItemType : System.Activities.Presentation.ContextItem;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TItemType GetValue&lt;(class System.Activities.Presentation.ContextItem) TItemType&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Presentation.ContextItemManager.GetValue``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue(Of TItemType As ContextItem) () As TItemType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TItemType&gt;&#xA; where TItemType : System::Activities::Presentation::ContextItem TItemType GetValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities.Presentation</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TItemType</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TItemType">
          <Constraints>
            <BaseTypeName>System.Activities.Presentation.ContextItem</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TItemType">Tipo de elemento que se va a devolver.</typeparam>
        <summary>Devuelve una instancia del tipo de elemento solicitado. Si no hay ningún elemento de contexto con el tipo dado, se creará un elemento vacío.</summary>
        <returns>Devuelve la clase <see cref="T:System.Activities.Presentation.ContextItem" />, que contiene un elemento de contexto del tipo solicitado. Si no hay ningún elemento en el contexto de este tipo, se crea uno predeterminado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método genérico invoca el método abstracto <xref:System.Activities.Presentation.ContextItemManager.GetValue%2A>, que se debe implementar para que este método proporcione la funcionalidad de obtención de tipos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyItemChanged">
      <MemberSignature Language="C#" Value="protected static void NotifyItemChanged (System.Activities.Presentation.EditingContext context, System.Activities.Presentation.ContextItem item, System.Activities.Presentation.ContextItem previousItem);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void NotifyItemChanged(class System.Activities.Presentation.EditingContext context, class System.Activities.Presentation.ContextItem item, class System.Activities.Presentation.ContextItem previousItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Presentation.ContextItemManager.NotifyItemChanged(System.Activities.Presentation.EditingContext,System.Activities.Presentation.ContextItem,System.Activities.Presentation.ContextItem)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub NotifyItemChanged (context As EditingContext, item As ContextItem, previousItem As ContextItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void NotifyItemChanged(System::Activities::Presentation::EditingContext ^ context, System::Activities::Presentation::ContextItem ^ item, System::Activities::Presentation::ContextItem ^ previousItem);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities.Presentation</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Activities.Presentation.EditingContext" />
        <Parameter Name="item" Type="System.Activities.Presentation.ContextItem" />
        <Parameter Name="previousItem" Type="System.Activities.Presentation.ContextItem" />
      </Parameters>
      <Docs>
        <param name="context">El objeto <see cref="T:System.Activities.Presentation.EditingContext" /> en uso.</param>
        <param name="item">Nuevo objeto <see cref="T:System.Activities.Presentation.ContextItem" />.</param>
        <param name="previousItem">
          <see cref="T:System.Activities.Presentation.ContextItem" /> anterior.</param>
        <summary>Representa un método auxiliar que invoca el método protegido <see cref="M:System.Activities.Presentation.ContextItem.OnItemChanged(System.Activities.Presentation.EditingContext,System.Activities.Presentation.ContextItem)" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" />, <paramref name="item" /> o <paramref name="previousItem" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveCallback">
      <MemberSignature Language="C#" Value="protected static Delegate RemoveCallback (Delegate existing, Delegate toRemove);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Delegate RemoveCallback(class System.Delegate existing, class System.Delegate toRemove) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Presentation.ContextItemManager.RemoveCallback(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function RemoveCallback (existing As Delegate, toRemove As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static Delegate ^ RemoveCallback(Delegate ^ existing, Delegate ^ toRemove);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities.Presentation</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="existing" Type="System.Delegate" />
        <Parameter Name="toRemove" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="existing">Delegado existente.</param>
        <param name="toRemove">Delegado que se va a quitar de <c>existing</c>.</param>
        <summary>Representa un método auxiliar que realiza eliminaciones de delegados y que desencapsula los delegados que actúan como proxy para las devoluciones de llamada genéricas.</summary>
        <returns>Devuelve un objeto <see cref="T:System.Delegate" />, que contiene el nuevo delegado que se debe asignar a <paramref name="existing" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método en sus implementaciones del método <xref:System.Activities.Presentation.ContextItemManager.Unsubscribe%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public abstract void SetValue (System.Activities.Presentation.ContextItem value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(class System.Activities.Presentation.ContextItem value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Presentation.ContextItemManager.SetValue(System.Activities.Presentation.ContextItem)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub SetValue (value As ContextItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetValue(System::Activities::Presentation::ContextItem ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities.Presentation</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Activities.Presentation.ContextItem" />
      </Parameters>
      <Docs>
        <param name="value">Valor que establecer en el objeto <see cref="T:System.Activities.Presentation.ContextItem" />.</param>
        <summary>Cuando se invalida en una clase derivada, establece un elemento de contexto en el valor especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No pase un `null` valor. Para establecer un objeto <xref:System.Activities.Presentation.ContextItem> en un valor vacío, cree una instancia del elemento utilizando un constructor predeterminado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subscribe">
      <MemberSignature Language="C#" Value="public abstract void Subscribe (Type contextItemType, System.Activities.Presentation.SubscribeContextCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Subscribe(class System.Type contextItemType, class System.Activities.Presentation.SubscribeContextCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Presentation.ContextItemManager.Subscribe(System.Type,System.Activities.Presentation.SubscribeContextCallback)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Subscribe (contextItemType As Type, callback As SubscribeContextCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Subscribe(Type ^ contextItemType, System::Activities::Presentation::SubscribeContextCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities.Presentation</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contextItemType" Type="System.Type" />
        <Parameter Name="callback" Type="System.Activities.Presentation.SubscribeContextCallback" />
      </Parameters>
      <Docs>
        <param name="contextItemType">El tipo de elemento al que se desea suscribir.</param>
        <param name="callback">
          <see cref="T:System.Activities.Presentation.SubscribeContextCallback" /> que se invoca cuando <c>contextItemType</c> cambia.</param>
        <summary>Cuando se invalida en una clase derivada, agrega una devolución de llamada de evento que se invoca cuando cambia un elemento de contexto del tipo de elemento especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="contextItemType" /> o <paramref name="callback" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subscribe&lt;TContextItemType&gt;">
      <MemberSignature Language="C#" Value="public void Subscribe&lt;TContextItemType&gt; (System.Activities.Presentation.SubscribeContextCallback&lt;TContextItemType&gt; callback) where TContextItemType : System.Activities.Presentation.ContextItem;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Subscribe&lt;(class System.Activities.Presentation.ContextItem) TContextItemType&gt;(class System.Activities.Presentation.SubscribeContextCallback`1&lt;!!TContextItemType&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Presentation.ContextItemManager.Subscribe``1(System.Activities.Presentation.SubscribeContextCallback{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Subscribe(Of TContextItemType As ContextItem) (callback As SubscribeContextCallback(Of TContextItemType))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TContextItemType&gt;&#xA; where TContextItemType : System::Activities::Presentation::ContextItem void Subscribe(System::Activities::Presentation::SubscribeContextCallback&lt;TContextItemType&gt; ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities.Presentation</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TContextItemType">
          <Constraints>
            <BaseTypeName>System.Activities.Presentation.ContextItem</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Activities.Presentation.SubscribeContextCallback&lt;TContextItemType&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TContextItemType">El tipo de elemento al que se desea suscribir.</typeparam>
        <param name="callback">
          <see cref="T:System.Activities.Presentation.SubscribeContextCallback`1" /> que se invoca cuando <c>contextItemType</c> cambia.</param>
        <summary>Agrega una devolución de llamada de evento que se invoca cuando cambia un elemento de contexto del tipo de elemento especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="contextItemType" /> o <paramref name="callback" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Presentation.ContextItemManager.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Activities.Presentation</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enumera los elementos de contexto en el contexto de edición.</summary>
        <returns>Devuelve <see cref="T:System.Collections.IEnumerator" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unsubscribe">
      <MemberSignature Language="C#" Value="public abstract void Unsubscribe (Type contextItemType, System.Activities.Presentation.SubscribeContextCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unsubscribe(class System.Type contextItemType, class System.Activities.Presentation.SubscribeContextCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Presentation.ContextItemManager.Unsubscribe(System.Type,System.Activities.Presentation.SubscribeContextCallback)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Unsubscribe (contextItemType As Type, callback As SubscribeContextCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Unsubscribe(Type ^ contextItemType, System::Activities::Presentation::SubscribeContextCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities.Presentation</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contextItemType" Type="System.Type" />
        <Parameter Name="callback" Type="System.Activities.Presentation.SubscribeContextCallback" />
      </Parameters>
      <Docs>
        <param name="contextItemType">El tipo de elemento de contexto del que se va a quitar la devolución de llamada.</param>
        <param name="callback">
          <see cref="T:System.Activities.Presentation.SubscribeContextCallback" /> que se va a quitar.</param>
        <summary>Cuando se invalida en una clase derivada, quita una suscripción.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unsubscribe&lt;TContextItemType&gt;">
      <MemberSignature Language="C#" Value="public void Unsubscribe&lt;TContextItemType&gt; (System.Activities.Presentation.SubscribeContextCallback&lt;TContextItemType&gt; callback) where TContextItemType : System.Activities.Presentation.ContextItem;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unsubscribe&lt;(class System.Activities.Presentation.ContextItem) TContextItemType&gt;(class System.Activities.Presentation.SubscribeContextCallback`1&lt;!!TContextItemType&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.Presentation.ContextItemManager.Unsubscribe``1(System.Activities.Presentation.SubscribeContextCallback{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unsubscribe(Of TContextItemType As ContextItem) (callback As SubscribeContextCallback(Of TContextItemType))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TContextItemType&gt;&#xA; where TContextItemType : System::Activities::Presentation::ContextItem void Unsubscribe(System::Activities::Presentation::SubscribeContextCallback&lt;TContextItemType&gt; ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities.Presentation</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TContextItemType">
          <Constraints>
            <BaseTypeName>System.Activities.Presentation.ContextItem</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Activities.Presentation.SubscribeContextCallback&lt;TContextItemType&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TContextItemType">El tipo de elemento de contexto del que se va a quitar la devolución de llamada.</typeparam>
        <param name="callback">
          <see cref="T:System.Activities.Presentation.SubscribeContextCallback`1" /> que se va a quitar.</param>
        <summary>Quita una suscripción.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callback" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>