<Type Name="Extensions" FullName="System.Xml.XPath.Extensions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="76b5c29266c0ff6b3da3581b1516c39a36e5729a" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="08/25/2018" /><Meta Name="ms.locfileid" Value="39916557" /></Metadata><TypeSignature Language="C#" Value="public static class Extensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Extensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XPath.Extensions" />
  <TypeSignature Language="VB.NET" Value="Public Module Extensions" />
  <TypeSignature Language="C++ CLI" Value="public ref class Extensions abstract sealed" />
  <TypeSignature Language="F#" Value="type Extensions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Esta clase contiene los métodos de extensión de LINQ to XML que le permiten evaluar las expresiones XPath.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hay una disminución del rendimiento para el uso de estos métodos. Uso de [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] produce un mejor rendimiento de consultas.  
  
 Aunque no se especifica el orden de las colecciones devueltas en la recomendación de XML XPath Language 1.0, este método de extensión devuelve nodos en orden del documento.  
  
 Tenga en cuenta que se devuelven nodos en orden del documento, incluso cuando se usa como un eje inverso, `preceding-sibling` o `ancestor-or-self`.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateNavigator">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un objeto <see cref="T:System.Xml.XPath.XPathNavigator" /> para <see cref="T:System.Xml.Linq.XNode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No puede modificar el árbol XML mediante el <xref:System.Xml.XPath.XPathNavigator> devuelto por este método. La propiedad <xref:System.Xml.XPath.XPathNavigator.CanEdit%2A> devuelve `false`.  
  
 No puede crear un <xref:System.Xml.XPath.XPathNavigator> para un <xref:System.Xml.Linq.XDocumentType> nodo. Tipos de documento no participan en el modelo de datos XPath.  
  
 Las declaraciones de Namespace se informa de izquierda a derecha. En cambio, para <xref:System.Xml.XmlDocument> se notifican los espacios de nombres de derecha a izquierda. Se trata de un comportamiento compatible porque no se ordenan las declaraciones de espacio de nombres en el modelo de datos XPath.  
  
 El método <xref:System.Xml.XPath.XPathNavigator.MoveToId%2A> no se admite para los navegadores que devuelven este método.  
  
 Puede usar este método para realizar una transformación XSLT. Puede crear un árbol XML, crear un <xref:System.Xml.XPath.XPathNavigator> desde el árbol XML, crear un nuevo documento y crear un <xref:System.Xml.XmlWriter> que escribirá en el nuevo documento. A continuación, puede invocar la transformación XSLT y pasar <xref:System.Xml.XPath.XPathNavigator> y <xref:System.Xml.XmlWriter> a la transformación. Después de que se complete correctamente la transformación, se rellenará el nuevo árbol XML con los resultados de la transformación.  
  
 Para llevar a cabo una transformación XSLT, puede usar un <xref:System.Xml.XmlReader> o <xref:System.Xml.XPath.XPathNavigator>. Los dos enfoques tienen distintas características de rendimiento. Algunas transformaciones se ejecutarán más rápido cuando se usa un <xref:System.Xml.XmlReader>, y otros se ejecutarán más rápido cuando se usa un <xref:System.Xml.XPath.XPathNavigator>. Si el rendimiento es un problema, se recomienda que experimente con cada enfoque para determinar lo que funcionará mejor en sus circunstancias.  
  
```csharp  
  
            string xslMarkup = @"<?xml version='1.0'?>  
<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
    <xsl:template match='/Parent'>  
        <Root>  
            <C1><xsl:value-of select='Child1'/></C1>  
            <C2><xsl:value-of select='Child2'/></C2>  
        </Root>  
    </xsl:template>  
</xsl:stylesheet>";  
  
XDocument xmlTree = new XDocument(  
    new XElement("Parent",  
        new XElement("Child1", "Child1 data"),  
        new XElement("Child2", "Child2 data")  
    )  
);  
  
XDocument newTree = new XDocument();  
using (XmlWriter writer = newTree.CreateWriter()) {  
    // Load the style sheet.  
    XslCompiledTransform xslt = new XslCompiledTransform();  
    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  
  
    // Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer);  
}  
  
Console.WriteLine(newTree);  
```  
  
```vb  
  
            Dim xslMarkup As XDocument = <?xml version='1.0'?>  
                             <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
                                 <xsl:template match='/Parent'>  
                                     <Root>  
                                         <C1><xsl:value-of select='Child1'/></C1>  
                                         <C2><xsl:value-of select='Child2'/></C2>  
                                     </Root>  
                                 </xsl:template>  
                             </xsl:stylesheet>  
  
Dim xmlTree As XDocument = <?xml version='1.0'?>  
                           <Parent>  
                               <Child1>Child1 data</Child1>  
                               <Child2>Child2 data</Child2>  
                           </Parent>  
  
Dim newTree As XDocument = New XDocument()  
  
Using writer As XmlWriter = newTree.CreateWriter()  
    ' Load the style sheet.  
    Dim xslt As XslCompiledTransform = _  
        New XslCompiledTransform()  
    xslt.Load(xslMarkup.CreateReader())  
  
    ' Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer)  
End Using  
  
Console.WriteLine(newTree)  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```xml  
  
            <Root>  
  <C1>Child1 data</C1>  
  <C2>Child2 data</C2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public static System.Xml.XPath.XPathNavigator CreateNavigator (this System.Xml.Linq.XNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.Linq.XNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.CreateNavigator(System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateNavigator (node As XNode) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::Linq::XNode ^ node);" />
      <MemberSignature Language="F#" Value="static member CreateNavigator : System.Xml.Linq.XNode -&gt; System.Xml.XPath.XPathNavigator" Usage="System.Xml.XPath.Extensions.CreateNavigator node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
      </Parameters>
      <Docs>
        <param name="node"><see cref="T:System.Xml.Linq.XNode" /> que puede procesar consultas XPath.</param>
        <summary>Crea un objeto <see cref="T:System.Xml.XPath.XPathNavigator" /> para <see cref="T:System.Xml.Linq.XNode" />.</summary>
        <returns><see cref="T:System.Xml.XPath.XPathNavigator" /> que puede procesar consultas XPath.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No puede modificar el árbol XML mediante el <xref:System.Xml.XPath.XPathNavigator> devuelto por este método. La propiedad <xref:System.Xml.XPath.XPathNavigator.CanEdit%2A> devuelve `false`.  
  
 No puede crear un <xref:System.Xml.XPath.XPathNavigator> para un <xref:System.Xml.Linq.XDocumentType> nodo. Tipos de documento no participan en el modelo de datos XPath.  
  
 Las declaraciones de Namespace se informa de izquierda a derecha. En cambio, para <xref:System.Xml.XmlDocument> se notifican los espacios de nombres de derecha a izquierda. Se trata de un comportamiento compatible porque no se ordenan las declaraciones de espacio de nombres en el modelo de datos XPath.  
  
 El método <xref:System.Xml.XPath.XPathNavigator.MoveToId%2A> no se admite para los navegadores que devuelven este método.  
  
 Puede usar este método para realizar una transformación XSLT. Puede crear un árbol XML, crear un <xref:System.Xml.XPath.XPathNavigator> desde el árbol XML, crear un nuevo documento y crear un <xref:System.Xml.XmlWriter> que escribirá en el nuevo documento. A continuación, puede invocar la transformación XSLT, pasando el <xref:System.Xml.XPath.XPathNavigator> y <xref:System.Xml.XmlWriter> a la transformación. Después de que se complete correctamente la transformación, se rellenará el nuevo árbol XML con los resultados de la transformación.  
  
 Para llevar a cabo una transformación XSLT, puede usar un <xref:System.Xml.XmlReader> o <xref:System.Xml.XPath.XPathNavigator>. Los dos enfoques tienen distintas características de rendimiento. Algunas transformaciones se ejecutarán más rápido cuando se usa un <xref:System.Xml.XmlReader>, y otros se ejecutarán más rápido cuando se usa un <xref:System.Xml.XPath.XPathNavigator>. Si el rendimiento es un problema, se recomienda que experimente con cada enfoque para determinar lo que funcionará mejor en sus circunstancias.  
  
   
  
## Examples  
  
```csharp  
  
                string xslMarkup = @"<?xml version='1.0'?>  
<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
    <xsl:template match='/Parent'>  
        <Root>  
            <C1><xsl:value-of select='Child1'/></C1>  
            <C2><xsl:value-of select='Child2'/></C2>  
        </Root>  
    </xsl:template>  
</xsl:stylesheet>";  
  
XDocument xmlTree = new XDocument(  
    new XElement("Parent",  
        new XElement("Child1", "Child1 data"),  
        new XElement("Child2", "Child2 data")  
    )  
);  
  
XDocument newTree = new XDocument();  
using (XmlWriter writer = newTree.CreateWriter()) {  
    // Load the style sheet.  
    XslCompiledTransform xslt = new XslCompiledTransform();  
    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  
  
    // Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer);  
}  
  
Console.WriteLine(newTree);  
```  
  
```vb  
  
                Dim xslMarkup As XDocument = _  
    <?xml version='1.0'?>  
    <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
        <xsl:template match='/Parent'>  
            <Root>  
                <C1><xsl:value-of select='Child1'/></C1>  
                <C2><xsl:value-of select='Child2'/></C2>  
            </Root>  
        </xsl:template>  
    </xsl:stylesheet>  
  
Dim xmlTree As XDocument = _  
    <?xml version='1.0'?>  
    <Parent>  
        <Child1>Child1 data</Child1>  
        <Child2>Child2 data</Child2>  
    </Parent>  
  
Dim newTree As XDocument = New XDocument()  
  
Using writer As XmlWriter = newTree.CreateWriter()  
    ' Load the style sheet.  
    Dim xslt As XslCompiledTransform = _  
        New XslCompiledTransform()  
    xslt.Load(xslMarkup.CreateReader())  
  
    ' Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateNavigator(), writer)  
End Using  
  
Console.WriteLine(newTree)  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```xml  
  
                <Root>  
  <C1>Child1 data</C1>  
  <C2>Child2 data</C2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public static System.Xml.XPath.XPathNavigator CreateNavigator (this System.Xml.Linq.XNode node, System.Xml.XmlNameTable nameTable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.Linq.XNode node, class System.Xml.XmlNameTable nameTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.CreateNavigator(System.Xml.Linq.XNode,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function CreateNavigator (node As XNode, nameTable As XmlNameTable) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::Linq::XNode ^ node, System::Xml::XmlNameTable ^ nameTable);" />
      <MemberSignature Language="F#" Value="static member CreateNavigator : System.Xml.Linq.XNode * System.Xml.XmlNameTable -&gt; System.Xml.XPath.XPathNavigator" Usage="System.Xml.XPath.Extensions.CreateNavigator (node, nameTable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="nameTable" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="node"><see cref="T:System.Xml.Linq.XNode" /> que procesa consultas XPath.</param>
        <param name="nameTable">Objeto <see cref="T:System.Xml.XmlNameTable" /> que se va a utilizar en <see cref="T:System.Xml.XPath.XPathNavigator" />.</param>
        <summary>Crea un objeto <see cref="T:System.Xml.XPath.XPathNavigator" /> para <see cref="T:System.Xml.Linq.XNode" />. <see cref="T:System.Xml.XmlNameTable" /> permite un procesamiento más eficaz de la expresión XPath.</summary>
        <returns><see cref="T:System.Xml.XPath.XPathNavigator" /> que puede procesar consultas XPath.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se puede editar el árbol XML mediante el <xref:System.Xml.XPath.XPathNavigator> devuelto por este método. La propiedad <xref:System.Xml.XPath.XPathNavigator.CanEdit%2A> devuelve `false`.  
  
 No puede crear un <xref:System.Xml.XPath.XPathNavigator> para un <xref:System.Xml.Linq.XDocumentType> nodo. Tipos de documento no participan en el modelo de datos XPath.  
  
 Las declaraciones de Namespace se informa de izquierda a derecha. En cambio, para <xref:System.Xml.XmlDocument> se notifican los espacios de nombres de derecha a izquierda. Se trata de un comportamiento compatible porque no se ordenan las declaraciones de espacio de nombres en el modelo de datos XPath.  
  
 El método <xref:System.Xml.XPath.XPathNavigator.MoveToId%2A> no se admite para los navegadores que devuelven este método.  
  
 Si usa un <xref:System.Xml.XmlNameTable> con este método para crear el <xref:System.Xml.XPath.XPathNavigator>, obtendrá un mejor rendimiento al evaluar expresiones XPath.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="XPathEvaluate">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Evalúa una expresión XPath.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque no se especifica el orden de las colecciones devueltas en la recomendación de XML XPath Language 1.0, este método de extensión devuelve nodos en orden del documento.  
  
 Tenga en cuenta que se devuelven nodos en orden del documento, incluso cuando se usa como un eje inverso, `preceding-sibling` o `ancestor-or-self`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="XPathEvaluate">
      <MemberSignature Language="C#" Value="public static object XPathEvaluate (this System.Xml.Linq.XNode node, string expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object XPathEvaluate(class System.Xml.Linq.XNode node, string expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathEvaluate(System.Xml.Linq.XNode,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathEvaluate (node As XNode, expression As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Object ^ XPathEvaluate(System::Xml::Linq::XNode ^ node, System::String ^ expression);" />
      <MemberSignature Language="F#" Value="static member XPathEvaluate : System.Xml.Linq.XNode * string -&gt; obj" Usage="System.Xml.XPath.Extensions.XPathEvaluate (node, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="node"><see cref="T:System.Xml.Linq.XNode" /> en el que se va a evaluar la expresión XPath.</param>
        <param name="expression"><see cref="T:System.String" /> que contiene una expresión XPath.</param>
        <summary>Evalúa una expresión XPath.</summary>
        <returns>Objeto que puede contener un valor <see langword="bool" />,  <see langword="double" />,  <see langword="string" /> o <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la colección es una enumeración de elementos o atributos, puede usar el `Cast` operador para obtener una colección de <xref:System.Xml.Linq.XElement> o <xref:System.Xml.Linq.XAttribute>.  
  
 Aunque no se especifica el orden de las colecciones devueltas en la recomendación de XML XPath Language 1.0, este método de extensión devuelve nodos en orden del documento.  
  
 Tenga en cuenta que se devuelven nodos en orden del documento, incluso cuando se usa como un eje inverso, `preceding-sibling` o `ancestor-or-self`.  
  
   
  
## Examples  
 El ejemplo siguiente se crea un árbol XML pequeño con un atributo, a continuación, usa el <xref:System.Xml.XPath.Extensions.XPathEvaluate%2A> método para recuperar el atributo.  
  
```csharp  
  
                String xml = "<root a='value'/>";  
XDocument d = XDocument.Parse(xml);  
IEnumerable att = (IEnumerable)d.XPathEvaluate("/root/@a");  
Console.WriteLine(att.Cast<XAttribute>().FirstOrDefault());  
```  
  
```vb  
  
                Dim d As XDocument = _  
    <?xml version='1.0'?>  
    <root a='value'/>  
Dim att As IEnumerable = CType(d.XPathEvaluate("/root/@a"), IEnumerable)  
Console.WriteLine(att.Cast(Of XAttribute)().FirstOrDefault())  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
a="value"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XPathEvaluate">
      <MemberSignature Language="C#" Value="public static object XPathEvaluate (this System.Xml.Linq.XNode node, string expression, System.Xml.IXmlNamespaceResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object XPathEvaluate(class System.Xml.Linq.XNode node, string expression, class System.Xml.IXmlNamespaceResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathEvaluate(System.Xml.Linq.XNode,System.String,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathEvaluate (node As XNode, expression As String, resolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Object ^ XPathEvaluate(System::Xml::Linq::XNode ^ node, System::String ^ expression, System::Xml::IXmlNamespaceResolver ^ resolver);" />
      <MemberSignature Language="F#" Value="static member XPathEvaluate : System.Xml.Linq.XNode * string * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="System.Xml.XPath.Extensions.XPathEvaluate (node, expression, resolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="resolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="node"><see cref="T:System.Xml.Linq.XNode" /> en el que se va a evaluar la expresión XPath.</param>
        <param name="expression"><see cref="T:System.String" /> que contiene una expresión XPath.</param>
        <param name="resolver"><see cref="T:System.Xml.IXmlNamespaceResolver" /> para los prefijos de espacio de nombres de la expresión XPath.</param>
        <summary>Evalúa una expresión XPath, resolviendo los prefijos de espacio de nombres mediante el <see cref="T:System.Xml.IXmlNamespaceResolver" /> especificado.</summary>
        <returns>Objeto que contiene el resultado de evaluar la expresión. El objeto puede ser <see langword="bool" />, <see langword="double" />, <see langword="string" /> o <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar este método para evaluar expresiones XPath que contienen los prefijos de espacio de nombres.  
  
 Aunque no se especifica el orden de las colecciones devueltas en la recomendación de XML XPath Language 1.0, este método de extensión devuelve nodos en orden del documento.  
  
 Tenga en cuenta que se devuelven nodos en orden del documento, incluso cuando se usa como un eje inverso, `preceding-sibling` o `ancestor-or-self`.  
  
   
  
## Examples  
 El ejemplo siguiente crea un árbol XML que contiene un espacio de nombres. Usa un objeto <xref:System.Xml.XmlReader> para leer el documento XML. Después obtiene un objeto <xref:System.Xml.XmlNameTable> de <xref:System.Xml.XmlReader> y un objeto <xref:System.Xml.XmlNamespaceManager> de <xref:System.Xml.XmlNameTable>. Usa el <xref:System.Xml.XmlNamespaceManager> al seleccionar un elemento.  
  
```csharp  
  
                string markup =  
@"<aw:Root xmlns:aw='http://www.adventure-works.com'>  
    <aw:Child1 aw:Att='attdata'>child one data 1</aw:Child1>  
</aw:Root>";  
XmlReader reader = XmlReader.Create(new StringReader(markup));  
XElement root = XElement.Load(reader);  
XmlNameTable nameTable = reader.NameTable;  
XmlNamespaceManager namespaceManager = new XmlNamespaceManager(nameTable);  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com");  
IEnumerable atts = (IEnumerable)root.XPathEvaluate("./aw:Child1/@aw:Att", namespaceManager);  
IEnumerable<XAttribute> attList = atts.Cast<XAttribute>();  
XAttribute att = attList.First();  
Console.WriteLine(att);  
```  
  
```vb  
  
                Dim markup As XElement = _  
    <aw:Root xmlns:aw='http://www.adventure-works.com'>  
        <aw:Child1 aw:Att='attdata'>child one data 1</aw:Child1>  
    </aw:Root>  
Dim reader As XmlReader = markup.CreateReader  
Dim nameTable As XmlNameTable = reader.NameTable  
Dim namespaceManager As XmlNamespaceManager = New XmlNamespaceManager(nameTable)  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com")  
Dim atts As IEnumerable = CType(markup.XPathEvaluate("./aw:Child1/@aw:Att", namespaceManager), IEnumerable)  
Dim attList As IEnumerable(Of XAttribute) = atts.Cast(Of XAttribute)()  
Dim att As XAttribute = attList.First()  
Console.WriteLine(att)  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
aw:Att="attdata"  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="XPathSelectElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Selecciona un objeto <see cref="T:System.Xml.Linq.XElement" /> mediante una expresión XPath.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="XPathSelectElement">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement XPathSelectElement (this System.Xml.Linq.XNode node, string expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement XPathSelectElement(class System.Xml.Linq.XNode node, string expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElement(System.Xml.Linq.XNode,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElement (node As XNode, expression As String) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::Linq::XElement ^ XPathSelectElement(System::Xml::Linq::XNode ^ node, System::String ^ expression);" />
      <MemberSignature Language="F#" Value="static member XPathSelectElement : System.Xml.Linq.XNode * string -&gt; System.Xml.Linq.XElement" Usage="System.Xml.XPath.Extensions.XPathSelectElement (node, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="node"><see cref="T:System.Xml.Linq.XNode" /> en el que se va a evaluar la expresión XPath.</param>
        <param name="expression"><see cref="T:System.String" /> que contiene una expresión XPath.</param>
        <summary>Selecciona un objeto <see cref="T:System.Xml.Linq.XElement" /> mediante una expresión XPath.</summary>
        <returns><see cref="T:System.Xml.Linq.XElement" /> o null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se crea un árbol XML pequeño y usa <xref:System.Xml.XPath.Extensions.XPathSelectElement%2A> para seleccionar un único elemento.  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    new XElement("Child6", 6)  
);  
XElement el = root.XPathSelectElement("./Child4");  
Console.WriteLine(el);  
```  
  
```vb  
  
                Dim root As XElement = _  
    <Root>  
        <Child1>1</Child1>  
        <Child2>2</Child2>  
        <Child3>3</Child3>  
        <Child4>4</Child4>  
        <Child5>5</Child5>  
        <Child6>6</Child6>  
    </Root>  
Dim el As XElement = root.XPathSelectElement("./Child4")  
Console.WriteLine(el)  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```xml  
<Child4>4</Child4>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XPathSelectElement">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XElement XPathSelectElement (this System.Xml.Linq.XNode node, string expression, System.Xml.IXmlNamespaceResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XElement XPathSelectElement(class System.Xml.Linq.XNode node, string expression, class System.Xml.IXmlNamespaceResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElement(System.Xml.Linq.XNode,System.String,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElement (node As XNode, expression As String, resolver As IXmlNamespaceResolver) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Xml::Linq::XElement ^ XPathSelectElement(System::Xml::Linq::XNode ^ node, System::String ^ expression, System::Xml::IXmlNamespaceResolver ^ resolver);" />
      <MemberSignature Language="F#" Value="static member XPathSelectElement : System.Xml.Linq.XNode * string * System.Xml.IXmlNamespaceResolver -&gt; System.Xml.Linq.XElement" Usage="System.Xml.XPath.Extensions.XPathSelectElement (node, expression, resolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="resolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="node"><see cref="T:System.Xml.Linq.XNode" /> en el que se va a evaluar la expresión XPath.</param>
        <param name="expression"><see cref="T:System.String" /> que contiene una expresión XPath.</param>
        <param name="resolver"><see cref="T:System.Xml.IXmlNamespaceResolver" /> para los prefijos de espacio de nombres de la expresión XPath.</param>
        <summary>Selecciona un <see cref="T:System.Xml.Linq.XElement" /> utilizando una expresión XPath, que resuelve los prefijos de espacio de nombres mediante el <see cref="T:System.Xml.IXmlNamespaceResolver" /> especificado.</summary>
        <returns><see cref="T:System.Xml.Linq.XElement" /> o null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar este método para evaluar expresiones XPath que contienen los prefijos de espacio de nombres.  
  
   
  
## Examples  
 El ejemplo siguiente crea un árbol XML que contiene un espacio de nombres. Usa un objeto <xref:System.Xml.XmlReader> para leer el documento XML. Después obtiene un objeto <xref:System.Xml.XmlNameTable> de <xref:System.Xml.XmlReader> y un objeto <xref:System.Xml.XmlNamespaceManager> de <xref:System.Xml.XmlNameTable>. Usa el <xref:System.Xml.XmlNamespaceManager> al seleccionar un elemento.  
  
```csharp  
  
                string markup = @"  
<aw:Root xmlns:aw='http://www.adventure-works.com'>  
    <aw:Child1>child one data</aw:Child1>  
    <aw:Child2>child two data</aw:Child2>  
</aw:Root>";  
XmlReader reader = XmlReader.Create(new StringReader(markup));  
XElement root = XElement.Load(reader);  
XmlNameTable nameTable = reader.NameTable;  
XmlNamespaceManager namespaceManager = new XmlNamespaceManager(nameTable);  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com");  
XElement child1 = root.XPathSelectElement("./aw:Child1", namespaceManager);  
Console.WriteLine(child1);  
```  
  
```vb  
  
                Dim markup As XElement = _  
    <aw:Root xmlns:aw='http://www.adventure-works.com'>  
        <aw:Child1>child one data</aw:Child1>  
        <aw:Child2>child two data</aw:Child2>  
    </aw:Root>  
Dim reader As XmlReader = markup.CreateReader  
Dim nameTable As XmlNameTable = reader.NameTable  
Dim namespaceManager As XmlNamespaceManager = New XmlNamespaceManager(nameTable)  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com")  
Dim child1 As XElement = markup.XPathSelectElement("./aw:Child1", namespaceManager)  
Console.WriteLine(child1)  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data</aw:Child1>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="XPathSelectElements">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Selecciona una colección de elementos mediante una expresión XPath.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque no se especifica el orden de las colecciones devueltas en la recomendación de XML XPath Language 1.0, este método de extensión devuelve nodos en orden del documento.  
  
 Tenga en cuenta que se devuelven nodos en orden del documento, incluso cuando se usa como un eje inverso, `preceding-sibling` o `ancestor-or-self`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="XPathSelectElements">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; XPathSelectElements (this System.Xml.Linq.XNode node, string expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; XPathSelectElements(class System.Xml.Linq.XNode node, string expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElements(System.Xml.Linq.XNode,System.String)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElements (node As XNode, expression As String) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ XPathSelectElements(System::Xml::Linq::XNode ^ node, System::String ^ expression);" />
      <MemberSignature Language="F#" Value="static member XPathSelectElements : System.Xml.Linq.XNode * string -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="System.Xml.XPath.Extensions.XPathSelectElements (node, expression)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="node"><see cref="T:System.Xml.Linq.XNode" /> en el que se va a evaluar la expresión XPath.</param>
        <param name="expression"><see cref="T:System.String" /> que contiene una expresión XPath.</param>
        <summary>Selecciona una colección de elementos mediante una expresión XPath.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" /> de <see cref="T:System.Xml.Linq.XElement" /> que contiene los elementos seleccionados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque no se especifica el orden de las colecciones devueltas en la recomendación de XML XPath Language 1.0, este método de extensión devuelve nodos en orden del documento.  
  
 Tenga en cuenta que se devuelven nodos en orden del documento, incluso cuando se usa como un eje inverso, `preceding-sibling` o `ancestor-or-self`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un árbol XML pequeño y se utiliza <xref:System.Xml.XPath.Extensions.XPathSelectElements%2A> para seleccionar un conjunto de elementos.  
  
```csharp  
  
                XElement root = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child1", 2),  
    new XElement("Child1", 3),  
    new XElement("Child2", 4),  
    new XElement("Child2", 5),  
    new XElement("Child2", 6)  
);  
IEnumerable<XElement> list = root.XPathSelectElements("./Child2");  
foreach (XElement el in list)  
    Console.WriteLine(el);  
```  
  
```vb  
  
                Dim root As XElement = _  
    <Root>  
        <Child1>1</Child1>  
        <Child1>2</Child1>  
        <Child1>3</Child1>  
        <Child2>4</Child2>  
        <Child2>5</Child2>  
        <Child2>6</Child2>  
    </Root>  
Dim list As IEnumerable(Of XElement) = root.XPathSelectElements("./Child2")  
For Each el As XElement In list  
    Console.WriteLine(el)  
Next  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```xml  
<Child2>4</Child2>  
<Child2>5</Child2>  
<Child2>6</Child2>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XPathSelectElements">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; XPathSelectElements (this System.Xml.Linq.XNode node, string expression, System.Xml.IXmlNamespaceResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; XPathSelectElements(class System.Xml.Linq.XNode node, string expression, class System.Xml.IXmlNamespaceResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XPath.Extensions.XPathSelectElements(System.Xml.Linq.XNode,System.String,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function XPathSelectElements (node As XNode, expression As String, resolver As IXmlNamespaceResolver) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ XPathSelectElements(System::Xml::Linq::XNode ^ node, System::String ^ expression, System::Xml::IXmlNamespaceResolver ^ resolver);" />
      <MemberSignature Language="F#" Value="static member XPathSelectElements : System.Xml.Linq.XNode * string * System.Xml.IXmlNamespaceResolver -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="System.Xml.XPath.Extensions.XPathSelectElements (node, expression, resolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XPath.XDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" RefType="this" />
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="resolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="node"><see cref="T:System.Xml.Linq.XNode" /> en el que se va a evaluar la expresión XPath.</param>
        <param name="expression"><see cref="T:System.String" /> que contiene una expresión XPath.</param>
        <param name="resolver"><see cref="T:System.Xml.IXmlNamespaceResolver" /> para los prefijos de espacio de nombres de la expresión XPath.</param>
        <summary>Selecciona una colección de elementos utilizando una expresión XPath, que resuelve los prefijos de espacio de nombres mediante el <see cref="T:System.Xml.IXmlNamespaceResolver" /> especificado.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" /> de <see cref="T:System.Xml.Linq.XElement" /> que contiene los elementos seleccionados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar este método para evaluar expresiones XPath que contienen los prefijos de espacio de nombres.  
  
 Aunque no se especifica el orden de las colecciones devueltas en la recomendación de XML XPath Language 1.0, este método de extensión devuelve nodos en orden del documento.  
  
 Tenga en cuenta que se devuelven nodos en orden del documento, incluso cuando se usa como un eje inverso, `preceding-sibling` o `ancestor-or-self`.  
  
   
  
## Examples  
 Este ejemplo crea un árbol XML que contiene un espacio de nombres. Usa un objeto <xref:System.Xml.XmlReader> para leer el documento XML. Después obtiene un objeto <xref:System.Xml.XmlNameTable> de <xref:System.Xml.XmlReader> y un objeto <xref:System.Xml.XmlNamespaceManager> de <xref:System.Xml.XmlNameTable>. Usa el <xref:System.Xml.XmlNamespaceManager> al seleccionar la lista de elementos.  
  
```csharp  
  
                string markup = @"  
<aw:Root xmlns:aw='http://www.adventure-works.com'>  
    <aw:Child1>child one data 1</aw:Child1>  
    <aw:Child1>child one data 2</aw:Child1>  
    <aw:Child1>child one data 3</aw:Child1>  
    <aw:Child2>child two data 4</aw:Child2>  
    <aw:Child2>child two data 5</aw:Child2>  
    <aw:Child2>child two data 6</aw:Child2>  
</aw:Root>";  
XmlReader reader = XmlReader.Create(new StringReader(markup));  
XElement root = XElement.Load(reader);  
XmlNameTable nameTable = reader.NameTable;  
XmlNamespaceManager namespaceManager = new XmlNamespaceManager(nameTable);  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com");  
IEnumerable<XElement> elements = root.XPathSelectElements("./aw:Child1", namespaceManager);  
foreach (XElement el in elements)  
    Console.WriteLine(el);  
```  
  
```vb  
  
                Dim markup As XElement = _  
<aw:Root xmlns:aw="http://www.adventure-works.com">  
    <aw:Child1>child one data 1</aw:Child1>  
    <aw:Child1>child one data 2</aw:Child1>  
    <aw:Child1>child one data 3</aw:Child1>  
    <aw:Child2>child two data 4</aw:Child2>  
    <aw:Child2>child two data 5</aw:Child2>  
    <aw:Child2>child two data 6</aw:Child2>  
</aw:Root>  
Dim reader As XmlReader = markup.CreateReader  
Dim nameTable As XmlNameTable = reader.NameTable  
Dim namespaceManager As XmlNamespaceManager = New XmlNamespaceManager(nameTable)  
namespaceManager.AddNamespace("aw", "http://www.adventure-works.com")  
Dim elements As IEnumerable(Of XElement) = markup.XPathSelectElements("./aw:Child1", namespaceManager)  
For Each el As XElement In elements  
    Console.WriteLine(el)  
Next  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```xml  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data 1</aw:Child1>  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data 2</aw:Child1>  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">child one data 3</aw:Child1>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>