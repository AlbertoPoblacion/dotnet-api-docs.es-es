<Type Name="JsonElement" FullName="System.Text.Json.JsonElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="51a8c97865a204f94ca8138d8ace1990918286bb" /><Meta Name="ms.sourcegitcommit" Value="ef1f0c8985003a14413f66c3de381b8f3b6e4436" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="05/30/2019" /><Meta Name="ms.locfileid" Value="66380765" /></Metadata><TypeSignature Language="C#" Value="public struct JsonElement" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit JsonElement extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Text.Json.JsonElement" />
  <TypeSignature Language="VB.NET" Value="Public Structure JsonElement" />
  <TypeSignature Language="C++ CLI" Value="public value class JsonElement" />
  <TypeSignature Language="F#" Value="type JsonElement = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Json</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un valor JSON específico en un objeto <see cref="T:System.Text.Json.JsonDocument" />.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.Json.JsonElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As JsonElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::Json::JsonElement Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Text.Json.JsonElement" Usage="jsonElement.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto JsonElement que se puede almacenar de forma segura más allá de la duración del <see cref="T:System.Text.Json.JsonDocument" /> original.</summary>
        <returns>Objeto JsonElement que se puede almacenar de forma segura más allá de la duración del <see cref="T:System.Text.Json.JsonDocument" /> original.</returns>
        <remarks>
          <format><![CDATA[
          
Si este JsonElement sí es el resultado de una llamada anterior a `Clone` o un valor dentro de otra JsonElement que fue el resultado de una llamada anterior a `Clone`, este método da como resultado ninguna asignación de memoria adicional.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateArray">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonElement.ArrayEnumerator EnumerateArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.Json.JsonElement/ArrayEnumerator EnumerateArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.EnumerateArray" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateArray () As JsonElement.ArrayEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::Json::JsonElement::ArrayEnumerator EnumerateArray();" />
      <MemberSignature Language="F#" Value="member this.EnumerateArray : unit -&gt; System.Text.Json.JsonElement.ArrayEnumerator" Usage="jsonElement.EnumerateArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonElement+ArrayEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un enumerador que enumera los valores de la matriz JSON representados por este JsonElement.</summary>
        <returns>Enumerador que enumera los valores de la matriz JSON representados por este JsonElement.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Array" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateObject">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonElement.ObjectEnumerator EnumerateObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.Json.JsonElement/ObjectEnumerator EnumerateObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.EnumerateObject" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateObject () As JsonElement.ObjectEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::Json::JsonElement::ObjectEnumerator EnumerateObject();" />
      <MemberSignature Language="F#" Value="member this.EnumerateObject : unit -&gt; System.Text.Json.JsonElement.ObjectEnumerator" Usage="jsonElement.EnumerateObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonElement+ObjectEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un enumerador que enumera las propiedades del objeto JSON representadas por este JsonElement.</summary>
        <returns>Enumerador que enumera las propiedades del objeto JSON representadas por este JsonElement.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Object" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetArrayLength">
      <MemberSignature Language="C#" Value="public int GetArrayLength ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetArrayLength() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetArrayLength" />
      <MemberSignature Language="VB.NET" Value="Public Function GetArrayLength () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetArrayLength();" />
      <MemberSignature Language="F#" Value="member this.GetArrayLength : unit -&gt; int" Usage="jsonElement.GetArrayLength " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el número de valores incluidos en el valor de matriz actual.</summary>
        <returns>Número de valores incluidos en el valor de matriz actual.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Array" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoolean">
      <MemberSignature Language="C#" Value="public bool GetBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetBoolean();" />
      <MemberSignature Language="F#" Value="member this.GetBoolean : unit -&gt; bool" Usage="jsonElement.GetBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el valor del elemento como <see cref="T:System.Boolean" />.</summary>
        <returns>Valor del elemento como <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no analiza el contenido de un valor de cadena JSON.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.True" /> ni <see cref="F:System.Text.Json.JsonValueType.False" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTime">
      <MemberSignature Language="C#" Value="public DateTime GetDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTime GetDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTime GetDateTime();" />
      <MemberSignature Language="F#" Value="member this.GetDateTime : unit -&gt; DateTime" Usage="jsonElement.GetDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el valor del elemento como <see cref="T:System.DateTime" />.</summary>
        <returns>Valor del elemento como <see cref="T:System.DateTime" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no crea una representación de fecha y hora de valores distintos de las cadenas JSON.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.String" />.</exception>
        <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.DateTime" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTimeOffset">
      <MemberSignature Language="C#" Value="public DateTimeOffset GetDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset GetDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset GetDateTimeOffset();" />
      <MemberSignature Language="F#" Value="member this.GetDateTimeOffset : unit -&gt; DateTimeOffset" Usage="jsonElement.GetDateTimeOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el valor del elemento como <see cref="T:System.DateTimeOffset" />.</summary>
        <returns>Valor del elemento como <see cref="T:System.DateTimeOffset" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no crea una representación de DateTimeOffset de valores distintos de las cadenas JSON.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.String" />.</exception>
        <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.DateTimeOffset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDecimal">
      <MemberSignature Language="C#" Value="public decimal GetDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Decimal GetDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Decimal GetDecimal();" />
      <MemberSignature Language="F#" Value="member this.GetDecimal : unit -&gt; decimal" Usage="jsonElement.GetDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el número JSON actual como <see cref="T:System.Decimal" />.</summary>
        <returns>Número JSON actual como <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format><![CDATA[
          
          This method does not parse the contents of a JSON string value.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Number" />.</exception>
        <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDouble">
      <MemberSignature Language="C#" Value="public double GetDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetDouble" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetDouble();" />
      <MemberSignature Language="F#" Value="member this.GetDouble : unit -&gt; double" Usage="jsonElement.GetDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el número JSON actual como <see cref="T:System.Double" />.</summary>
        <returns>Número JSON actual como <see cref="T:System.Double" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no analiza el contenido de un valor de cadena JSON.
               
En .NET Core, este método devuelve <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> para valores mayores que <xref:System.Double.MaxValue?displayProperty=nameWithType>, y devuelve <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> para los valores inferiores a <xref:System.Double.MinValue?displayProperty=nameWithType>.
                 
               ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Number" />.</exception>
        <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.Double" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGuid">
      <MemberSignature Language="C#" Value="public Guid GetGuid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Guid GetGuid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetGuid" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGuid () As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Guid GetGuid();" />
      <MemberSignature Language="F#" Value="member this.GetGuid : unit -&gt; Guid" Usage="jsonElement.GetGuid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el valor del elemento como <see cref="T:System.Guid" />.</summary>
        <returns>Valor del elemento como <see cref="T:System.Guid" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no crea una representación Guid de valores distintos de las cadenas JSON.
    
          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.String" />.</exception>
        <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.Guid" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt32">
      <MemberSignature Language="C#" Value="public int GetInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt32 () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetInt32();" />
      <MemberSignature Language="F#" Value="member this.GetInt32 : unit -&gt; int" Usage="jsonElement.GetInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el número JSON actual como <see cref="T:System.Int32" />.</summary>
        <returns>Número JSON actual como <see cref="T:System.Int32" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Number" />.</exception>
        <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.Int32" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt64">
      <MemberSignature Language="C#" Value="public long GetInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInt64 () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetInt64();" />
      <MemberSignature Language="F#" Value="member this.GetInt64 : unit -&gt; int64" Usage="jsonElement.GetInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el número JSON actual como <see cref="T:System.Int64" />.</summary>
        <returns>Número JSON actual como <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no analiza el contenido de un valor de cadena JSON.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Number" />.</exception>
        <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.Int64" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonElement GetProperty (ReadOnlySpan&lt;byte&gt; utf8PropertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.Json.JsonElement GetProperty(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetProperty(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (utf8PropertyName As ReadOnlySpan(Of Byte)) As JsonElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::Json::JsonElement GetProperty(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName);" />
      <MemberSignature Language="F#" Value="member this.GetProperty : ReadOnlySpan&lt;byte&gt; -&gt; System.Text.Json.JsonElement" Usage="jsonElement.GetProperty utf8PropertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Representación UTF-8 (sin marca de orden de bytes [BOM]) del nombre de la propiedad que se va a devolver.</param>
        <summary>Obtiene un objeto <see cref="T:System.Text.Json.JsonElement" /> que representa el valor de una propiedad obligatoria identificada por <paramref name="utf8PropertyName" />.</summary>
        <returns>Objeto <see cref="T:System.Text.Json.JsonElement" /> que representa el valor de la propiedad solicitada.</returns>
        <remarks>
          <format><![CDATA[
          
Se realiza la coincidencia de nombres de propiedad como una comparación ordinal, distingue mayúsculas de minúsculas.
               
Si se define una propiedad varias veces para el mismo objeto, el método coincide con la última definición de este tipo.
                 
               ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Object" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">No se encontró ninguna propiedad con el nombre solicitado.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonElement GetProperty (ReadOnlySpan&lt;char&gt; propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.Json.JsonElement GetProperty(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetProperty(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (propertyName As ReadOnlySpan(Of Char)) As JsonElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::Json::JsonElement GetProperty(ReadOnlySpan&lt;char&gt; propertyName);" />
      <MemberSignature Language="F#" Value="member this.GetProperty : ReadOnlySpan&lt;char&gt; -&gt; System.Text.Json.JsonElement" Usage="jsonElement.GetProperty propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de la propiedad cuyo valor se va a devolver.</param>
        <summary>Obtiene un objeto <see cref="T:System.Text.Json.JsonElement" /> que representa el valor de una propiedad obligatoria identificada por <paramref name="propertyName" />.</summary>
        <returns>Objeto <see cref="T:System.Text.Json.JsonElement" /> que representa el valor de la propiedad solicitada.</returns>
        <remarks>
          <format><![CDATA[
          
Se realiza la coincidencia de nombres de propiedad como una comparación ordinal, distingue mayúsculas de minúsculas.
               
Si se define una propiedad varias veces para el mismo objeto, el método coincide con la última definición de este tipo.
                 
               ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Object" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">No se encontró ninguna propiedad con el nombre solicitado.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonElement GetProperty (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.Json.JsonElement GetProperty(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (propertyName As String) As JsonElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::Json::JsonElement GetProperty(System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string -&gt; System.Text.Json.JsonElement" Usage="jsonElement.GetProperty propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de la propiedad cuyo valor se va a devolver.</param>
        <summary>Obtiene un objeto <see cref="T:System.Text.Json.JsonElement" /> que representa el valor de una propiedad obligatoria identificada por <paramref name="propertyName" />.</summary>
        <returns>Objeto <see cref="T:System.Text.Json.JsonElement" /> que representa el valor de la propiedad solicitada.</returns>
        <remarks>
          <format><![CDATA[
          
Se realiza la coincidencia de nombres de propiedad como una comparación ordinal, distingue mayúsculas de minúsculas.
            
Si se define una propiedad varias veces para el mismo objeto, el método coincide con la última definición de este tipo.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Object" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">No se encontró ninguna propiedad con el nombre solicitado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRawText">
      <MemberSignature Language="C#" Value="public string GetRawText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRawText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetRawText" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRawText () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRawText();" />
      <MemberSignature Language="F#" Value="member this.GetRawText : unit -&gt; string" Usage="jsonElement.GetRawText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene una cadena que representa los datos de entrada originales que respaldan este valor.</summary>
        <returns>Datos de entrada originales que respaldan este valor.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSingle">
      <MemberSignature Language="C#" Value="public float GetSingle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 GetSingle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetSingle" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSingle () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float GetSingle();" />
      <MemberSignature Language="F#" Value="member this.GetSingle : unit -&gt; single" Usage="jsonElement.GetSingle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el número JSON actual como <see cref="T:System.Single" />.</summary>
        <returns>Número JSON actual como <see cref="T:System.Single" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no analiza el contenido de un valor de cadena JSON.
               
En .NET Core, este método devuelve <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> para valores mayores que <xref:System.Single.MaxValue?displayProperty=nameWithType> y <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> para los valores inferiores a <xref:System.Single.MinValue?displayProperty=nameWithType>.
                 
               ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Number" />.</exception>
        <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.Single" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetString" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString();" />
      <MemberSignature Language="F#" Value="member this.GetString : unit -&gt; string" Usage="jsonElement.GetString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el valor del elemento como <see cref="T:System.String" />.</summary>
        <returns>Valor del elemento como <see cref="T:System.String" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no crea una representación de cadena de valores distintos de las cadenas JSON.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.String" /> ni <see cref="F:System.Text.Json.JsonValueType.Null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetUInt32">
      <MemberSignature Language="C#" Value="public uint GetUInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int32 GetUInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetUInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt32 () As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt32 GetUInt32();" />
      <MemberSignature Language="F#" Value="member this.GetUInt32 : unit -&gt; uint32" Usage="jsonElement.GetUInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el número JSON actual como <see cref="T:System.UInt32" />.</summary>
        <returns>Número JSON actual como <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no analiza el contenido de un valor de cadena JSON.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Number" />.</exception>
        <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.UInt32" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetUInt64">
      <MemberSignature Language="C#" Value="public ulong GetUInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int64 GetUInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.GetUInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUInt64 () As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::UInt64 GetUInt64();" />
      <MemberSignature Language="F#" Value="member this.GetUInt64 : unit -&gt; uint64" Usage="jsonElement.GetUInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el número JSON actual como <see cref="T:System.UInt64" />.</summary>
        <returns>Número JSON actual como <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no analiza el contenido de un valor de cadena JSON.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Number" />.</exception>
        <exception cref="T:System.FormatException">El valor no se puede representar como <see cref="T:System.UInt64" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonElement this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonElement Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonElement.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As JsonElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonElement default[int] { System::Text::Json::JsonElement get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : System.Text.Json.JsonElement" Usage="System.Text.Json.JsonElement.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>Obtiene el valor en el índice especificado cuando el valor actual es un objeto <see cref="F:System.Text.Json.JsonValueType.Array" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Array" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> no está en el rango [0, <see cref="M:System.Text.Json.JsonElement.GetArrayLength" />()).</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="jsonElement.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene una representación de cadena del valor actual correspondiente al tipo de valor.</summary>
        <returns>Representación de cadena del valor actual correspondiente al tipo de valor.</returns>
        <remarks>
          <format><![CDATA[
          
Para <xref:System.Text.Json.JsonValueType.Null?displayProperty=nameWithType>, <xref:System.String.Empty?displayProperty=nameWithType> se devuelve.
               
Para <xref:System.Text.Json.JsonValueType.True?displayProperty=nameWithType>, <xref:System.Boolean.TrueString?displayProperty=nameWithType> se devuelve.
               
Para <xref:System.Text.Json.JsonValueType.False?displayProperty=nameWithType>, <xref:System.Boolean.FalseString?displayProperty=nameWithType> se devuelve.
               
Para <xref:System.Text.Json.JsonValueType.String?displayProperty=nameWithType>, el valor de <xref:System.Text.Json.JsonElement.GetString> se devuelve.
               
Para otros tipos, el valor de <xref:System.Text.Json.JsonElement.GetRawText> se devuelve.
                 
               ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetDateTime">
      <MemberSignature Language="C#" Value="public bool TryGetDateTime (out DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDateTime([out] valuetype System.DateTime&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.TryGetDateTime(System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDateTime (ByRef value As DateTime) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDateTime([Runtime::InteropServices::Out] DateTime % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDateTime :  -&gt; bool" Usage="jsonElement.TryGetDateTime value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Cuando este método devuelve un resultado, contiene el valor de fecha y hora equivalente a la cadena JSON actual.</param>
        <summary>Número de intentos para representar la cadena JSON actual como <see cref="T:System.DateTime" />.</summary>
        <returns>Es <see langword="true" /> si la cadena puede representarse como <see cref="T:System.DateTime" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no crea una representación de fecha y hora de valores distintos de las cadenas JSON.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.String" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetDateTimeOffset">
      <MemberSignature Language="C#" Value="public bool TryGetDateTimeOffset (out DateTimeOffset value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDateTimeOffset([out] valuetype System.DateTimeOffset&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.TryGetDateTimeOffset(System.DateTimeOffset@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDateTimeOffset (ByRef value As DateTimeOffset) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDateTimeOffset([Runtime::InteropServices::Out] DateTimeOffset % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDateTimeOffset :  -&gt; bool" Usage="jsonElement.TryGetDateTimeOffset value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTimeOffset" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Cuando este método devuelve un resultado, contiene la fecha y hora equivalente a la cadena JSON actual.</param>
        <summary>Número de intentos para representar la cadena JSON actual como <see cref="T:System.DateTimeOffset" />.</summary>
        <returns>Es <see langword="true" /> si la cadena puede representarse como <see cref="T:System.DateTimeOffset" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no crea una representación de DateTimeOffset de valores distintos de las cadenas JSON.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.String" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetDecimal">
      <MemberSignature Language="C#" Value="public bool TryGetDecimal (out decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDecimal([out] valuetype System.Decimal&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.TryGetDecimal(System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDecimal (ByRef value As Decimal) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDecimal([Runtime::InteropServices::Out] System::Decimal % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDecimal :  -&gt; bool" Usage="jsonElement.TryGetDecimal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Cuando este método devuelve un resultado, contiene el decimal equivalente del número JSON actual.</param>
        <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.Decimal" />.</summary>
        <returns>Es <see langword="true" /> si el número puede representarse como <see cref="T:System.Decimal" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no analiza el contenido de un valor de cadena JSON.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Number" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetDouble">
      <MemberSignature Language="C#" Value="public bool TryGetDouble (out double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetDouble([out] float64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.TryGetDouble(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetDouble (ByRef value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetDouble([Runtime::InteropServices::Out] double % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetDouble :  -&gt; bool" Usage="jsonElement.TryGetDouble value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Cuando este método devuelve un resultado, contiene un valor de número de punto flotante de doble precisión equivalente a la cadena JSON actual.</param>
        <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.Double" />.</summary>
        <returns>Es <see langword="true" /> si el número puede representarse como <see cref="T:System.Double" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no analiza el contenido de un valor de cadena JSON.
               
En .NET Core, este método no devuelve `false` para valores mayores que <xref:System.Double.MaxValue?displayProperty=nameWithType> o menor que <xref:System.Double.MinValue?displayProperty=nameWithType>. En su lugar, devuelve < vea langword = "true > y asigna <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> a `value`.
                 
               ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Number" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetGuid">
      <MemberSignature Language="C#" Value="public bool TryGetGuid (out Guid value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetGuid([out] valuetype System.Guid&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.TryGetGuid(System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetGuid (ByRef value As Guid) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetGuid([Runtime::InteropServices::Out] Guid % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetGuid :  -&gt; bool" Usage="jsonElement.TryGetGuid value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Guid" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Cuando este método devuelve un resultado, contiene el GUID equivalente a la cadena JSON actual.</param>
        <summary>Número de intentos para representar la cadena JSON actual como <see cref="T:System.Guid" />.</summary>
        <returns>Es <see langword="true" /> si la cadena puede representarse como <see cref="T:System.Guid" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no crea una representación Guid de valores distintos de las cadenas JSON.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.String" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetInt32">
      <MemberSignature Language="C#" Value="public bool TryGetInt32 (out int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt32([out] int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.TryGetInt32(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt32 (ByRef value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt32([Runtime::InteropServices::Out] int % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt32 :  -&gt; bool" Usage="jsonElement.TryGetInt32 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Cuando este método devuelve un resultado, contiene un valor entero de 32 bits equivalente a la cadena JSON actual.</param>
        <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.Int32" />.</summary>
        <returns>Es <see langword="true" /> si el número puede representarse como <see cref="T:System.Int32" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no analiza el contenido de un valor de cadena JSON.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Number" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetInt64">
      <MemberSignature Language="C#" Value="public bool TryGetInt64 (out long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetInt64([out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.TryGetInt64(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetInt64 (ByRef value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetInt64([Runtime::InteropServices::Out] long % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetInt64 :  -&gt; bool" Usage="jsonElement.TryGetInt64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Cuando este método devuelve un resultado, contiene un valor entero de 64 bits equivalente a la cadena JSON actual.</param>
        <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.Int64" />.</summary>
        <returns>Es <see langword="true" /> si el número puede representarse como <see cref="T:System.Int64" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no analiza el contenido de un valor de cadena JSON.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Number" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetProperty">
      <MemberSignature Language="C#" Value="public bool TryGetProperty (ReadOnlySpan&lt;byte&gt; utf8PropertyName, out System.Text.Json.JsonElement value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetProperty(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, [out] valuetype System.Text.Json.JsonElement&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.TryGetProperty(System.ReadOnlySpan{System.Byte},System.Text.Json.JsonElement@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetProperty (utf8PropertyName As ReadOnlySpan(Of Byte), ByRef value As JsonElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetProperty(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, [Runtime::InteropServices::Out] System::Text::Json::JsonElement % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetProperty : ReadOnlySpan&lt;byte&gt; *  -&gt; bool" Usage="jsonElement.TryGetProperty (utf8PropertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Text.Json.JsonElement" RefType="out" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Representación UTF-8 (sin marca de orden de bytes [BOM]) del nombre de la propiedad que se va a devolver.</param>
        <param name="value">Recibe el valor de la propiedad encontrada.</param>
        <summary>Busca una propiedad denominada <paramref name="utf8PropertyName" /> en el objeto actual y devuelve un valor que indica si dicha propiedad existe o no. Cuando la propiedad existe, el método asigna su valor al argumento <paramref name="value" />.</summary>
        <returns>Es <see langword="true" /> si se encontró la propiedad; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format><![CDATA[
          
Se realiza la coincidencia de nombres de propiedad como una comparación ordinal, distingue mayúsculas de minúsculas.
               
Si se define una propiedad varias veces para el mismo objeto, el método coincide con la última definición de este tipo.
                 
               ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Object" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetProperty">
      <MemberSignature Language="C#" Value="public bool TryGetProperty (ReadOnlySpan&lt;char&gt; propertyName, out System.Text.Json.JsonElement value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetProperty(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, [out] valuetype System.Text.Json.JsonElement&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.TryGetProperty(System.ReadOnlySpan{System.Char},System.Text.Json.JsonElement@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetProperty (propertyName As ReadOnlySpan(Of Char), ByRef value As JsonElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetProperty(ReadOnlySpan&lt;char&gt; propertyName, [Runtime::InteropServices::Out] System::Text::Json::JsonElement % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetProperty : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="jsonElement.TryGetProperty (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="value" Type="System.Text.Json.JsonElement" RefType="out" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de la propiedad que se va a buscar.</param>
        <param name="value">Cuando este método devuelve un resultado, contiene el valor de la propiedad especificada.</param>
        <summary>Busca una propiedad denominada <paramref name="propertyName" /> en el objeto actual y devuelve un valor que indica si dicha propiedad existe o no. Cuando la propiedad existe, el método asigna su valor al argumento <paramref name="value" />.</summary>
        <returns>Es <see langword="true" /> si se encontró la propiedad; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format><![CDATA[
          
Se realiza la coincidencia de nombres de propiedad como una comparación ordinal, distingue mayúsculas de minúsculas.
               
Si se define una propiedad varias veces para el mismo objeto, el método coincide con la última definición de este tipo.
                 
               ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Object" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetProperty">
      <MemberSignature Language="C#" Value="public bool TryGetProperty (string propertyName, out System.Text.Json.JsonElement value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetProperty(string propertyName, [out] valuetype System.Text.Json.JsonElement&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.TryGetProperty(System.String,System.Text.Json.JsonElement@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetProperty (propertyName As String, ByRef value As JsonElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetProperty(System::String ^ propertyName, [Runtime::InteropServices::Out] System::Text::Json::JsonElement % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetProperty : string *  -&gt; bool" Usage="jsonElement.TryGetProperty (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.Text.Json.JsonElement" RefType="out" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de la propiedad que se va a buscar.</param>
        <param name="value">Cuando este método devuelve un resultado, contiene el valor de la propiedad especificada.</param>
        <summary>Busca una propiedad denominada <paramref name="propertyName" /> en el objeto actual y devuelve un valor que indica si dicha propiedad existe o no. Cuando la propiedad existe, su valor se asigna al argumento <paramref name="value" />.</summary>
        <returns>Es <see langword="true" /> si se encontró la propiedad; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format><![CDATA[
          
Se realiza la coincidencia de nombres de propiedad como una comparación ordinal, distingue mayúsculas de minúsculas.
               
Si se define una propiedad varias veces para el mismo objeto, el método coincide con la última definición de este tipo.
                 
               ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Object" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="propertyName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetSingle">
      <MemberSignature Language="C#" Value="public bool TryGetSingle (out float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetSingle([out] float32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.TryGetSingle(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetSingle (ByRef value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetSingle([Runtime::InteropServices::Out] float % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetSingle :  -&gt; bool" Usage="jsonElement.TryGetSingle value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Cuando este método devuelve un resultado, contiene un valor de número de punto flotante de precisión sencilla equivalente a la cadena JSON actual.</param>
        <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.Single" />.</summary>
        <returns>Es <see langword="true" /> si el número puede representarse como <see cref="T:System.Single" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no analiza el contenido de un valor de cadena JSON.
               
En .NET Core, este método no devuelve `false` para valores mayores que <xref:System.Single.MaxValue?displayProperty=nameWithType> o menor que <xref:System.Single.MinValue?displayProperty=nameWithType>). En su lugar, devuelve `false` y asigna <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> a la `value` argumento.
                 
               ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Number" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt32">
      <MemberSignature Language="C#" Value="public bool TryGetUInt32 (out uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt32([out] unsigned int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.TryGetUInt32(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt32 (ByRef value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt32([Runtime::InteropServices::Out] System::UInt32 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt32 :  -&gt; bool" Usage="jsonElement.TryGetUInt32 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Cuando este método devuelve un resultado, contiene un valor entero de 32 bits sin signo equivalente al número JSON actual.</param>
        <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.UInt32" />.</summary>
        <returns>Es <see langword="true" /> si el número puede representarse como <see cref="T:System.UInt32" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no analiza el contenido de un valor de cadena JSON.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Number" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetUInt64">
      <MemberSignature Language="C#" Value="public bool TryGetUInt64 (out ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetUInt64([out] unsigned int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.TryGetUInt64(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetUInt64 (ByRef value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetUInt64([Runtime::InteropServices::Out] System::UInt64 % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetUInt64 :  -&gt; bool" Usage="jsonElement.TryGetUInt64 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Cuando este método devuelve un resultado, contiene un valor entero de 64 bits sin signo equivalente al número JSON actual.</param>
        <summary>Número de intentos para representar el número JSON actual como <see cref="T:System.UInt64" />.</summary>
        <returns>Es <see langword="true" /> si el número puede representarse como <see cref="T:System.UInt64" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format><![CDATA[
          
Este método no analiza el contenido de un valor de cadena JSON.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor no es <see cref="F:System.Text.Json.JsonValueType.Number" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonValueType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonValueType Type" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonElement.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As JsonValueType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonValueType Type { System::Text::Json::JsonValueType get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : System.Text.Json.JsonValueType" Usage="System.Text.Json.JsonElement.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonValueType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo del elemento JSON actual.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsProperty">
      <MemberSignature Language="C#" Value="public void WriteAsProperty (ReadOnlySpan&lt;byte&gt; utf8PropertyName, System.Text.Json.Utf8JsonWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteAsProperty(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, class System.Text.Json.Utf8JsonWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.WriteAsProperty(System.ReadOnlySpan{System.Byte},System.Text.Json.Utf8JsonWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAsProperty (utf8PropertyName As ReadOnlySpan(Of Byte), writer As Utf8JsonWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAsProperty(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, System::Text::Json::Utf8JsonWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteAsProperty : ReadOnlySpan&lt;byte&gt; * System.Text.Json.Utf8JsonWriter -&gt; unit" Usage="jsonElement.WriteAsProperty (utf8PropertyName, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="writer" Type="System.Text.Json.Utf8JsonWriter" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Texto con codificación UTF8 que representa el nombre para este valor en el objeto JSON.</param>
        <param name="writer">Sistema de escritura.</param>
        <summary>Escribe el elemento en el sistema de escritura proporcionado como una propiedad de objeto cuyo nombre se define mediante texto con codificación UTF8.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor es <see cref="F:System.Text.Json.JsonValueType.Undefined" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsProperty">
      <MemberSignature Language="C#" Value="public void WriteAsProperty (ReadOnlySpan&lt;char&gt; propertyName, System.Text.Json.Utf8JsonWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteAsProperty(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, class System.Text.Json.Utf8JsonWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.WriteAsProperty(System.ReadOnlySpan{System.Char},System.Text.Json.Utf8JsonWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAsProperty (propertyName As ReadOnlySpan(Of Char), writer As Utf8JsonWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAsProperty(ReadOnlySpan&lt;char&gt; propertyName, System::Text::Json::Utf8JsonWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteAsProperty : ReadOnlySpan&lt;char&gt; * System.Text.Json.Utf8JsonWriter -&gt; unit" Usage="jsonElement.WriteAsProperty (propertyName, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="writer" Type="System.Text.Json.Utf8JsonWriter" />
      </Parameters>
      <Docs>
        <param name="propertyName">Intervalo de caracteres que especifica el nombre para este valor en el objeto JSON.</param>
        <param name="writer">Sistema de escritura.</param>
        <summary>Escribe el elemento en el sistema de escritura proporcionado como una propiedad de objeto cuyo nombre se define mediante el intervalo de caracteres especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor es <see cref="F:System.Text.Json.JsonValueType.Undefined" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsValue">
      <MemberSignature Language="C#" Value="public void WriteAsValue (System.Text.Json.Utf8JsonWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteAsValue(class System.Text.Json.Utf8JsonWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonElement.WriteAsValue(System.Text.Json.Utf8JsonWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAsValue (writer As Utf8JsonWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAsValue(System::Text::Json::Utf8JsonWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteAsValue : System.Text.Json.Utf8JsonWriter -&gt; unit" Usage="jsonElement.WriteAsValue writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Text.Json.Utf8JsonWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Sistema de escritura.</param>
        <summary>Escribe el elemento en el sistema de escritura proporcionado como un valor.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">El elemento <see cref="P:System.Text.Json.JsonElement.Type" /> de este valor es <see cref="F:System.Text.Json.JsonValueType.Undefined" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el elemento primario <see cref="T:System.Text.Json.JsonDocument" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>