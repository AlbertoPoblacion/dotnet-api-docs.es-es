<Type Name="Utf8JsonWriter" FullName="System.Text.Json.Utf8JsonWriter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a53989de8d83f4c2a1475dab523c2f9f73feb572" /><Meta Name="ms.sourcegitcommit" Value="6b9d64332f31de312efea785fbb19e4d80f544d5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="06/12/2019" /><Meta Name="ms.locfileid" Value="67027324" /></Metadata><TypeSignature Language="C#" Value="public sealed class Utf8JsonWriter : IAsyncDisposable, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Utf8JsonWriter extends System.Object implements class System.IAsyncDisposable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Json.Utf8JsonWriter" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Utf8JsonWriter&#xA;Implements IAsyncDisposable, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Utf8JsonWriter sealed : IAsyncDisposable, IDisposable" />
  <TypeSignature Language="F#" Value="type Utf8JsonWriter = class&#xA;    interface IDisposable&#xA;    interface IAsyncDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Json</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-3.0">System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Proporciona una API de alto rendimiento para la escritura de solo avance sin almacenamiento en caché de texto JSON con codificación UTF-8.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

## Remarks

`Utf8JsonWriter` Escribe el texto de forma secuencial con ningún almacenamiento en caché y de forma predeterminada se ajusta a la [JSON RFC](https://tools.ietf.org/html/rfc8259), a excepción de escribir comentarios.

Un método que intenta escribir JSON no válido cuando la validación es habilitado inicia un <xref:System.InvalidOperationException> con un mensaje de error específicos del contexto.

Puesto que este tipo es un struct ref, no admite directamente async. Sin embargo, proporciona compatibilidad para la reentrada para escribir datos parciales y seguir escribiendo en fragmentos.

Para poder dar formato al resultado con sangría y espacios en blanco u omitir la validación, cree una instancia de <xref:System.Text.Json.JsonWriterOptions> y pasarlo en el sistema de escritura.

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonWriter (System.Buffers.IBufferWriter&lt;byte&gt; bufferWriter, System.Text.Json.JsonWriterOptions options = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Buffers.IBufferWriter`1&lt;unsigned int8&gt; bufferWriter, valuetype System.Text.Json.JsonWriterOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.#ctor(System.Buffers.IBufferWriter{System.Byte},System.Text.Json.JsonWriterOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bufferWriter As IBufferWriter(Of Byte), Optional options As JsonWriterOptions = null)" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonWriter : System.Buffers.IBufferWriter&lt;byte&gt; * System.Text.Json.JsonWriterOptions -&gt; System.Text.Json.Utf8JsonWriter" Usage="new System.Text.Json.Utf8JsonWriter (bufferWriter, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bufferWriter" Type="System.Buffers.IBufferWriter&lt;System.Byte&gt;" />
        <Parameter Name="options" Type="System.Text.Json.JsonWriterOptions" />
      </Parameters>
      <Docs>
        <param name="bufferWriter">Destino de la escritura de texto JSON.</param>
        <param name="options">Define el comportamiento personalizado de la <see cref="T:System.Text.Json.Utf8JsonWriter" />. De forma predeterminada, escribe JSON minimizado (sin espacios en blanco adicionales) y valida que el JSON que se escribe es estructuralmente válido según la JSON RFC.</param>
        <summary>Crea una instancia de <see cref="T:System.Text.Json.Utf8JsonWriter" /> con un objeto <see langword="System.Buffers.IBufferWriter&lt;System.Byte&gt;" /> especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="bufferWriter" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Utf8JsonWriter (System.IO.Stream utf8Json, System.Text.Json.JsonWriterOptions options = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream utf8Json, valuetype System.Text.Json.JsonWriterOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.#ctor(System.IO.Stream,System.Text.Json.JsonWriterOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (utf8Json As Stream, Optional options As JsonWriterOptions = null)" />
      <MemberSignature Language="F#" Value="new System.Text.Json.Utf8JsonWriter : System.IO.Stream * System.Text.Json.JsonWriterOptions -&gt; System.Text.Json.Utf8JsonWriter" Usage="new System.Text.Json.Utf8JsonWriter (utf8Json, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Text.Json.JsonWriterOptions" />
      </Parameters>
      <Docs>
        <param name="utf8Json">Destino de la escritura de texto JSON.</param>
        <param name="options">Define el comportamiento personalizado de la <see cref="T:System.Text.Json.Utf8JsonWriter" />. De forma predeterminada, escribe JSON minimizado (sin espacios en blanco adicionales) y valida que el JSON que se escribe es estructuralmente válido según la JSON RFC.</param>
        <summary>Crea una instancia de <see cref="T:System.Text.Json.Utf8JsonWriter" /> con un objeto <paramref name="utf8Json" /> especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="utf8Json" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesCommitted">
      <MemberSignature Language="C#" Value="public long BytesCommitted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 BytesCommitted" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonWriter.BytesCommitted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesCommitted As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long BytesCommitted { long get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesCommitted : int64" Usage="System.Text.Json.Utf8JsonWriter.BytesCommitted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número total de bytes confirmados en la salida por la instancia actual hasta el momento.</summary>
        <value>El número total de bytes confirmados en la salida por el <see cref="T:System.Text.Json.Utf8JsonWriter" /> hasta ahora.</value>
        <remarks>
          <format><![CDATA[
          
En el caso de un <xref:System.Buffers.IBufferWriter%601>, esta propiedad indica cuánto ha avanzado el IBufferWriter.

En el caso de un <xref:System.IO.Stream>, esta propiedad indica la cantidad de datos se ha escrito en la secuencia.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BytesPending">
      <MemberSignature Language="C#" Value="public int BytesPending { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesPending" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonWriter.BytesPending" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesPending As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesPending { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesPending : int" Usage="System.Text.Json.Utf8JsonWriter.BytesPending" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de bytes escritos por el objeto <see cref="T:System.Text.Json.Utf8JsonWriter" /> hasta el momento que aún no se han vaciado en la salida y confirmado.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentDepth">
      <MemberSignature Language="C#" Value="public int CurrentDepth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentDepth" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonWriter.CurrentDepth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentDepth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentDepth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDepth : int" Usage="System.Text.Json.Utf8JsonWriter.CurrentDepth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la profundidad del token actual.</summary>
        <value>La profundidad del token actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

El `CurrentDepth` propiedad realiza un seguimiento de la profundidad recursiva de los objetos anidados o matrices dentro del texto JSON escrito hasta ahora.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="utf8JsonWriter.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Confirma el texto JSON restante que aún no se ha vaciado y libera todos los recursos utilizados por la instancia actual.</summary>
        <remarks>
          <format><![CDATA[
          
En el caso de IBufferWriter, esto hace avanzar subyacente <xref:System.Buffers.IBufferWriter`1> según lo que se ha escrito hasta ahora.

En el caso de Stream, este escribe los datos en la secuencia y la vuelca.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="abstract member DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask&#xA;override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="utf8JsonWriter.DisposeAsync " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IAsyncDisposable.DisposeAsync</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Confirma asincrónicamente el texto JSON restante que aún no se ha vaciado y libera todos los recursos utilizados por la instancia actual.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format><![CDATA[
          
En el caso de IBufferWriter, esto hace avanzar subyacente <xref:System.Buffers.IBufferWriter`1> según lo que se ha escrito hasta ahora.
          
En el caso de Stream, este escribe los datos en la secuencia y la vuelca.
            
            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="utf8JsonWriter.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Confirma el texto JSON escrito hasta el momento, lo que hace que sea visible en el destino de salida.</summary>
        <remarks>
          <format><![CDATA[
          
En el caso de IBufferWriter, esto hace avanzar subyacente <xref:System.Buffers.IBufferWriter`1> según lo que se ha escrito hasta ahora.

En el caso de <xref:System.IO.Stream>, éste escribe los datos en la secuencia y la vuelca.

          ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Esta instancia se ha eliminado.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="utf8JsonWriter.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">To be added.</param>
        <summary>Confirma asincrónicamente el texto JSON escrito hasta el momento, lo que hace que sea visible en el destino de salida.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format><![CDATA[
          
En el caso de IBufferWriter, esto hace avanzar subyacente <xref:System.Buffers.IBufferWriter`1> según lo que se ha escrito hasta ahora.

En el caso de <xref:System.IO.Stream>, esto escribe los datos en la secuencia y la vuelca asincrónicamente, al supervisar las solicitudes de cancelación.

          ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Esta instancia se ha eliminado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonWriterOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonWriterOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Utf8JsonWriter.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As JsonWriterOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonWriterOptions Options { System::Text::Json::JsonWriterOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.Json.JsonWriterOptions" Usage="System.Text.Json.Utf8JsonWriter.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonWriterOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el comportamiento personalizado al escribir JSON con esta instancia, lo que indica si se debe dar formato a la salida mientras se escribe y si se debe omitir la validación JSON estructural.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; unit" Usage="utf8JsonWriter.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el estado interno de esta instancia para que se pueda reutilizar.</summary>
        <remarks>
          <format><![CDATA[
          
El <xref:System.Text.Json.Utf8JsonWriter> seguirá usando las opciones de sistema de escritura original y la salida original (ya sea <xref:System.Buffers.IBufferWriter`1> o <xref:System.IO.Stream>) como el destino.

          ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Esta instancia se ha eliminado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset (System.Buffers.IBufferWriter&lt;byte&gt; bufferWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset(class System.Buffers.IBufferWriter`1&lt;unsigned int8&gt; bufferWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.Reset(System.Buffers.IBufferWriter{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset (bufferWriter As IBufferWriter(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reset(System::Buffers::IBufferWriter&lt;System::Byte&gt; ^ bufferWriter);" />
      <MemberSignature Language="F#" Value="member this.Reset : System.Buffers.IBufferWriter&lt;byte&gt; -&gt; unit" Usage="utf8JsonWriter.Reset bufferWriter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferWriter" Type="System.Buffers.IBufferWriter&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bufferWriter">Destino de la escritura de texto JSON.</param>
        <summary>Restablece el estado interno de esta instancia para que se pueda reutilizar con una nueva instancia de <see cref="T:System.Buffers.IBufferWriter`1" />.</summary>
        <remarks>
          <format><![CDATA[
          
El <xref:System.Text.Json.Utf8JsonWriter> seguirá usando las opciones de sistema de escritura original, pero ahora se escribe en `bufferWriter` como el nuevo destino.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bufferWriter" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Esta instancia se ha eliminado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset (System.IO.Stream utf8Json);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset(class System.IO.Stream utf8Json) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.Reset(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset (utf8Json As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reset(System::IO::Stream ^ utf8Json);" />
      <MemberSignature Language="F#" Value="member this.Reset : System.IO.Stream -&gt; unit" Usage="utf8JsonWriter.Reset utf8Json" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="utf8Json">Destino de la escritura de texto JSON.</param>
        <summary>Restablece el estado interno de esta instancia para que se pueda reutilizar con una nueva instancia de <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format><![CDATA[
          
El <xref:System.Text.Json.Utf8JsonWriter> seguirán utilizando las opciones de sistema de escritura original pero escribir ahora en `utf8Json` como el nuevo destino.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="utf8Json" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Esta instancia se ha eliminado.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBoolean">
      <MemberSignature Language="C#" Value="public void WriteBoolean (ReadOnlySpan&lt;byte&gt; utf8PropertyName, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteBoolean(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteBoolean(System.ReadOnlySpan{System.Byte},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteBoolean (utf8PropertyName As ReadOnlySpan(Of Byte), value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteBoolean(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, bool value);" />
      <MemberSignature Language="F#" Value="member this.WriteBoolean : ReadOnlySpan&lt;byte&gt; * bool -&gt; unit" Usage="utf8JsonWriter.WriteBoolean (utf8PropertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <param name="value">Valor que se va escribir como un literal "true" o "false" de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.Boolean" /> (como un literal "true" o "false" de JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBoolean">
      <MemberSignature Language="C#" Value="public void WriteBoolean (ReadOnlySpan&lt;char&gt; propertyName, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteBoolean(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteBoolean(System.ReadOnlySpan{System.Char},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteBoolean (propertyName As ReadOnlySpan(Of Char), value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteBoolean(ReadOnlySpan&lt;char&gt; propertyName, bool value);" />
      <MemberSignature Language="F#" Value="member this.WriteBoolean : ReadOnlySpan&lt;char&gt; * bool -&gt; unit" Usage="utf8JsonWriter.WriteBoolean (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un literal "true" o "false" de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.Boolean" /> (como un literal "true" o "false" de JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El nombre de propiedad es de escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBoolean">
      <MemberSignature Language="C#" Value="public void WriteBoolean (string propertyName, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteBoolean(string propertyName, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteBoolean(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteBoolean (propertyName As String, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteBoolean(System::String ^ propertyName, bool value);" />
      <MemberSignature Language="F#" Value="member this.WriteBoolean : string * bool -&gt; unit" Usage="utf8JsonWriter.WriteBoolean (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un literal "true" o "false" de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.Boolean" /> (como un literal "true" o "false" de JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El nombre de propiedad es de escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBooleanValue">
      <MemberSignature Language="C#" Value="public void WriteBooleanValue (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteBooleanValue(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteBooleanValue(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteBooleanValue (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteBooleanValue(bool value);" />
      <MemberSignature Language="F#" Value="member this.WriteBooleanValue : bool -&gt; unit" Usage="utf8JsonWriter.WriteBooleanValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir como un literal "true" o "false" de JSON como un elemento de una matriz de JSON.</param>
        <summary>Escribe el valor <see cref="T:System.Boolean" /> (como un literal "true" o "false" de JSON) como elemento de una matriz JSON.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteCommentValue">
      <MemberSignature Language="C#" Value="public void WriteCommentValue (ReadOnlySpan&lt;byte&gt; utf8Value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteCommentValue(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteCommentValue(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteCommentValue (utf8Value As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteCommentValue(ReadOnlySpan&lt;System::Byte&gt; utf8Value);" />
      <MemberSignature Language="F#" Value="member this.WriteCommentValue : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="utf8JsonWriter.WriteCommentValue utf8Value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="utf8Value">Valor con codificación UTF-8 que se va escribir como comentario de JSON en /*..*/.</param>
        <summary>Escribe el valor de texto UTF-8 como comentario JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El valor de comentario no se aplicará escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.
        
O bien

<paramref name="utf8Value" /> contiene un delimitador de comentario (es decir, */).</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteCommentValue">
      <MemberSignature Language="C#" Value="public void WriteCommentValue (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteCommentValue(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteCommentValue(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteCommentValue (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteCommentValue(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.WriteCommentValue : ReadOnlySpan&lt;char&gt; -&gt; unit" Usage="utf8JsonWriter.WriteCommentValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Valor con codificación UTF-16 que se va escribir como comentario de JSON transcodificado a UTF-8 en /*..*/.</param>
        <summary>Escribe el valor de texto UTF-16 como comentario JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El valor de comentario no se aplicará escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.
        
O bien

<paramref name="value" /> contiene un delimitador de comentario (es decir, */).</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteCommentValue">
      <MemberSignature Language="C#" Value="public void WriteCommentValue (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteCommentValue(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteCommentValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteCommentValue (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteCommentValue(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.WriteCommentValue : string -&gt; unit" Usage="utf8JsonWriter.WriteCommentValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valor con codificación UTF-16 que se va escribir como comentario de JSON transcodificado a UTF-8 en /*..*/.</param>
        <summary>Escribe el valor de texto de cadena como comentario JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El valor de comentario no se aplicará escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.
        
O bien

<paramref name="value" /> contiene un delimitador de comentario (es decir, */).</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEndArray">
      <MemberSignature Language="C#" Value="public void WriteEndArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEndArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteEndArray" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEndArray ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEndArray();" />
      <MemberSignature Language="F#" Value="member this.WriteEndArray : unit -&gt; unit" Usage="utf8JsonWriter.WriteEndArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Escribe el final de una matriz de JSON.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEndObject">
      <MemberSignature Language="C#" Value="public void WriteEndObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEndObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteEndObject" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEndObject ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEndObject();" />
      <MemberSignature Language="F#" Value="member this.WriteEndObject : unit -&gt; unit" Usage="utf8JsonWriter.WriteEndObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Escribe el final de un objeto de JSON.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNull">
      <MemberSignature Language="C#" Value="public void WriteNull (ReadOnlySpan&lt;byte&gt; utf8PropertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNull(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNull(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNull (utf8PropertyName As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNull(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName);" />
      <MemberSignature Language="F#" Value="member this.WriteNull : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="utf8JsonWriter.WriteNull utf8PropertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el literal "NULL" de JSON como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El nombre de propiedad es de escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNull">
      <MemberSignature Language="C#" Value="public void WriteNull (ReadOnlySpan&lt;char&gt; propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNull(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNull(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNull (propertyName As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNull(ReadOnlySpan&lt;char&gt; propertyName);" />
      <MemberSignature Language="F#" Value="member this.WriteNull : ReadOnlySpan&lt;char&gt; -&gt; unit" Usage="utf8JsonWriter.WriteNull propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el literal "NULL" de JSON como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El nombre de propiedad es de escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNull">
      <MemberSignature Language="C#" Value="public void WriteNull (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNull(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNull(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNull (propertyName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNull(System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="member this.WriteNull : string -&gt; unit" Usage="utf8JsonWriter.WriteNull propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <summary>Escribe el nombre de propiedad especificado como cadena y el literal "NULL" de JSON como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El nombre de propiedad es de escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNullValue">
      <MemberSignature Language="C#" Value="public void WriteNullValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNullValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNullValue" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNullValue ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNullValue();" />
      <MemberSignature Language="F#" Value="member this.WriteNullValue : unit -&gt; unit" Usage="utf8JsonWriter.WriteNullValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Escribe el literal "NULL" de JSON como un elemento de una matriz de JSON.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (ReadOnlySpan&lt;byte&gt; utf8PropertyName, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Byte},System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (utf8PropertyName As ReadOnlySpan(Of Byte), value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : ReadOnlySpan&lt;byte&gt; * decimal -&gt; unit" Usage="utf8JsonWriter.WriteNumber (utf8PropertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.Decimal" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El nombre de propiedad es de escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (ReadOnlySpan&lt;byte&gt; utf8PropertyName, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (utf8PropertyName As ReadOnlySpan(Of Byte), value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, double value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : ReadOnlySpan&lt;byte&gt; * double -&gt; unit" Usage="utf8JsonWriter.WriteNumber (utf8PropertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.Double" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El nombre de propiedad es de escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (ReadOnlySpan&lt;byte&gt; utf8PropertyName, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (utf8PropertyName As ReadOnlySpan(Of Byte), value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, int value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="utf8JsonWriter.WriteNumber (utf8PropertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.Int32" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El nombre de propiedad es de escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (ReadOnlySpan&lt;byte&gt; utf8PropertyName, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (utf8PropertyName As ReadOnlySpan(Of Byte), value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, long value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : ReadOnlySpan&lt;byte&gt; * int64 -&gt; unit" Usage="utf8JsonWriter.WriteNumber (utf8PropertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.Int64" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El nombre de propiedad es de escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (ReadOnlySpan&lt;byte&gt; utf8PropertyName, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (utf8PropertyName As ReadOnlySpan(Of Byte), value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, float value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : ReadOnlySpan&lt;byte&gt; * single -&gt; unit" Usage="utf8JsonWriter.WriteNumber (utf8PropertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.Single" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El nombre de propiedad es de escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (ReadOnlySpan&lt;byte&gt; utf8PropertyName, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (utf8PropertyName As ReadOnlySpan(Of Byte), value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : ReadOnlySpan&lt;byte&gt; * uint32 -&gt; unit" Usage="utf8JsonWriter.WriteNumber (utf8PropertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.UInt32" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El nombre de propiedad es de escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (ReadOnlySpan&lt;byte&gt; utf8PropertyName, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (utf8PropertyName As ReadOnlySpan(Of Byte), value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : ReadOnlySpan&lt;byte&gt; * uint64 -&gt; unit" Usage="utf8JsonWriter.WriteNumber (utf8PropertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de bytes de solo lectura y el valor <see cref="T:System.UInt64" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El nombre de propiedad es de escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (ReadOnlySpan&lt;char&gt; propertyName, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Char},System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (propertyName As ReadOnlySpan(Of Char), value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(ReadOnlySpan&lt;char&gt; propertyName, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : ReadOnlySpan&lt;char&gt; * decimal -&gt; unit" Usage="utf8JsonWriter.WriteNumber (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.Decimal" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El nombre de propiedad es de escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (ReadOnlySpan&lt;char&gt; propertyName, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Char},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (propertyName As ReadOnlySpan(Of Char), value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(ReadOnlySpan&lt;char&gt; propertyName, double value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : ReadOnlySpan&lt;char&gt; * double -&gt; unit" Usage="utf8JsonWriter.WriteNumber (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.Double" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[
          
El nombre de propiedad es de escape antes de la escritura.
          
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (ReadOnlySpan&lt;char&gt; propertyName, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (propertyName As ReadOnlySpan(Of Char), value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(ReadOnlySpan&lt;char&gt; propertyName, int value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : ReadOnlySpan&lt;char&gt; * int -&gt; unit" Usage="utf8JsonWriter.WriteNumber (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.Int32" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (ReadOnlySpan&lt;char&gt; propertyName, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Char},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (propertyName As ReadOnlySpan(Of Char), value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(ReadOnlySpan&lt;char&gt; propertyName, long value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : ReadOnlySpan&lt;char&gt; * int64 -&gt; unit" Usage="utf8JsonWriter.WriteNumber (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.Int64" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (ReadOnlySpan&lt;char&gt; propertyName, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Char},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (propertyName As ReadOnlySpan(Of Char), value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(ReadOnlySpan&lt;char&gt; propertyName, float value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : ReadOnlySpan&lt;char&gt; * single -&gt; unit" Usage="utf8JsonWriter.WriteNumber (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.Single" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (ReadOnlySpan&lt;char&gt; propertyName, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Char},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (propertyName As ReadOnlySpan(Of Char), value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(ReadOnlySpan&lt;char&gt; propertyName, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : ReadOnlySpan&lt;char&gt; * uint32 -&gt; unit" Usage="utf8JsonWriter.WriteNumber (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.UInt32" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (ReadOnlySpan&lt;char&gt; propertyName, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.ReadOnlySpan{System.Char},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (propertyName As ReadOnlySpan(Of Char), value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(ReadOnlySpan&lt;char&gt; propertyName, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : ReadOnlySpan&lt;char&gt; * uint64 -&gt; unit" Usage="utf8JsonWriter.WriteNumber (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.UInt64" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (string propertyName, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(string propertyName, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.String,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (propertyName As String, value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(System::String ^ propertyName, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : string * decimal -&gt; unit" Usage="utf8JsonWriter.WriteNumber (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.Decimal" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (string propertyName, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(string propertyName, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.String,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (propertyName As String, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(System::String ^ propertyName, double value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : string * double -&gt; unit" Usage="utf8JsonWriter.WriteNumber (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.Double" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (string propertyName, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(string propertyName, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (propertyName As String, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(System::String ^ propertyName, int value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : string * int -&gt; unit" Usage="utf8JsonWriter.WriteNumber (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.Int32" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (string propertyName, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(string propertyName, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (propertyName As String, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(System::String ^ propertyName, long value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : string * int64 -&gt; unit" Usage="utf8JsonWriter.WriteNumber (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.Int64" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (string propertyName, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(string propertyName, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.String,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (propertyName As String, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(System::String ^ propertyName, float value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : string * single -&gt; unit" Usage="utf8JsonWriter.WriteNumber (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.Single" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (string propertyName, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(string propertyName, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.String,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (propertyName As String, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(System::String ^ propertyName, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : string * uint32 -&gt; unit" Usage="utf8JsonWriter.WriteNumber (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.UInt32" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumber">
      <MemberSignature Language="C#" Value="public void WriteNumber (string propertyName, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumber(string propertyName, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumber(System.String,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumber (propertyName As String, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumber(System::String ^ propertyName, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumber : string * uint64 -&gt; unit" Usage="utf8JsonWriter.WriteNumber (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como un número de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.UInt64" /> (como un número JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumberValue">
      <MemberSignature Language="C#" Value="public void WriteNumberValue (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumberValue(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumberValue(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumberValue (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumberValue(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumberValue : decimal -&gt; unit" Usage="utf8JsonWriter.WriteNumberValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir como un número de JSON como un elemento de una matriz de JSON.</param>
        <summary>Escribe el valor <see cref="T:System.Decimal" /> (como un número JSON) como elemento de una matriz JSON.</summary>
        <remarks>Este método escribe el <see cref="T:System.Decimal" /> con el valor predeterminado de valor <see cref="T:System.Buffers.StandardFormat" /> (es decir, "G").</remarks>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumberValue">
      <MemberSignature Language="C#" Value="public void WriteNumberValue (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumberValue(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumberValue(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumberValue (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumberValue(double value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumberValue : double -&gt; unit" Usage="utf8JsonWriter.WriteNumberValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir como un número de JSON como un elemento de una matriz de JSON.</param>
        <summary>Escribe el valor <see cref="T:System.Double" /> (como un número JSON) como elemento de una matriz JSON.</summary>
        <remarks>Este método escribe el <see cref="T:System.Double" /> con el valor predeterminado de valor <see cref="T:System.Buffers.StandardFormat" /> (es decir, "G").</remarks>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumberValue">
      <MemberSignature Language="C#" Value="public void WriteNumberValue (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumberValue(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumberValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumberValue (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumberValue(int value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumberValue : int -&gt; unit" Usage="utf8JsonWriter.WriteNumberValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir como un número de JSON como un elemento de una matriz de JSON.</param>
        <summary>Escribe el valor <see cref="T:System.Int32" /> (como un número JSON) como elemento de una matriz JSON.</summary>
        <remarks>Este método escribe el <see cref="T:System.Int32" /> con el valor predeterminado de valor <see cref="T:System.Buffers.StandardFormat" /> (es decir, "G"). Por ejemplo, 32767.</remarks>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumberValue">
      <MemberSignature Language="C#" Value="public void WriteNumberValue (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumberValue(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumberValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumberValue (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumberValue(long value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumberValue : int64 -&gt; unit" Usage="utf8JsonWriter.WriteNumberValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir como un número de JSON como un elemento de una matriz de JSON.</param>
        <summary>Escribe el valor <see cref="T:System.Int64" /> (como un número JSON) como elemento de una matriz JSON.</summary>
        <remarks>Este método escribe el <see cref="T:System.Int64" /> con el valor predeterminado de valor <see cref="T:System.Buffers.StandardFormat" /> (es decir, "G"). Por ejemplo, 32767.</remarks>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumberValue">
      <MemberSignature Language="C#" Value="public void WriteNumberValue (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumberValue(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumberValue(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumberValue (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumberValue(float value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumberValue : single -&gt; unit" Usage="utf8JsonWriter.WriteNumberValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir como un número de JSON como un elemento de una matriz de JSON.</param>
        <summary>Escribe el valor <see cref="T:System.Single" /> (como un número JSON) como elemento de una matriz JSON.</summary>
        <remarks>Este método escribe el <see cref="T:System.Single" /> con el valor predeterminado de valor <see cref="T:System.Buffers.StandardFormat" /> (es decir, "G").</remarks>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumberValue">
      <MemberSignature Language="C#" Value="public void WriteNumberValue (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumberValue(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumberValue(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumberValue (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumberValue(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumberValue : uint32 -&gt; unit" Usage="utf8JsonWriter.WriteNumberValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir como un número de JSON como un elemento de una matriz de JSON.</param>
        <summary>Escribe el valor <see cref="T:System.UInt32" /> (como un número JSON) como elemento de una matriz JSON.</summary>
        <remarks>Este método escribe el <see cref="T:System.UInt32" /> con el valor predeterminado de valor <see cref="T:System.Buffers.StandardFormat" /> (es decir, "G"). Por ejemplo, 32767.</remarks>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNumberValue">
      <MemberSignature Language="C#" Value="public void WriteNumberValue (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteNumberValue(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteNumberValue(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteNumberValue (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteNumberValue(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.WriteNumberValue : uint64 -&gt; unit" Usage="utf8JsonWriter.WriteNumberValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir como un número de JSON como un elemento de una matriz de JSON.</param>
        <summary>Escribe el valor <see cref="T:System.UInt64" /> (como un número JSON) como elemento de una matriz JSON.</summary>
        <remarks>Este método escribe el <see cref="T:System.UInt64" /> con el valor predeterminado de valor <see cref="T:System.Buffers.StandardFormat" /> (es decir, "G"). Por ejemplo, 32767.</remarks>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartArray">
      <MemberSignature Language="C#" Value="public void WriteStartArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStartArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteStartArray" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStartArray ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStartArray();" />
      <MemberSignature Language="F#" Value="member this.WriteStartArray : unit -&gt; unit" Usage="utf8JsonWriter.WriteStartArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Escribe el principio de una matriz de JSON.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000.

O bien

La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartArray">
      <MemberSignature Language="C#" Value="public void WriteStartArray (ReadOnlySpan&lt;byte&gt; utf8PropertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStartArray(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteStartArray(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStartArray (utf8PropertyName As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStartArray(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName);" />
      <MemberSignature Language="F#" Value="member this.WriteStartArray : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="utf8JsonWriter.WriteStartArray utf8PropertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 de la matriz JSON que se va a escribir.</param>
        <summary>Escribe el principio de una matriz JSON con un nombre de propiedad especificado como intervalo de bytes de solo lectura como la clave.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000.

O bien
       
La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartArray">
      <MemberSignature Language="C#" Value="public void WriteStartArray (ReadOnlySpan&lt;char&gt; propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStartArray(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteStartArray(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStartArray (propertyName As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStartArray(ReadOnlySpan&lt;char&gt; propertyName);" />
      <MemberSignature Language="F#" Value="member this.WriteStartArray : ReadOnlySpan&lt;char&gt; -&gt; unit" Usage="utf8JsonWriter.WriteStartArray propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 de la matriz de JSON que se va a transcodificar y escribir como UTF-8.</param>
        <summary>Escribe el principio de una matriz JSON con un nombre de propiedad especificado como intervalo de caracteres de solo lectura como la clave.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000.

O bien
       
La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartArray">
      <MemberSignature Language="C#" Value="public void WriteStartArray (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStartArray(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteStartArray(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStartArray (propertyName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStartArray(System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="member this.WriteStartArray : string -&gt; unit" Usage="utf8JsonWriter.WriteStartArray propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 de la matriz de JSON que se va a transcodificar y escribir como UTF-8.</param>
        <summary>Escribe el principio de una matriz JSON con un nombre de propiedad especificado como cadena como la clave.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000.

O bien
       
La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartObject">
      <MemberSignature Language="C#" Value="public void WriteStartObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStartObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteStartObject" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStartObject ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStartObject();" />
      <MemberSignature Language="F#" Value="member this.WriteStartObject : unit -&gt; unit" Usage="utf8JsonWriter.WriteStartObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Escribe el principio de un objeto de JSON.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000.

O bien

La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartObject">
      <MemberSignature Language="C#" Value="public void WriteStartObject (ReadOnlySpan&lt;byte&gt; utf8PropertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStartObject(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteStartObject(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStartObject (utf8PropertyName As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStartObject(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName);" />
      <MemberSignature Language="F#" Value="member this.WriteStartObject : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="utf8JsonWriter.WriteStartObject utf8PropertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <summary>Escribe el principio de un objeto JSON con un nombre de propiedad especificado como intervalo de bytes de solo lectura como la clave.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000. 

O bien
       
La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartObject">
      <MemberSignature Language="C#" Value="public void WriteStartObject (ReadOnlySpan&lt;char&gt; propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStartObject(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteStartObject(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStartObject (propertyName As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStartObject(ReadOnlySpan&lt;char&gt; propertyName);" />
      <MemberSignature Language="F#" Value="member this.WriteStartObject : ReadOnlySpan&lt;char&gt; -&gt; unit" Usage="utf8JsonWriter.WriteStartObject propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <summary>Escribe el principio de un objeto JSON con un nombre de propiedad especificado como intervalo de caracteres de solo lectura como la clave.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000. 

O bien
       
La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartObject">
      <MemberSignature Language="C#" Value="public void WriteStartObject (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStartObject(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteStartObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStartObject (propertyName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStartObject(System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="member this.WriteStartObject : string -&gt; unit" Usage="utf8JsonWriter.WriteStartObject propertyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <summary>Escribe el principio de un objeto JSON con un nombre de propiedad especificado como cadena como la clave.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La profundidad del archivo JSON supera la profundidad máxima de 1000. 

O bien
       
La validación está habilitada y esta operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (ReadOnlySpan&lt;byte&gt; utf8PropertyName, DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Byte},System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (utf8PropertyName As ReadOnlySpan(Of Byte), value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, DateTime value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : ReadOnlySpan&lt;byte&gt; * DateTime -&gt; unit" Usage="utf8JsonWriter.WriteString (utf8PropertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad UTF-8 y el valor <see cref="T:System.DateTime" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (ReadOnlySpan&lt;byte&gt; utf8PropertyName, DateTimeOffset value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, valuetype System.DateTimeOffset value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Byte},System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (utf8PropertyName As ReadOnlySpan(Of Byte), value As DateTimeOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, DateTimeOffset value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : ReadOnlySpan&lt;byte&gt; * DateTimeOffset -&gt; unit" Usage="utf8JsonWriter.WriteString (utf8PropertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad UTF-8 y el valor <see cref="T:System.DateTimeOffset" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (ReadOnlySpan&lt;byte&gt; utf8PropertyName, Guid value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, valuetype System.Guid value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Byte},System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (utf8PropertyName As ReadOnlySpan(Of Byte), value As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, Guid value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : ReadOnlySpan&lt;byte&gt; * Guid -&gt; unit" Usage="utf8JsonWriter.WriteString (utf8PropertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad UTF-8 y el valor <see cref="T:System.Guid" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (ReadOnlySpan&lt;byte&gt; utf8PropertyName, ReadOnlySpan&lt;byte&gt; utf8Value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (utf8PropertyName As ReadOnlySpan(Of Byte), utf8Value As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, ReadOnlySpan&lt;System::Byte&gt; utf8Value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="utf8JsonWriter.WriteString (utf8PropertyName, utf8Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="utf8Value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <param name="utf8Value">Valor con codificación UTF-8 que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad UTF-8 y el valor de texto UTF-8 (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad y el valor es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (ReadOnlySpan&lt;byte&gt; utf8PropertyName, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (utf8PropertyName As ReadOnlySpan(Of Byte), value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;char&gt; -&gt; unit" Usage="utf8JsonWriter.WriteString (utf8PropertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <param name="value">Valor con codificación UTF-16 que se va escribir como una cadena de JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad UTF-8 y el valor de texto UTF-16 (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad y el valor es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (ReadOnlySpan&lt;byte&gt; utf8PropertyName, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8PropertyName, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Byte},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (utf8PropertyName As ReadOnlySpan(Of Byte), value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(ReadOnlySpan&lt;System::Byte&gt; utf8PropertyName, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : ReadOnlySpan&lt;byte&gt; * string -&gt; unit" Usage="utf8JsonWriter.WriteString (utf8PropertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8PropertyName" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="utf8PropertyName">Nombre de propiedad con codificación UTF-8 del objeto JSON que se va a escribir.</param>
        <param name="value">Valor con codificación UTF-16 que se va escribir como una cadena de JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad UTF-8 y el valor de texto de cadena (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad y el valor es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (ReadOnlySpan&lt;char&gt; propertyName, DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Char},System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (propertyName As ReadOnlySpan(Of Char), value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(ReadOnlySpan&lt;char&gt; propertyName, DateTime value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : ReadOnlySpan&lt;char&gt; * DateTime -&gt; unit" Usage="utf8JsonWriter.WriteString (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.DateTime" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (ReadOnlySpan&lt;char&gt; propertyName, DateTimeOffset value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, valuetype System.DateTimeOffset value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Char},System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (propertyName As ReadOnlySpan(Of Char), value As DateTimeOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(ReadOnlySpan&lt;char&gt; propertyName, DateTimeOffset value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : ReadOnlySpan&lt;char&gt; * DateTimeOffset -&gt; unit" Usage="utf8JsonWriter.WriteString (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="value" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.DateTimeOffset" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (ReadOnlySpan&lt;char&gt; propertyName, Guid value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, valuetype System.Guid value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Char},System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (propertyName As ReadOnlySpan(Of Char), value As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(ReadOnlySpan&lt;char&gt; propertyName, Guid value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : ReadOnlySpan&lt;char&gt; * Guid -&gt; unit" Usage="utf8JsonWriter.WriteString (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="value" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como intervalo de caracteres de solo lectura y el valor <see cref="T:System.Guid" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (ReadOnlySpan&lt;char&gt; propertyName, ReadOnlySpan&lt;byte&gt; utf8Value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (propertyName As ReadOnlySpan(Of Char), utf8Value As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(ReadOnlySpan&lt;char&gt; propertyName, ReadOnlySpan&lt;System::Byte&gt; utf8Value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="utf8JsonWriter.WriteString (propertyName, utf8Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="utf8Value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="utf8Value">Valor con codificación UTF-8 que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad UTF-16 y el valor de texto UTF-8 (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad y el valor es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (ReadOnlySpan&lt;char&gt; propertyName, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (propertyName As ReadOnlySpan(Of Char), value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(ReadOnlySpan&lt;char&gt; propertyName, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; unit" Usage="utf8JsonWriter.WriteString (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor con codificación UTF-16 que se va escribir como una cadena de JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad UTF-16 y el valor de texto UTF-16 (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad y el valor es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (ReadOnlySpan&lt;char&gt; propertyName, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(valuetype System.ReadOnlySpan`1&lt;char&gt; propertyName, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.ReadOnlySpan{System.Char},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (propertyName As ReadOnlySpan(Of Char), value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(ReadOnlySpan&lt;char&gt; propertyName, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : ReadOnlySpan&lt;char&gt; * string -&gt; unit" Usage="utf8JsonWriter.WriteString (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor con codificación UTF-16 que se va escribir como una cadena de JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad UTF-16 y el valor de texto de cadena (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad y el valor es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (string propertyName, DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(string propertyName, valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (propertyName As String, value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(System::String ^ propertyName, DateTime value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : string * DateTime -&gt; unit" Usage="utf8JsonWriter.WriteString (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.DateTime" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (string propertyName, DateTimeOffset value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(string propertyName, valuetype System.DateTimeOffset value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.String,System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (propertyName As String, value As DateTimeOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(System::String ^ propertyName, DateTimeOffset value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : string * DateTimeOffset -&gt; unit" Usage="utf8JsonWriter.WriteString (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.DateTimeOffset" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (string propertyName, Guid value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(string propertyName, valuetype System.Guid value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.String,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (propertyName As String, value As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(System::String ^ propertyName, Guid value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : string * Guid -&gt; unit" Usage="utf8JsonWriter.WriteString (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como cadena y el valor <see cref="T:System.Guid" /> (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (string propertyName, ReadOnlySpan&lt;byte&gt; utf8Value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(string propertyName, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.String,System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (propertyName As String, utf8Value As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(System::String ^ propertyName, ReadOnlySpan&lt;System::Byte&gt; utf8Value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : string * ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="utf8JsonWriter.WriteString (propertyName, utf8Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="utf8Value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="utf8Value">Valor con codificación UTF-8 que se va escribir como una cadena de JSON como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como cadena y el valor de texto UTF-8 (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad y el valor es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (string propertyName, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(string propertyName, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.String,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (propertyName As String, value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(System::String ^ propertyName, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : string * ReadOnlySpan&lt;char&gt; -&gt; unit" Usage="utf8JsonWriter.WriteString (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor con codificación UTF-16 que se va escribir como una cadena de JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como cadena y el valor de texto UTF-16 (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad y el valor es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public void WriteString (string propertyName, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteString(string propertyName, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteString (propertyName As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteString(System::String ^ propertyName, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.WriteString : string * string -&gt; unit" Usage="utf8JsonWriter.WriteString (propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nombre de propiedad con codificación UTF-16 del objeto JSON que se va a transcodificar y escribir como UTF-8.</param>
        <param name="value">Valor con codificación UTF-16 que se va escribir como una cadena de JSON transcodificada a UTF-8 como parte del par nombre-valor.</param>
        <summary>Escribe el nombre de propiedad especificado como cadena y el valor de texto de cadena (como una cadena JSON) como parte de un par nombre-valor de un objeto JSON.</summary>
        <remarks>
          <format><![CDATA[

El nombre de propiedad y el valor es de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor o nombre de propiedad especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStringValue">
      <MemberSignature Language="C#" Value="public void WriteStringValue (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStringValue(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteStringValue(System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStringValue (value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStringValue(DateTime value);" />
      <MemberSignature Language="F#" Value="member this.WriteStringValue : DateTime -&gt; unit" Usage="utf8JsonWriter.WriteStringValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir como una cadena de JSON como un elemento de una matriz de JSON.</param>
        <summary>Escribe el valor <see cref="T:System.DateTime" /> (como una cadena JSON) como elemento de una matriz JSON.</summary>
        <remarks>Este método escribe el <see cref="T:System.DateTime" /> utilizando la ida y vuelta (' o ') <see cref="T:System.Buffers.StandardFormat" />. Por ejemplo, 2017-06-12T05:30:45.7680000.</remarks>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStringValue">
      <MemberSignature Language="C#" Value="public void WriteStringValue (DateTimeOffset value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStringValue(valuetype System.DateTimeOffset value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteStringValue(System.DateTimeOffset)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStringValue (value As DateTimeOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStringValue(DateTimeOffset value);" />
      <MemberSignature Language="F#" Value="member this.WriteStringValue : DateTimeOffset -&gt; unit" Usage="utf8JsonWriter.WriteStringValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTimeOffset" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir como una cadena de JSON como un elemento de una matriz de JSON.</param>
        <summary>Escribe el valor <see cref="T:System.DateTimeOffset" /> (como una cadena JSON) como elemento de una matriz JSON.</summary>
        <remarks>Este método escribe el <see cref="T:System.DateTimeOffset" /> utilizando la ida y vuelta (' o ') <see cref="T:System.Buffers.StandardFormat" />. Por ejemplo, 2017-06-12T05:30:45.7680000-07:00.</remarks>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStringValue">
      <MemberSignature Language="C#" Value="public void WriteStringValue (Guid value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStringValue(valuetype System.Guid value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteStringValue(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStringValue (value As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStringValue(Guid value);" />
      <MemberSignature Language="F#" Value="member this.WriteStringValue : Guid -&gt; unit" Usage="utf8JsonWriter.WriteStringValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir como una cadena de JSON como un elemento de una matriz de JSON.</param>
        <summary>Escribe el valor <see cref="T:System.Guid" /> (como una cadena JSON) como elemento de una matriz JSON.</summary>
        <remarks>Este método escribe el <see cref="T:System.Guid" /> con el valor predeterminado de valor <see cref="T:System.Buffers.StandardFormat" /> (es decir, tenía '), como el formulario: nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn.</remarks>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación daría lugar a la escritura de JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStringValue">
      <MemberSignature Language="C#" Value="public void WriteStringValue (ReadOnlySpan&lt;byte&gt; utf8Value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStringValue(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteStringValue(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStringValue (utf8Value As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStringValue(ReadOnlySpan&lt;System::Byte&gt; utf8Value);" />
      <MemberSignature Language="F#" Value="member this.WriteStringValue : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="utf8JsonWriter.WriteStringValue utf8Value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="utf8Value">El valor con codificación UTF-8 que se va a escribir como un elemento de cadena de JSON de una matriz de JSON.</param>
        <summary>Escribe el valor de texto UTF-8 (como una cadena JSON) como elemento de una matriz JSON.</summary>
        <remarks>
          <format><![CDATA[

El valor de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStringValue">
      <MemberSignature Language="C#" Value="public void WriteStringValue (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStringValue(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteStringValue(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStringValue (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStringValue(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.WriteStringValue : ReadOnlySpan&lt;char&gt; -&gt; unit" Usage="utf8JsonWriter.WriteStringValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">Valor con codificación UTF-16 que se va a escribir como un elemento de cadena de JSON transcodificado a UTF-8 de una matriz de JSON.</param>
        <summary>Escribe el valor de texto UTF-16 (como una cadena JSON) como elemento de una matriz JSON.</summary>
        <remarks>
          <format><![CDATA[

El valor de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStringValue">
      <MemberSignature Language="C#" Value="public void WriteStringValue (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteStringValue(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Utf8JsonWriter.WriteStringValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteStringValue (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteStringValue(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.WriteStringValue : string -&gt; unit" Usage="utf8JsonWriter.WriteStringValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valor con codificación UTF-16 que se va a escribir como un elemento de cadena de JSON transcodificado a UTF-8 de una matriz de JSON.</param>
        <summary>Escribe el valor de texto de cadena (como una cadena JSON) como elemento de una matriz JSON.</summary>
        <remarks>
          <format><![CDATA[

El valor de escape antes de la escritura.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor especificado es demasiado grande.</exception>
        <exception cref="T:System.InvalidOperationException">La validación está habilitada y la operación de escritura generaría un JSON no válido.</exception>
      </Docs>
    </Member>
  </Members>
</Type>