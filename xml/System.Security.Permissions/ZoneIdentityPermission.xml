<Type Name="ZoneIdentityPermission" FullName="System.Security.Permissions.ZoneIdentityPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bac0e8f306739a9bfc95d93e0faaa004ab7ceb3b" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30500059" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ZoneIdentityPermission : System.Security.CodeAccessPermission" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit ZoneIdentityPermission extends System.Security.CodeAccessPermission" />
  <TypeSignature Language="DocId" Value="T:System.Security.Permissions.ZoneIdentityPermission" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ZoneIdentityPermission&#xA;Inherits CodeAccessPermission" />
  <TypeSignature Language="C++ CLI" Value="public ref class ZoneIdentityPermission sealed : System::Security::CodeAccessPermission" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.CodeAccessPermission</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Define el permiso de identidad para la zona desde la que se origina el código. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este permiso puede determinar si el código de llamada es de una zona determinada. Las zonas se configuran según las opciones de Microsoft Internet Explorer y se asignan desde la dirección URL de Internet Explorer IInternetSecurityManager y las API relacionadas. Solo coincidencias exactas de zona se definen para el permiso; una dirección URL sólo puede pertenecer a una zona.  
  
-   Zona de intranet local: zona de intranet Local se utiliza para contenido situado en la intranet de la compañía. Dado que los servidores están dentro del firewall de la compañía, contenido en la intranet se asigna un nivel más alto de confianza.  
  
-   Zona de sitios de confianza: zona de sitios de confianza se utiliza para contenido situado en sitios Web que se consideran más serios y confiables que otros sitios en Internet. Los usuarios pueden utilizar esta zona para asignar un nivel más alto de confianza para sitios de Internet específicos. El usuario debe asignar a esta zona las direcciones URL de los sitios Web de confianza. De forma predeterminada, los sitios en la zona de sitios de confianza no reciben ninguna confianza mayor que los de la zona de Internet. Un usuario o empresa necesita cambiar el nivel de confianza concedido a esta zona si desean que los sitios que contiene para proporcionar un mayor nivel de confianza.  
  
-   Zona de Internet: zona de Internet se usa para los sitios Web en Internet que no pertenecen a otra zona. La configuración predeterminada permite al código descargado de estos sitios mínima acceso a los recursos en el equipo del usuario. Sitios Web que no se asignan automáticamente a otras zonas pertenecen a esta zona.  
  
-   Zona de sitios restringidos: la zona Sitios restringidos se utiliza para los sitios Web que incluyen contenido que podría provocar o haber provocado anteriormente, problemas al descargarse. Esta zona podría usarse para evitar que código descargado de estos sitios no se ejecuten en el equipo del usuario. El usuario debe asignar a esta zona las direcciones URL de los sitios Web que no son de confianza.  
  
-   Zona equipo local: zona de equipo Local es una zona implícita que se utiliza para el contenido que existe en el equipo del usuario. El contenido que se encuentra en el equipo del usuario, excepto el contenido almacenado en caché por Internet Explorer en el sistema local, se trata con un nivel muy alto de confianza.  
  
> [!IMPORTANT]
>  A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], no se utilizan los permisos de identidad.  
>   
>  En las versiones 1.0 y 1.1 de .NET Framework, las peticiones en los permisos de identidad son efectivos, incluso cuando el ensamblado que realiza la llamada es de plena confianza. Es decir, aunque el ensamblado que realiza la llamada no tiene plena confianza, una petición para un permiso de identidad se produce un error si el ensamblado no cumple los criterios requeridos. A partir de la versión 2.0 de .NET Framework, las solicitudes de permisos de identidad son efectivas si el ensamblado que realiza la llamada tiene plena confianza. Esto garantiza la coherencia para todos los permisos, lo que elimina el tratamiento de los permisos de identidad como un caso especial.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.Permissions.ZoneIdentityPermissionAttribute" />
    <altmember cref="T:System.Security.Policy.Zone" />
    <altmember cref="T:System.Security.Policy.ZoneMembershipCondition" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Permissions.ZoneIdentityPermission" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ZoneIdentityPermission (System.Security.Permissions.PermissionState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Security.Permissions.PermissionState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.ZoneIdentityPermission.#ctor(System.Security.Permissions.PermissionState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (state As PermissionState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ZoneIdentityPermission(System::Security::Permissions::PermissionState state);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="state" Type="System.Security.Permissions.PermissionState" />
      </Parameters>
      <Docs>
        <param name="state">Uno de los valores de <see cref="T:System.Security.Permissions.PermissionState" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Permissions.ZoneIdentityPermission" /> con el objeto <see cref="T:System.Security.Permissions.PermissionState" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea un totalmente restringido (`None`) o `Unrestricted` permiso.  
  
> [!NOTE]
>  En las versiones 1.0 y 1.1 de .NET Framework, los permisos de identidad no pueden tener un <xref:System.Security.Permissions.PermissionState.Unrestricted> valor de estado de permiso. A partir de la versión 2.0 de .NET Framework, los permisos de identidad pueden tener cualquier valor de estado de permiso. Esto significa que en las versiones 2.0 y versiones posteriores, los permisos de identidad tienen el mismo comportamiento que los permisos que implementan la <xref:System.Security.Permissions.IUnrestrictedPermission> interfaz. Es decir, una petición para una identidad siempre se realiza correctamente, independientemente de la identidad del ensamblado, si el ensamblado se ha concedido plena confianza.  
  
 En las versiones 1.0 y 1.1 de .NET Framework, las peticiones en los permisos de identidad son efectivos, incluso cuando el ensamblado que realiza la llamada es de plena confianza. Es decir, aunque el ensamblado que realiza la llamada no tiene plena confianza, una petición para un permiso de identidad se produce un error si el ensamblado no cumple los criterios requeridos. A partir de la versión 2.0 de .NET Framework, las solicitudes de permisos de identidad son efectivas si el ensamblado que realiza la llamada tiene plena confianza. Esto garantiza la coherencia para todos los permisos, lo que elimina el tratamiento de los permisos de identidad como un caso especial.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Security.Permissions.ZoneIdentityPermission.%23ctor%28System.Security.Permissions.PermissionState%29?displayProperty=nameWithType> constructor.  
  
 [!code-csharp[System.Security.Permissions.ZoneIdentityPermission#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.ZoneIdentityPermission/CS/zoneidentity.cs#7)]
 [!code-vb[System.Security.Permissions.ZoneIdentityPermission#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.ZoneIdentityPermission/VB/zoneidentity.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="state" /> no es un valor válido de <see cref="T:System.Security.Permissions.PermissionState" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ZoneIdentityPermission (System.Security.SecurityZone zone);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Security.SecurityZone zone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.ZoneIdentityPermission.#ctor(System.Security.SecurityZone)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (zone As SecurityZone)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ZoneIdentityPermission(System::Security::SecurityZone zone);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="zone" Type="System.Security.SecurityZone" />
      </Parameters>
      <Docs>
        <param name="zone">Identificador de la zona.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.Permissions.ZoneIdentityPermission" /> que representa la identidad de zona especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Security.Permissions.ZoneIdentityPermission.%23ctor%28System.Security.SecurityZone%29?displayProperty=nameWithType> constructor.  
  
 [!code-csharp[System.Security.Permissions.ZoneIdentityPermission#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.ZoneIdentityPermission/CS/zoneidentity.cs#8)]
 [!code-vb[System.Security.Permissions.ZoneIdentityPermission#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.ZoneIdentityPermission/VB/zoneidentity.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.ZoneIdentityPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea y devuelve una copia idéntica del permiso actual.</summary>
        <returns>Copia del permiso actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una copia de un permiso representa el mismo acceso a los recursos que el permiso original.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public override void FromXml (System.Security.SecurityElement esd);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXml(class System.Security.SecurityElement esd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.ZoneIdentityPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXml (esd As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXml(System::Security::SecurityElement ^ esd);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="esd" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="esd">Codificación XML que se usa para reconstruir el permiso.</param>
        <summary>Reconstruye un permiso con un estado especificado a partir de una codificación XML.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="esd" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="esd" /> no es un elemento de permiso válido.  
  
 O bien  
  
 El número de versión del parámetro <paramref name="esd" /> no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.ZoneIdentityPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Permiso para formar intersección con el permiso actual. Debe ser del mismo tipo que el permiso actual.</param>
        <summary>Crea y devuelve un permiso que es la intersección del permiso actual y el permiso especificado.</summary>
        <returns>Nuevo permiso que representa la intersección del permiso actual y del permiso especificado. Este nuevo permiso es <see langword="null" /> si la intersección está vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La intersección de dos permisos es un permiso que describe el conjunto de operaciones descritas en ambos. Solo una petición que pase ambos permisos originales aprobará la intersección.  
  
 La intersección de dos idénticos <xref:System.Security.Permissions.ZoneIdentityPermission> objetos es el mismo permiso. Cualquier otra combinación da como resultado un permiso que es `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="target" /> no es <see langword="null" /> y tampoco es del mismo tipo que el permiso actual.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public override bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.ZoneIdentityPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Permiso que se va a probar para la relación de subconjunto. Este permiso debe ser del mismo tipo que el permiso actual.</param>
        <summary>Determina si el permiso actual es un subconjunto del permiso especificado.</summary>
        <returns>
          <see langword="true" /> si el permiso actual es un subconjunto del permiso especificado; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El permiso actual es un subconjunto del permiso especificado si los dos permisos son iguales o si el permiso actual representa la <xref:System.Security.SecurityZone.NoZone> zona de seguridad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="target" /> no es <see langword="null" />, este permiso no representa la zona de seguridad <see cref="F:System.Security.SecurityZone.NoZone" /> y el permiso especificado no es igual que el permiso actual.</exception>
      </Docs>
    </Member>
    <Member MemberName="SecurityZone">
      <MemberSignature Language="C#" Value="public System.Security.SecurityZone SecurityZone { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityZone SecurityZone" />
      <MemberSignature Language="DocId" Value="P:System.Security.Permissions.ZoneIdentityPermission.SecurityZone" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityZone As SecurityZone" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::SecurityZone SecurityZone { System::Security::SecurityZone get(); void set(System::Security::SecurityZone value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityZone</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la zona representada por el <see cref="T:System.Security.Permissions.ZoneIdentityPermission" /> actual.</summary>
        <value>Uno de los valores de <see cref="T:System.Security.SecurityZone" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El valor de parámetro no es un valor válido para <see cref="T:System.Security.SecurityZone" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public override System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.ZoneIdentityPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::SecurityElement ^ ToXml();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una codificación XML del permiso y su estado actual.</summary>
        <returns>Codificación XML del permiso, incluida cualquier información de estado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Union (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Union(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.ZoneIdentityPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Union (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Union(System::Security::IPermission ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Permiso para combinar con el permiso actual. Debe ser del mismo tipo que el permiso actual.</param>
        <summary>Crea un permiso que es la unión del permiso actual y el permiso especificado.</summary>
        <returns>Nuevo permiso que representa la unión del permiso actual y el especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El resultado de una llamada a <xref:System.Security.Permissions.ZoneIdentityPermission.Union%2A> es un permiso que representa la zona de seguridad representada por el permiso actual y el permiso especificado. Cualquier solicitud que pase alguno de estos permisos pasa también su unión. La unión de dos idénticos <xref:System.Security.Permissions.ZoneIdentityPermission> objetos es el mismo permiso. La unión de un permiso nulo y un <xref:System.Security.Permissions.ZoneIdentityPermission> permiso es el que no sea null.  
  
 Tenga en cuenta que un <xref:System.Security.Permissions.ZoneIdentityPermission> objeto que representa un <xref:System.Security.SecurityZone.NoZone> zona de seguridad se tratan como un permiso nulo y se tratan como un caso especial. La unión de un <xref:System.Security.Permissions.ZoneIdentityPermission> objeto que representa la <xref:System.Security.SecurityZone.NoZone> zona de seguridad y un permiso null es null. La unión de dos permisos de identidad de zona diferentes da como resultado un <xref:System.ArgumentException> excepción producida cuando ninguno de los dos permisos representa la <xref:System.Security.SecurityZone.NoZone> zona de seguridad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="target" /> no es <see langword="null" /> y tampoco es del mismo tipo que el permiso actual.  
  
 O bien  
  
 Los dos permisos no son iguales y el permiso actual no representa la zona de seguridad <see cref="F:System.Security.SecurityZone.NoZone" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>