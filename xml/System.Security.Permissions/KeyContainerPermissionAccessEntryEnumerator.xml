<Type Name="KeyContainerPermissionAccessEntryEnumerator" FullName="System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="da65806156c94207fb56fded67eb2366db905e0f" /><Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/27/2018" /><Meta Name="ms.locfileid" Value="52376078" /></Metadata><TypeSignature Language="C#" Value="public sealed class KeyContainerPermissionAccessEntryEnumerator : System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit KeyContainerPermissionAccessEntryEnumerator extends System.Object implements class System.Collections.IEnumerator" />
  <TypeSignature Language="DocId" Value="T:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class KeyContainerPermissionAccessEntryEnumerator&#xA;Implements IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class KeyContainerPermissionAccessEntryEnumerator sealed : System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type KeyContainerPermissionAccessEntryEnumerator = class&#xA;    interface IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa el enumerador de los objetos <see cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntry" /> en un elemento <see cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los enumeradores permiten solo lectura de los datos de la colección. No se puede usar enumeradores para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. El <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Reset%2A> método también devuelve el enumerador a esta posición. En esta posición, una llamada a la <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> propiedad produce una excepción. Por lo tanto, debe llamar a la <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> método para hacer avanzar el enumerador hasta el primer elemento de la colección antes de leer el valor de la <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> propiedad.  
  
 <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> o a <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Reset%2A>. <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> establece <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> en el siguiente elemento.  
  
 Cuando se pasa el final de la colección, el enumerador se coloca detrás del último elemento de la colección y si se llama al método <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> devuelve `false`. Si la última llamada a <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> devuelve `false`, al llamar a <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> produce una excepción. Para restablecer <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> al primer elemento de la colección, llame a <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Reset%2A> seguido por una llamada a <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A>.  
  
 Un enumerador es válido mientras la colección no cambie. Si se realizan cambios en la colección, como agregar, modificar, o eliminar elementos, el enumerador queda invalida invalidado y la siguiente llamada a <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> o <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Reset%2A> produce una <xref:System.InvalidOperationException>. Si la colección se modifica entre llamar a <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> y <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A>, <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> devuelve el elemento al que está establecido actualmente, incluso si el enumerador ya se ha invalidado.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public KeyContainerPermissionAccessEntryEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; KeyContainerPermissionAccessEntryEnumerator();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Security.Permissions.KeyContainerPermissionAccessEntry Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Permissions.KeyContainerPermissionAccessEntry Current" />
      <MemberSignature Language="DocId" Value="P:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As KeyContainerPermissionAccessEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Permissions::KeyContainerPermissionAccessEntry ^ Current { System::Security::Permissions::KeyContainerPermissionAccessEntry ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Security.Permissions.KeyContainerPermissionAccessEntry" Usage="System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Permissions.KeyContainerPermissionAccessEntry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la entrada actual de la colección.</summary>
        <value>El objeto <see cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntry" /> actual de la colección.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se crea el enumerador, no apunta a un objeto, por lo que el <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> propiedad no es válida y se iniciará una excepción si se tiene acceso. Debe llamar primero a la <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> método para colocar el cursor en el primer objeto de la colección.  
  
 Obteniendo el <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> propiedad varias veces con ninguna llamada intermedia a <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> devolverá el mismo <xref:System.Security.Permissions.KeyContainerPermissionAccessEntry> objeto cada vez.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se tiene acceso a la propiedad <see cref="P:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current" /> antes de llamar por primera vez al método <see cref="M:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext" />. El cursor se encuentra ubicado delante del primer objeto de la colección.  
  
O bien 
Se tiene acceso a la propiedad <see cref="P:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current" /> después de que una llamada al método <see cref="M:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext" /> devuelva <see langword="false" />, lo que indica que el cursor se encuentra después del último objeto de la colección.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="keyContainerPermissionAccessEntryEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se desplaza al siguiente elemento de la colección.</summary>
        <returns>Es <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; es <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> devuelve del método `false` inmediatamente si no hay ningún objeto en la colección.  
  
 <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> Devuelve `true` hasta que ha llegado al final de la colección. A continuación, devuelve `false` para cada llamada sucesiva. Sin embargo, una vez <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> ha devuelto `false`, al acceder a la <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> propiedad produce una excepción.  
  
 Tras su creación, el enumerador se coloca antes del primer <xref:System.Security.Permissions.KeyContainerPermissionAccessEntry> objeto en la colección y la primera llamada a <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> coloca el enumerador al primer objeto de la colección.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="keyContainerPermissionAccessEntryEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el enumerador al principio de la colección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un enumerador se desplaza en una dirección de solo avance. Utilice este método para volver al principio de la colección.  
  
 El <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Reset%2A> método coloca el cursor en el primer objeto de la colección. Después de llamar a <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Reset%2A>, no es necesario llamar a <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.MoveNext%2A> para mover el cursor hacia delante al primer objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto actual de la colección.</summary>
        <value>Objeto actual de la colección.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No llame a este método; Utilice el <xref:System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator.Current%2A> propiedad en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>