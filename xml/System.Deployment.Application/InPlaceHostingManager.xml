<Type Name="InPlaceHostingManager" FullName="System.Deployment.Application.InPlaceHostingManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="68d7f05548565a28b549d7712be953879fb97710" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="37666866" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class InPlaceHostingManager : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InPlaceHostingManager extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Deployment.Application.InPlaceHostingManager" />
  <TypeSignature Language="VB.NET" Value="Public Class InPlaceHostingManager&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class InPlaceHostingManager : IDisposable" />
  <TypeSignature Language="F#" Value="type InPlaceHostingManager = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Deployment</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Instala o actualiza una implementación de ClickOnce en un equipo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar <xref:System.Deployment.Application.InPlaceHostingManager> escribir programas de instalación [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicaciones mediante programación. Por ejemplo, puede usar esta clase en un entorno de software (SMS) de administración de controladas del sistema o en situaciones donde es necesario una instalación compleja que realiza una serie de operaciones previas o posteriores a la instalación en el equipo local. Por lo general, deseará utilizar a los miembros de esta clase en un orden específico:  
  
1.  Cree una nueva instancia de <xref:System.Deployment.Application.InPlaceHostingManager>.  
  
2.  Descargar el manifiesto de implementación mediante <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A>.  
  
3.  Compruebe que la aplicación se puede ejecutar con los permisos adecuados mediante <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>.  
  
4.  Descargue e instale la aplicación mediante el uso de <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>.  
  
-   Si llama a cualquiera de estos parámetros en el orden correcto, producirá una excepción.  
  
 <xref:System.Deployment.Application.InPlaceHostingManager> puede instalar un [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicación, pero no puede ejecutarla. Algunos métodos en esta clase, como <xref:System.Deployment.Application.InPlaceHostingManager.Execute%2A>, están reservados para su uso al descargar una aplicación basada en Windows Presentation Foundation que se ejecuta dentro de un explorador Web.  
  
 Para usar <xref:System.Deployment.Application.InPlaceHostingManager> para descargar e instalar aplicaciones, debe asegurarse de que el certificado para firmar el [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] las aplicaciones que se va a instalar ya está instalado en los equipos cliente como un editor de confianza. Para obtener más información sobre los editores de confianza, consulte [Trusted Application Deployment Overview](http://msdn.microsoft.com/library/b24a1702-8fbe-45b1-87a0-9618a0708f1d).  
  
> [!NOTE]
>  Actualmente hay una limitación de producto que impide que <xref:System.Deployment.Application.InPlaceHostingManager> funcione correctamente cuando se depura el código con Visual Studio. Si depura la aplicación en Visual Studio mediante el uso de la tecla F5, el ejemplo producirá excepciones extrañas al llamar a <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>. Para depurar con Visual Studio, inicie la aplicación sin depuración y, a continuación, adjunte al depurador. Como alternativa, puede usar a otro depurador, como WinDbg.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo usar <xref:System.Deployment.Application.InPlaceHostingManager> para instalar un [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicación mediante programación en un equipo cliente.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#1)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva instancia de <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> para descargar e instalar la aplicación especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InPlaceHostingManager (Uri deploymentManifest);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri deploymentManifest) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.#ctor(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (deploymentManifest As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InPlaceHostingManager(Uri ^ deploymentManifest);" />
      <MemberSignature Language="F#" Value="new System.Deployment.Application.InPlaceHostingManager : Uri -&gt; System.Deployment.Application.InPlaceHostingManager" Usage="new System.Deployment.Application.InPlaceHostingManager deploymentManifest" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="deploymentManifest" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="deploymentManifest">Identificador uniforme de recursos (<see cref="T:System.Uri" />) en el manifiesto de implementación de una aplicación [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</param>
        <summary>Crea una nueva instancia de <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> para descargar e instalar la aplicación especificada hospedada en un explorador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor se utiliza cuando desea descargar una aplicación basada en Windows Presentation Foundation que se hospeda en un explorador Web. Para descargar aplicaciones basadas en Windows Forms que se implementan mediante [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], utilice el <xref:System.Deployment.Application.InPlaceHostingManager.%23ctor%2A> constructor con la `launchInHostProcess` parámetro establecido en `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> sólo se puede utilizar en Windows XP o en versiones posteriores del sistema operativo Windows.</exception>
        <exception cref="T:System.ArgumentNullException">No puede pasar <see langword="null" /> para el argumento <paramref name="deploymentManifest" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="deploymentManifest" /> utiliza un esquema del URI que no admite [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InPlaceHostingManager (Uri deploymentManifest, bool launchInHostProcess);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri deploymentManifest, bool launchInHostProcess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.#ctor(System.Uri,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (deploymentManifest As Uri, launchInHostProcess As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InPlaceHostingManager(Uri ^ deploymentManifest, bool launchInHostProcess);" />
      <MemberSignature Language="F#" Value="new System.Deployment.Application.InPlaceHostingManager : Uri * bool -&gt; System.Deployment.Application.InPlaceHostingManager" Usage="new System.Deployment.Application.InPlaceHostingManager (deploymentManifest, launchInHostProcess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="deploymentManifest" Type="System.Uri" />
        <Parameter Name="launchInHostProcess" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deploymentManifest">Identificador uniforme de recursos (URI) en el manifiesto de implementación de la aplicación que se instalará.</param>
        <param name="launchInHostProcess">Indica si esta aplicación se ejecutará en un host, como un explorador web. Para una aplicación independiente, establezca este valor en <see langword="false" />.</param>
        <summary>Crea una nueva instancia de <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> para descargar e instalar la aplicación especificada, que puede ser una aplicación independiente basada en formularios Windows Forms o en una aplicación hospedada en un explorador web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear una instancia de <xref:System.Deployment.Application.InPlaceHostingManager> que le permite descargar las aplicaciones basadas en formularios de Windows implementadas mediante [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#2)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> sólo se puede utilizar en Windows XP o en versiones posteriores del sistema operativo Windows.</exception>
        <exception cref="T:System.ArgumentNullException">No puede pasar <see langword="null" /> para el argumento <paramref name="deploymentManifest" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="deploymentManifest" /> utiliza un esquema del URI que no admite [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AssertApplicationRequirements">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si la aplicación ClickOnce tiene los permisos adecuados y las dependencias de plataforma para que se pueda ejecutar en el equipo local.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AssertApplicationRequirements">
      <MemberSignature Language="C#" Value="public void AssertApplicationRequirements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AssertApplicationRequirements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements" />
      <MemberSignature Language="VB.NET" Value="Public Sub AssertApplicationRequirements ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AssertApplicationRequirements();" />
      <MemberSignature Language="F#" Value="member this.AssertApplicationRequirements : unit -&gt; unit" Usage="inPlaceHostingManager.AssertApplicationRequirements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina si la aplicación [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] tiene los permisos adecuados y las dependencias de plataforma para que se pueda ejecutar en el equipo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe llamar a <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A> después <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> devuelve correctamente. No se debe llamar a <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A> a menos que llame a <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>, y devuelve sin errores.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>, que llama en el cuerpo de una correcta <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> controlador de eventos.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Producida si se llama a este método antes que al método <see cref="M:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AssertApplicationRequirements">
      <MemberSignature Language="C#" Value="public void AssertApplicationRequirements (bool grantApplicationTrust);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AssertApplicationRequirements(bool grantApplicationTrust) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AssertApplicationRequirements (grantApplicationTrust As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AssertApplicationRequirements(bool grantApplicationTrust);" />
      <MemberSignature Language="F#" Value="member this.AssertApplicationRequirements : bool -&gt; unit" Usage="inPlaceHostingManager.AssertApplicationRequirements grantApplicationTrust" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="grantApplicationTrust" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="grantApplicationTrust">Si es <see langword="true" />, la aplicación intentará elevar sus permisos al nivel necesario.</param>
        <summary>Determina si la aplicación [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] tiene los permisos adecuados y las dependencias de plataforma para que se pueda ejecutar en el equipo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `grantApplicationTrust` es `true`, <xref:System.Deployment.Application.InPlaceHostingManager> concederá a la aplicación permisos elevados, si así lo requiere. Esto solo es posible si <xref:System.Deployment.Application.InPlaceHostingManager> es capaz de conceder dichos permisos. Por ejemplo, si un [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicación se instala como parte de un paquete más grande y se concedió el instalador de plena confianza, <xref:System.Deployment.Application.InPlaceHostingManager> podrá conceder el [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicación plena confianza. Si `grantApplicationTrust` es `false`, la aplicación no concede ningún permiso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="inPlaceHostingManager.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela una operación de descarga asincrónica.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="inPlaceHostingManager.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos que usa <see cref="T:System.Deployment.Application.InPlaceHostingManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A> cuando haya terminado de usar <xref:System.Deployment.Application.InPlaceHostingManager>. El método <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A> deja el <xref:System.Deployment.Application.InPlaceHostingManager> en un estado no utilizable. Después de llamar a <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A>, debe liberar todas las referencias a la <xref:System.Deployment.Application.InPlaceHostingManager> por lo que el recolector de elementos no utilizados pueda reclamar la memoria que el <xref:System.Deployment.Application.InPlaceHostingManager> estaba ocupando. Para obtener más información, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Realice siempre una llamada a <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A> antes de liberar la última referencia al objeto <xref:System.Deployment.Application.InPlaceHostingManager>. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.Deployment.Application.InPlaceHostingManager> del objeto `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadApplicationAsync">
      <MemberSignature Language="C#" Value="public void DownloadApplicationAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadApplicationAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadApplicationAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadApplicationAsync();" />
      <MemberSignature Language="F#" Value="member this.DownloadApplicationAsync : unit -&gt; unit" Usage="inPlaceHostingManager.DownloadApplicationAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Descarga una actualización de la aplicación en segundo plano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe llamar a este método después de llamar a <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>, que llama al final de una correcta <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> controlador de eventos.  
  
 Ejemplos de código siguientes se suponen que ya ha definido y creado una instancia de <xref:System.Deployment.Application.InPlaceHostingManager> denominado `iphm`.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Producida si se llama a este método antes que a los métodos <see cref="M:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync" /> y <see cref="M:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DownloadApplicationCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt; DownloadApplicationCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt; DownloadApplicationCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event DownloadApplicationCompleted As EventHandler(Of DownloadApplicationCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Deployment::Application::DownloadApplicationCompletedEventArgs ^&gt; ^ DownloadApplicationCompleted;" />
      <MemberSignature Language="F#" Value="member this.DownloadApplicationCompleted : EventHandler&lt;System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt; " Usage="member this.DownloadApplicationCompleted : System.EventHandler&lt;System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la aplicación ha finalizado la descarga al equipo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si va a instalar una aplicación basada en Windows Forms, deberá indicar a los usuarios para iniciar la aplicación ellos mismos; no se puede iniciar aplicaciones basadas en Windows Forms mediante programación utilizando la <xref:System.Deployment.Application.InPlaceHostingManager.Execute%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra un controlador para el <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationCompleted> eventos.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#7)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadProgressChanged">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Deployment.Application.DownloadProgressChangedEventArgs&gt; DownloadProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Deployment.Application.DownloadProgressChangedEventArgs&gt; DownloadProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.InPlaceHostingManager.DownloadProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event DownloadProgressChanged As EventHandler(Of DownloadProgressChangedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Deployment::Application::DownloadProgressChangedEventArgs ^&gt; ^ DownloadProgressChanged;" />
      <MemberSignature Language="F#" Value="member this.DownloadProgressChanged : EventHandler&lt;System.Deployment.Application.DownloadProgressChangedEventArgs&gt; " Usage="member this.DownloadProgressChanged : System.EventHandler&lt;System.Deployment.Application.DownloadProgressChangedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Deployment.Application.DownloadProgressChangedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando hay un cambio en el estado de la descarga de una aplicación o un manifiesto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En una aplicación de consola, los eventos se asignan a subprocesos de un grupo de subprocesos. Por consiguiente, podría recibir eventos de actualización de progreso desordenados, con un evento posterior que muestra una disminución en comparación con un evento anterior. No verá este comportamiento en una aplicación basada en formularios de Windows, dado que los eventos de Windows Forms se procesan secuencialmente fuera de la cola de mensajes del subproceso de interfaz de usuario.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo actualizar un <xref:System.Windows.Forms.ToolStripProgressBar> que está dentro de un <xref:System.Windows.Forms.StatusStrip>.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#6)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle Execute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle Execute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.Execute" />
      <MemberSignature Language="VB.NET" Value="Public Function Execute () As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ Execute();" />
      <MemberSignature Language="F#" Value="member this.Execute : unit -&gt; System.Runtime.Remoting.ObjectHandle" Usage="inPlaceHostingManager.Execute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia la aplicación [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], si y sólo si es una aplicación basada en Windows Presentation Foundation que se ejecute en un explorador web.</summary>
        <returns>Un <see cref="T:System.Runtime.Remoting.ObjectHandle" /> que corresponde a la aplicación iniciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es válido solo para las aplicaciones basadas en Windows Presentation Foundation que pueden hospedarse en un explorador Web (es decir, definen sus manifiestos de implementación el `hostInBrowser` elemento XML).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestAsync">
      <MemberSignature Language="C#" Value="public void GetManifestAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetManifestAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetManifestAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetManifestAsync();" />
      <MemberSignature Language="F#" Value="member this.GetManifestAsync : unit -&gt; unit" Usage="inPlaceHostingManager.GetManifestAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Descarga el manifiesto de implementación de la aplicación [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] en segundo plano y genera un evento cuando la operación ha concluido o detecta un error.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para recibir una notificación de cuando se completa este evento, cree un controlador de eventos para el <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> eventos. Si se llama a este evento y no se indica ningún error <xref:System.Deployment.Application.GetManifestCompletedEventArgs>, debe llamar después a <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A> para comprobar que la aplicación tendrá permiso para ejecutar en el equipo local.  
  
   
  
## Examples  
 Ejemplos de código siguientes muestran cómo llamar a la <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> método. El controlador para el <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> comprobaciones de devolución de llamada de evento para ver si la descarga del manifiesto se completó correctamente y si es así, se pide al usuario con información adicional acerca de la aplicación. Si el usuario acepta continuar con la instalación, el controlador llama <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>.  
  
 Ejemplos de código siguientes se suponen que ya ha definido y creado una instancia de <xref:System.Deployment.Application.InPlaceHostingManager> denominado `iphm`.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Deployment.Application.GetManifestCompletedEventArgs&gt; GetManifestCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Deployment.Application.GetManifestCompletedEventArgs&gt; GetManifestCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event GetManifestCompleted As EventHandler(Of GetManifestCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Deployment::Application::GetManifestCompletedEventArgs ^&gt; ^ GetManifestCompleted;" />
      <MemberSignature Language="F#" Value="member this.GetManifestCompleted : EventHandler&lt;System.Deployment.Application.GetManifestCompletedEventArgs&gt; " Usage="member this.GetManifestCompleted : System.EventHandler&lt;System.Deployment.Application.GetManifestCompletedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Deployment.Application.GetManifestCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el manifiesto de implementación se ha descargado al equipo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> propiedad de <xref:System.Deployment.Application.GetManifestCompletedEventArgs> para comprobar si <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> se completó correctamente o devolvió un error. Si <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> es null, <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> se completó correctamente y se puede llamar a <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>.  
  
   
  
## Examples  
 Ejemplos de código siguientes muestran cómo llamar a la <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> método. El controlador para el <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> comprobaciones de devolución de llamada de evento para ver si la descarga del manifiesto se completó correctamente y si es así, se pide al usuario con información adicional acerca de la aplicación. Si el usuario acepta continuar con la instalación, el controlador llama <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>.  
  
 Ejemplos de código siguientes se suponen que ya ha definido y creado una instancia de <xref:System.Deployment.Application.InPlaceHostingManager> denominado `iphm`.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#2)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#2)]  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UninstallCustomAddIn">
      <MemberSignature Language="C#" Value="public static void UninstallCustomAddIn (string subscriptionId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UninstallCustomAddIn(string subscriptionId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.UninstallCustomAddIn(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UninstallCustomAddIn (subscriptionId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UninstallCustomAddIn(System::String ^ subscriptionId);" />
      <MemberSignature Language="F#" Value="static member UninstallCustomAddIn : string -&gt; unit" Usage="System.Deployment.Application.InPlaceHostingManager.UninstallCustomAddIn subscriptionId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subscriptionId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subscriptionId">Una cadena que contiene un identificador de suscripción, que indica el complemento que se va a quitar.</param>
        <summary>Quita de una aplicación un componente definido por el usuario y anteriormente instalado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="subscriptionId" /> no es una identidad de suscripción válida o no incluye un nombre, un token de clave pública, la arquitectura del procesador ni el número de versión.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subscriptionId" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UninstallCustomUXApplication">
      <MemberSignature Language="C#" Value="public static void UninstallCustomUXApplication (string subscriptionId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UninstallCustomUXApplication(string subscriptionId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.UninstallCustomUXApplication(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UninstallCustomUXApplication (subscriptionId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UninstallCustomUXApplication(System::String ^ subscriptionId);" />
      <MemberSignature Language="F#" Value="static member UninstallCustomUXApplication : string -&gt; unit" Usage="System.Deployment.Application.InPlaceHostingManager.UninstallCustomUXApplication subscriptionId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subscriptionId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subscriptionId">Una cadena que contiene un identificador de suscripción, que indica la aplicación [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] que se va a quitar.</param>
        <summary>Quita una aplicación [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] que incluye el elemento &lt;customUX&gt;.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método desinstala instalado previamente [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicación que usa el `<customUX>` elemento en el [ &lt;entryPoint&gt; elemento](http://msdn.microsoft.com/library/10ad3083-10c1-4189-a870-9bba2eab244f).  
  
 Instaladores personalizados que no creación una entrada de agregar o quitar programas para la [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplicación debe almacenar el identificador de suscripción se encuentra en la <xref:System.Deployment.Application.GetManifestCompletedEventArgs.SubscriptionIdentity%2A> propiedad durante la instalación.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>