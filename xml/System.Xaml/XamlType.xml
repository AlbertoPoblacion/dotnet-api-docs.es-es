<Type Name="XamlType" FullName="System.Xaml.XamlType">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5f660970c55af6a8e8be700e1df5ac2c266d1596" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52254553" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlType : IEquatable&lt;System.Xaml.XamlType&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlType extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlType&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlType" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlType&#xA;Implements IEquatable(Of XamlType)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlType : IEquatable&lt;System::Xaml::XamlType ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlType = class&#xA;    interface IEquatable&lt;XamlType&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlType&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Informa de los tipos XAML como parte del sistema XAML global implementado en los servicios XAML de .NET Framework.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Muchas API en el <xref:System.Xaml.XamlType> clase proporcionan información sobre los tipos XAML, donde el concepto que notifican es similar a secciones específicas de la especificación XAML [MS-XAML].  
  
 <xref:System.Xaml.XamlType> se usa ampliamente en la API de servicios XAML de .NET Framework para notificar información sobre un tipo XAML. <xref:System.Xaml.XamlType> notifica la información que necesita saber acerca de un tipo XAML para trabajar con una instancia o tener acceso a sus miembros desde un flujo de nodo XAML o una representación de XAML similar. Sus informes es similar a cómo el <xref:System.Type> en el CLR de sistema de tipos, junto con las clases de reflexión como <xref:System.Reflection.MemberInfo>, proporcionan información sobre un tipo CLR y su uso.  
  
 Para extender el sistema de tipos XAML, puede derivar de <xref:System.Xaml.XamlType>. Para hacerlo de forma eficaz, es posible que deba implementar una <xref:System.Xaml.Schema.XamlTypeInvoker>. El <xref:System.Xaml.Schema.XamlTypeInvoker> permite que el sistema de tipos XAML generalizado trabajar con el sistema de tipos de seguridad que especifique como parte del comportamiento de invocación. Personalizado específico <xref:System.Xaml.Schema.XamlTypeInvoker> proporciona una forma de reducir las dependencias en el sistema de tipos CLR, que son usadas por el valor predeterminado <xref:System.Xaml.XamlType> comportamiento.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlType" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="underlyingType">Objeto <see cref="T:System.Type" /> subyacente de CLR para el tipo XAML que se va a construir.</param>
        <param name="schemaContext">Contexto de esquema XAML para lectores XAML o sistemas de escritura XAML.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlType" />, basándose en la información del tipo subyacente de CLR.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios <paramref name="underlyingType" /> o <paramref name="schemaContext" /> son <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XamlType (string typeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string typeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (typeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XamlType(System::String ^ typeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (typeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="typeName">Nombre del tipo que se va a crear.</param>
        <param name="typeArguments">Argumentos de tipo para un objeto <see cref="T:System.Xaml.XamlType" /> que representa un tipo genérico. Puede ser (y a menudo es) <see langword="null" />, lo que indica que el tipo representado no es un tipo genérico.</param>
        <param name="schemaContext">Contexto de esquema XAML para lectores XAML y sistemas de escritura XAML.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlType" />, basándose en un nombre de cadena para el tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un constructor protegido. Ninguna clase derivada pública actual existe que utilizan esta ruta de acceso determinada para la construcción. Como consumidor de existente <xref:System.Xaml.XamlType>, debe usar las otras firmas de constructor (<xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%2CSystem.Xaml.Schema.XamlTypeInvoker%29>, <xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%29>, o <xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29>) para inicializar un <xref:System.Xaml.XamlType> objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios <paramref name="typeName" /> o <paramref name="schemaContext" /> son <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlTypeInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlTypeInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlTypeInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext, invoker As XamlTypeInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlTypeInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlTypeInvoker -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlTypeInvoker" />
      </Parameters>
      <Docs>
        <param name="underlyingType">Tipo subyacente del tipo XAML que se va a construir.</param>
        <param name="schemaContext">Contexto de esquema XAML para el lector XAML.</param>
        <param name="invoker">Implementación de <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> que administra las llamadas de reflexión en tiempo de ejecución al objeto <see cref="T:System.Xaml.XamlType" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlType" />, basándose en la información del tipo subyacente y una implementación de <see cref="T:System.Xaml.Schema.XamlTypeInvoker" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios <paramref name="underlyingType" /> o <paramref name="schemaContext" /> son <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (string unknownTypeNamespace, string unknownTypeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string unknownTypeNamespace, string unknownTypeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (unknownTypeNamespace As String, unknownTypeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(System::String ^ unknownTypeNamespace, System::String ^ unknownTypeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (unknownTypeNamespace, unknownTypeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="unknownTypeNamespace" Type="System.String" />
        <Parameter Name="unknownTypeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="unknownTypeNamespace">Espacio de nombres XAML del tipo, en forma de cadena.</param>
        <param name="unknownTypeName">Nombre del tipo en el espacio de nombres XAML especificado por el parámetro <paramref name="unknownTypeNamespace" />.</param>
        <param name="typeArguments">Argumentos de tipo para un objeto <see cref="T:System.Xaml.XamlType" /> que representa un tipo genérico. Puede ser (y a menudo es) <see langword="null" />, lo que indica que el tipo representado no es un tipo genérico.</param>
        <param name="schemaContext">Contexto de esquema XAML para lectores XAML o sistemas de escritura XAML.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlType" />, basándose en el espacio de nombres XAML y un nombre de cadena para el tipo. Este constructor es exclusivamente para el análisis y la grabación de nodos XAML de usos de tipos que se sabe que no tienen correspondencia en el sistema de tipos auxiliar y el contexto de esquema de XAML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor solo para los tipos "desconocidos" donde un tipo XAML que se asigna a un sistema de tipos subyacente no está disponible. Este constructor no puede producir un resultado donde <xref:System.Xaml.XamlType.IsUnknown%2A?displayProperty=nameWithType> es `true`. En su lugar, la lógica predeterminada de reflector indica el tipo subyacente como <xref:System.Xaml.XamlLanguage.Object%2A?displayProperty=nameWithType>. Sin embargo, puede cambiar este comportamiento debido la <xref:System.Xaml.XamlType.LookupIsUnknown%2A> invalidar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uno o varios de los valores de <paramref name="unknownTypeNamespace" />, <paramref name="unknownTypeName" /> o <paramref name="schemaContext" /> son <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowedContentTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; AllowedContentTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; AllowedContentTypes" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.AllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllowedContentTypes As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ AllowedContentTypes { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowedContentTypes : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.AllowedContentTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de solo lectura de los tipos que se pueden usar como valor de la propiedad <see cref="P:System.Xaml.XamlType.ContentProperty" /> de este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Colección de solo lectura de los posibles tipos de contenido.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tipos que se pueden asignables un tipo de contenido específico (por ejemplo, puede asignar a un tipo base que es un tipo de contenido permitido) no se consideran varios tipos para los fines de <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupAllowedContentTypes%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ BaseType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Xaml.XamlType" /> para el tipo base inmediato de este tipo XAML. La determinación de este valor se basa en el tipo subyacente de este objeto <see cref="T:System.Xaml.XamlType" /> y el contexto de esquema.</summary>
        <value>
          <see cref="T:System.Xaml.XamlType" /> para el tipo base inmediato de este tipo XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupBaseType%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupBaseType%2A> en este tipo. De forma predeterminada, <xref:System.Xaml.XamlType.BaseType%2A> devuelve una constante interna que representa un <xref:System.Object> si <xref:System.Xaml.XamlType.UnderlyingType%2A> es `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> es virtual y, por lo tanto, se puede invalidar. El reemplazo tiene el potencial (para propósitos malintencionados o de otro modo) para cambiar la información de tipo que se notifica sobre un tipo XAML para que ya no esté disponible en la manera esperada con la información del sistema de tipo de su tipo CLR subyacente. Para cualquier comprobación crítico para la seguridad de las operaciones de asignación y acceso, para usar el tipo CLR subyacente en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanAssignTo">
      <MemberSignature Language="C#" Value="public virtual bool CanAssignTo (System.Xaml.XamlType xamlType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanAssignTo(class System.Xaml.XamlType xamlType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.CanAssignTo(System.Xaml.XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanAssignTo(System::Xaml::XamlType ^ xamlType);" />
      <MemberSignature Language="F#" Value="abstract member CanAssignTo : System.Xaml.XamlType -&gt; bool&#xA;override this.CanAssignTo : System.Xaml.XamlType -&gt; bool" Usage="xamlType.CanAssignTo xamlType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType">Tipo que se va a comparar con el tipo <see cref="T:System.Xaml.XamlType" /> actual.</param>
        <summary>Devuelve un valor que indica si una instancia de este tipo <see cref="T:System.Xaml.XamlType" /> tiene el tipo <see cref="T:System.Xaml.XamlType" /> especificado en su lista de tipos asignables.</summary>
        <returns>Es <see langword="true" /> si <paramref name="xamlType" /> está en la lista de tipos asignables; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque el tipo asignable no tiene todas las capacidades del tipo de referencia, puede usarlo para la asignación. Por ejemplo, puede usar la asignación para hacer coincidir el tipo de los valores de una propiedad. El concepto de tipos asignables en XAML es similar al concepto de convertir en el sistema de tipos CLR. Por ejemplo, en un sistema de tipos CLR, cada tipo tiene un <xref:System.Object> en su lista de tipos asignables.  
  
 Si uno de los dos <xref:System.Xaml.XamlType> instancias que se utilizan para comparación tiene <xref:System.Xaml.XamlType.IsUnknown%2A> igual a `true`, este método tiene un modo desconocido especial que devuelve `true` si los dos <xref:System.Xaml.XamlType> las instancias son equivalentes.  
  
 La implementación predeterminada usa CLR <xref:System.Type> desde <xref:System.Xaml.XamlType.UnderlyingType%2A> para este <xref:System.Xaml.XamlType> y la entrada <xref:System.Xaml.XamlType>y llama a <xref:System.Type.IsAssignableFrom%2A>. Invalide este método si desea una determinación diferente de tipos asignables.  
  
 Pasar un valor null `xamlType` no produce una excepción y siempre devuelve `false`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.CanAssignTo%2A> es virtual y, por lo tanto, se puede invalidar. El reemplazo tiene el potencial (para propósitos malintencionados o de otro modo) para cambiar la asignación de un tipo XAML para que ya no esté disponible en la manera esperada con el comportamiento de conversión de tipos de su tipo CLR subyacente. Para cualquier comprobación crítico para la seguridad de las operaciones de asignación y acceso, para usar el tipo CLR subyacente en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="public bool ConstructionRequiresArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ConstructionRequiresArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConstructionRequiresArguments As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ConstructionRequiresArguments { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ConstructionRequiresArguments : bool" Usage="System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> debe tener argumentos (restricciones genéricas mediante <see langword="x:TypeArguments" />, texto de inicialización u otras técnicas de XAML) para construir una instancia válida del tipo.</summary>
        <value>Es <see langword="true" /> si la construcción de una instancia necesita valores de argumento; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember ContentProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlMember ContentProperty" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentProperty As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlMember ^ ContentProperty { System::Xaml::XamlMember ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentProperty : System.Xaml.XamlMember" Usage="System.Xaml.XamlType.ContentProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene información sobre <see cref="T:System.Xaml.XamlMember" /> para la propiedad de contenido de este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Información sobre <see cref="T:System.Xaml.XamlMember" /> para la propiedad de contenido de este objeto <see cref="T:System.Xaml.XamlType" />. Su valor puede ser <see langword="null" /> si no existe ninguna propiedad de contenido.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando usa el enlace o de seguridad del sistema de tipos CLR, la propiedad de contenido XAML puede especificarse en un tipo aplicando <xref:System.Windows.Markup.ContentPropertyAttribute> a la definición de tipo.  
  
 Esta propiedad se alinea con el `[content property]` elemento de información en la especificación [MS-XAML].  
  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupContentProperty%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupContentProperty%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentWrappers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; ContentWrappers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; ContentWrappers" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentWrappers As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ ContentWrappers { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentWrappers : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.ContentWrappers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los tipos que se usan para encapsular el contenido de una propiedad de contenido cuando no es una coincidencia exacta de tipos, como cadenas en un objeto <see langword="Collection&lt;T&gt;" /> fuertemente tipado.</summary>
        <value>Colección de solo lectura de los posibles tipos de contenedor de contenido; de lo contrario, es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay ningún contenedor para aflojar de coincidencia de tipo, esta propiedad es `null`.  
  
 Tipos que se evalúan como <xref:System.Xaml.XamlType.CanAssignTo%2A> para un tipo de contenido específico no se consideran varios tipos para los fines de <xref:System.Xaml.XamlType.ContentWrappers%2A>.  
  
 En el enlace de CLR para <xref:System.Xaml> y <xref:System.Xaml.XamlType>, se puede especificar el tipo de contenedor de contenido XAML en un tipo como un <xref:System.Windows.Markup.ContentWrapperAttribute>.  
  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupContentWrappers%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupContentWrappers%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlType.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> que representa el comportamiento de la conversión de carga aplazada para este tipo.</summary>
        <value>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> con restricción <see cref="T:System.Xaml.XamlDeferringLoader" /> que representa el comportamiento de carga diferido para este tipo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comportamiento de la plantilla XAML en WPF es un ejemplo de comportamiento de carga aplazada.  
  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si el objeto actual es igual que otro objeto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlType.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar con este objeto.</param>
        <summary>Indica si el objeto actual es igual que otro objeto.</summary>
        <returns>
          <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="obj" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlType other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlType other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlType ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlType -&gt; bool" Usage="xamlType.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="other">Objeto que se va a comparar con este objeto.</param>
        <summary>Indica si el objeto actual es igual que otro objeto del mismo tipo.</summary>
        <returns>
          <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAliasedProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="member this.GetAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">Directiva para la cual se busca el miembro con alias.</param>
        <summary>Devuelve el miembro XAML para el que se ha establecido como alias una directiva XAML mediante este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Miembro con alias, si se encuentra; de lo contrario, devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar llamadas a este método <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllAttachableMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllAttachableMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllAttachableMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una colección que contiene todas las propiedades adjuntables expuestas por este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Colección que contiene cero o más valores de <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada <xref:System.Xaml.XamlMember> en la colección devuelta debe contener valores que admiten el concepto que el <xref:System.Xaml.XamlMember> es un miembro adjuntable. Por ejemplo, deben devolver miembros `true` para <xref:System.Xaml.XamlMember.IsAttachable%2A>, un tipo para <xref:System.Xaml.XamlMember.TargetType%2A>, y así sucesivamente.  
  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar llamadas a este método <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una colección que contiene todos los miembros expuestos por este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Colección que contiene cero o más valores de <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pueden invocar llamadas a este método <xref:System.Xaml.XamlType.LookupAllMembers%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttachableMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del miembro adjuntable que se va a obtener, en el formulario <c>ownerTypeName.MemberName</c>.</param>
        <summary>Devuelve un <see cref="T:System.Xaml.XamlMember" /> que representa un miembro adjuntable con nombre específico de este <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Objeto <see cref="T:System.Xaml.XamlMember" /> para el miembro adjuntable solicitado; de lo contrario, <see langword="null" />, si no existe ningún miembro adjuntable con ese nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pueden invocar llamadas a este método <xref:System.Xaml.XamlType.LookupAttachableMember%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> es virtual y, por lo tanto, se puede invalidar. El reemplazo tiene el potencial (para propósitos malintencionados o de otro modo) para cambiar los miembros de un tipo XAML notificados para que ya no queden en la manera esperada con el <xref:System.ComponentModel.TypeDescriptor> `Get*` información sobre el tipo CLR subyacente. Para cualquier comprobación crítico para la seguridad de miembro reporting, para usar el tipo CLR subyacente en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlType.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de este objeto.</summary>
        <returns>Código hash entero.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del miembro que se va a obtener (en forma de cadena).</param>
        <summary>Devuelve un objeto <see cref="T:System.Xaml.XamlMember" /> para un miembro con nombre específico de este tipo <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Información de <see cref="T:System.Xaml.XamlMember" /> para el miembro, si se encuentra alguno; de lo contrario, devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de `name` debe estar incompleto. Nombres calificados con el tipo que indican un miembro adjunto se deben enviar a <xref:System.Xaml.XamlType.GetAttachableMember%2A> en su lugar. El prefijo de miembro no se deben usar nombres; un prefijo es situacional para un uso y el sistema de tipos XAML no conoce el contexto de este tipo de uso y cómo se asigna el prefijo.  
  
 Pueden invocar llamadas a este método <xref:System.Xaml.XamlType.LookupMember%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> es virtual y, por lo tanto, se puede invalidar. El reemplazo tiene el potencial (para propósitos malintencionados o de otro modo) para cambiar los miembros de un tipo XAML notificados para que ya no queden en la manera esperada con el <xref:System.ComponentModel.TypeDescriptor> `Get*` información sobre el tipo CLR subyacente. Para cualquier comprobación crítico para la seguridad de miembro reporting, para usar el tipo CLR subyacente en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPositionalParameters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; GetPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; GetPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ GetPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="member this.GetPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.GetPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">Número de parámetros del modo de sintaxis o constructor del que se va a obtener información.</param>
        <summary>Para los tipos de extensión de marcado, devuelve los tipos de los parámetros posicionales admitidos en un uso específico de las extensiones de marcado para este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Lista de valores de <see cref="T:System.Xaml.XamlType" />, donde cada <see cref="T:System.Xaml.XamlType" /> es el tipo para esa posición en la sintaxis. Es preciso especificar los tipos en el mismo orden al proporcionar entradas de marcado para la extensión de marcado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta API solo es pertinente si este <xref:System.Xaml.XamlType> representa una extensión de marcado (<xref:System.Xaml.XamlType.IsMarkupExtension%2A> es `true`).  
  
 La entrada `parameterCount` no es para solicitar el tipo de un parámetro posicional concreto. Es para especificar la aridad de uso de una extensión de marcado. Uso de la extensión de marcado a menudo tiene varias "firmas" y usa diferentes parámetros de aridad (recuento) de los parámetros posicionales para diferenciar. Sin embargo, puede configurar un contexto de esquema para permitir duplicar aridades y usar tipos de los parámetros posicionales para diferenciación. Para obtener más información, vea <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Para una aridad concreta (recuento), pueden variar las posiciones de parámetro y tipos. Para obtener el tipo posicional del uso de extensión de marcado de una aridad concreta, llame primero a <xref:System.Xaml.XamlType.GetPositionalParameters%2A> especificar el número de aridad. A continuación, obtenga el elemento en esa posición de la colección devuelta.  
  
 Pueden invocar llamadas a este método <xref:System.Xaml.XamlType.LookupPositionalParameters%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlType.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una lista de identificadores de cadena para los espacios de nombres XAML que incluyen el tipo.</summary>
        <returns>Lista de valores de cadena, donde cada cadena es el identificador URI de un espacio de nombres XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificadores de espacio de nombres XAML típicos son cadenas con formato URI.  
  
 La implementación predeterminada comprueba lo siguiente, en orden: el espacio de nombres XAML que se proporciona en construcción (<xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29> solo firma); y los espacios de nombres que están disponibles en el contexto de esquema. Si se trata cada `null`, se genera una nueva lista que contiene una sola cadena vacía. Puede invalidar este método para cambiar la metodología de búsqueda.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlTypeInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlTypeInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlTypeInvoker ^ Invoker { System::Xaml::Schema::XamlTypeInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlTypeInvoker" Usage="System.Xaml.XamlType.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la implementación de <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> que está asociada a este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Implementación de <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> que está asociada a este objeto <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, al llamar a <xref:System.Xaml.XamlType.Invoker%2A> puede llamar <xref:System.Xaml.XamlType.LookupInvoker%2A> o una invalidación específica de ese método. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupInvoker%2A> en este tipo.  
  
 Si un <xref:System.Xaml.XamlType.LookupInvoker%2A> invalidar devuelve `null`, o si la implementación predeterminada devuelve `null` debido a falta de <xref:System.Xaml.XamlType.UnderlyingType%2A> para este <xref:System.Xaml.XamlType>, a continuación, <xref:System.Xaml.XamlType.Invoker%2A> devuelve <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlType.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo de ambiente según la definición de XAML.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo de ambiente; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupIsAmbient%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupIsAmbient%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Xaml.XamlType.IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa una matriz.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa una matriz; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupCollectionKind%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupCollectionKind%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollection">
      <MemberSignature Language="C#" Value="public bool IsCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollection : bool" Usage="System.Xaml.XamlType.IsCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa una colección.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa una colección; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupCollectionKind%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupCollectionKind%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructible">
      <MemberSignature Language="C#" Value="public bool IsConstructible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructible" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsConstructible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructible : bool" Usage="System.Xaml.XamlType.IsConstructible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo que se puede construir según la definición de XAML.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo que se puede construir; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se alinea con el `[is default constructible]` elemento de información en la especificación [MS-XAML].  
  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupIsConstructible%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupIsConstructible%2A> en este tipo.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      </Docs>
    </Member>
    <Member MemberName="IsDictionary">
      <MemberSignature Language="C#" Value="public bool IsDictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDictionary" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsDictionary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDictionary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDictionary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDictionary : bool" Usage="System.Xaml.XamlType.IsDictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa un diccionario según la definición de XAML.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa un diccionario; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se alinea con el `[is dictionary]` elemento de información en la especificación [MS-XAML].  
  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupCollectionKind%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupCollectionKind%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGeneric">
      <MemberSignature Language="C#" Value="public bool IsGeneric { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGeneric" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsGeneric" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGeneric As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGeneric { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGeneric : bool" Usage="System.Xaml.XamlType.IsGeneric" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo genérico.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo genérico; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es una propiedad de la aplicación auxiliar que busca un valor nulo de <xref:System.Xaml.XamlType.TypeArguments%2A>. No hay ningún específico `Lookup` relacionados con el método <xref:System.Xaml.XamlType.IsGeneric%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarkupExtension">
      <MemberSignature Language="C#" Value="public bool IsMarkupExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarkupExtension" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarkupExtension As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarkupExtension { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarkupExtension : bool" Usage="System.Xaml.XamlType.IsMarkupExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa una extensión de marcado.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa una extensión de marcado; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En términos de especificación de XAML, este tipo debe ser asignable a `x:MarkupExtension` con el fin de devolver `true` para <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameScope">
      <MemberSignature Language="C#" Value="public bool IsNameScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameScope As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameScope { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameScope : bool" Usage="System.Xaml.XamlType.IsNameScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa un ámbito de nombres XAML según la definición de XAML.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa un ámbito de nombres XAML; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un ámbito de nombres XAML exige la exclusividad del nombre de la propiedad o propiedades que se usan para `x:Name`  /  `[name property]`. Si <xref:System.Xaml.XamlType.IsNameScope%2A> es `true`, algún mecanismo para exigir la unicidad debe existir y debe evaluarse desde la perspectiva de este tipo que posee un ámbito de nombres XAML. El ámbito de nombres XAML, a continuación, se extiende al contenido del tipo hasta que se encuentra otro tipo de propietario con ámbito de nombres XAML.  
  
 Esta propiedad se alinea con el `[is name scope]` elemento de información en la especificación [MS-XAML].  
  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupIsNameScope%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlType.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> se inicializa usando una cadena <see langword="xamlName" /> válida como valor de su propiedad <see cref="P:System.Xaml.XamlType.Name" />.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> se inicializa usando una cadena <see langword="xamlName" /> válida; de lo contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullable">
      <MemberSignature Language="C#" Value="public bool IsNullable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNullable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNullable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNullable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNullable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNullable : bool" Usage="System.Xaml.XamlType.IsNullable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo que acepta valores NULL según la definición de XAML.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo que acepta valores NULL; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se alinea con el `[is nullable]` elemento de información en la especificación [MS-XAML].  
  
 Si no usa la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupIsNullable%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Xaml.XamlType.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo público en el sistema de tipos adecuado.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo público; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupIsPublic%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> es virtual y, por lo tanto, se puede invalidar. El reemplazo tiene el potencial (para propósitos malintencionados o de otro modo) para cambiar la información de acceso que se notifica sobre un tipo XAML para que ya no esté disponible en la manera esperada con la información de tipo de sistema y el acceso de su tipo CLR subyacente. Para cualquier comprobación crítico para la seguridad de las operaciones de asignación y acceso, para usar el tipo CLR subyacente en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlType.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo que no se puede resolver en el sistema de tipos subyacente.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo que no se puede resolver; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupIsUnknown%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas.  
  
 Para una ruta de acceso de carga que implica <xref:System.Xaml.XamlObjectWriter>, un <xref:System.Xaml.XamlType> cuya `true` para <xref:System.Xaml.XamlType.IsUnknown%2A> no se puede escribir en un gráfico de objetos. En las implementaciones predeterminadas en <xref:System.Xaml> , el <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A?displayProperty=nameWithType> llamar a produce un <xref:System.Xaml.XamlObjectWriterException> cuando la correspondiente <xref:System.Xaml.XamlType> informes `true` para <xref:System.Xaml.XamlType.IsUnknown%2A>. No debe pasar un <xref:System.Xaml.XamlType> cuya <xref:System.Xaml.XamlType.IsUnknown%2A> como `true` a menos que esté preparado para controlar las excepciones de <xref:System.Xaml.XamlObjectWriter>, o tienen otras formas de ajustar la <xref:System.Xaml.XamlObjectWriter> comportamiento o el flujo de nodo XAML antes de escribir el objeto gráfico.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUsableDuringInitialization">
      <MemberSignature Language="C#" Value="public bool IsUsableDuringInitialization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUsableDuringInitialization" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUsableDuringInitialization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUsableDuringInitialization { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUsableDuringInitialization : bool" Usage="System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> se compila de forma descendente durante la inicialización de XAML.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> se compila de forma descendente durante la inicialización de XAML; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Arriba a abajo es una metáfora que se aproxima al comportamiento del procesador XAML al crear el gráfico de objetos. Cuando compila de arriba a abajo, se crea un tipo, asociado al principal, y, a continuación, se establecen sus propiedades. Construcción de arriba a abajo evita invocar controladores de cambio de propiedad varias veces. Dicho control propaga el gráfico de objetos y por lo tanto, elimina varias llamadas del controlador y proporciona una optimización del rendimiento para el inicio del gráfico de objetos.  
  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> en este tipo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
        <altmember cref="P:System.Windows.FrameworkElement.IsInitialized" />
      </Docs>
    </Member>
    <Member MemberName="IsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="public bool IsWhitespaceSignificantCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWhitespaceSignificantCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWhitespaceSignificantCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWhitespaceSignificantCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWhitespaceSignificantCollection : bool" Usage="System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa una colección con espacio en blanco significativo, según la definición de XML.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa una colección con espacio en blanco significativo; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsXData">
      <MemberSignature Language="C#" Value="public bool IsXData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsXData" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsXData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsXData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsXData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsXData : bool" Usage="System.Xaml.XamlType.IsXData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa <see langword="XDATA" /> en XML según la definición de XAML.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa <see langword="XDATA" />; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se alinea con el `[is xdata]` elemento de información en la especificación [MS-XAML].  
  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupIsXData%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupIsXData%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType ItemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType ItemType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ItemType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ ItemType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.ItemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que proporciona información de tipo para la propiedad <see langword="Items" /> de este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Objeto <see cref="T:System.Xaml.XamlType" /> para el tipo de los elementos de la colección; de lo contrario, es <see langword="null" /> si este objeto <see cref="T:System.Xaml.XamlType" /> no representa una colección.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad solo es pertinente si este <xref:System.Xaml.XamlType> representa una colección (<xref:System.Xaml.XamlType.IsCollection%2A> es `true`). El `Items` propiedad es cualquier propiedad que contiene los elementos de ese tipo de colección o matriz.  
  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupItemType%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupItemType%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType KeyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType KeyType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.KeyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ KeyType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.KeyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que proporciona información de tipo para la propiedad de la clave de este objeto <see cref="T:System.Xaml.XamlType" />, si <see cref="T:System.Xaml.XamlType" /> representa un diccionario.</summary>
        <value>Objeto <see cref="T:System.Xaml.XamlType" /> que corresponde al tipo de la clave para el uso del diccionario; de lo contrario, es <see langword="null" />, si este objeto <see cref="T:System.Xaml.XamlType" /> no representa un diccionario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad solo es pertinente si este <xref:System.Xaml.XamlType> representa un diccionario (<xref:System.Xaml.XamlType.IsDictionary%2A> es `true`).  
  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupKeyType%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupKeyType%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAliasedProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="abstract member LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember&#xA;override this.LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">Directiva para la cual se busca el miembro con alias.</param>
        <summary>Devuelve el miembro XAML para el que se ha establecido como alias una directiva XAML mediante este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Miembro con alias, si se encuentra; de lo contrario, devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se puede invocar este método cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlType.GetAliasedProperty%2A>.  
  
 La implementación predeterminada puede devolver resultados de las siguientes directivas XAML: `Key`; `Name`; `Uid`; y `xml:lang`. Los valores de estos dependen de reflexión subyacente y todavía podrían devolver `null` si no se encuentra ninguna propiedad de un alias.  
  
 Invalide este método si no confía en la reflexión de CLR interna predeterminada y está usando metadatos u otras técnicas para notificar la información de sistema de tipos XAML o la información del esquema de un tipo.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xaml.XamlDirective" />
        <altmember cref="T:System.Xaml.XamlLanguage" />
      </Docs>
    </Member>
    <Member MemberName="LookupAllAttachableMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllAttachableMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un conjunto enumerable que contiene todas las propiedades adjuntables expuestas por este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Conjunto enumerable que contiene cero o más valores de <see cref="T:System.Xaml.XamlMember" />; de lo contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se puede invocar este método cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A>.  
  
 Aunque <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A> devuelve una colección genérica, esto `Lookup` método devuelve un conjunto enumerable genérico.  
  
 La implementación predeterminada usa la reflexión de CLR interna. Cuando <xref:System.Xaml.XamlType.UnderlyingType%2A> es `null`, puede usar la implementación predeterminada <xref:System.Xaml.XamlType.BaseType%2A>, si está disponible. Llama este comportamiento <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> recursivamente para intentar encontrar un tipo base válido y devuelve `null` si no existe ningún tipo base válido.  
  
 Invalide este método si no confía en la reflexión de CLR interna predeterminada y está usando metadatos u otras técnicas para notificar la información de sistema de tipos XAML o información de esquema de un tipo. Un valor null devuelto se debe reservar para los casos donde no se puede determinar información debido a falta de compatibilidad de sistema o de reflexión de tipos. Si un tipo es válido y reflexión u otras técnicas están disponibles, pero un tipo no tiene miembros que se puede asociar, en su lugar, debe devolver un valor vacío <xref:System.Collections.Generic.IEnumerable%601> establecido.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un conjunto enumerable que contiene todos los miembros expuestos por este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Conjunto enumerable que contiene cero o más valores de <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se puede invocar este método cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlType.GetAllMembers%2A>.  
  
 Aunque <xref:System.Xaml.XamlType.GetAllMembers%2A> devuelve una colección genérica, esto `Lookup` método devuelve un conjunto enumerable genérico.  
  
 La implementación predeterminada usa la reflexión de CLR interna. Para los casos donde <xref:System.Xaml.XamlType.UnderlyingType%2A> es `null`, puede usar la implementación predeterminada <xref:System.Xaml.XamlType.BaseType%2A>, si está disponible. Llama este comportamiento <xref:System.Xaml.XamlType.LookupAllMembers%2A> recursivamente para intentar encontrar un tipo base válido y devuelve `null` si no existe ningún tipo base válido.  
  
 Invalide este método si no confía en la reflexión de CLR interna predeterminada y está usando metadatos u otras técnicas para notificar la información de sistema de tipos XAML o información de esquema de un tipo. Un valor null devuelto se debe reservar para los casos donde no se puede determinar información debido a falta de compatibilidad de sistema o de reflexión de tipos. Si un tipo es válido, la reflexión u otras técnicas están disponibles; Si un tipo no tiene miembros, en su lugar, debe devolver un valor vacío <xref:System.Collections.Generic.IEnumerable%601> establecido.  
  
 Devolver valores de <xref:System.Xaml.XamlType.LookupAllMembers%2A> y <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> deben ser mutuamente excluyentes. Si tienes una situación donde una propiedad de sistema de tipo de respaldo puede admitir un uso de la instancia estándar, así como un uso que se puede asociar, ese miembro debe notificarse como dos diferentes <xref:System.Xaml.XamlMember> valores, con un valor que aparece en la lista que se puede asociar y otro en el lista de miembros estándar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllowedContentTypes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupAllowedContentTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupAllowedContentTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllowedContentTypes () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupAllowedContentTypes();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupAllowedContentTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una lista de los tipos que se pueden usar como valor de la propiedad <see cref="P:System.Xaml.XamlType.ContentProperty" /> de este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Lista de posibles tipos de contenido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se puede invocar este método cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Tipos que se evalúan como <xref:System.Xaml.XamlType.CanAssignTo%2A> para un tipo de contenido específico no se consideran varios tipos para los fines de <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 La implementación predeterminada puede usar otras propiedades de <xref:System.Xaml.XamlType> (<xref:System.Xaml.XamlType.ContentWrappers%2A>, <xref:System.Xaml.XamlType.ContentProperty%2A>, o <xref:System.Xaml.XamlType.ItemType%2A>) para obtener un resultado. El `Lookup` invalida de la lista de propiedades anterior también se puede invocar en esta determinación.  
  
 Invalide este método si no confía en la reflexión de CLR interna predeterminada y está usando metadatos u otras técnicas para notificar la información de sistema de tipos XAML o información de esquema de un tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAttachableMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member LookupAttachableMember : string -&gt; System.Xaml.XamlMember&#xA;override this.LookupAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del miembro adjuntable que se va a obtener, en el formulario <c>ownerTypeName.MemberName</c>.</param>
        <summary>Devuelve un <see cref="T:System.Xaml.XamlMember" /> para un adjuntable con nombre especificado en este <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Objeto <see cref="T:System.Xaml.XamlMember" /> para el miembro adjuntable solicitado; de lo contrario, <see langword="null" />, si no existe ningún miembro adjuntable con ese nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se puede invocar este método cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlType.GetAttachableMember%2A>.  
  
 La implementación predeterminada usa la reflexión de CLR interna. Cuando <xref:System.Xaml.XamlType.UnderlyingType%2A> es `null`, puede usar la implementación predeterminada <xref:System.Xaml.XamlType.BaseType%2A>, si está disponible. Llama este comportamiento <xref:System.Xaml.XamlType.LookupAttachableMember%2A> recursivamente para intentar encontrar un tipo base válido y devuelve `null` si no existe ningún tipo base válido.  
  
 Invalide este método si no confía en la reflexión de CLR interna predeterminada y está usando metadatos u otras técnicas para notificar la información de sistema de tipos XAML o información de esquema de un tipo.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> es virtual y, por lo tanto, se puede invalidar. El reemplazo tiene el potencial (para propósitos malintencionados o de otro modo) para cambiar los miembros de un tipo XAML notificados para que ya no queden en la manera esperada con el <xref:System.ComponentModel.TypeDescriptor> `Get*` información sobre el tipo CLR subyacente. Para cualquier comprobación crítico para la seguridad de miembro reporting, para usar el tipo CLR subyacente en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupBaseType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupBaseType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupBaseType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupBaseType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupBaseType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupBaseType();" />
      <MemberSignature Language="F#" Value="abstract member LookupBaseType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupBaseType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupBaseType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el objeto <see cref="T:System.Xaml.XamlType" /> para el tipo base inmediato de este tipo XAML. La determinación de este valor se basa en el tipo subyacente de este objeto <see cref="T:System.Xaml.XamlType" /> y el contexto de esquema.</summary>
        <returns>
          <see cref="T:System.Xaml.XamlType" /> para el tipo base inmediato de este tipo XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se puede invocar este método cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlType.BaseType%2A>.  
  
 La implementación predeterminada podría devolver una constante interna que representa la <xref:System.Object> si <xref:System.Xaml.XamlType.UnderlyingType%2A> es `null`.  
  
 Invalide este método si no confía en la reflexión de CLR interna predeterminada y está usando metadatos u otras técnicas para notificar la información de sistema de tipos XAML o información de esquema de un tipo.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> es virtual y, por lo tanto, se puede invalidar. El reemplazo tiene el potencial (para propósitos malintencionados o de otro modo) para cambiar la información de tipo que se notifica sobre un tipo XAML para que ya no esté disponible en la manera esperada con la información del sistema de tipo de su tipo CLR subyacente. Para cualquier comprobación crítico para la seguridad de las operaciones de asignación y acceso, para usar el tipo CLR subyacente en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCollectionKind">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlCollectionKind LookupCollectionKind ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Xaml.Schema.XamlCollectionKind LookupCollectionKind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCollectionKind" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCollectionKind () As XamlCollectionKind" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlCollectionKind LookupCollectionKind();" />
      <MemberSignature Language="F#" Value="abstract member LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind&#xA;override this.LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind" Usage="xamlType.LookupCollectionKind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlCollectionKind</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor de la enumeración <see cref="T:System.Xaml.Schema.XamlCollectionKind" /> que declara el tipo de colección que este objeto <see cref="T:System.Xaml.XamlType" /> usa.</summary>
        <returns>Valor de la enumeración <see cref="T:System.Xaml.Schema.XamlCollectionKind" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invoca un método privado interno (no pública `CollectionKind` o `GetCollectionKind` API existe en <xref:System.Xaml.XamlType>).  
  
 La implementación predeterminada usa la reflexión de CLR interna. Para los casos donde <xref:System.Xaml.XamlType.UnderlyingType%2A> es `null`, puede usar la implementación predeterminada <xref:System.Xaml.XamlType.BaseType%2A>, si está disponible. Este comportamiento llama indirectamente <xref:System.Xaml.XamlType.LookupCollectionKind%2A> recursivamente para intentar buscar un tipo base válido; devuelve <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> si no existe ningún tipo base válido. En general, la implementación predeterminada intenta encontrar el `Add` método del tipo subyacente por reflexión. Si se encuentra, el <xref:System.Reflection.MethodInfo> de la `Add` método es suficiente información para determinar qué <xref:System.Xaml.Schema.XamlCollectionKind> se debe devolver el valor. De lo contrario, devuelve <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType>.  
  
 Invalide este método si no confía en la reflexión de CLR interna predeterminada y está usando metadatos u otras técnicas para notificar la información de sistema de tipos XAML o información de esquema de un tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="protected virtual bool LookupConstructionRequiresArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupConstructionRequiresArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupConstructionRequiresArguments () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupConstructionRequiresArguments();" />
      <MemberSignature Language="F#" Value="abstract member LookupConstructionRequiresArguments : unit -&gt; bool&#xA;override this.LookupConstructionRequiresArguments : unit -&gt; bool" Usage="xamlType.LookupConstructionRequiresArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> debe tener argumentos (restricciones genéricas a través de <see langword="x:TypeArguments" />, texto de inicialización u otras técnicas de XAML) para construir una instancia válida del tipo.</summary>
        <returns>Es <see langword="true" /> si la construcción de una instancia necesita valores de argumento; de lo contrario, es false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se puede invocar este método cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>.  
  
 La implementación predeterminada devuelve `false` para los tipos que se consideran tipos de valor en el CLR de sistema de tipos. Para los tipos de valor, la reflexión de CLR que no <xref:System.Reflection.ConstructorInfo> se usa para determinar si existe un constructor predeterminado.  
  
 Invalide este método si no confía en la reflexión de CLR interna predeterminada y está usando metadatos u otras técnicas para notificar la información de sistema de tipos XAML o información de esquema de un tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupContentProperty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupContentProperty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentProperty () As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupContentProperty();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentProperty : unit -&gt; System.Xaml.XamlMember&#xA;override this.LookupContentProperty : unit -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupContentProperty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve información sobre <see cref="T:System.Xaml.XamlMember" /> para la propiedad de contenido de este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Información sobre <see cref="T:System.Xaml.XamlMember" /> para la propiedad de contenido de este objeto <see cref="T:System.Xaml.XamlType" />. Puede ser <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se puede invocar este método cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlType.ContentProperty%2A>.  
  
 La implementación predeterminada busca <xref:System.Windows.Markup.ContentPropertyAttribute> en la definición de tipo. También puede comprobar <xref:System.Xaml.XamlType.BaseType%2A> para el atributo si se encuentra ningún atributo en el tipo subyacente de inmediato. Si estas comprobaciones no detectan un tipo de contenido, la implementación predeterminada devuelve `null`.  
  
 Invalide este método si no confía en la reflexión de CLR interna predeterminada y está usando metadatos u otras técnicas para notificar la información de sistema de tipos XAML o información de esquema de un tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentWrappers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupContentWrappers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupContentWrappers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentWrappers () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupContentWrappers();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupContentWrappers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene una lista de valores de <see cref="T:System.Xaml.XamlType" /> que representan los contenedores de contenido de este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Lista de valores de <see cref="T:System.Xaml.XamlType" /> que representan los contenedores de contenido de este objeto <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contenedor de contenido es una clase que representa el tipo de colección de contenido cuando los tipos que se usan en esa colección no son contiguos en el sistema de tipos. Los tipos de elementos de recopilación para el contenedor de contenido deben estar limitado de alguna manera más allá de <xref:System.Object> o un equivalente de objeto neutro. Sin embargo, esta limitación solo se aplica por el diseño o el propósito de las propiedades que usan ese tipo y no por el sistema de tipos. Puede haber más de un contenedor de contenido en un tipo.  
  
 Para una clase de ejemplo y el escenario de la implementación WPF XAML, vea <xref:System.Windows.Documents.InlineCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlType.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se implementa en una clase derivada, devuelve una implementación de <see cref="T:System.Reflection.ICustomAttributeProvider" />.</summary>
        <returns>Implementación de <see cref="T:System.Reflection.ICustomAttributeProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalide este método para proporcionar la reflexión interna con una manera alternativa para obtener los valores de atributo CLR. En ausencia de una invalidación, el reflector interno usa la lógica de reflexión de CLR típica.  
  
 La implementación predeterminada devuelve `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlType.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, que se emplea para la carga aplazada de objetos declarados en XAML.</summary>
        <returns>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> que tiene una restricción <see cref="T:System.Xaml.XamlDeferringLoader" /> en el genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se puede invocar este método cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlType.DeferringLoader%2A>. Invalide este método si desea <xref:System.Xaml.XamlType.DeferringLoader%2A> para devolver un valor diferente que está habilitado de forma reflexión interna predeterminada y también proporcionan una personalizada <xref:System.Xaml.Schema.XamlTypeInvoker> información.  
  
 La implementación predeterminada devuelve un objeto basándose en la lectura <xref:System.Windows.Markup.XamlDeferLoadAttribute>. También puede comprobar <xref:System.Xaml.XamlType.BaseType%2A> para el atributo si se encuentra ningún atributo en el tipo subyacente de inmediato. Si un valor no está disponible, este método devuelve `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlTypeInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlTypeInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlTypeInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker" Usage="xamlType.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> que está asociado con este <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Información de <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> para este <see cref="T:System.Xaml.XamlType" />; de lo contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.Invoker%2A>.  
  
 La implementación predeterminada no requiere que un <xref:System.Xaml.XamlType> se construye mediante uno de los constructores que pasan un inicial <xref:System.Xaml.Schema.XamlTypeInvoker>. Sin embargo, un <xref:System.Xaml.XamlType.UnderlyingType%2A> valor debe existir para el <xref:System.Xaml.XamlType>; de lo contrario, la implementación predeterminada devuelve `null`.  
  
 Invalide este método si crea también una clase derivada de <xref:System.Xaml.Schema.XamlTypeInvoker> y va a devolver la clase derivada. Si la devolución `null`, <xref:System.Xaml.XamlType.Invoker%2A> devuelve <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType> a los llamadores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlType.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo de ambiente según la definición de XAML.</summary>
        <returns>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo de ambiente; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.IsAmbient%2A>.  
  
 La implementación predeterminada usa la reflexión de CLR en el <xref:System.Xaml.XamlType.UnderlyingType%2A> y puede comprobar los tipos base. Esta implementación comprueba el <xref:System.Windows.Markup.AmbientAttribute> que se aplica a la definición del tipo pertinente en el nivel de clase y devuelve `true` en este caso. Devuelven todos los demás casos `false`.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.IsAmbient%2A> para devolver un valor diferente que está habilitado por reflexión interna predeterminada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsConstructible">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsConstructible ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsConstructible() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsConstructible" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsConstructible () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsConstructible();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsConstructible : unit -&gt; bool&#xA;override this.LookupIsConstructible : unit -&gt; bool" Usage="xamlType.LookupIsConstructible " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo que se puede construir según la definición de XAML.</summary>
        <returns>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo que se puede construir; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.IsConstructible%2A>.  
  
 La implementación predeterminada usa la reflexión de CLR en el <xref:System.Xaml.XamlType.UnderlyingType%2A>. El tipo debe ser concreto, no anidado y cerrado. La implementación predeterminada comprueba si el tipo es un tipo de valor y la devolución de <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>. Para un valor null <xref:System.Xaml.XamlType.UnderlyingType%2A>, este método devuelve `true`.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.IsConstructible%2A> para devolver un valor diferente que está habilitado por reflexión interna predeterminada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsMarkupExtension">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsMarkupExtension ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsMarkupExtension() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsMarkupExtension () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsMarkupExtension();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsMarkupExtension : unit -&gt; bool&#xA;override this.LookupIsMarkupExtension : unit -&gt; bool" Usage="xamlType.LookupIsMarkupExtension " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa una extensión de marcado.</summary>
        <returns>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa una extensión de marcado; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 La implementación predeterminada consta solo de esta llamada:  
  
 `return CanAssignTo(XamlLanguage.MarkupExtension);`  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.IsMarkupExtension%2A> para utilizar una lógica diferente.  
  
 En términos de especificación de XAML, este tipo debe ser asignable a `x:MarkupExtension` con el fin de devolver `true` para <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsNameScope">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNameScope ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNameScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNameScope" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNameScope () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNameScope();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNameScope : unit -&gt; bool&#xA;override this.LookupIsNameScope : unit -&gt; bool" Usage="xamlType.LookupIsNameScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa un ámbito de nombres XAML según la definición de XAML.</summary>
        <returns>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa un ámbito de nombres XAML; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.IsNameScope%2A>.  
  
 La implementación predeterminada crea un <xref:System.Xaml.XamlType.CanAssignTo%2A> llamar indirectamente con el tipo <xref:System.Windows.Markup.INameScope>. <xref:System.Windows.Markup.INameScope> es una interfaz que se define en el ensamblado WindowsBase.dll. Esta técnica para la identificación de ámbito de nombres XAML se usa tanto las implementaciones de XAML de WPF y Windows Workflow Foundation.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.IsNameScope%2A> para utilizar una lógica diferente.  
  
 Un ámbito de nombres XAML exige la exclusividad del nombre de la propiedad o propiedades que se usan para `x:Name`  /  `[name property]`. Si <xref:System.Xaml.XamlType.IsNameScope%2A> es `true`, a continuación, algún mecanismo para exigir la unicidad debe existir y debe evaluarse desde la perspectiva de este tipo que posee un ámbito de nombres XAML. El ámbito de nombres XAML, a continuación, se extiende al contenido del tipo hasta que se encuentra otro tipo propietario de ámbito de nombres XAML.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlObjectWriter.RootNameScope" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsNullable">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNullable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNullable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNullable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNullable () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNullable();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNullable : unit -&gt; bool&#xA;override this.LookupIsNullable : unit -&gt; bool" Usage="xamlType.LookupIsNullable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo que acepta valores NULL según la definición de XAML.</summary>
        <returns>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo que acepta valores NULL; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.IsNullable%2A>.  
  
 La implementación predeterminada toma una decisión basándose en el CLR concepto fundamental de biblioteca que acepta valores NULL, comprueban con respecto a <xref:System.Xaml.XamlType.UnderlyingType%2A>. Para un valor null <xref:System.Xaml.XamlType.UnderlyingType%2A>, devuelve `true`.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.IsNullable%2A> para utilizar una lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsPublic : unit -&gt; bool&#xA;override this.LookupIsPublic : unit -&gt; bool" Usage="xamlType.LookupIsPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo público en el sistema de tipos adecuado.</summary>
        <returns>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo público; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.IsPublic%2A>.  
  
 La implementación predeterminada usa la reflexión de CLR en un valor no null <xref:System.Xaml.XamlType.UnderlyingType%2A>. Para un valor null <xref:System.Xaml.XamlType.UnderlyingType%2A>, devuelve `true`.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.IsPublic%2A> para utilizar una lógica diferente.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> es virtual y, por lo tanto, se puede invalidar. El reemplazo tiene el potencial (para propósitos malintencionados o de otro modo) para cambiar la información de acceso que se notifica sobre un tipo XAML para que ya no esté disponible en la manera esperada con la información de tipo de sistema o de acceso de su tipo CLR subyacente. Para cualquier comprobación crítico para la seguridad de las operaciones de asignación y acceso, para usar el tipo CLR subyacente en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlType.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo que no se puede resolver en el sistema de tipos subyacente.</summary>
        <returns>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo que no se puede resolver; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.IsUnknown%2A>.  
  
 La implementación predeterminada puede usar la reflexión de CLR. Para un valor null <xref:System.Xaml.XamlType.UnderlyingType%2A>, devuelve `true`.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.IsUnknown%2A> para utilizar una lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWhitespaceSignificantCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWhitespaceSignificantCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWhitespaceSignificantCollection () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWhitespaceSignificantCollection();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWhitespaceSignificantCollection : unit -&gt; bool&#xA;override this.LookupIsWhitespaceSignificantCollection : unit -&gt; bool" Usage="xamlType.LookupIsWhitespaceSignificantCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa una colección con espacio en blanco significativo, según la definición de XML.</summary>
        <returns>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa una colección con espacio en blanco significativo; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A>.  
  
 La implementación predeterminada devuelve un valor basado en lectura <xref:System.Windows.Markup.WhitespaceSignificantCollectionAttribute>. También puede comprobar el <xref:System.Xaml.XamlType.BaseType%2A> para el atributo si se encuentra ningún atributo en el tipo subyacente de inmediato. Si un valor no está disponible, devuelve `false`.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A> para utilizar una lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsXData">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsXData ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsXData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsXData" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsXData () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsXData();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsXData : unit -&gt; bool&#xA;override this.LookupIsXData : unit -&gt; bool" Usage="xamlType.LookupIsXData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> representa <see langword="XDATA" /> en XML según la definición de XAML.</summary>
        <returns>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa <see langword="XDATA" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.IsXData%2A>.  
  
 La implementación predeterminada crea un <xref:System.Xaml.XamlType.CanAssignTo%2A> llamar indirectamente con el tipo <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.IsXData%2A> para utilizar una lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupItemType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupItemType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupItemType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupItemType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupItemType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupItemType();" />
      <MemberSignature Language="F#" Value="abstract member LookupItemType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupItemType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupItemType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que proporciona información de tipo para la propiedad <see langword="Items" /> de este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Objeto <see cref="T:System.Xaml.XamlType" /> para el tipo de los elementos de la colección; de lo contrario, es <see langword="null" /> si este objeto <see cref="T:System.Xaml.XamlType" /> no representa una colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.ItemType%2A>.  
  
 La implementación predeterminada puede usar los conceptos de reflexión de CLR, como la comprobación de un `Add` método <xref:System.Reflection.MethodInfo> y el uso de la <xref:System.Reflection.ParameterInfo>; comprobación <xref:System.Xaml.XamlType.IsArray%2A>; y la comprobación de <xref:System.Xaml.XamlType.BaseType%2A> y probando la misma lógica.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.ItemType%2A> para utilizar una lógica diferente. Casos donde <xref:System.Xaml.XamlType.LookupCollectionKind%2A> devuelve <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> debe devolver `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupKeyType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupKeyType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupKeyType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupKeyType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupKeyType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupKeyType();" />
      <MemberSignature Language="F#" Value="abstract member LookupKeyType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupKeyType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupKeyType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que proporciona información de tipo para la propiedad de clave de este objeto <see cref="T:System.Xaml.XamlType" /> si <see cref="T:System.Xaml.XamlType" /> representa un diccionario.</summary>
        <returns>Objeto <see cref="T:System.Xaml.XamlType" /> del tipo de la clave que representa un diccionario o <see langword="null" /> si este objeto <see cref="T:System.Xaml.XamlType" /> no representa un diccionario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.KeyType%2A>.  
  
 La implementación predeterminada puede usar los conceptos de reflexión de CLR, como la comprobación de un `Add` método <xref:System.Reflection.MethodInfo> y el uso de la <xref:System.Reflection.ParameterInfo>; y la comprobación de <xref:System.Xaml.XamlType.BaseType%2A> y probando la misma lógica.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.KeyType%2A> para utilizar una lógica diferente. Casos donde <xref:System.Xaml.XamlType.LookupCollectionKind%2A> no devuelve <xref:System.Xaml.Schema.XamlCollectionKind.Dictionary?displayProperty=nameWithType> debe devolver `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupMarkupExtensionReturnType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupMarkupExtensionReturnType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionReturnType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupMarkupExtensionReturnType();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupMarkupExtensionReturnType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que proporciona información de tipo para el valor devuelto de <see langword="ProvideValue" /> de este objeto <see cref="T:System.Xaml.XamlType" /> si representa una extensión de marcado.</summary>
        <returns>Objeto <see cref="T:System.Xaml.XamlType" /> del tipo de valor devuelto que representa una extensión de marcado; de lo contrario, es <see langword="null" /> si <see cref="T:System.Xaml.XamlType" /> no representa una extensión de marcado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A>.  
  
 La implementación predeterminada devuelve un <xref:System.Xaml.XamlType> basándose en la lectura <xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute>. También puede comprobar <xref:System.Xaml.XamlType.BaseType%2A> para el atributo si se encuentra ningún atributo en el tipo subyacente de inmediato. Si un valor no está disponible, devuelve `null`.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A> para utilizar una lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupMember (string name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupMember(string name, bool skipReadOnlyCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMember(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMember (name As String, skipReadOnlyCheck As Boolean) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupMember(System::String ^ name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="F#" Value="abstract member LookupMember : string * bool -&gt; System.Xaml.XamlMember&#xA;override this.LookupMember : string * bool -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupMember (name, skipReadOnlyCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="skipReadOnlyCheck" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del miembro que se va a obtener (en forma de cadena).</param>
        <param name="skipReadOnlyCheck">Es <see langword="true" /> para devolver un miembro aunque dicho miembro tenga el valor <see langword="true" /> para la propiedad <see cref="P:System.Xaml.XamlMember.IsReadOnly" />; es <see langword="false" /> para no devolver ningún miembro con la propiedad <see cref="P:System.Xaml.XamlMember.IsReadOnly" />. El valor predeterminado es <see langword="false" />.</param>
        <summary>Devuelve el objeto <see cref="T:System.Xaml.XamlMember" /> para un miembro con nombre específico de este tipo <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Información de <see cref="T:System.Xaml.XamlMember" /> para el miembro, si se encuentra; de lo contrario, devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.GetMember%2A>.  
  
 La implementación predeterminada devuelve un <xref:System.Xaml.XamlType> en función de reflexión de CLR interna y evaluación en el contexto de esquema.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.GetMember%2A> para utilizar una lógica diferente.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> es virtual y, por lo tanto, se puede invalidar. El reemplazo tiene el potencial (para propósitos malintencionados o de otro modo) para cambiar los miembros de un tipo XAML notificados para que ya no queden en la manera esperada con el <xref:System.ComponentModel.TypeDescriptor> `Get*` información sobre el tipo CLR subyacente. Para cualquier comprobación crítico para la seguridad de miembro reporting, para usar el tipo CLR subyacente en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupPositionalParameters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="abstract member LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">Número de parámetros del modo de sintaxis o constructor del que se va a obtener información.</param>
        <summary>Para los tipos de extensión de marcado, devuelve los tipos de los parámetros posicionales admitidos en un uso específico de las extensiones de marcado para este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Lista de valores de <see cref="T:System.Xaml.XamlType" />, donde cada <see cref="T:System.Xaml.XamlType" /> es el tipo para esa posición en la sintaxis. Es preciso especificar esos tipos en el mismo orden al proporcionar entradas de marcado para la extensión de marcado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.GetPositionalParameters%2A>.  
  
 La implementación predeterminada usa la información de reflexión interna basada en búsqueda de constructores y comprobar la aridad. Invalide este método si desea que <xref:System.Xaml.XamlType.GetPositionalParameters%2A> para utilizar una lógica diferente.  
  
 Esta API solo es pertinente si este <xref:System.Xaml.XamlType> representa una extensión de marcado (<xref:System.Xaml.XamlType.IsMarkupExtension%2A> es `true`).  
  
 La entrada `parameterCount` no es para solicitar el tipo de un parámetro posicional concreto. Es para especificar la aridad de uso de una extensión de marcado. Uso de la extensión de marcado a menudo tiene varias signaturas y usa diferentes parámetros de aridad (recuento) de los parámetros posicionales para diferenciar. Sin embargo, puede configurar un contexto de esquema para permitir duplicar aridades y usar tipos de los parámetros posicionales para diferenciación. Para obtener más información, vea <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Un recuento de aridad concreta, pueden variar las posiciones de parámetro y tipos. Para obtener el tipo posicional del uso de extensión de marcado de una aridad concreta, llame primero a <xref:System.Xaml.XamlType.GetPositionalParameters%2A> con el recuento de aridad. A continuación, obtenga el elemento en esa posición de la colección devuelta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetMarkupExtensionHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetMarkupExtensionHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetMarkupExtensionHandler () As EventHandler(Of XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetMarkupExtensionEventArgs ^&gt; ^ LookupSetMarkupExtensionHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;&#xA;override this.LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;" Usage="xamlType.LookupSetMarkupExtensionHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una devolución de llamada de controlador que se va a usar para establecer las extensiones de marcado.</summary>
        <returns>Devolución de llamada de controlador que se va a usar para establecer las extensiones de marcado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada devuelve un valor basado en lectura <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute>. También puede comprobar <xref:System.Xaml.XamlType.BaseType%2A> para el atributo si se encuentra ningún atributo en el tipo subyacente de inmediato. Si un valor no está disponible, devuelve `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetTypeConverterHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetTypeConverterHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetTypeConverterHandler () As EventHandler(Of XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetTypeConverterEventArgs ^&gt; ^ LookupSetTypeConverterHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;&#xA;override this.LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;" Usage="xamlType.LookupSetTypeConverterHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un controlador que se va a usar para establecer el convertidor de tipos.</summary>
        <returns>Controlador que se va a usar para establecer el convertidor de tipos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada devuelve un valor basado en lectura <xref:System.Windows.Markup.XamlSetTypeConverterAttribute>. También puede comprobar <xref:System.Xaml.XamlType.BaseType%2A> para el atributo si se encuentra ningún atributo en el tipo subyacente de inmediato. Si un valor no está disponible, devuelve `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="protected virtual bool LookupTrimSurroundingWhitespace ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupTrimSurroundingWhitespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTrimSurroundingWhitespace () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupTrimSurroundingWhitespace();" />
      <MemberSignature Language="F#" Value="abstract member LookupTrimSurroundingWhitespace : unit -&gt; bool&#xA;override this.LookupTrimSurroundingWhitespace : unit -&gt; bool" Usage="xamlType.LookupTrimSurroundingWhitespace " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> debe serializarse en un modo que recorte el espacio en blanco circundante.</summary>
        <returns>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> debe serializarse en un modo que recorte el espacio en blanco circundante; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.TrimSurroundingWhitespace%2A>.  
  
 La implementación predeterminada devuelve un valor basado en lectura <xref:System.Windows.Markup.TrimSurroundingWhitespaceAttribute>. También puede comprobar <xref:System.Xaml.XamlType.BaseType%2A> para el atributo si se encuentra ningún atributo en el tipo subyacente de inmediato. Si un valor no está disponible, devuelve `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlType.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> que tiene una restricción <see cref="T:System.ComponentModel.TypeConverter" />, que representa el comportamiento de la conversión de tipos para los valores de este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> con la restricción <see cref="T:System.ComponentModel.TypeConverter" /> que representa el comportamiento de la conversión de tipos para los valores de este objeto <see cref="T:System.Xaml.XamlType" />; de lo contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.TypeConverter%2A>.  
  
 La implementación predeterminada devuelve un valor basado en lectura <xref:System.ComponentModel.TypeConverterAttribute>. También puede comprobar la implementación predeterminada <xref:System.Xaml.XamlType.BaseType%2A> para el atributo si se encuentra ningún atributo en el tipo subyacente de inmediato. También incluye una lógica especial para la conversión predeterminada de enumeraciones, tipos de valor comunes y genéricos. Si un valor no está disponible, devuelve `null`.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.TypeConverter%2A> para utilizar una lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingType">
      <MemberSignature Language="C#" Value="protected virtual Type LookupUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type LookupUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ LookupUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingType : unit -&gt; Type&#xA;override this.LookupUnderlyingType : unit -&gt; Type" Usage="xamlType.LookupUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el objeto <see cref="T:System.Type" /> de CLR subyacente a este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Objeto <see cref="T:System.Type" /> de CLR subyacente a este objeto <see cref="T:System.Xaml.XamlType" />; de lo contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.UnderlyingType%2A>.  
  
 La implementación predeterminada devuelve un campo interno. Ese campo generalmente se inicializa durante la construcción y su valor se basa en el constructor que llamaba a la información que proporcionó.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.UnderlyingType%2A> para utilizar una lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUsableDuringInitialization">
      <MemberSignature Language="C#" Value="protected virtual bool LookupUsableDuringInitialization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupUsableDuringInitialization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUsableDuringInitialization () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupUsableDuringInitialization();" />
      <MemberSignature Language="F#" Value="abstract member LookupUsableDuringInitialization : unit -&gt; bool&#xA;override this.LookupUsableDuringInitialization : unit -&gt; bool" Usage="xamlType.LookupUsableDuringInitialization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> se compila de forma descendente durante la inicialización de XAML.</summary>
        <returns>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> se compila de forma descendente durante la inicialización de XAML; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Arriba a abajo es una metáfora que se aproxima al comportamiento del procesador XAML cuando crea el gráfico de objetos. Cuando compila de arriba a abajo, se crea la instancia de un tipo, adjunta al elemento primario, y se establecen sus propiedades. Construcción de arriba a abajo evita invocar controladores de cambio de propiedad varias veces. Dicho control propaga el gráfico de objetos y por lo tanto, elimina varias llamadas del controlador y proporciona una optimización del rendimiento para el inicio del gráfico de objetos.  
  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A>.  
  
 La implementación predeterminada devuelve un valor basado en lectura <xref:System.Windows.Markup.UsableDuringInitializationAttribute>. También puede comprobar <xref:System.Xaml.XamlType.BaseType%2A> para el atributo si se encuentra ningún atributo en el tipo subyacente de inmediato. Si un valor no está disponible, devuelve `false`.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A> para utilizar una lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlType.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> que tiene una restricción <see cref="T:System.Windows.Markup.ValueSerializer" />, que representa el comportamiento de serialización para los valores de este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> con la restricción <see cref="T:System.Windows.Markup.ValueSerializer" /> que representa el comportamiento de serialización para los valores de este objeto <see cref="T:System.Xaml.XamlType" />; de lo contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede invocar mediante llamadas a <xref:System.Xaml.XamlType.ValueSerializer%2A>.  
  
 La implementación predeterminada devuelve un valor basado en lectura <xref:System.Windows.Markup.ValueSerializerAttribute>. También puede comprobar <xref:System.Xaml.XamlType.BaseType%2A> para el atributo si se encuentra ningún atributo en el tipo subyacente de inmediato. También incluye una lógica especial para la serialización predeterminada de enumeraciones, tipos de valor comunes o genéricos. Si un valor no está disponible, devuelve `null`.  
  
 Invalide este método si desea que <xref:System.Xaml.XamlType.ValueSerializer%2A> para utilizar una lógica diferente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType MarkupExtensionReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType MarkupExtensionReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionReturnType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ MarkupExtensionReturnType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionReturnType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que proporciona información de tipo para el valor devuelto de <see langword="ProvideValue" /> de este objeto <see cref="T:System.Xaml.XamlType" /> si representa una extensión de marcado.</summary>
        <value>Objeto <see cref="T:System.Xaml.XamlType" /> del tipo de valor devuelto que representa una extensión de marcado; de lo contrario, es <see langword="null" /> si <see cref="T:System.Xaml.XamlType" /> no representa una extensión de marcado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad solo es pertinente si este <xref:System.Xaml.XamlType> representa una extensión de marcado (`x:MarkupExtension` está en la lista de tipos asignables).  
  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlType.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de cadena del tipo representado por este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Nombre de cadena de este tipo XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, esta propiedad obtiene el nombre de esquema construido (por la <xref:System.Xaml.XamlType.%23ctor%2A> firma), o el nombre de la <xref:System.Type>, si se construye utilizando el constructor pertinente del sistema de tipos CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Equality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="xamlType1 = xamlType2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1">
          <see cref="T:System.Xaml.XamlType" /> o <see langword="null" />.</param>
        <param name="xamlType2">
          <see cref="T:System.Xaml.XamlType" /> o <see langword="null" />.</param>
        <summary>Determina si dos objetos <see cref="T:System.Xaml.XamlType" /> especificados tienen el mismo valor.</summary>
        <returns>
          <see langword="true" /> si el valor de <paramref name="xamlType1" /> es el mismo que el valor de <paramref name="xamlType2" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Inequality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="System.Xaml.XamlType.op_Inequality (xamlType1, xamlType2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1">
          <see cref="T:System.Xaml.XamlType" /> o <see langword="null" />.</param>
        <param name="xamlType2">
          <see cref="T:System.Xaml.XamlType" /> o <see langword="null" />.</param>
        <summary>Determina si dos objetos <see cref="T:System.Xaml.XamlType" /> especificados tienen valores diferentes.</summary>
        <returns>
          <see langword="true" /> si el valor de <paramref name="xamlType1" /> es diferente que el valor de <paramref name="xamlType2" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el espacio de nombres XAML primario de este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Identificador, en forma de cadena, del espacio de nombres XAML primario de este tipo XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación proporciona el mismo valor que una llamada a <xref:System.Xaml.XamlType.GetXamlNamespaces%2A> y, a continuación, obtener la primera cadena de valor desde el conjunto enumerable devuelto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaContext">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlSchemaContext SchemaContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlSchemaContext SchemaContext" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.SchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SchemaContext As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlSchemaContext ^ SchemaContext { System::Xaml::XamlSchemaContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaContext : System.Xaml.XamlSchemaContext" Usage="System.Xaml.XamlType.SchemaContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Xaml.XamlSchemaContext" /> activo para procesar este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Objeto <see cref="T:System.Xaml.XamlSchemaContext" /> activo para procesar este objeto <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlSchemaContext> es una entrada de parámetro necesarios al construir un <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlType.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una representación de cadena de este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Representación de cadena de este objeto <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Xaml.XamlType> implementací <xref:System.Object.ToString%2A> devuelve el <xref:System.Xaml.XamlType.Name%2A> propiedad de la <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="public bool TrimSurroundingWhitespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimSurroundingWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TrimSurroundingWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrimSurroundingWhitespace { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.TrimSurroundingWhitespace : bool" Usage="System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlType" /> dispone de un comportamiento de serialización con control del espacio en blanco para recortar el espacio en blanco circundante en su contenido.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo que recorta el espacio en blanco; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeArguments">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; TypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; TypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeArguments As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ TypeArguments { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeArguments : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.TypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una lista de argumentos de tipo para los casos en los que este objeto <see cref="T:System.Xaml.XamlType" /> representa un tipo genérico.</summary>
        <value>Lista de argumentos de tipo; de lo contrario, es <see langword="null" /> si este objeto <see cref="T:System.Xaml.XamlType" /> no representa un tipo genérico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hay ciertos escenarios para un <xref:System.Xaml.XamlType> cuando una llamada a la <xref:System.Xaml.XamlType.TypeArguments%2A> parámetro devuelve una lista donde los tipos todavía están abiertos. En este caso, uno o varios de los devueltos <xref:System.Xaml.XamlType> valores tendrá los valores de marcador de posición para <xref:System.Xaml.XamlType.Name%2A?displayProperty=nameWithType>, tales como `T`, para representar que el tipo genérico todavía está abierto. Esta situación puede producirse si se produce un <xref:System.Xaml.XamlType> desde una llamada a <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A>, en lugar de desde una implementación de lector XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlType.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> con la restricción <see cref="T:System.ComponentModel.TypeConverter" /> que representa el comportamiento de la conversión de tipos para los valores de este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> con la restricción <see cref="T:System.ComponentModel.TypeConverter" /> que representa el comportamiento de la conversión de tipos para los valores de este objeto <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupTypeConverter%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupTypeConverter%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingType">
      <MemberSignature Language="C#" Value="public Type UnderlyingType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.UnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ UnderlyingType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingType : Type" Usage="System.Xaml.XamlType.UnderlyingType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Type" /> de CLR subyacente a este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Objeto <see cref="T:System.Type" /> de CLR subyacente a este objeto <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlType.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> con la restricción <see cref="T:System.Windows.Markup.ValueSerializer" /> que representa el comportamiento de serialización para los valores de este objeto <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> con la restricción <see cref="T:System.Windows.Markup.ValueSerializer" /> que representa el comportamiento de serialización para los valores de este objeto <see cref="T:System.Xaml.XamlType" />; de lo contrario, es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no utiliza la técnica de reflexión de CLR interna de predeterminada para un <xref:System.Xaml.XamlType>, pueden invocar las llamadas a esta propiedad <xref:System.Xaml.XamlType.LookupValueSerializer%2A> invalidaciones en <xref:System.Xaml.XamlType> las clases derivadas. Para obtener más información acerca de los valores devueltos y otros comportamientos, consulte la documentación de <xref:System.Xaml.XamlType.LookupValueSerializer%2A> en este tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>