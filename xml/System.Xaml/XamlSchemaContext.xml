<Type Name="XamlSchemaContext" FullName="System.Xaml.XamlSchemaContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c3cb020dadf6911a6184d7c73f01746771d9bdf1" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30720719" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlSchemaContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlSchemaContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlSchemaContext" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlSchemaContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlSchemaContext" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Define un contexto reutilizable para interpretar o asignar tipos XAML, y los tipos de los ensamblados subyacentes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un contexto de esquema XAML proporciona una capa de abstracción entre un esquema o vocabulario para XAML y una implementación del analizador concreta. Insertando el concepto de un contexto de esquema, el esquema se puede usar con analizadores XAML diferentes y el contexto de esquema rellena los detalles que se necesitan para interactuar con un analizador XAML específico. Por ejemplo, el contexto de esquema XAML proporciona API de consulta que relacionados con los conceptos de XAML o el enlace de CLR para el sistema de tipos XAML. El contexto de esquema XAML también es responsable de mantener la lista de ensamblados de los ensamblados cargados, que define donde un analizador XAML busca tipos de respaldo.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>En un <see cref="T:System.AppDomain" />, un <see cref="T:System.Xaml.XamlSchemaContext" /> pueden compartirse entre varios llamadores, que incluyen ambos completa y los llamadores de confianza parcial. Esta situación existe en marcos como WPF, que proporcionan acceso de confianza parcial de XAML en cargar para partes del modelo de aplicación de WPF. El valor predeterminado <see cref="T:System.Xaml.XamlSchemaContext" /> implementación proporciona medidas de seguridad en este escenario manteniendo todas sus propiedades y valores inmutables. Las implementaciones derivadas también deberían considerar seguir este modelo de inmutabilidad para las propiedades y la configuración de un contexto de esquema XAML.  
  
 La <see cref="T:System.Xaml.XamlSchemaContext" /> clase base está diseñada para que las búsquedas no tengan efectos deseados externamente observables. Los tipos que se hace referencia por <see cref="T:System.Xaml.XamlSchemaContext" /> API en la base de la clase, como <see cref="T:System.Xaml.XamlType" /> o <see cref="T:System.Xaml.XamlMember" />, también se producen efectos no deseados de las búsquedas. Todos los datos que es necesaria para tomar una determinación del esquema deben estar disponibles desde la construcción y la configuración de la <see cref="T:System.AppDomain" />. Observe que ninguna búsqueda API basadas en servicios de pasa de forma explícita; su entrada se basa en la cadena de entrada solo.  
  
 El <see cref="T:System.Xaml.XamlSchemaContext" /> de la clase base y <see cref="T:System.Xaml.XamlType" /> y <see cref="T:System.Xaml.XamlMember" /> son seguras en sus implementaciones base todos los subprocesos. Si deriva de <see cref="T:System.Xaml.XamlSchemaContext" /> o derivar clases de sistema de tipos XAML como <see cref="T:System.Xaml.XamlType" /> y <see cref="T:System.Xaml.XamlMember" /> , puede elegir si sus clases se comportarán como seguras para subprocesos.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext (System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; referenceAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; referenceAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (referenceAssemblies As IEnumerable(Of Assembly))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext(System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ referenceAssemblies);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="referenceAssemblies" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;" />
      </Parameters>
      <Docs>
        <param name="referenceAssemblies">Conjunto enumerable de elementos de información de ensamblado. La información de cada elemento viene especificada por un valor <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlSchemaContext" /> basándose en un conjunto de ensamblados de referencia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext (System.Xaml.XamlSchemaContextSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xaml.XamlSchemaContextSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor(System.Xaml.XamlSchemaContextSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (settings As XamlSchemaContextSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext(System::Xaml::XamlSchemaContextSettings ^ settings);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="settings" Type="System.Xaml.XamlSchemaContextSettings" />
      </Parameters>
      <Docs>
        <param name="settings">Objeto de configuración que se va a usar para crear el objeto <see cref="T:System.Xaml.XamlSchemaContext" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlSchemaContext" /> basándose en un objeto de configuración.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El objeto de configuración almacena información sobre características específicas de la extensión de marcado para el contexto de esquema y el convertidor de texto. Para obtener más información, vea <xref:System.Xaml.XamlSchemaContextSettings>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext (System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; referenceAssemblies, System.Xaml.XamlSchemaContextSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; referenceAssemblies, class System.Xaml.XamlSchemaContextSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Xaml.XamlSchemaContextSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (referenceAssemblies As IEnumerable(Of Assembly), settings As XamlSchemaContextSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext(System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ referenceAssemblies, System::Xaml::XamlSchemaContextSettings ^ settings);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="referenceAssemblies" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;" />
        <Parameter Name="settings" Type="System.Xaml.XamlSchemaContextSettings" />
      </Parameters>
      <Docs>
        <param name="referenceAssemblies">Conjunto enumerable de información de ensamblado. La información de cada elemento viene especificada por un valor <see cref="T:System.Reflection.Assembly" />.</param>
        <param name="settings">Objeto de configuración que se va a usar para crear el objeto <see cref="T:System.Xaml.XamlSchemaContext" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlSchemaContext" /> basándose en un conjunto de ensamblados de referencia y un objeto de configuración.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~XamlSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!XamlSchemaContext ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Proporciona una implementación de <see langword="Finalize" /> no estándar que no invoca a <see langword="Dispose" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contextos de esquema XAML no deberían eliminarse mediante una recolección automática o mediante las operaciones manuales. Aunque los contextos de esquema XAML tienen recursos no administrados, <xref:System.Windows.Markup.XamlDeferLoadAttribute> propiedades todavía pueden estar activas y desechar un contexto de esquema XAML puede interferir con la operación de carga-aplazar relacionados.  
  
 <xref:System.AppDomain.AssemblyLoad> controladores de eventos, que están enlazados internamente como referencias débiles, se limpian mediante la implementación.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullyQualifyAssemblyNamesInClrNamespaces">
      <MemberSignature Language="C#" Value="public bool FullyQualifyAssemblyNamesInClrNamespaces { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FullyQualifyAssemblyNamesInClrNamespaces" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlSchemaContext.FullyQualifyAssemblyNamesInClrNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FullyQualifyAssemblyNamesInClrNamespaces As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool FullyQualifyAssemblyNamesInClrNamespaces { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que especifica si un esquema XAML y su contexto emplean nombres de ensamblado completos en los valores devueltos por la API de búsqueda.</summary>
        <value>
          Es <see langword="true" /> si un esquema XAML y su contexto emplean nombres de ensamblado completos en los valores devueltos por las API de búsqueda; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el <xref:System.Xaml.XamlSchemaContextSettings.FullyQualifyAssemblyNamesInClrNamespaces%2A?displayProperty=nameWithType> valor que se establece en la configuración de la <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Xaml.XamlSchemaContextSettings%29> firma del constructor. Si otras firmas se usaron para la construcción o si <xref:System.Xaml.XamlSchemaContextSettings.FullyQualifyAssemblyNamesInClrNamespaces%2A?displayProperty=nameWithType> no se establece específicamente `true`, el valor de esta propiedad es `false`.  
  
 El valor de esta propiedad influye en las cadenas que se devuelven por <xref:System.Xaml.XamlSchemaContext.GetAllXamlNamespaces%2A>. Si <xref:System.Xaml.XamlSchemaContext.FullyQualifyAssemblyNamesInClrNamespaces%2A> es `true`, la parte del ensamblado de la cadena notificará el equivalente de <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetAllXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetAllXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetAllXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAllXamlNamespaces () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetAllXamlNamespaces();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Busca en los ensamblados que contiene <see cref="T:System.Xaml.XamlSchemaContext" /> y devuelve un conjunto de espacios de nombres.</summary>
        <returns>Conjunto enumerable de identificadores de espacio de nombres. Estos identificadores se proporcionan como cadenas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método sólo busca los ensamblados de referencia si se pasan a través de la configuración de construcción o de propiedad. Si ningún ensamblado se establece como ensamblados de referencia, la lógica de este método examina todos los ensamblados cargados donde esto <xref:System.Xaml.XamlSchemaContext> está activo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllXamlTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt; GetAllXamlTypes (string xamlNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlType&gt; GetAllXamlTypes(string xamlNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetAllXamlTypes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAllXamlTypes (xamlNamespace As String) As ICollection(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::ICollection&lt;System::Xaml::XamlType ^&gt; ^ GetAllXamlTypes(System::String ^ xamlNamespace);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Espacio de nombres XAML del que se van a devolver tipos.</param>
        <summary>Busca en los ensamblados que contiene <see cref="T:System.Xaml.XamlSchemaContext" /> y devuelve un conjunto de tipos del espacio de nombres XAML especificado.</summary>
        <returns>Conjunto enumerable de tipos XAML. Cada tipo XAML del conjunto está representado por un objeto <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPreferredPrefix">
      <MemberSignature Language="C#" Value="public virtual string GetPreferredPrefix (string xmlns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetPreferredPrefix(string xmlns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetPreferredPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreferredPrefix (xmlns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetPreferredPrefix(System::String ^ xmlns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlns">Espacio de nombres XAML del que se va a obtener el prefijo preferido.</param>
        <summary>Obtiene una cadena que se notifica como el prefijo preferido para uso de los consumidores cuando asignan el espacio de nombres XAML especificado.</summary>
        <returns>Cadena que los consumidores deberían usar cuando asignan el espacio de nombres XAML especificado para uso del marcado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El consumidor más inmediato de la información suele ser un escritor de XAML. Otros consumidores indirectos incluyen herramientas de diseño.  
  
 Como parte del enlace XAML para common language runtime (CLR), puede especificar esta información mediante la aplicación <xref:System.Windows.Markup.XmlnsPrefixAttribute> en el nivel de ensamblado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="xmlns" /> es null.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueConverter&lt;TConverterBase&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Xaml.Schema.XamlValueConverter&lt;TConverterBase&gt; GetValueConverter&lt;TConverterBase&gt; (Type converterType, System.Xaml.XamlType targetType) where TConverterBase : class;" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Xaml.Schema.XamlValueConverter`1&lt;!!TConverterBase&gt; GetValueConverter&lt;class TConverterBase&gt;(class System.Type converterType, class System.Xaml.XamlType targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetValueConverter``1(System.Type,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetValueConverter(Of TConverterBase As Class) (converterType As Type, targetType As XamlType) As XamlValueConverter(Of TConverterBase)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TConverterBase&gt;&#xA; where TConverterBase : class System::Xaml::Schema::XamlValueConverter&lt;TConverterBase&gt; ^ GetValueConverter(Type ^ converterType, System::Xaml::XamlType ^ targetType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;TConverterBase&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TConverterBase">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="converterType" Type="System.Type" />
        <Parameter Name="targetType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <typeparam name="TConverterBase">Clase base concreta del convertidor.</typeparam>
        <param name="converterType">Implementación del convertidor.</param>
        <param name="targetType">Tipo de destino deseado para el convertidor.</param>
        <summary>Devuelve un convertidor de valores que puede realizar la conversión al valor <paramref name="targetType" /> solicitado.</summary>
        <returns>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> con una restricción que coincide con la restricción que se coloca en la llamada al método.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlDirective">
      <MemberSignature Language="C#" Value="public virtual System.Xaml.XamlDirective GetXamlDirective (string xamlNamespace, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xaml.XamlDirective GetXamlDirective(string xamlNamespace, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlDirective(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlDirective (xamlNamespace As String, name As String) As XamlDirective" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xaml::XamlDirective ^ GetXamlDirective(System::String ^ xamlNamespace, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlDirective</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Espacio de nombres XAML que contiene la directiva con nombre.</param>
        <param name="name">Nombre de la directiva que se va a obtener.</param>
        <summary>Devuelve un valor <see cref="T:System.Xaml.XamlDirective" /> que representa una directiva, bien para el lenguaje XAML o para una implementación determinada.</summary>
        <returns>Objeto <see cref="T:System.Xaml.XamlDirective" /> que representa la directiva solicitada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalide este método si crea una clase derivada de <xref:System.Xaml.XamlDirective> como parte de un escenario de extensión de sistema de tipos XAML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="xamlNamespace" /> o <paramref name="name" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetXamlType">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Xaml.XamlType" /> que se basa en un identificador de tipo de CLR o XAML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetXamlType">
      <MemberSignature Language="C#" Value="public virtual System.Xaml.XamlType GetXamlType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xaml.XamlType GetXamlType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xaml::XamlType ^ GetXamlType(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Tipo para el que se va a obtener un objeto <see cref="T:System.Xaml.XamlType" />.</param>
        <summary>Devuelve un objeto <see cref="T:System.Xaml.XamlType" /> que se basa en un identificador de tipo de CLR.</summary>
        <returns>
          <see cref="T:System.Xaml.XamlType" /> que coincide con el valor <paramref name="type" /> de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se da por supuesto que está utilizando el CLR para el sistema de tipos de respaldo. Si no se usa el sistema de tipos CLR, use <xref:System.Xaml.XamlSchemaContext.GetXamlType%28System.Xaml.Schema.XamlTypeName%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetXamlType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType GetXamlType (System.Xaml.Schema.XamlTypeName xamlTypeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlType GetXamlType(class System.Xaml.Schema.XamlTypeName xamlTypeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlType(System.Xaml.Schema.XamlTypeName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlType ^ GetXamlType(System::Xaml::Schema::XamlTypeName ^ xamlTypeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlTypeName" Type="System.Xaml.Schema.XamlTypeName" />
      </Parameters>
      <Docs>
        <param name="xamlTypeName">Nombre de tipo XAML para el que se va a obtener un objeto <see cref="T:System.Xaml.XamlType" />.</param>
        <summary>Devuelve un objeto <see cref="T:System.Xaml.XamlType" /> que se basa en un nombre de tipo de sistema XAML.</summary>
        <returns>
          <see cref="T:System.Xaml.XamlType" /> que coincide con el valor <paramref name="xamlTypeName" /> de entrada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Un componente de <paramref name="xamlTypeName" /> (<see cref="P:System.Xaml.Schema.XamlTypeName.Name" /> o <see cref="P:System.Xaml.Schema.XamlTypeName.Namespace" />) es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="xamlTypeName" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Xaml.Schema.XamlTypeName" />
      </Docs>
    </Member>
    <Member MemberName="GetXamlType">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xaml.XamlType GetXamlType (string xamlNamespace, string name, params System.Xaml.XamlType[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xaml.XamlType GetXamlType(string xamlNamespace, string name, class System.Xaml.XamlType[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlType(System.String,System.String,System.Xaml.XamlType[])" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetXamlType (xamlNamespace As String, name As String, ParamArray typeArguments As XamlType()) As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xaml::XamlType ^ GetXamlType(System::String ^ xamlNamespace, System::String ^ name, ... cli::array &lt;System::Xaml::XamlType ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Xaml.XamlType[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Espacio de nombres XAML que contiene el tipo deseado.</param>
        <param name="name">Nombre de cadena del tipo deseado.</param>
        <param name="typeArguments">Argumentos de tipo de inicialización para un tipo genérico.</param>
        <summary>Devuelve un objeto <see cref="T:System.Xaml.XamlType" /> basado en un espacio de nombres XAML y una cadena para el nombre de tipo. Esta firma puede especificar los argumentos de tipo para aquellos casos en los que el tipo deseado es un tipo genérico.</summary>
        <returns>
          <see cref="T:System.Xaml.XamlType" /> que coincide con el criterio de entrada.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAssemblyResolve">
      <MemberSignature Language="C#" Value="protected internal virtual System.Reflection.Assembly OnAssemblyResolve (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Reflection.Assembly OnAssemblyResolve(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.OnAssemblyResolve(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function OnAssemblyResolve (assemblyName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Reflection::Assembly ^ OnAssemblyResolve(System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre del ensamblado que se va a cargar.</param>
        <summary>Se llama cuando las operaciones usan este contexto de esquema para resolver un ensamblado requerido para resolver los espacios de nombres XAML que contiene.</summary>
        <returns>Ensamblado resuelto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La técnica de resolución de ensamblado subyacente, que es una API interna, ha integrado tolerancias para distintas formas de cadena de un nombre de ensamblado como basada en la <xref:System.Reflection.AssemblyName> comportamiento de construcción.  
  
 El propósito de esta API es habilitar la resolución de primera oportunidad en conjuntos de ensamblados, conocidos como en los ensamblados de referencia en lugar de en una memoria caché global de ensamblados. Si se rellena la lista de ensamblados de referencia, la implementación predeterminada puede tener acceso a los ensamblados de referencia conocidas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceAssemblies">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Reflection.Assembly&gt; ReferenceAssemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Reflection.Assembly&gt; ReferenceAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlSchemaContext.ReferenceAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReferenceAssemblies As IList(Of Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Reflection::Assembly ^&gt; ^ ReferenceAssemblies { System::Collections::Generic::IList&lt;System::Reflection::Assembly ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un conjunto enumerable de ensamblados de referencia para el contexto de esquema XAML.</summary>
        <value>Conjunto enumerable de ensamblados de referencia para el contexto de esquema. La información de cada elemento viene especificada por un valor <see cref="T:System.Reflection.Assembly" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportMarkupExtensionsWithDuplicateArity">
      <MemberSignature Language="C#" Value="public bool SupportMarkupExtensionsWithDuplicateArity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportMarkupExtensionsWithDuplicateArity" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportMarkupExtensionsWithDuplicateArity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportMarkupExtensionsWithDuplicateArity { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que especifica si un esquema XAML y su contexto admiten extensiones de marcado en las que hay dos constructores con la misma aridad (número de parámetros de entrada).</summary>
        <value>
          Es <see langword="true" /> si el contexto de esquema permite extensiones de marcado con aridad duplicada; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A?displayProperty=nameWithType> valor que se establece en la configuración de la <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Xaml.XamlSchemaContextSettings%29> firma del constructor. Si otras firmas se usan para la construcción o si <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A?displayProperty=nameWithType> no se establece específicamente `true`, el valor de esta propiedad es `false`.  
  
 Aridad duplicada de las extensiones de marcado no se trata específicamente por la especificación XAML [MS-XAML] sección 6.6.7.2. Esto es porque la información del elemento de información de XAML para una extensión de marcado es idéntica independientemente de aridad duplicada que puedan existir en la implementación de extensión de marcado. Solo la invocación real de la extensión de marcado y su `ProvideValue` expone los problemas asociados con aridad duplicada. Comportamiento para administrar la aridad duplicada es indefinido y se deja en cada contexto de esquema XAML y su integración de sistema de escritura XAML. El contexto de esquema XAML predeterminado tal como se implementa para las operaciones de servicios XAML de .NET Framework no admite la aridad duplicada; varias API de servicios XAML de .NET Framework producirán excepciones al procesar el uso de la extensión de marcado con aridad duplicada subyacente.  
  
 Para obtener más información acerca de cómo definir las extensiones de marcado, vea [extensiones de marcado para XAML Overview](~/docs/framework/xaml-services/markup-extensions-for-xaml-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetCompatibleXamlNamespace">
      <MemberSignature Language="C#" Value="public virtual bool TryGetCompatibleXamlNamespace (string xamlNamespace, out string compatibleNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetCompatibleXamlNamespace(string xamlNamespace, [out] string&amp; compatibleNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.TryGetCompatibleXamlNamespace(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetCompatibleXamlNamespace (xamlNamespace As String, ByRef compatibleNamespace As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetCompatibleXamlNamespace(System::String ^ xamlNamespace, [Runtime::InteropServices::Out] System::String ^ % compatibleNamespace);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="compatibleNamespace" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Cadena <see langword="xmlns" /> del espacio de nombres XAML en el que se va a buscar un resultado compatible.</param>
        <param name="compatibleNamespace">Cuando este método devuelve un valor, es la cadena <see langword="xmlns" /> para una solicitud de espacio de nombres XAML compatible. Puede ser idéntico a <c>xamlNamespace</c> si el método devuelve <see langword="false" />.</param>
        <summary>Devuelve un valor que indica si ha sido correcta o no la solicitud de un espacio de nombres XAML compatible. Si la solicitud es correcta, se notifica ese espacio de nombres XAML como parámetro de salida.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="compatibleNamespace" /> contiene un resultado utilizable; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Internamente, este método utiliza el siguiente orden de búsqueda:  
  
1.  Un diccionario de compatibilidad implementado internamente, que se han rellenado por una búsqueda anterior.  
  
2.  El <xref:System.Windows.Markup.XmlnsCompatibleWithAttribute> evaluación del parámetro.  
  
 Si no se detecta ningún otro espacio de nombres compatible y este método devuelve `false`, `compatibleNamespace` salida parámetro podría tener el mismo valor que el `xamlNamespace` entrada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="xamlNamespace" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>