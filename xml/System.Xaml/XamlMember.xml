<Type Name="XamlMember" FullName="System.Xaml.XamlMember">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="043e180cfa1cd2c740edc299acbc22e34cd99019" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39978671" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlMember : IEquatable&lt;System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlMember extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlMember" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlMember&#xA;Implements IEquatable(Of XamlMember)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlMember : IEquatable&lt;System::Xaml::XamlMember ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlMember = class&#xA;    interface IEquatable&lt;XamlMember&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlMember&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Proporciona el identificador del sistema de tipos XAML para miembros de tipos XAML. Los lectores XAML y los sistemas de escritura XAML usan el identificador al procesar los nodos de miembro (cuando el lector XAML está en un miembro <see cref="F:System.Xaml.XamlNodeType.StartMember" />) y también para la lógica general del sistema de tipos de XAML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember> Puede usar las metodologías de tres para devolver información acerca de un miembro XAML: common language runtime (CLR) reflexión estándar; una técnica de referencia de solo reflexión interna de una llamada a las API de ese bit optimizada marcas; o reemplaza una llamada a virtual de la `Lookup*` API proporcionada por posibles <xref:System.Xaml.XamlMember> subclases. Para la mayoría de los usos de la API de servicios XAML de .NET Framework y el <xref:System.Xaml.XamlMember> API, usa el contexto de esquema XAML predeterminado. El contexto de esquema XAML predeterminado para los servicios XAML de .NET Framework usa para el sistema de tipos de respaldo de CLR. Esto permite que los lectores XAML y escritores XAML para trabajar con cualquier tipo o miembro que se define en, o de otro modo disponible para, CLR y sus técnicas de reflexión.  
  
## <a name="lookup-apis-and-xamlmember-derived-classes"></a>Las clases derivadas de API de búsqueda y XamlMember  
 <xref:System.Xaml.XamlMember> define varios miembros virtuales que las clases derivadas pueden invalidar. Estos miembros tienen nombres que siempre comienzan con la cadena `Lookup`. El resto de la API de referencias, a continuación, la propiedad de nombre que influye en el método virtual. Por ejemplo, un <xref:System.Xaml.XamlMember> clase derivada podría reemplazar <xref:System.Xaml.XamlMember.LookupTargetType%2A> para influir en lo que la propiedad definida en la base de <xref:System.Xaml.XamlMember.TargetType%2A> devuelve en una clase derivada. Puede predecir valores devueltos para estas propiedades en <xref:System.Xaml.XamlMember> o existente de las clases derivadas, lea la documentación correspondiente `Lookup*` métodos.  
  
 El propósito de la `Lookup*` métodos es proporcionar una técnica de extensión de sistema de tipo XAML que incorpora el <xref:System.Xaml.XamlMember> clase base. Al derivar de <xref:System.Xaml.XamlMember> e invalidar la `Lookup` miembros virtuales, puede definir el concepto de un miembro XAML para un esquema XAML en un sistema de tipos XAML sin estar vinculados a los detalles de un sistema de tipos de respaldo o tecnología. Puede también usar un contexto de esquema XAML proporcionado con este esquema y devolver los resultados que desee.  
  
 Por ejemplo, considere la <xref:System.Xaml.XamlMember> propiedad <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Esta propiedad informa a los llamadores que las operaciones como el uso de un <xref:System.Xaml.XamlWriter> para la serialización puede escribir un valor para este miembro en un objeto de destino. En la implementación predeterminada, la determinación de si el miembro es de escritura se realiza mediante el uso de técnicas de reflexión en el CLR de respaldo <xref:System.Type> y sus miembros (el <xref:System.Reflection.MemberInfo>). Por lo tanto, de forma predeterminada, el sistema de tipos XAML depende del sistema de tipos CLR. Sin embargo, puede quitar esta dependencia para los informes de sistema de tipo XAML de <xref:System.Xaml.XamlMember.IsWritePublic%2A> invalidando la API <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>. Dentro de la invalidación, puede usar otras determinaciones, como metadatos que son específicos de su tecnología, una tabla de búsqueda principal que está optimizada para un vocabulario XAML fijo o una variedad de otras estrategias para determinar si un miembro XAML es grabable en la Vocabulario XAML.  
  
## <a name="constructing-xamlmember-without-xaml-schema-context"></a>Construir XamlMember sin contexto de esquema XAML  
 La mayoría de los constructores de <xref:System.Xaml.XamlMember> requieren un <xref:System.Xaml.XamlSchemaContext> como parte de su inicialización. El <xref:System.Xaml.XamlSchemaContext> también es necesario para muchas interno <xref:System.Xaml.XamlSchemaContext> operaciones, como la obtención de información que se reenvían desde el tipo de respaldo. Cuando se trabaja con el <xref:System.Xaml.XamlMember> API, suelen tener un <xref:System.Xaml.XamlSchemaContext> que está disponible en una construcción circundante como un <xref:System.Xaml.XamlWriter>. En este caso, puede pasar el <xref:System.Xaml.XamlSchemaContext> hace referencia mediante todas las llamadas de sistema de tipo XAML que requieren un contexto de esquema XAML.  
  
 Un constructor específico, <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>, no requiere un <xref:System.Xaml.XamlSchemaContext>. Sin embargo, un <xref:System.Xaml.XamlMember> que se construye con la <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> firma devuelve `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Para una ruta de acceso de carga que implica <xref:System.Xaml.XamlObjectWriter>, dicho miembro no se puede escribir en un gráfico de objetos. Mediante la implementación de servicios XAML de .NET Framework, el <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> llamar a produce un <xref:System.Xaml.XamlObjectWriterException> cuando la correspondiente <xref:System.Xaml.XamlMember> informes `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 No debe construir un <xref:System.Xaml.XamlMember> que tiene un valor de `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A> a menos que su implementación puede controlar las excepciones de <xref:System.Xaml.XamlObjectWriter>, o tienen otras formas de ajustar la <xref:System.Xaml.XamlObjectWriter> comportamiento. Por ejemplo, puede suceder de su implementación de uno o varios de los siguientes:  
  
-   El contexto de esquema XAML está disponible más tarde.  
  
-   Use un patrón del invocador de miembro.  
  
-   Invalida deliberadamente <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> en un sistema de escritura XAML personalizado.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlType" />
    <altmember cref="T:System.Xaml.XamlDirective" />
    <altmember cref="T:System.Xaml.XamlObjectWriter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlMember" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="eventInfo">
          <see cref="T:System.Reflection.EventInfo" /> del sistema de tipos de CLR que representa el miembro de evento.</param>
        <param name="schemaContext">Contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que califica el miembro.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlMember" /> usando <see cref="T:System.Reflection.EventInfo" /> del sistema de tipos de CLR y un <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor si el miembro representa un evento (propiedad de punto de conexión del controlador de eventos).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">
          <see cref="T:System.Reflection.PropertyInfo" /> del sistema de tipos de CLR que representa el miembro de propiedad.</param>
        <param name="schemaContext">Contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que califica el miembro.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlMember" /> usando <see cref="T:System.Reflection.PropertyInfo" /> del sistema de tipos de CLR y un <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor si el miembro representa una propiedad (y en concreto, no es una conexión de controlador de eventos).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="eventInfo">
          <see cref="T:System.Reflection.EventInfo" /> del sistema de tipos de CLR que representa el miembro de evento.</param>
        <param name="schemaContext">Contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que califica el miembro.</param>
        <param name="invoker">Implementación de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que administra las llamadas de reflexión en tiempo de ejecución al objeto <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlMember" /> usando <see cref="T:System.Reflection.EventInfo" /> del sistema de tipos de CLR y un <see cref="T:System.Xaml.XamlSchemaContext" />, incluyendo información de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor si el miembro representa un evento (o una propiedad de punto de conexión del controlador de eventos).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">
          <see cref="T:System.Reflection.PropertyInfo" /> del sistema de tipos de CLR que representa el miembro de propiedad.</param>
        <param name="schemaContext">Contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que califica el miembro.</param>
        <param name="invoker">Implementación de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que controla las llamadas de invocación en tiempo de ejecución al objeto <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlMember" /> usando <see cref="T:System.Reflection.PropertyInfo" /> de reflexión y un <see cref="T:System.Xaml.XamlSchemaContext" />, incluyendo información de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor solo si el miembro representa una propiedad y si no es una conexión de controlador de eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">El nombre de cadena del evento que se puede asociar.</param>
        <param name="adder">
          <see cref="T:System.Reflection.MethodInfo" /> del sistema de tipos de CLR para el método <see langword="Add" /> del controlador de la implementación de respaldo del miembro que se puede adjuntar.</param>
        <param name="schemaContext">Contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que califica el miembro.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlMember" /> para un <see cref="T:System.Xaml.XamlMember" /> que representa un evento que se puede adjuntar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor si el miembro representa a un miembro de evento que se puede adjuntar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string name, System.Xaml.XamlType declaringType, bool isAttachable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Xaml.XamlType declaringType, bool isAttachable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, declaringType As XamlType, isAttachable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ name, System::Xaml::XamlType ^ declaringType, bool isAttachable);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Xaml.XamlType * bool -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (name, declaringType, isAttachable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="declaringType" Type="System.Xaml.XamlType" />
        <Parameter Name="isAttachable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">El nombre de cadena del miembro.</param>
        <param name="declaringType">Información de <see cref="T:System.Xaml.XamlType" /> para el tipo declarativo.</param>
        <param name="isAttachable">Es <see langword="true" /> para indicar que el miembro se puede adjuntar; de lo contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlMember" /> usando un nombre de cadena y declarando información de <see cref="T:System.Xaml.XamlType" />. Un <see cref="T:System.Xaml.XamlMember" /> que se construye con esta firma tiene limitaciones importantes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Xaml.XamlMember> que se construye con la <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> firma devuelve `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Para una ruta de acceso de carga que implica <xref:System.Xaml.XamlObjectWriter>, dicho miembro no se puede escribir en un gráfico de objetos. Mediante la implementación de servicios XAML de .NET Framework, el <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> llamar a produce un <xref:System.Xaml.XamlObjectWriterException> cuando la correspondiente <xref:System.Xaml.XamlMember> informes `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 No debe construir un <xref:System.Xaml.XamlMember> con <xref:System.Xaml.XamlMember.IsUnknown%2A> `true` a menos que su implementación puede controlar las excepciones de <xref:System.Xaml.XamlObjectWriter>, o tienen otras formas de ajustar la <xref:System.Xaml.XamlObjectWriter> comportamiento. Por ejemplo, puede suceder de su implementación de uno o varios de los siguientes:  
  
-   El contexto de esquema XAML está disponible más tarde.  
  
-   Use un patrón del invocador de miembro.  
  
-   Invalida deliberadamente <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> en un sistema de escritura XAML personalizado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="name" /> o <paramref name="declaringType" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">El nombre de cadena de la propiedad que se puede asociar.</param>
        <param name="getter">
          <see cref="T:System.Reflection.MethodInfo" /> del sistema de tipos de CLR para el descriptor de acceso <see langword="get" /> de la implementación de respaldo del miembro que se puede adjuntar.</param>
        <param name="setter">
          <see cref="T:System.Reflection.MethodInfo" /> del sistema de tipos de CLR para el descriptor de acceso <see langword="set" /> de la implementación de respaldo del miembro que se puede adjuntar.</param>
        <param name="schemaContext">Contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que califica el miembro.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlMember" /> para un <see cref="T:System.Xaml.XamlMember" /> que representa una propiedad que se puede adjuntar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor si el miembro representa una propiedad que se puede adjuntar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">El nombre de cadena del evento que se puede asociar.</param>
        <param name="adder">
          <see cref="T:System.Reflection.MethodInfo" /> del sistema de tipos de CLR para el método <see langword="Add" /> del controlador de la implementación de respaldo del miembro que se puede adjuntar.</param>
        <param name="schemaContext">Contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que califica el miembro.</param>
        <param name="invoker">Implementación de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que controla las llamadas de invocación en tiempo de ejecución al objeto <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlMember" /> para un <see cref="T:System.Xaml.XamlMember" /> que representa un evento que se puede adjuntar, incluyendo información de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor si el miembro representa a un miembro de evento que se puede adjuntar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">El nombre de cadena de la propiedad que se puede asociar.</param>
        <param name="getter">
          <see cref="T:System.Reflection.MethodInfo" /> del sistema de tipos de CLR para el descriptor de acceso <see langword="get" /> de la implementación de respaldo del miembro que se puede adjuntar.</param>
        <param name="setter">
          <see cref="T:System.Reflection.MethodInfo" /> del sistema de tipos de CLR para el descriptor de acceso <see langword="set" /> de la implementación de respaldo del miembro que se puede adjuntar.</param>
        <param name="schemaContext">Contexto <see cref="T:System.Xaml.XamlSchemaContext" /> que califica el miembro.</param>
        <param name="invoker">Implementación de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que controla las llamadas de invocación en tiempo de ejecución al objeto <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xaml.XamlMember" /> para un <see cref="T:System.Xaml.XamlMember" /> que representa una propiedad que se puede adjuntar, incluyendo información de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor si el miembro representa a un miembro de propiedad adjuntable.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ DeclaringType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el <see cref="T:System.Xaml.XamlType" /> para el tipo que declara el miembro asociado a este <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>
          <see cref="T:System.Xaml.XamlType" /> para el tipo que declara el miembro asociado a este <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor normalmente se establece durante la inicialización y no suele ser `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.DeclaringType%2A> los constructores puede pasar en información para la inicialización. Mediante una llamada directamente a los constructores bases, la inicialización para <xref:System.Xaml.XamlMember> las clases derivadas pueden omitir algunas de las comprobaciones de valor que se realizan en la clase base. Por lo tanto, la inicialización derivada puede cambiar la información de relación de miembro de tipo notificado de un miembro XAML para que ya no esté disponible en la manera esperada con la información del sistema de tipo de su declaración de CLR subyacente. Para cualquier comprobación crítico para la seguridad de la declaración de la información de tipo, para usar el tipo CLR subyacente en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlMember.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, que se usa para la carga diferida de objetos declarados en XAML.</summary>
        <value>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> con la restricción <see cref="T:System.Xaml.XamlDeferringLoader" /> en el tipo genérico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Xaml.XamlMember.DeferringLoader%2A> invoca <xref:System.Xaml.XamlMember.LookupDeferringLoader%2A> o una invalidación específica de ese método. Este comportamiento se produce en los casos donde la lógica de reflexión interna inicial aún no ha establecido la información.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependsOn">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; DependsOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; DependsOn" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DependsOn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependsOn As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ DependsOn { System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependsOn : System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="System.Xaml.XamlMember.DependsOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una lista de objetos <see cref="T:System.Xaml.XamlMember" />. Indican los miembros donde existen relaciones de dependencia para el orden de inicialización con respecto a este <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Una lista de objetos <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Xaml.XamlMember.DependsOn%2A> invoca <xref:System.Xaml.XamlMember.LookupDependsOn%2A> o una invalidación específica de ese método. Este comportamiento se produce en los casos donde la lógica de reflexión interna inicial aún no ha establecido la información.  
  
 El `DependsOn` patrón se puede aplicar a los casos del modelo de objeto que contradicen deliberadamente una regla general de XAML. La regla general de XAML es que los miembros de un tipo que no se pasan como texto de inicialización (o un método de fábrica en XAML 2009) deben poder asignarse en cualquier orden. Aplicando un `DependsOn` patrón a un miembro, puede indicar a los escritores XAML para procesar siempre el miembro que se hace referencia antes de este miembro. Puede aplicar este patrón en situaciones donde el valor del miembro actual requiere contexto u otra información que solo está disponible después de establece el otro miembro.  
  
 El `DependsOn` patrón debe aplicarse con prudencia y reservado para los escenarios de propiedad donde sirve un propósito de arquitectura. Gran número de dependencias tiene el potencial para reducir el procesamiento de XAML. Además, es posible generar dependencias circulares, en cuyo caso el comportamiento de procesamiento de XAML es indefinido.  
  
 Ejemplo `DependsOn` escenarios de WPF incluyen ciertas propiedades en <xref:System.Windows.Controls.ControlTemplate> y <xref:System.Windows.DataTemplate>, en <xref:System.Windows.Trigger>y en <xref:System.Windows.Setter>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.DependsOnAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si el objeto actual es igual que otro objeto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlMember.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar con este objeto.</param>
        <summary>Indica si el objeto actual es igual que otro objeto.</summary>
        <returns>
          <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="obj" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlMember other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlMember other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlMember ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlMember -&gt; bool" Usage="xamlMember.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="other">Objeto que se va a comparar con este objeto.</param>
        <summary>Indica si el objeto actual es igual que otro objeto del mismo tipo.</summary>
        <returns>
          <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlMember.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de este objeto.</summary>
        <returns>Código hash entero.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlMember.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una lista de los espacios de nombres XAML donde este miembro XAML puede existir.</summary>
        <returns>Lista de identificadores de espacio de nombres XAML, en forma de cadenas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada devuelve el <xref:System.Xaml.XamlType.GetXamlNamespaces%2A?displayProperty=nameWithType> resultado de llamada la <xref:System.Xaml.XamlMember.DeclaringType%2A> que está asociado a este <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlMemberInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlMemberInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlMemberInvoker ^ Invoker { System::Xaml::Schema::XamlMemberInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlMemberInvoker" Usage="System.Xaml.XamlMember.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la implementación de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que está asociada a este objeto <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Implementación de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que está asociada a este objeto <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Invoker` patrón es una técnica avanzada de extensión de sistema de tipos XAML. El `Invoker` patrón proporciona una forma de insertar el comportamiento de asignación de tipos de esquema diferente, mientras sigue usando definiciones de sistema de tipos XAML de los servicios XAML de .NET Framework.  
  
 Si un <xref:System.Xaml.XamlMember.LookupInvoker%2A> invalidar devuelve `null`, o si la implementación predeterminada devuelve `null` porque carece del <xref:System.Xaml.XamlMember.UnderlyingMember%2A> para este <xref:System.Xaml.XamlMember>, el <xref:System.Xaml.XamlMember.Invoker%2A> propiedad devuelve <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> es el valor predeterminado. Esto es cierto para la mayoría de las operaciones que usan los servicios XAML de .NET Framework y el contexto de esquema XAML predeterminado y donde ningún modelo específico invalidan `Invoker` patrones se pasan para la construcción de las entidades del sistema de tipo XAML.  
  
 Una llamada a <xref:System.Xaml.XamlMember.Invoker%2A> invoca <xref:System.Xaml.XamlMember.LookupInvoker%2A> o una invalidación específica de ese método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlMember.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto <see cref="T:System.Xaml.XamlMember" /> se notifica como una propiedad de ambiente.</summary>
        <value>Es <see langword="true" /> si este <see cref="T:System.Xaml.XamlMember" /> se notifica como propiedad de ambiente; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Xaml.XamlMember.IsAmbient%2A> invoca <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> o una invalidación específica de ese método. Este comportamiento se produce en las implementaciones donde la lógica de reflexión interna inicial aún no ha establecido la información.  
  
 Comprobación de las propiedades de ambiente es normalmente forman parte de lógica de procesamiento de XAML para asegurarse de que los objetos y valores que se basan en el uso de ambiente para la cualificación de tipo pueden funcionar correctamente. Las API de servicios XAML de .NET Framework y el contexto de esquema XAML predeterminado rellena este valor en función de atribución con <xref:System.Windows.Markup.AmbientAttribute>. La implementación predeterminada de <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> usa este existente <xref:System.Windows.Markup.AmbientAttribute> técnica y devuelve `true` si <xref:System.Windows.Markup.AmbientAttribute> existe en una declaración de miembro.  
  
 <xref:System.Windows.Markup.AmbientAttribute> no se encuentra en los miembros de los distintos tipos WPF, que incluyen <xref:System.Windows.Application>, <xref:System.Windows.Setter>, y <xref:System.Windows.Style>. También se encuentra en la <xref:System.Windows.ResourceDictionary> tipo, que indica la existencia de que cualquier miembro que usa <xref:System.Windows.ResourceDictionary> como su tipo debe considerarse ambiente incluso si el miembro no se atribuye específicamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsAttachable">
      <MemberSignature Language="C#" Value="public bool IsAttachable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttachable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAttachable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttachable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttachable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttachable : bool" Usage="System.Xaml.XamlMember.IsAttachable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este <see cref="T:System.Xaml.XamlMember" /> es un miembro que se puede adjuntar.</summary>
        <value>Es <see langword="true" /> si este <see cref="T:System.Xaml.XamlMember" /> es un miembro que se puede adjuntar; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Xaml.XamlMember.IsAttachable%2A> valor se inicializa en función de qué constructor se utiliza para construir un <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirective">
      <MemberSignature Language="C#" Value="public bool IsDirective { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirective" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsDirective" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirective As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirective { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirective : bool" Usage="System.Xaml.XamlMember.IsDirective" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este <see cref="T:System.Xaml.XamlMember" /> es una directiva XAML.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Xaml.XamlMember" /> es una directiva XAML; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Xaml.XamlMember.IsDirective%2A> valor se inicializa en función de qué constructor se utiliza para construir un <xref:System.Xaml.XamlMember>. La base de <xref:System.Xaml.XamlMember> constructores inicializan poder <xref:System.Xaml.XamlMember.IsDirective%2A> es `false`. Sin embargo, el <xref:System.Xaml.XamlDirective> clase (una <xref:System.Xaml.XamlMember> clase derivada) inicializa para que <xref:System.Xaml.XamlMember.IsDirective%2A> es `true`.  
  
 Si desea informar <xref:System.Xaml.XamlMember.IsDirective%2A> como `true` a los llamadores de una clase personalizada de esquema XAML para los miembros XAML, asegúrese de que derivan de <xref:System.Xaml.XamlDirective> ya que es la única manera de habilitar ese comportamiento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvent">
      <MemberSignature Language="C#" Value="public bool IsEvent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEvent" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsEvent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEvent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEvent : bool" Usage="System.Xaml.XamlMember.IsEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este <see cref="T:System.Xaml.XamlMember" /> representa un miembro de evento.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlMember" /> representa un evento; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Xaml.XamlMember.IsEvent%2A> invoca <xref:System.Xaml.XamlMember.LookupIsEvent%2A> o una invalidación específica de ese método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlMember.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este <see cref="T:System.Xaml.XamlMember" /> se inicializa con una cadena <see langword="xamlName" /> válida como valor de su propiedad <see cref="P:System.Xaml.XamlMember.Name" />.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlMember" /> se inicializa con una cadena <see langword="xamlName" /> válida; de lo contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xaml.XamlMember.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Xaml.XamlMember" /> representa un miembro de solo lectura.</summary>
        <value>Es <see langword="true" /> si este <see cref="T:System.Xaml.XamlMember" /> representa un miembro de solo lectura; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Xaml.XamlMember.IsReadOnly%2A> invoca <xref:System.Xaml.XamlMember.LookupIsReadOnly%2A> o una invalidación específica de ese método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadPublic">
      <MemberSignature Language="C#" Value="public bool IsReadPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadPublic : bool" Usage="System.Xaml.XamlMember.IsReadPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este <see cref="T:System.Xaml.XamlMember" /> representa un miembro con un descriptor de acceso <see langword="get" /> público invocable.</summary>
        <value>Es <see langword="true" /> si este <see cref="T:System.Xaml.XamlMember" /> representa un descriptor de acceso <see langword="get" /> público invocable; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Xaml.XamlMember.IsReadPublic%2A> valor comprueba si la <xref:System.Xaml.XamlMember.DeclaringType%2A> es público. Si <xref:System.Xaml.XamlMember.DeclaringType%2A> no es público, el `get` descriptor de acceso no es invocable en forma práctica y <xref:System.Xaml.XamlMember.IsReadPublic%2A> devuelve `false`.  
  
 Una llamada a <xref:System.Xaml.XamlMember.IsReadPublic%2A> invoca <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> o una invalidación específica de ese método.  
  
> [!IMPORTANT]
>  El <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> método es virtual y por lo tanto, se puede invalidar. El reemplazo tiene el potencial de cambiar (de forma malintencionada o incorrectamente) la información de acceso que se notifica de un miembro XAML para que ya no esté disponible en la manera esperada con la información de acceso del sistema de tipo de su declaración de CLR subyacente. Para comprobaciones crítico para la seguridad de los niveles de acceso, use el tipo subyacente de CLR en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlMember.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el sistema de respaldo usado para la resolución de tipos y de miembros no puede resolver el miembro.</summary>
        <value>Es <see langword="true" /> si el miembro no se puede resolver y <see langword="false" /> si el miembro se puede resolver.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Xaml.XamlMember> que se construye con la <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> firma devuelve `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Para una ruta de acceso de carga que implica <xref:System.Xaml.XamlObjectWriter>, un <xref:System.Xaml.XamlMember> con `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A> no se puede escribir en un gráfico de objetos. En las implementaciones predeterminadas de la API de servicios XAML de .NET Framework, el <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> llamar a produce un <xref:System.Xaml.XamlObjectWriterException> cuando la correspondiente <xref:System.Xaml.XamlMember> informes `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 No debe construir un <xref:System.Xaml.XamlMember> que tiene un valor de `true` para <xref:System.Xaml.XamlMember.IsUnknown%2A> a menos que su implementación puede controlar las excepciones de <xref:System.Xaml.XamlObjectWriter>, o tienen otras formas de ajustar la <xref:System.Xaml.XamlObjectWriter> comportamiento.  
  
 Una llamada a <xref:System.Xaml.XamlMember.IsUnknown%2A> invoca <xref:System.Xaml.XamlMember.LookupIsUnknown%2A> o una invalidación específica de ese método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteOnly">
      <MemberSignature Language="C#" Value="public bool IsWriteOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteOnly : bool" Usage="System.Xaml.XamlMember.IsWriteOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Xaml.XamlMember" /> representa un miembro de solo escritura.</summary>
        <value>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlMember" /> representa un miembro de solo escritura; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Xaml.XamlMember.IsWriteOnly%2A> invoca <xref:System.Xaml.XamlMember.LookupIsWriteOnly%2A> o una invalidación específica de ese método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWritePublic">
      <MemberSignature Language="C#" Value="public bool IsWritePublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWritePublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWritePublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWritePublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWritePublic : bool" Usage="System.Xaml.XamlMember.IsWritePublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este <see cref="T:System.Xaml.XamlMember" /> representa un miembro que tiene un descriptor de acceso <see langword="set" /> público invocable.</summary>
        <value>Es <see langword="true" /> si este <see cref="T:System.Xaml.XamlMember" /> representa un descriptor de acceso <see langword="set" /> público invocable; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Xaml.XamlMember.IsWritePublic%2A> valor tiene en cuenta si la <xref:System.Xaml.XamlMember.DeclaringType%2A> es público como parte de la determinación. Si <xref:System.Xaml.XamlMember.DeclaringType%2A> no es público, el `set` descriptor de acceso no es invocable en forma práctica y <xref:System.Xaml.XamlMember.IsWritePublic%2A> devuelve `false`.  
  
 Una llamada a <xref:System.Xaml.XamlMember.IsWritePublic%2A> invoca <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> o una invalidación específica de ese método.  
  
> [!IMPORTANT]
>  El <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> método es virtual y por lo tanto, se puede invalidar. El reemplazo tiene el potencial de cambiar (de forma malintencionada o incorrectamente) la información de acceso que se notifica de un miembro XAML para que ya no esté disponible en la manera esperada con la información de acceso del sistema de tipo de su declaración de CLR subyacente. Para comprobaciones crítico para la seguridad de los niveles de acceso, use el tipo subyacente de CLR en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlMember.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se implementa en una clase derivada, devuelve una implementación de <see cref="T:System.Reflection.ICustomAttributeProvider" />.</summary>
        <returns>Implementación de <see cref="T:System.Reflection.ICustomAttributeProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalide este método para proporcionar la reflexión interna con una manera alternativa para obtener los valores de atributo CLR. En ausencia de una invalidación, el reflector interno usa la lógica de reflexión de CLR típica como las llamadas a <xref:System.Reflection.CustomAttributeData.GetCustomAttributes%2A>.  
  
 La implementación predeterminada devuelve `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlMember.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, que se emplea para la carga diferida de objetos declarados en XAML.</summary>
        <returns>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> que tiene una restricción <see cref="T:System.Xaml.XamlDeferringLoader" /> en el genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se invoca cuando un autor de llamada recibe un valor de la <xref:System.Xaml.XamlMember.DeferringLoader%2A> propiedad. Invalide este método si desea <xref:System.Xaml.XamlMember.DeferringLoader%2A> para devolver un valor que es diferente del valor que habilita la reflexión interna predeterminada, y si también va a proporcionar personalizado <xref:System.Xaml.Schema.XamlMemberInvoker> información.  
  
 La implementación predeterminada, devuelve un objeto mediante la lectura de <xref:System.Windows.Markup.XamlDeferLoadAttribute> o mediante un <xref:System.Xaml.XamlDeferringLoader> del tipo declarativo. Si no hay ningún objeto está disponible, este método puede devolver `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DeferringLoader" />
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDependsOn" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDependsOn () As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ LookupDependsOn();" />
      <MemberSignature Language="F#" Value="abstract member LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="xamlMember.LookupDependsOn " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una lista de objetos <see cref="T:System.Xaml.XamlMember" />. Los elementos de la lista notifican los miembros en los que existen relaciones de dependencia para el orden de inicialización con respecto a este objeto <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Una lista de objetos <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se invoca cuando un autor de llamada recibe un valor de la <xref:System.Xaml.XamlMember.DependsOn%2A> propiedad. Invalide este método si desea <xref:System.Xaml.XamlMember.DependsOn%2A> para devolver un valor que es diferente del valor que habilita la reflexión interna predeterminada, y si también va a proporcionar personalizado <xref:System.Xaml.Schema.XamlMemberInvoker> información.  
  
 Las implementaciones de lector y escritor de WPF XAML este caso con el atributo <xref:System.Windows.Markup.DependsOnAttribute>. La implementación predeterminada usa este existente <xref:System.Windows.Markup.DependsOnAttribute> técnica.  
  
 Invalide este método si no usas <xref:System.Windows.Markup.DependsOnAttribute> para este propósito y piensa reemplazar esa técnica para indicar el orden de procesamiento de la propiedad con su propia técnica. Si no piensa admitir un orden de procesamiento de la propiedad, puede usar la implementación predeterminada porque no devuelve ningún resultado, que es adecuado.  
  
 Se trata de una lista de solo lectura.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlMemberInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker" Usage="xamlMember.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> que está asociado con este <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Información de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> para este objeto <see cref="T:System.Xaml.XamlMember" /> o <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se invoca mediante llamadas a <xref:System.Xaml.XamlMember.Invoker%2A>.  
  
 La implementación predeterminada no requiere que un <xref:System.Xaml.XamlMember> se construye mediante uno de los constructores que pasan un inicial <xref:System.Xaml.Schema.XamlMemberInvoker>. Sin embargo, un <xref:System.Xaml.XamlMember.UnderlyingMember%2A> valor debe existir para el <xref:System.Xaml.XamlMember>; de lo contrario, la implementación predeterminada devuelve `null`.  
  
 Invalide este método si también se deriva de <xref:System.Xaml.Schema.XamlMemberInvoker> y va a devolver la clase derivada. Si la devolución `null`, <xref:System.Xaml.XamlMember.Invoker%2A> devuelve <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> a los llamadores.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Invoker" />
        <altmember cref="T:System.Xaml.Schema.XamlMemberInvoker" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlMember.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlMember" /> se considera una propiedad de ambiente.</summary>
        <returns>Es <see langword="true" /> para notificar este <see cref="T:System.Xaml.XamlMember" /> como una propiedad de ambiente; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se invoca mediante llamadas internas que buscan información de propiedad de ambiente XAML. Comportamiento de la propiedad de ambiente se recoge en el comportamiento de API público de lectores XAML y escritores XAML. Las llamadas internas que hagan referencia a <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> normalmente forman parte de la lógica de procesamiento de XAML para asegurarse de que los objetos y valores que se basan en el uso de ambiente para la cualificación de tipo pueden funcionar correctamente. La implementación de servicios XAML de .NET Framework predeterminada usa los atributos de CLR para obtener esta información de reflexión a través de tipos de respaldo. En concreto, la implementación predeterminada busca <xref:System.Windows.Markup.AmbientAttribute> y devuelve `true` para <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> si <xref:System.Windows.Markup.AmbientAttribute> existe en una definición de miembro.  
  
 Invalide este método si no usas <xref:System.Windows.Markup.AmbientAttribute> para este propósito y piensa reemplazar esa técnica para indicar las propiedades de ambiente XAML con su propia técnica.  
  
 Ejemplo API de WPF que con el atributo <xref:System.Windows.Markup.AmbientAttribute> son <xref:System.Windows.Trigger.Property%2A?displayProperty=nameWithType> y <xref:System.Windows.Style.BasedOn%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsEvent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsEvent();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsEvent : unit -&gt; bool&#xA;override this.LookupIsEvent : unit -&gt; bool" Usage="xamlMember.LookupIsEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlMember" /> representa un evento.</summary>
        <returns>Es <see langword="true" /> para notificar que este objeto <see cref="T:System.Xaml.XamlMember" /> representa un evento; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las comprobaciones de la implementación predeterminada si <xref:System.Xaml.XamlMember.UnderlyingMember%2A> es de tipo <xref:System.Reflection.EventInfo>y si es así, devuelve `true`.  
  
 Este método se invoca cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlMember.IsEvent%2A>. Invalide este método si desea que los resultados del informe uniforme para toda una <xref:System.Xaml.XamlMember> clase derivada, o si dispone de metadatos que se pueden interpretar para determinar el XAML especializado representaciones de sistema de tipos por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsEvent" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadOnly : unit -&gt; bool&#xA;override this.LookupIsReadOnly : unit -&gt; bool" Usage="xamlMember.LookupIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlMember" /> representa una propiedad de solo lectura.</summary>
        <returns>Es <see langword="true" /> para indicar si este objeto <see cref="T:System.Xaml.XamlMember" /> representa una propiedad de solo lectura; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada devuelve `true` si <xref:System.Xaml.XamlMember.UnderlyingMember%2A> existe, pero una pública `set` descriptor de acceso no existe, según lo determinado por la reflexión interna.  
  
 Este método se invoca cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlMember.IsReadOnly%2A>. Invalide este método si desea que los resultados del informe uniforme para toda una <xref:System.Xaml.XamlMember> clase derivada, o si dispone de metadatos que se pueden interpretar para determinar el XAML especializado representaciones de sistema de tipos por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadPublic : unit -&gt; bool&#xA;override this.LookupIsReadPublic : unit -&gt; bool" Usage="xamlMember.LookupIsReadPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlMember" /> representa una propiedad que tiene un descriptor de acceso <see langword="get" /> público.</summary>
        <returns>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlMember" /> representa una propiedad que tiene un descriptor de acceso <see langword="get" /> público; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada devuelve resultados basados en reflexión interna o la negación de <xref:System.Xaml.XamlMember.IsWriteOnly%2A>, procesamiento en ese orden.  
  
 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Devuelve si el propio miembro es público. Devuelve `true` para un miembro público en un nonpublic tipo declarativo. Use <xref:System.Xaml.XamlMember.IsReadPublic%2A> en su lugar, si también desea tener en cuenta la visibilidad del tipo declarativo.  
  
 Este método se invoca cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlMember.IsReadPublic%2A>. Invalide este método si desea que los resultados del informe uniforme para toda una <xref:System.Xaml.XamlMember> clase derivada, o si tiene metadatos disponibles para determinar esto por caso.  
  
> [!IMPORTANT]
>  El <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> método es virtual y por lo tanto, se puede invalidar. El reemplazo tiene el potencial de cambiar (de forma malintencionada o incorrectamente) la información de acceso que se notifica de un miembro XAML para que ya no esté disponible en la manera esperada con la información de acceso del sistema de tipo de su declaración de CLR subyacente. Para comprobaciones crítico para la seguridad de los niveles de acceso, use el tipo subyacente de CLR en su lugar.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadPublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlMember.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlMember" /> representa un miembro que no puede ser resuelto por el sistema de respaldo que se usa para la resolución de tipos y miembros.</summary>
        <returns>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlMember" /> representa un miembro que no se puede resolver; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se puede invocar este método cuando el llamador obtiene un valor de <xref:System.Xaml.XamlMember.IsUnknown%2A>. La implementación predeterminada devuelve resultados que están en función de reflexión interna o comprobar una `null` valor <xref:System.Xaml.XamlMember.UnderlyingMember%2A>, procesamiento en ese orden.  
  
 Invalide este método si desea que los resultados del informe uniforme para toda una <xref:System.Xaml.XamlMember> clase derivada, o si tiene metadatos disponibles para determinar esto por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsUnknown" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWriteOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWriteOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWriteOnly : unit -&gt; bool&#xA;override this.LookupIsWriteOnly : unit -&gt; bool" Usage="xamlMember.LookupIsWriteOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlMember" /> representa un miembro que tiene un descriptor de acceso <see langword="set" /> público pero no un descriptor de acceso <see langword="get" /> público.</summary>
        <returns>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlMember" /> representa un miembro de solo escritura; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada devuelve `true` si un <xref:System.Xaml.XamlMember.UnderlyingMember%2A> existe que tiene un público `set` descriptor de acceso y un nonpublic `get` descriptor de acceso, según lo determinado por la reflexión interna.  
  
 Este método se invoca cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlMember.IsWriteOnly%2A>. Invalide este método si desea que los resultados del informe uniforme para toda una <xref:System.Xaml.XamlMember> clase derivada, o si tiene metadatos disponibles para determinar esto por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWriteOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWritePublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWritePublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWritePublic : unit -&gt; bool&#xA;override this.LookupIsWritePublic : unit -&gt; bool" Usage="xamlMember.LookupIsWritePublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si este objeto <see cref="T:System.Xaml.XamlMember" /> representa un miembro que tiene un descriptor de acceso <see langword="set" /> público.</summary>
        <returns>Es <see langword="true" /> si este objeto <see cref="T:System.Xaml.XamlMember" /> representa un miembro que permite escritura; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada devuelve resultados basados en reflexión interna o la negación de <xref:System.Xaml.XamlMember.IsReadOnly%2A>, procesamiento en ese orden.  
  
 Este método se invoca cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Invalide este método si desea que los resultados del informe uniforme para toda una <xref:System.Xaml.XamlMember> clase derivada, o si tiene metadatos disponibles para determinar esto por caso.  
  
> [!IMPORTANT]
>  El <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> método es virtual y por lo tanto, se puede invalidar. El reemplazo tiene el potencial de cambiar (de forma malintencionada o incorrectamente) la información de acceso que se notifica de un miembro XAML para que ya no esté disponible en la manera esperada con la información de acceso del sistema de tipo de su declaración de CLR subyacente. Para comprobaciones crítico para la seguridad de los niveles de acceso, use el tipo subyacente de CLR en su lugar.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWritePublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; LookupMarkupExtensionBracketCharacters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; LookupMarkupExtensionBracketCharacters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionBracketCharacters () As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ LookupMarkupExtensionBracketCharacters();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;&#xA;override this.LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="xamlMember.LookupMarkupExtensionBracketCharacters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve los caracteres de corchete de apertura y cierre de una extensión de marcado.</summary>
        <returns>Colección que contiene los caracteres de corchete de apertura y cierre.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTargetType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTargetType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupTargetType();" />
      <MemberSignature Language="F#" Value="abstract member LookupTargetType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupTargetType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupTargetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el objeto <see cref="T:System.Xaml.XamlType" /> del tipo donde <see cref="T:System.Xaml.XamlMember" /> puede existir.</summary>
        <returns>Tipo donde <see cref="T:System.Xaml.XamlMember" /> puede existir.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada distingue entre los miembros que se puede adjuntar y que no se puede adjuntar. Para los miembros que no se puede asociar, <xref:System.Xaml.XamlMember.LookupTargetType%2A> siempre devuelve <xref:System.Xaml.XamlMember.DeclaringType%2A>. Para los miembros adjuntables, <xref:System.Xaml.XamlMember.LookupTargetType%2A> devuelve un resultado basado en el examen de la <xref:System.Xaml.XamlMember.UnderlyingMember%2A> tipo de parámetro del descriptor de acceso e interpreta que el tipo se basa en el contexto de esquema XAML.  
  
 Este método se invoca cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlMember.TargetType%2A>. Invalide este método si desea que los resultados del informe uniforme para toda una <xref:System.Xaml.XamlMember> clase derivada, o si tiene metadatos disponibles para determinar esto por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TargetType" />
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupType();" />
      <MemberSignature Language="F#" Value="abstract member LookupType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el objeto <see cref="T:System.Xaml.XamlType" /> del tipo usado por el miembro.</summary>
        <returns>
          <see cref="T:System.Xaml.XamlType" /> del tipo usado por el miembro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se invoca cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlMember.Type%2A>. Invalide este método si desea <xref:System.Xaml.XamlMember.Type%2A> para devolver un valor que es diferente del valor que habilita la reflexión interna predeterminada, y si también va a proporcionar personalizado <xref:System.Xaml.Schema.XamlMemberInvoker> información.  
  
 La implementación predeterminada usa rutas de acceso de código diferentes y significados conceptuales para el valor devuelto <xref:System.Xaml.XamlType> que se basa en Si esto <xref:System.Xaml.XamlMember> representa una propiedad, método o evento.  
  
-   Para una propiedad, el valor devuelto <xref:System.Xaml.XamlType> es el tipo que es devuelto por la propiedad o establece la propiedad.  
  
-   Para un evento, el valor devuelto <xref:System.Xaml.XamlType> es el tipo de controlador de eventos necesarios (un delegado en una implementación de CLR).  
  
-   Para un método, <xref:System.Xaml.XamlType> es el tipo de valor devuelto.  
  
 En cada caso, el contexto de esquema XAML se usa para evaluar el tipo XAML del tipo de sistema subyacente.  
  
 Este método se invoca cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlMember.Type%2A>. Invalide este método si desea que los resultados del informe uniforme para toda una <xref:System.Xaml.XamlMember> clase derivada, o si tiene metadatos disponibles para determinar esto por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlMember.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una implementación de convertidor de tipos que está asociada a este objeto <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Instancia de <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> con la restricción <see cref="T:System.ComponentModel.TypeConverter" /> o <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada usa la siguiente lógica y el orden de procesamiento:  
  
-   Si existen atributos en el nivel de miembro (<xref:System.ComponentModel.TypeConverterAttribute>), la información de atributo se usa para llamar a <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> en el contexto de esquema XAML.  
  
-   Si <xref:System.Xaml.XamlMember.Type%2A> es válido, se devuelve un convertidor de tipos que está asociado con el tipo.  
  
-   Si el miembro es un evento, se devuelve un convertidor de tipos específicos del evento.  
  
 Este método se invoca cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlMember.TypeConverter%2A>. Invalide este método si desea que los resultados del informe uniforme para toda una <xref:System.Xaml.XamlMember> clase derivada, o si tiene metadatos disponibles para determinar esto por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingGetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingGetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingGetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingGetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un descriptor de acceso <see langword="get" /> que está asociado a este objeto <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>
          <see cref="T:System.Reflection.MethodInfo" /> para el descriptor de acceso <see langword="get" /> asociado o <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada interpreta el <xref:System.Xaml.XamlMember.UnderlyingMember%2A> propiedad como <xref:System.Reflection.PropertyInfo> y devuelve el valor de <xref:System.Reflection.PropertyInfo.GetGetMethod%2A?displayProperty=nameWithType> (con el parámetro establecido en `true`), lo que significa que el método devuelto puede ser no público. Este comportamiento puede producir `null` determinados casos. incluidos los casos donde no existe ningún descriptor de acceso asociado o el miembro no es una propiedad.  
  
 Este método se invoca cuando un autor de llamada recibe un valor de la <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingGetter%2A> asociada una propiedad <xref:System.Xaml.Schema.XamlMemberInvoker>. Invalide este método si desea que los resultados del informe uniforme para toda una <xref:System.Xaml.XamlMember> clase derivada, o si tiene metadatos disponibles para determinar esto por caso. Asegúrese de implementar <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, y <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> para que devuelvan resultados correlacionados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingMember () As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MemberInfo ^ LookupUnderlyingMember();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo&#xA;override this.LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo" Usage="xamlMember.LookupUnderlyingMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Reflection.MemberInfo" /> del sistema de tipos de CLR que está asociado a este objeto <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Objeto <see cref="T:System.Reflection.MemberInfo" /> del sistema de tipos de CLR que está asociado a este <see cref="T:System.Xaml.XamlMember" /> o <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada devuelve la información de miembro subyacente, que se basa en construcción. Si el <xref:System.Reflection.MemberInfo> se construye el objeto con una firma que no proporciona suficiente información para establecer el miembro subyacente, que devuelve este método `null`.  
  
 Si un miembro subyacente se estableció durante la construcción, no es necesario llamar a este método.  
  
 Este método se invoca cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlMember.UnderlyingMember%2A>. Invalide este método si desea que los resultados del informe uniforme para toda una <xref:System.Xaml.XamlMember> clase derivada, o si tiene metadatos disponibles para determinar esto por caso. Asegúrese de implementar <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, y <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> para que devuelvan resultados correlacionados.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.UnderlyingMember" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingSetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingSetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingSetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingSetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un descriptor de acceso <see langword="set" /> que está asociado a este objeto <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>
          <see cref="T:System.Reflection.MethodInfo" /> para el descriptor de acceso <see langword="set" /> asociado o <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada interpreta <xref:System.Xaml.XamlMember.UnderlyingMember%2A> como <xref:System.Reflection.PropertyInfo> y devuelve el valor de <xref:System.Reflection.PropertyInfo.GetSetMethod%2A?displayProperty=nameWithType> (con el parámetro establecido en `true`), lo que significa que el método devuelto puede ser no público. Esto puede dar lugar a `null` para ciertos casos, incluidos los casos donde no hay ningún descriptor de acceso de este tipo o el miembro no es una propiedad.  
  
 Este método se invoca cuando un autor de llamada recibe un valor de <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingSetter%2A> en un asociado <xref:System.Xaml.Schema.XamlMemberInvoker>. Invalide este método si desea que los resultados del informe uniforme para toda una <xref:System.Xaml.XamlMember> clase derivada, o si tiene metadatos disponibles para determinar esto por caso. Asegúrese de implementar <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, y <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> para que devuelvan resultados correlacionados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlMember.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una implementación de serializador de valor que está asociada a este <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Instancia de <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> que está asociada a la restricción <see cref="T:System.Windows.Markup.ValueSerializer" /> o <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada usa la siguiente lógica y el orden de procesamiento:  
  
-   Si existen atributos en el nivel de miembro (<xref:System.Windows.Markup.ValueSerializerAttribute>), la información de atributo se usa para llamar a <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> en el contexto de esquema XAML.  
  
-   Si <xref:System.Xaml.XamlMember.Type%2A> es válido, se devuelve un convertidor de valores que está asociado con el tipo.  
  
-   Si no se aplican las condiciones anteriores, `null` se devuelve.  
  
 Este método se invoca cuando un autor de llamada recibe un valor de <xref:System.Xaml.XamlMember.ValueSerializer%2A>. Invalide este método si desea que los resultados del informe uniforme para toda una <xref:System.Xaml.XamlMember> clase derivada, o si tiene metadatos disponibles para determinar esto por caso.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.ValueSerializer" />
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; MarkupExtensionBracketCharacters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; MarkupExtensionBracketCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionBracketCharacters As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ MarkupExtensionBracketCharacters { System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionBracketCharacters : System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define los caracteres de corchete de apertura y cierre de una extensión de marcado.</summary>
        <value>Colección que contiene los caracteres de corchete de apertura y cierre.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlMember.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cadena de nombre <see langword="xamlName" /> que declara este <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Cadena de nombre <see langword="xamlName" /> que declara este <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor siempre se establece durante la construcción. Los constructores que se implementan mediante <xref:System.Xaml.XamlMember> normalmente produce una excepción si no se especifica un nombre inicial; por lo tanto, no se espera que esta propiedad sea `null` o una cadena vacía, si está utilizando servicios XAML de forma predeterminada .NET Framework implementaciones.  
  
 [Gramática de XamlName](~/docs/framework/xaml-services/xamlname-grammar.md) y reglas de nomenclatura para el tipo CLR y los miembros no están una intersección exacta. Es posible declarar un nombre de miembro que es legal en CLR pero no es válido en nombres de XAML. Debe evitar esta situación si es posible.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Equality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="xamlMember1 = xamlMember2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">
          <see cref="T:System.Xaml.XamlMember" /> o <see langword="null" />.</param>
        <param name="xamlMember2">
          <see cref="T:System.Xaml.XamlMember" /> o <see langword="null" />.</param>
        <summary>Determina si dos objetos <see cref="T:System.Xaml.XamlMember" /> especificados tienen el mismo valor.</summary>
        <returns>
          <see langword="true" /> si el valor de <paramref name="xamlMember1" /> es el mismo que el valor de <paramref name="xamlMember2" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Inequality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="System.Xaml.XamlMember.op_Inequality (xamlMember1, xamlMember2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">
          <see cref="T:System.Xaml.XamlMember" /> o <see langword="null" />.</param>
        <param name="xamlMember2">
          <see cref="T:System.Xaml.XamlMember" /> o <see langword="null" />.</param>
        <summary>Determina si dos objetos <see cref="T:System.Xaml.XamlMember" /> especificados tienen valores diferentes.</summary>
        <returns>Es <see langword="true" /> si el valor de <paramref name="xamlMember1" /> difiere del valor de <paramref name="xamlMember2" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador URI único del espacio de nombres XAML que identifica el espacio de nombres XAML primario de este <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Identificador del espacio de nombres XAML primario de este <see cref="T:System.Xaml.XamlMember" />, en forma de cadena.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> propiedad proporciona el mismo valor que una llamada a <xref:System.Xaml.XamlMember.GetXamlNamespaces%2A> y, a continuación, obtener la primera cadena del valor de la lista devuelta. El espacio de nombres XAML preferido debe usarse al escribir al miembro nuevo a texto u otras representaciones que conservan la información de espacio de nombres XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.Xaml.XamlMember.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor <see cref="T:System.ComponentModel.DesignerSerializationVisibility" />, que indica cómo un diseñador visual debería procesar el miembro.</summary>
        <value>Valor de la enumeración <see cref="T:System.ComponentModel.DesignerSerializationVisibility" />. El valor predeterminado es <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Visible" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType TargetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ TargetType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Xaml.XamlType" /> del tipo donde <see cref="T:System.Xaml.XamlMember" /> puede existir.</summary>
        <value>Tipo donde <see cref="T:System.Xaml.XamlMember" /> puede existir.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto es diferente para los miembros que se puede adjuntar y que no se puede adjuntar. Para los miembros que no se puede asociar, <xref:System.Xaml.XamlMember.TargetType%2A> devuelve <xref:System.Xaml.XamlMember.DeclaringType%2A>. Para los miembros adjuntables, <xref:System.Xaml.XamlMember.LookupTargetType%2A> devuelve un resultado que se basa en esta lógica:  
  
-   Si la reflexión no puede resolver un respaldo (<xref:System.Xaml.XamlMember.IsUnknown%2A> `true`), este método devuelve una constante interna que representa un tipo de objeto genérico.  
  
-   Si la condición anterior no se aplica, <xref:System.Xaml.XamlMember.LookupTargetType%2A> se llama. La implementación predeterminada devuelve un <xref:System.Xaml.XamlType> que se basa en el examen de los métodos que implementan el `get` y `set` descriptores de acceso. Una clase podría invalidar <xref:System.Xaml.XamlMember.LookupTargetType%2A> usar un comportamiento diferente, como otros metadatos de forma que podría informar tipos de destino para los miembros que se pueden adjuntar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlMember.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una representación de cadena de este objeto <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Representación de cadena de este objeto <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación devuelve <xref:System.Xaml.XamlMember.Name%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType Type" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ Type { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Xaml.XamlType" /> del tipo usado por el miembro.</summary>
        <value>
          <see cref="T:System.Xaml.XamlType" /> del tipo usado por el miembro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Xaml.XamlMember.Type%2A> invoca <xref:System.Xaml.XamlMember.LookupType%2A> o una invalidación específica de ese método. Esto se produce cuando la lógica de reflexión interna inicial aún no ha establecido la información.  
  
 En el comportamiento predeterminado (ninguna <xref:System.Xaml.XamlMember.LookupType%2A> invalidar), el valor devuelto <xref:System.Xaml.XamlType> pueden tener diferentes significados conceptuales. Se aplica el significado que depende de si esto <xref:System.Xaml.XamlMember> representa una propiedad, método o evento, como se muestra en la lista siguiente:  
  
-   Para una propiedad, el valor devuelto <xref:System.Xaml.XamlType> es el tipo que es devuelto por la propiedad o establece la propiedad.  
  
-   Para un evento, el valor devuelto <xref:System.Xaml.XamlType> es el tipo de controlador de eventos necesarios (un delegado en una implementación de CLR).  
  
-   Para un método, <xref:System.Xaml.XamlType> es el tipo de valor devuelto de ese método, que puede ser `null`.  
  
 En cada caso, el contexto de esquema XAML se usa para evaluar el tipo XAML del tipo de respaldo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlMember.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, que se puede usar para la construcción de la conversión de tipos de objetos XAML declarados.</summary>
        <value>Valor <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> con una restricción <see cref="T:System.ComponentModel.TypeConverter" /> en el tipo genérico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Xaml.XamlMember.TypeConverter%2A> invoca <xref:System.Xaml.XamlMember.LookupTypeConverter%2A> o una invalidación específica de ese método. Este comportamiento se produce cuando la lógica de reflexión interna inicial aún no ha establecido la información.  
  
 Valor de las implementaciones que devuelven una propiedad que no sea null para <xref:System.Xaml.XamlMember.TypeConverter%2A> no son necesariamente un trabajo <xref:System.ComponentModel.TypeConverter>. La siguiente es una lista de posibles valores devueltos no null para <xref:System.Xaml.XamlMember.TypeConverter%2A> y lo que representan estos valores:  
  
-   El valor devuelto notifica un convertidor de tipos que se atribuye específicamente a ese miembro o de manera más general para el tipo de destino del convertidor. Este comportamiento es normalmente lo que la mayoría los sistemas de tipos XAML y buscan los procesadores XAML con el fin de crear una instancia de un convertidor de tipos e invocar sus métodos.  
  
-   El valor devuelto notifica un convertidor de valores integrados. Estos convertidores existen para determinadas operaciones internas realizadas por un sistema de escritura XAML. En concreto, estos convertidores de valores integrados conversión los valores de cadena sin formato del atributo en las primitivas de nivel de lenguaje XAML. La implementación de servicios XAML de .NET Framework, estas conversiones de tipo integrado se reenvían a menudo a un convertidor de tipos que se define en el ensamblado del sistema. Por ejemplo, una conversión de un <xref:System.Int32> valor tiene integrado reenvían la conversión y por lo tanto, el <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterType%2A> referencias de valor <xref:System.ComponentModel.Int32Converter>.  
  
-   El valor devuelto notifica el caso especial de un modelo de objetos sin restricciones; es decir, el <xref:System.Xaml.XamlMember> tiene un <xref:System.Xaml.XamlMember.Type%2A> valor <xref:System.Object>. En este caso, el <xref:System.Xaml.Schema.XamlValueConverter%601> informa de que el <xref:System.Xaml.Schema.XamlValueConverter%601.Name%2A?displayProperty=nameWithType> es {`Object}`. Sin embargo, <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A> es `null` porque ningún tipo o instancia está disponible para realizar esta conversión. En su lugar, el comportamiento del modelo de objetos no se puede determinar hasta el tiempo de ejecución, cuando el tiempo de ejecución de la tecnología concreta determina el control de su gráfico de objetos.  
  
 Si puede tener acceso a un trabajo <xref:System.ComponentModel.TypeConverter> desde <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>, puede invocar sus métodos de conversión. Sin embargo, muchos de los métodos de conversión dependen del contexto de servicio. Si no tiene el mismo contexto de servicio disponible que el convertidor de tipos de espera para su rol típico de la escritura de objetos para los gráficos de objetos, los métodos de convertidor de tipos pueden producir excepciones.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo UnderlyingMember { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MemberInfo UnderlyingMember" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.UnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingMember As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MemberInfo ^ UnderlyingMember { System::Reflection::MemberInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingMember : System.Reflection.MemberInfo" Usage="System.Xaml.XamlMember.UnderlyingMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Reflection.MemberInfo" /> del sistema de tipos de CLR que está disponible para un miembro construido por <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.MethodInfo" /> o <see cref="T:System.Reflection.EventInfo" />.</summary>
        <value>Información <see cref="T:System.Reflection.MemberInfo" /> del sistema de tipos de CLR, según se convierte de los parámetros del constructor iniciales. Un <see cref="T:System.Xaml.XamlMember" /> que se construye con la firma <see cref="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" /> devuelve <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Xaml.XamlMember.UnderlyingMember%2A> invoca <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> o una invalidación específica de ese método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlMember.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, que se emplea para la serialización de valores de objetos declarados en XAML.</summary>
        <value>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> con la restricción <see cref="T:System.Windows.Markup.ValueSerializer" /> en el tipo genérico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Xaml.XamlMember.ValueSerializer%2A> invoca <xref:System.Xaml.XamlMember.LookupValueSerializer%2A> o una invalidación específica de ese método. Este comportamiento se produce cuando la lógica de reflexión interna inicial aún no ha establecido la información.  
  
 Valor no todos los casos que devuelven una propiedad que no sea null para <xref:System.Xaml.XamlMember.ValueSerializer%2A> son necesariamente un <xref:System.Windows.Markup.ValueSerializer>. Consulte <xref:System.Xaml.XamlMember.TypeConverter%2A>; las mismas consideraciones se aplican a <xref:System.Xaml.XamlMember.ValueSerializer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>