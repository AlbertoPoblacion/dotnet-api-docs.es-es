<Type Name="Dispatcher" FullName="System.Windows.Threading.Dispatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bdf8ec58a8f88c3092a414f6b3d77d7a2d8e4de0" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37494890" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Dispatcher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Dispatcher extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Threading.Dispatcher" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Dispatcher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Dispatcher sealed" />
  <TypeSignature Language="F#" Value="type Dispatcher = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides services for managing the queue of work items for a thread.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Threading.Dispatcher> mantiene una cola con prioridades de los elementos de trabajo para un subproceso concreto.  
  
 Cuando un <xref:System.Windows.Threading.Dispatcher> se crea en un subproceso, pasa a ser el único <xref:System.Windows.Threading.Dispatcher> que pueden asociarse con el subproceso, incluso si la <xref:System.Windows.Threading.Dispatcher> se apaga.  
  
 Si se intenta obtener el <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> para el subproceso actual y un <xref:System.Windows.Threading.Dispatcher> no está asociado con el subproceso, un <xref:System.Windows.Threading.Dispatcher> se creará. Un <xref:System.Windows.Threading.Dispatcher> también se crea cuando se crea un <xref:System.Windows.Threading.DispatcherObject>. Si creas un <xref:System.Windows.Threading.Dispatcher> en un subproceso en segundo plano, asegúrese de cerrar el distribuidor antes de salir del subproceso.  
  
 Si un <xref:System.Windows.Threading.Dispatcher> se apague, no se puede reiniciar.  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], un <xref:System.Windows.Threading.DispatcherObject> sólo puede tener acceso el <xref:System.Windows.Threading.Dispatcher> está asociado.  Por ejemplo, un subproceso en segundo plano no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que está asociado con el <xref:System.Windows.Threading.Dispatcher> en el [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] subproceso.  En orden para el subproceso en segundo plano tener acceso a la <xref:System.Windows.Controls.ContentControl.Content%2A> propiedad de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado con el [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] subproceso.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se llama en un <xref:System.Windows.Threading.Dispatcher> que se ha cerrado, la propiedad estado devuelto del <xref:System.Windows.Threading.DispatcherOperation> está establecido en <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 Todos los métodos en <xref:System.Windows.Threading.Dispatcher>, con la excepción de <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, son de subprocesamiento libre.  
  
 Objetos que derivan de <xref:System.Windows.Threading.DispatcherObject> tienen afinidad de subprocesos.  
  
 Objetos que derivan de <xref:System.Windows.Freezable> quedan libres del subproceso cuando se inmovilizan.  Para obtener más información, consulte [Información general sobre objetos Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo colocar una operación en un <xref:System.Windows.Threading.Dispatcher>.  Para el código fuente completo de este ejemplo, vea [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  
  
 En primer lugar, se crea un delegado que no acepta argumentos.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 A continuación, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> se llama.  Esta llamada a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> toma dos parámetros: la prioridad, que se establece en <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>y la devolución de llamada, que se pasa a través de una instancia del delegado `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Executes a delegate asynchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica; por lo tanto, control vuelve inmediatamente al objeto que realiza la llamada después de que se llame.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Devuelve un <xref:System.Windows.Threading.DispatcherOperation> objeto que puede usarse para interactuar con el delegado al que el delegado de eventos cola.  
  
 El <xref:System.Windows.Threading.DispatcherOperation> objeto devuelto por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se puede usar de varias formas para interactuar con el delegado especificado, como:  
  
-   Cambiar el <xref:System.Windows.Threading.DispatcherPriority> del delegado porque lo está pendiente la ejecución en la cola de eventos.  
  
-   Quitando al delegado de la cola de eventos.  
  
-   Esperando a que el delegado que se va a devolver.  
  
-   Obtener el valor que devuelve el delegado después de se ejecuta.  
  
 Si hay varios <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> las llamadas se realizan al mismo tiempo <xref:System.Windows.Threading.DispatcherPriority>, se ejecutará en el orden en que se realizaron las llamadas.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se llama en un <xref:System.Windows.Threading.Dispatcher> que se ha cerrado, la propiedad estado devuelto del <xref:System.Windows.Threading.DispatcherOperation> está establecido en <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">The delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate asynchronously with the specified arguments on the thread that the <see cref="T:System.Windows.Threading.Dispatcher" /> was created on.</summary>
        <returns>An object, which is returned immediately after <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Threading.DispatcherOperation> objeto devuelto por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se puede usar de varias formas para interactuar con el delegado especificado, como:  
  
-   Cambiar el <xref:System.Windows.Threading.DispatcherPriority> del delegado porque lo está pendiente la ejecución en la cola de eventos.  
  
-   Quitando al delegado de la cola de eventos.  
  
-   Esperando a que el delegado que se va a devolver.  
  
-   Obtener el valor que devuelve el delegado después de se ejecuta.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica; por lo tanto, control vuelve inmediatamente al objeto que realiza la llamada después de que se llame.  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto. Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario. En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario. Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica. La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se llama en un <xref:System.Windows.Threading.Dispatcher> que se ha cerrado, la propiedad estado devuelto del <xref:System.Windows.Threading.DispatcherOperation> está establecido en <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">The delegate to a method that takes no arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <summary>Executes the specified delegate asynchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si hay varios <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> las llamadas se realizan al mismo tiempo <xref:System.Windows.Threading.DispatcherPriority>, se ejecutará en el orden en que se realizaron las llamadas.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Devuelve un <xref:System.Windows.Threading.DispatcherOperation> objeto que puede usarse para interactuar con el delegado al que el delegado de eventos cola.  
  
 El <xref:System.Windows.Threading.DispatcherOperation> objeto devuelto por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se puede usar de varias formas para interactuar con el delegado especificado, como:  
  
-   Cambiar el <xref:System.Windows.Threading.DispatcherPriority> del delegado porque lo está pendiente la ejecución en la cola de eventos.  
  
-   Quitando al delegado de la cola de eventos.  
  
-   Esperando a que el delegado que se va a devolver.  
  
-   Obtener el valor que devuelve el delegado después de se ejecuta.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica; por lo tanto, control vuelve inmediatamente al objeto que realiza la llamada después de que se llame.  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se llama en un <xref:System.Windows.Threading.Dispatcher> que se ha cerrado, la propiedad estado devuelto del <xref:System.Windows.Threading.DispatcherOperation> está establecido en <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo colocar una operación en un <xref:System.Windows.Threading.Dispatcher>.  Para el código fuente completo de este ejemplo, vea [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  
  
 En primer lugar, se crea un delegado que no acepta argumentos.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 A continuación, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> se llama.  Porque cada <xref:System.Windows.Threading.DispatcherObject> tiene una propiedad que devuelve el <xref:System.Windows.Threading.Dispatcher> está asociado, deseado <xref:System.Windows.Threading.Dispatcher> se obtiene consultando la <xref:System.Windows.Threading.DispatcherObject>, en este caso un <xref:System.Windows.Controls.Button> denominado `startStopButton`.   La llamada a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> toma dos parámetros: la prioridad, que se establece en <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>y la devolución de llamada, que se pasa a través de una instancia del delegado `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">The delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate asynchronously with the specified arguments, at the specified priority, on the thread that the <see cref="T:System.Windows.Threading.Dispatcher" /> was created on.</summary>
        <returns>An object, which is returned immediately after <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Threading.DispatcherOperation> objeto devuelto por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se puede usar de varias formas para interactuar con el delegado especificado, como:  
  
-   Cambiar el <xref:System.Windows.Threading.DispatcherPriority> del delegado porque lo está pendiente la ejecución en la cola de eventos.  
  
-   Quitando al delegado de la cola de eventos.  
  
-   Esperando a que el delegado que se va a devolver.  
  
-   Obtener el valor que devuelve el delegado después de se ejecuta.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica; por lo tanto, control vuelve inmediatamente al objeto que realiza la llamada después de que se llame.  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto. Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario. En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario. Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica. La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se llama en un <xref:System.Windows.Threading.Dispatcher> que se ha cerrado, la propiedad estado devuelto del <xref:System.Windows.Threading.DispatcherOperation> está establecido en <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">A delegate to a method that takes one argument, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">The object to pass as an argument to the specified method.</param>
        <summary>Executes the specified delegate asynchronously at the specified priority and with the specified argument on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` puede ser `null` si se necesita ningún argumento.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Devuelve un <xref:System.Windows.Threading.DispatcherOperation> objeto que puede usarse para interactuar con el delegado al que el delegado de eventos cola.  
  
 El <xref:System.Windows.Threading.DispatcherOperation> objeto devuelto por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se puede usar de varias formas para interactuar con el delegado especificado, como:  
  
-   Cambiar el <xref:System.Windows.Threading.DispatcherPriority> del delegado porque lo está pendiente la ejecución en la cola de eventos.  
  
-   Quitando al delegado de la cola de eventos.  
  
-   Esperando a que el delegado que se va a devolver.  
  
-   Obtener el valor que devuelve el delegado después de se ejecuta.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica; por lo tanto, control vuelve inmediatamente al objeto que realiza la llamada después de que se llame.  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si hay varios <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> las llamadas se realizan al mismo tiempo <xref:System.Windows.Threading.DispatcherPriority>, se ejecutará en el orden en que se realizaron las llamadas.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se llama en un <xref:System.Windows.Threading.Dispatcher> que se ha cerrado, la propiedad estado devuelto del <xref:System.Windows.Threading.DispatcherOperation> está establecido en <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo colocar una operación en un <xref:System.Windows.Threading.Dispatcher>.  
  
 En primer lugar, se crea un delegado que acepta un argumento, en este caso una cadena.  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdelegates)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdelegates)]  
  
 A continuación, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> se llama.  Porque cada <xref:System.Windows.Threading.DispatcherObject> tiene una propiedad que devuelve el <xref:System.Windows.Threading.Dispatcher> está asociado, deseado <xref:System.Windows.Threading.Dispatcher> se obtiene consultando la <xref:System.Windows.Threading.DispatcherObject>, en este caso un <xref:System.Windows.Controls.Grid> denominado `tomorrowsWeather`. La llamada a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> toma tres parámetros: la prioridad, que se establece en <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>; la devolución de llamada, que se pasa a través de una instancia del delegado `OneArgDelegate`; y una cadena denominada `weather`, que es el argumento de la devolución de llamada.  
  
 [!code-csharp[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdispatcheronearge)]
 [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdispatcheronearge)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.BeginInvoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">A delegate to a method that takes multiple arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">The object to pass as an argument to the specified method.</param>
        <param name="args">An array of objects to pass as arguments to the specified method.</param>
        <summary>Executes the specified delegate asynchronously at the specified priority and with the specified array of arguments on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> is called, that can be used to interact with the delegate as it is pending execution in the <see cref="T:System.Windows.Threading.Dispatcher" /> queue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `arg` parámetro puede ser `null` si se necesita ningún argumento.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Devuelve un <xref:System.Windows.Threading.DispatcherOperation> objeto que puede usarse para interactuar con el delegado al que el delegado de eventos cola.  
  
 El <xref:System.Windows.Threading.DispatcherOperation> objeto devuelto por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se puede usar de varias formas para interactuar con el delegado especificado, como:  
  
-   Cambiar el <xref:System.Windows.Threading.DispatcherPriority> del delegado porque lo está pendiente la ejecución en la cola de eventos.  
  
-   Quitando al delegado de la cola de eventos.  
  
-   Esperando a que el delegado que se va a devolver.  
  
-   Obtener el valor que devuelve el delegado después de se ejecuta.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica; por lo tanto, control vuelve inmediatamente al objeto que realiza la llamada después de que se llame.  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si hay varios <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> las llamadas se realizan al mismo tiempo <xref:System.Windows.Threading.DispatcherPriority>, se ejecutará en el orden en que se realizaron las llamadas.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se llama en un <xref:System.Windows.Threading.Dispatcher> que se ha cerrado, la propiedad estado devuelto del <xref:System.Windows.Threading.DispatcherOperation> está establecido en <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <see cref="T:System.Windows.Threading.DispatcherPriority" /> is not a valid priority.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInvokeShutdown">
      <MemberSignature Language="C#" Value="public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginInvokeShutdown(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInvokeShutdown (priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginInvokeShutdown(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.BeginInvokeShutdown : System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.BeginInvokeShutdown priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">The priority at which to begin shutting down the dispatcher.</param>
        <summary>Initiates shutdown of the <see cref="T:System.Windows.Threading.Dispatcher" /> asynchronously.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.BeginInvokeShutdown%2A> demandas no restringido los permisos de la interfaz de usuario.  
  
 Cuando el <xref:System.Windows.Threading.Dispatcher> empieza a cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> provoca el evento y <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> está establecido en `true`.  
  
 El <xref:System.Windows.Threading.Dispatcher> no se apaga completamente hasta que se desenrede la cola de eventos.  
  
 Cuando el distribuidor termina de cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> provoca el evento y el <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propiedad está establecida en `true`.  
  
 Una vez que comienza el proceso de cierre, trabajo pendiente se anulan los elementos de la cola.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para cerrar el distribuidor.  Enumeraciones asociadas:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public bool CheckAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckAccess () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckAccess();" />
      <MemberSignature Language="F#" Value="member this.CheckAccess : unit -&gt; bool" Usage="dispatcher.CheckAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determines whether the calling thread is the thread associated with this <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>
          <see langword="true" /> if the calling thread is the thread associated with this <see cref="T:System.Windows.Threading.Dispatcher" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo el <xref:System.Windows.Threading.Dispatcher> que un <xref:System.Windows.Threading.DispatcherObject> se crea en puede tener acceso al objeto.  Use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> para tener acceso al objeto desde un subproceso diferente.  
  
 <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> se puede llamar desde cualquier subproceso.  
  
 La diferencia entre <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> y <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> es <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> devuelve un valor booleano que indica si el subproceso de llamada tiene acceso a la <xref:System.Windows.Threading.Dispatcher> y <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> produce una excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> para determinar si un subproceso tiene acceso a un <xref:System.Windows.Controls.Button>.  El <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> método en el <xref:System.Windows.Threading.Dispatcher> asociado con el <xref:System.Windows.Controls.Button> se llama para comprobar el acceso al subproceso.  Si el subproceso de llamada tiene acceso a la <xref:System.Windows.Threading.Dispatcher>, el <xref:System.Windows.Controls.Button> se actualiza mediante el acceso a los miembros de la <xref:System.Windows.Controls.Button>; en caso contrario, un delegado, que acepta un <xref:System.Windows.Controls.Button> como argumento, se coloca en el <xref:System.Windows.Threading.Dispatcher>.  El <xref:System.Windows.Threading.Dispatcher> delegará el trabajo de actualización de la <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccesscheckaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccesscheckaccess)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDispatcher">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Threading.Dispatcher CurrentDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDispatcher As Dispatcher" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Threading::Dispatcher ^ CurrentDispatcher { System::Windows::Threading::Dispatcher ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDispatcher : System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Windows.Threading.Dispatcher" /> for the thread currently executing and creates a new <see cref="T:System.Windows.Threading.Dispatcher" /> if one is not already associated with the thread.</summary>
        <value>El distribuidor asociado al subproceso actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un <xref:System.Windows.Threading.Dispatcher> no está asociado con el subproceso actual, un nuevo <xref:System.Windows.Threading.Dispatcher> se creará.  Esto no sucede así con el método <xref:System.Windows.Threading.Dispatcher.FromThread%2A>.  <xref:System.Windows.Threading.Dispatcher.FromThread%2A> devolverá `null` si no hay un distribuidor asociado al subproceso especificado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableProcessing">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.DisableProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Function DisableProcessing () As DispatcherProcessingDisabled" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherProcessingDisabled DisableProcessing();" />
      <MemberSignature Language="F#" Value="member this.DisableProcessing : unit -&gt; System.Windows.Threading.DispatcherProcessingDisabled" Usage="dispatcher.DisableProcessing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherProcessingDisabled</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disables processing of the <see cref="T:System.Windows.Threading.Dispatcher" /> queue.</summary>
        <returns>A structure used to re-enable dispatcher processing.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deshabilite el procesamiento del distribuidor es un método avanzado que está pensado para eliminar la posibilidad de reentrada no relacionada.  
  
 Los efectos de deshabilitar el procesamiento son los siguientes:  
  
-   Bloqueos CLR no extrae los mensajes internamente.  
  
-   <xref:System.Windows.Threading.DispatcherFrame> no se permiten objetos que se van a insertar.  
  
-   No se permite el procesamiento de mensajes.  
  
 El <xref:System.Windows.Threading.DispatcherProcessingDisabled> estructura que <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> devuelve cuando se llama puede utilizarse para volver a habilitar el procesamiento del distribuidor.  Una llamada a <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> en el <xref:System.Windows.Threading.DispatcherProcessingDisabled> estructura vuelve a habilita el procesamiento.  
  
 <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> solo se puede llamar en el subproceso de la <xref:System.Windows.Threading.Dispatcher> está asociado.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo deshabilitar el procesamiento del distribuidor y volver a habilitar el procesamiento del distribuidor.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> se llama en un **mediante** instrucción.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> Devuelve un <xref:System.Windows.Threading.DispatcherProcessingDisabled> estructura que se usa como el objeto se elimina cuando el **mediante** bloquear finaliza.  Cuando <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> se llama en el <xref:System.Windows.Threading.DispatcherProcessingDisabled> estructura, el procesamiento del distribuidor se vuelve a habilitar.  
  
 [!code-csharp[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdisableprocessing)]
 [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdisableprocessing)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExitAllFrames">
      <MemberSignature Language="C#" Value="public static void ExitAllFrames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitAllFrames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitAllFrames ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitAllFrames();" />
      <MemberSignature Language="F#" Value="static member ExitAllFrames : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ExitAllFrames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Requests that all frames exit, including nested frames.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para llamar a este método. Enumeraciones asociadas:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
        <altmember cref="T:System.Windows.Threading.DispatcherFrame" />
      </Docs>
    </Member>
    <Member MemberName="FromThread">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Threading.Dispatcher FromThread(class System.Threading.Thread thread) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::Dispatcher ^ FromThread(System::Threading::Thread ^ thread);" />
      <MemberSignature Language="F#" Value="static member FromThread : System.Threading.Thread -&gt; System.Windows.Threading.Dispatcher" Usage="System.Windows.Threading.Dispatcher.FromThread thread" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="System.Threading.Thread" />
      </Parameters>
      <Docs>
        <param name="thread">The thread to obtain the <see cref="T:System.Windows.Threading.Dispatcher" /> from.</param>
        <summary>Gets the <see cref="T:System.Windows.Threading.Dispatcher" /> for the specified thread.</summary>
        <returns>The dispatcher for <paramref name="thread" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no está disponible para el subproceso especificado, un distribuidor `null` se devolverá.  
  
 <xref:System.Windows.Threading.Dispatcher.FromThread%2A> no se crea un <xref:System.Windows.Threading.Dispatcher> en un subproceso que no tiene un <xref:System.Windows.Threading.Dispatcher>.   Un nuevo <xref:System.Windows.Threading.Dispatcher> se crea en un subproceso que no tenga ya una <xref:System.Windows.Threading.Dispatcher> al intentar obtener el <xref:System.Windows.Threading.Dispatcher> utilizando el <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownFinished">
      <MemberSignature Language="C#" Value="public bool HasShutdownFinished { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownFinished" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownFinished As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownFinished { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownFinished : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the <see cref="T:System.Windows.Threading.Dispatcher" /> has finished shutting down.</summary>
        <value>
          <see langword="true" /> Si el distribuidor ha terminado de cerrarse en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Windows.Threading.Dispatcher> empieza a cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> provoca el evento y <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> está establecido en `true`.  
  
 El <xref:System.Windows.Threading.Dispatcher> no se apaga completamente hasta que se desenrede la cola de eventos.  
  
 Cuando el distribuidor termina de cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> provoca el evento y el <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propiedad está establecida en `true`.  
  
 Una vez que comienza el proceso de cierre, trabajo pendiente se anulan los elementos de la cola.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the <see cref="T:System.Windows.Threading.Dispatcher" /> is shutting down.</summary>
        <value>
          <see langword="true" /> Si el <see cref="T:System.Windows.Threading.Dispatcher" /> está cerrando; de lo contrario, se ha iniciado <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Windows.Threading.Dispatcher> empieza a cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> provoca el evento y <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> está establecido en `true`.  
  
 El <xref:System.Windows.Threading.Dispatcher> no se apaga completamente hasta que se desenrede la cola de eventos.  
  
 Cuando el distribuidor termina de cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> provoca el evento y el <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propiedad está establecida en `true`.  
  
 Una vez que comienza el proceso de cierre, trabajo pendiente se anulan los elementos de la cola.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hooks">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherHooks Hooks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Threading.DispatcherHooks Hooks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Hooks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Hooks As DispatcherHooks" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Threading::DispatcherHooks ^ Hooks { System::Windows::Threading::DispatcherHooks ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Hooks : System.Windows.Threading.DispatcherHooks" Usage="System.Windows.Threading.Dispatcher.Hooks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherHooks</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of hooks that provide additional event information about the <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <value>Los enlaces asociados con este <see cref="T:System.Windows.Threading.Dispatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Threading.DispatcherHooks> clase proporciona información de eventos adicional sobre el <xref:System.Windows.Threading.Dispatcher>, por ejemplo, cuando el <xref:System.Windows.Threading.Dispatcher> está inactivo o cuando se complete una operación.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Para obtener esta propiedad.  Enumeraciones asociadas:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Executes the specified delegate synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no se devuelve al objeto que realiza la llamada hasta después de la devolución de llamada.  
  
   
  
## Examples  
 En el ejemplo siguiente se coloca un delegado en un <xref:System.Windows.Threading.Dispatcher> en <xref:System.Windows.Threading.DispatcherPriority.Normal> mediante <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action -&gt; unit" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action, priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority -&gt; unit" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">A delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto. Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario. En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario. Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica. La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no se devuelve al objeto que realiza la llamada hasta después de la devolución de llamada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">A delegate to a method that takes no arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <summary>Executes the specified delegate synchronously at the specified priority on the thread on which the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no se devuelve al objeto que realiza la llamada hasta después de la devolución de llamada.  
  
   
  
## Examples  
 En el ejemplo siguiente se coloca un delegado en un <xref:System.Windows.Threading.Dispatcher> en <xref:System.Windows.Threading.DispatcherPriority.Normal> mediante <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> is equal to <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid priority.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the action.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">A delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="timeout">The maximum amount of time to wait for the operation to complete.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate within the designated time span at the specified priority with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto. Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario. En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario. Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica. La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no se devuelve al objeto que realiza la llamada hasta después de la devolución de llamada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">A delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate at the specified priority with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto. Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario. En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario. Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica. La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no se devuelve al objeto que realiza la llamada hasta después de la devolución de llamada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">A delegate to a method that takes one argument, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">An object to pass as an argument to the given method.</param>
        <summary>Executes the specified delegate at the specified priority with the specified argument synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` puede ser `null` si no se necesita un argumento  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no se devuelve al objeto que realiza la llamada hasta después de la devolución de llamada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> is equal to <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid priority.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="timeout">The maximum time to wait for the operation to finish.</param>
        <param name="method">The delegate to a method that takes no arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <summary>Executes the specified delegate synchronously at the specified priority and with the specified time-out value on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> was created.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no se devuelve al objeto que realiza la llamada hasta después de la devolución de llamada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; unit" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the action.</param>
        <param name="timeout">The minimum amount of time to wait for the operation to start.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate * TimeSpan * System.Windows.Threading.DispatcherPriority * obj[] -&gt; obj" Usage="dispatcher.Invoke (method, timeout, priority, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">A delegate to a method that takes parameters specified in <c>args</c>, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="timeout">The maximum amount of time to wait for the operation to complete.</param>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="args">An array of objects to pass as arguments to the given method. Can be <see langword="null" />.</param>
        <summary>Executes the specified delegate within the designated time span at the specified priority with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto. Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario. En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario. Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica. La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no se devuelve al objeto que realiza la llamada hasta después de la devolución de llamada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="method">A delegate to a method that takes multiple arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">An object to pass as an argument to the given method.</param>
        <param name="args">An array of objects to pass as arguments to the given method.</param>
        <summary>Executes the specified delegate at the specified priority with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` puede ser `null` si no se necesita un argumento  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no se devuelve al objeto que realiza la llamada hasta después de la devolución de llamada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> is equal to <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid priority.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="timeout">The maximum time to wait for the operation to finish.</param>
        <param name="method">A delegate to a method that takes multiple arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">An object to pass as an argument to the given method. This can be <see langword="null" /> if no arguments are needed.</param>
        <summary>Executes the specified delegate at the specified priority with the specified argument synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` puede ser `null` si no se necesita un argumento  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no se devuelve al objeto que realiza la llamada hasta después de la devolución de llamada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> is equal to <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid priority.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Windows.Threading.DispatcherPriority * TimeSpan * Delegate * obj * obj[] -&gt; obj" Usage="dispatcher.Invoke (priority, timeout, method, arg, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">The priority, relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue, the specified method is invoked.</param>
        <param name="timeout">The maximum time to wait for the operation to finish.</param>
        <param name="method">A delegate to a method that takes multiple arguments, which is pushed onto the <see cref="T:System.Windows.Threading.Dispatcher" /> event queue.</param>
        <param name="arg">An object to pass as an argument to the specified method.</param>
        <param name="args">An array of objects to pass as arguments to the specified method.</param>
        <summary>Executes the specified delegate at the specified priority with the specified arguments synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>The return value from the delegate being invoked or <see langword="null" /> if the delegate has no return value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` puede ser `null` si no se necesita un argumento.  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> pueden tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que se ponga en marcha del subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo en el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no se devuelve al objeto que realiza la llamada hasta después de la devolución de llamada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> is equal to <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; -&gt; 'Result" Usage="dispatcher.Invoke callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">El tipo de valor devuelto del delegado especificado.</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> synchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">El tipo de valor devuelto del delegado especificado.</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">El tipo de valor devuelto del delegado especificado.</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the operation.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken * TimeSpan -&gt; 'Result" Usage="dispatcher.Invoke (callback, priority, cancellationToken, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">El tipo de valor devuelto del delegado especificado.</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the operation.</param>
        <param name="timeout">The minimum amount of time to wait for the operation to start.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeAsync">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Executes the specified delegate asynchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> asynchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action, priority As DispatcherPriority) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> asynchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Action * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the action.</param>
        <summary>Executes the specified <see cref="T:System.Action" /> asynchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult)) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">El tipo de valor devuelto del delegado especificado.</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> asynchronously on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">El tipo de valor devuelto del delegado especificado.</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> asynchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : Func&lt;'Result&gt; * System.Windows.Threading.DispatcherPriority * System.Threading.CancellationToken -&gt; System.Windows.Threading.DispatcherOperation&lt;'Result&gt;" Usage="dispatcher.InvokeAsync (callback, priority, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">El tipo de valor devuelto del delegado especificado.</typeparam>
        <param name="callback">A delegate to invoke through the dispatcher.</param>
        <param name="priority">The priority that determines in what order the specified callback is invoked relative to the other pending operations in the <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">An object that indicates whether to cancel the operation.</param>
        <summary>Executes the specified <see cref="T:System.Func`1" /> synchronously at the specified priority on the thread the <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <returns>An object, which is returned immediately after <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" /> is called, that can be used to interact with the delegate as it is pending execution in the event queue.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeShutdown">
      <MemberSignature Language="C#" Value="public void InvokeShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeShutdown();" />
      <MemberSignature Language="F#" Value="member this.InvokeShutdown : unit -&gt; unit" Usage="dispatcher.InvokeShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiates the shutdown process of the <see cref="T:System.Windows.Threading.Dispatcher" /> synchronously.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.InvokeShutdown%2A> demandas no restringido los permisos de la interfaz de usuario.  
  
 Cuando el <xref:System.Windows.Threading.Dispatcher> empieza a cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> provoca el evento y <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> está establecido en `true`.  
  
 El <xref:System.Windows.Threading.Dispatcher> no se apaga completamente hasta que se desenrede la cola de eventos.  
  
 Cuando el distribuidor termina de cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> provoca el evento y el <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propiedad está establecida en `true`.  
  
 Una vez que comienza el proceso de cierre, trabajo pendiente se anulan los elementos de la cola.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para cerrar el distribuidor.  Enumeraciones asociadas:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PushFrame">
      <MemberSignature Language="C#" Value="public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PushFrame(class System.Windows.Threading.DispatcherFrame frame) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PushFrame (frame As DispatcherFrame)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PushFrame(System::Windows::Threading::DispatcherFrame ^ frame);" />
      <MemberSignature Language="F#" Value="static member PushFrame : System.Windows.Threading.DispatcherFrame -&gt; unit" Usage="System.Windows.Threading.Dispatcher.PushFrame frame" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frame" Type="System.Windows.Threading.DispatcherFrame" />
      </Parameters>
      <Docs>
        <param name="frame">The frame for the dispatcher to process.</param>
        <summary>Enters an execute loop.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Threading.DispatcherFrame> representa un bucle que procesa los elementos de trabajo pendiente.  
  
 El distribuidor procese la cola de elementos de trabajo en un bucle.  El bucle se conoce como una trama.  El bucle inicial suele ser iniciado por la aplicación mediante una llamada a <xref:System.Windows.Threading.Dispatcher.Run%2A>.  
  
 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> entra en un bucle representado por el parámetro `frame`.  En cada iteración del bucle, la <xref:System.Windows.Threading.Dispatcher> comprobará el <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> propiedad en el <xref:System.Windows.Threading.DispatcherFrame> clase para determinar si el bucle debe continuar o si se detiene.  
  
 <xref:System.Windows.Threading.DispatcherFrame> permite la <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> propiedad debe establecerse explícitamente y se respeta el <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> propiedad en el <xref:System.Windows.Threading.Dispatcher>.  Esto significa que cuando el <xref:System.Windows.Threading.Dispatcher> empieza a cerrar, los marcos que use el valor predeterminado <xref:System.Windows.Threading.DispatcherFrame> implementación se cerrará, que permite a los fotogramas anidados salir.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar un <xref:System.Windows.Threading.DispatcherFrame> para lograr resultados similares como la [!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)] <xref:System.Windows.Forms.Application.DoEvents%2A> método.  
  
 [!code-csharp[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdispatcherframedoevents)]
 [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdispatcherframedoevents)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="frame" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" /> is <see langword="true" />  -or-  <paramref name="frame" /> is running on a different <see cref="T:System.Windows.Threading.Dispatcher" />.  -or-  Dispatcher processing has been disabled.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para insertar un fotograma de ejecución.  Enumeraciones asociadas:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Threading.Dispatcher.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pushes the main execution frame on the event queue of the <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Threading.Dispatcher> procesa la cola de eventos en un bucle.  El bucle se conoce como una trama.  El bucle inicial suele ser iniciado por la aplicación mediante una llamada a <xref:System.Windows.Threading.Dispatcher.Run%2A>.  
  
 El marco de ejecución principal continuará hasta el <xref:System.Windows.Threading.Dispatcher> está apagada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownFinished">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownFinished;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownFinished" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownFinished As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownFinished;" />
      <MemberSignature Language="F#" Value="member this.ShutdownFinished : EventHandler " Usage="member this.ShutdownFinished : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="T:System.Windows.Threading.Dispatcher" /> finishes shutting down.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el proceso de cierre de un <xref:System.Windows.Threading.Dispatcher> se inicia, el <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> provoca el evento y <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> está establecido en `true`.  
  
 El <xref:System.Windows.Threading.Dispatcher> no se apaga completamente hasta que se desenrede la cola de eventos.  
  
 Cuando el distribuidor termina de cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> provoca el evento y el <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propiedad está establecida en `true`.  
  
 Una vez que comienza el proceso de cierre, trabajo pendiente se anulan los elementos de la cola.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownStarted">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownStarted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownStarted As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownStarted;" />
      <MemberSignature Language="F#" Value="member this.ShutdownStarted : EventHandler " Usage="member this.ShutdownStarted : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="T:System.Windows.Threading.Dispatcher" /> begins to shut down.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el proceso de cierre de un <xref:System.Windows.Threading.Dispatcher> se inicia, el <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> provoca el evento y <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> está establecido en `true`.  
  
 El <xref:System.Windows.Threading.Dispatcher> no se apaga completamente hasta que se desenrede la cola de eventos.  
  
 Cuando el distribuidor termina de cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> provoca el evento y el <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propiedad está establecida en `true`.  
  
 Una vez que comienza el proceso de cierre, trabajo pendiente se anulan los elementos de la cola.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="Thread">
      <MemberSignature Language="C#" Value="public System.Threading.Thread Thread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Thread Thread" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Thread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Thread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Thread ^ Thread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Thread : System.Threading.Thread" Usage="System.Windows.Threading.Dispatcher.Thread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the thread this <see cref="T:System.Windows.Threading.Dispatcher" /> is associated with.</summary>
        <value>Subproceso.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Event UnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a thread exception is thrown and uncaught during execution of a delegate by way of <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> or <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena cuando una excepción que se produjo durante la ejecución de un delegado por medio de <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es no detectadas.  
  
 Un controlador puede marcar la excepción como controlado, que impedirá que el controlador de excepción interna que se llama.  
  
 Controladores de eventos para este evento se deben escribir con cuidado para evitar crear excepciones secundarias y detectar cualquier usuario que se producen. Se recomienda evitar la asignación de memoria o realizar operaciones intensivas en el controlador de cualquier recurso.  
  
 El <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> eventos proporcionan un medio para que no produzca el <xref:System.Windows.Threading.Dispatcher.UnhandledException> eventos.  El <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> evento se produce en primer lugar y si <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> en el <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> está establecido en `false`, el <xref:System.Windows.Threading.Dispatcher.UnhandledException> no se producirá el evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledExceptionFilter">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledExceptionFilter As DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionFilterEventHandler ^ UnhandledExceptionFilter;" />
      <MemberSignature Language="F#" Value="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " Usage="member this.UnhandledExceptionFilter : System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a thread exception is thrown and uncaught during execution of a delegate by way of <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> or <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> when in the filter stage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena durante la fase de filtrado para una excepción producida durante la ejecución de un delegado por medio de <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> y no detectada.  
  
 La pila de llamadas no se desenreda en este momento (excepciones de primera oportunidad).  
  
 Controladores de eventos para este evento se deben escribir con cuidado para evitar crear excepciones secundarias y detectar cualquier usuario que se producen.  Se recomienda evitar la asignación de memoria o realizar operaciones intensivas en el controlador de cualquier recurso.  
  
 El <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> eventos proporcionan un medio para que no produzca el <xref:System.Windows.Threading.Dispatcher.UnhandledException> eventos.  El <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> evento se produce en primer lugar y si <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> en el <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> está establecido en `false`, el <xref:System.Windows.Threading.Dispatcher.UnhandledException> no se producirá el evento.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Para agregar o quitar un controlador para este evento.  Enumeraciones asociadas:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ValidatePriority">
      <MemberSignature Language="C#" Value="public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ValidatePriority(valuetype System.Windows.Threading.DispatcherPriority priority, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ValidatePriority (priority As DispatcherPriority, parameterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ValidatePriority(System::Windows::Threading::DispatcherPriority priority, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="static member ValidatePriority : System.Windows.Threading.DispatcherPriority * string -&gt; unit" Usage="System.Windows.Threading.Dispatcher.ValidatePriority (priority, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="priority">The priority to check.</param>
        <param name="parameterName">A string that will be returned by the exception that occurs if the priority is invalid.</param>
        <summary>Determines whether the specified <see cref="T:System.Windows.Threading.DispatcherPriority" /> is a valid priority.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> is not a valid <see cref="T:System.Windows.Threading.DispatcherPriority" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyAccess">
      <MemberSignature Language="C#" Value="public void VerifyAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void VerifyAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      <MemberSignature Language="VB.NET" Value="Public Sub VerifyAccess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void VerifyAccess();" />
      <MemberSignature Language="F#" Value="member this.VerifyAccess : unit -&gt; unit" Usage="dispatcher.VerifyAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determines whether the calling thread has access to this <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo el subproceso de la <xref:System.Windows.Threading.Dispatcher> se crea en pueden tener acceso a la <xref:System.Windows.Threading.Dispatcher>.  
  
 Este método es público. por lo tanto, cualquier subproceso puede comprobar si tiene acceso a la <xref:System.Windows.Threading.Dispatcher>.  
  
 La diferencia entre <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> y <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> es <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> devuelve un valor booleano si el subproceso de llamada no tiene acceso a la <xref:System.Windows.Threading.Dispatcher> y <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> produce una excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> para determinar si un subproceso tiene acceso al subproceso que un <xref:System.Windows.Controls.Button> se creó.  El método toma un objeto como argumento, que se convierte en un <xref:System.Windows.Controls.Button>.  El <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> método en el <xref:System.Windows.Threading.Dispatcher> de la <xref:System.Windows.Controls.Button> se llama para comprobar el acceso al subproceso.  
  
 Si el subproceso de llamada tiene acceso a la <xref:System.Windows.Threading.Dispatcher>, <xref:System.Windows.Controls.Button> se actualiza mediante el acceso solo a los miembros de la <xref:System.Windows.Controls.Button>.  
  
 Si el subproceso de llamada no tiene acceso, un <xref:System.InvalidOperationException> se produce.  En este ejemplo detecta la excepción e inserta un delegado, que acepta un <xref:System.Windows.Controls.Button> como argumento, en el <xref:System.Windows.Threading.Dispatcher> de la <xref:System.Windows.Controls.Button>.  Esto <xref:System.Windows.Threading.Dispatcher> realizará el trabajo de actualización de la <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccessverifyaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccessverifyaccess)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The calling thread does not have access to this <see cref="T:System.Windows.Threading.Dispatcher" />.</exception>
        <altmember cref="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Yield">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates an awaitable object that asynchronously yields control back to the current dispatcher and provides an opportunity for the dispatcher to process other events.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an awaitable object that asynchronously yields control back to the current dispatcher and provides an opportunity for the dispatcher to process other events.</summary>
        <returns>An awaitable object that asynchronously yields control back to the current dispatcher and provides an opportunity for the dispatcher to process other events.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método proporciona una manera de liberar temporalmente el control de ejecución para el distribuidor actual para que pueda hacer otro trabajo, como procesar otros eventos. Use la `await`, o `Await` en Visual Basic, operador en el valor devuelto para devolver el control al distribuidor actual. Utilice este método si desea dar una oportunidad para procesar los eventos mientras la aplicación realiza mucho trabajo en el subproceso de interfaz de usuario de la aplicación. Por ejemplo, puede usar este método en un bucle de ejecución prolongada que actualiza un control.  
  
 Este método es equivalente a llamar a la <xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29> método y pasando <xref:System.Windows.Threading.DispatcherPriority.Background?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield (priority As DispatcherPriority) As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberSignature Language="F#" Value="static member Yield : System.Windows.Threading.DispatcherPriority -&gt; System.Windows.Threading.DispatcherPriorityAwaitable" Usage="System.Windows.Threading.Dispatcher.Yield priority" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">The priority at which to schedule the continuation.</param>
        <summary>Creates an awaitable object that asynchronously yields control back to the current dispatcher and provides an opportunity for the dispatcher to process other events.  The work that occurs when control returns to the code awaiting the result of this method is scheduled with the specified priority.</summary>
        <returns>An awaitable object that asynchronously yields control back to the current dispatcher and provides an opportunity for the dispatcher to process other events.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método proporciona una manera de liberar temporalmente el control de ejecución para el distribuidor actual para que pueda hacer otro trabajo, como procesar otros eventos. Use la `await`, o `Await` en Visual Basic, operador en el valor devuelto para devolver el control al distribuidor actual. Utilice este método si desea dar una oportunidad para procesar los eventos mientras la aplicación realiza mucho trabajo en el subproceso de interfaz de usuario de la aplicación. Por ejemplo, puede usar este método en un bucle de ejecución prolongada que actualiza un control.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>