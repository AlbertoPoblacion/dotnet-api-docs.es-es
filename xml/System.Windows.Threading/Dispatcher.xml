<Type Name="Dispatcher" FullName="System.Windows.Threading.Dispatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="af2078811c84a8b49a1ceb3a8f31ec5f35058b25" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32695080" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Dispatcher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Dispatcher extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Threading.Dispatcher" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Dispatcher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Dispatcher sealed" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona los servicios para administrar la cola de elementos de trabajo de un subproceso.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Threading.Dispatcher> mantiene una cola con prioridades de los elementos de trabajo para un subproceso concreto.  
  
 Cuando un <xref:System.Windows.Threading.Dispatcher> se crea en un subproceso, pasa a ser el único <xref:System.Windows.Threading.Dispatcher> que pueden asociarse con el subproceso, incluso si la <xref:System.Windows.Threading.Dispatcher> se apaga.  
  
 Si intenta obtener la <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> para el subproceso actual y un <xref:System.Windows.Threading.Dispatcher> no está asociado con el subproceso, un <xref:System.Windows.Threading.Dispatcher> se creará. A <xref:System.Windows.Threading.Dispatcher> también se crea cuando se crea un <xref:System.Windows.Threading.DispatcherObject>. Si crea un <xref:System.Windows.Threading.Dispatcher> en un subproceso en segundo plano, asegúrese de cerrar el distribuidor antes de terminar el subproceso.  
  
 Si un <xref:System.Windows.Threading.Dispatcher> permanezca inactivo, no se puede reiniciar.  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], <xref:System.Windows.Threading.DispatcherObject> solo sea accesible para el <xref:System.Windows.Threading.Dispatcher> que está asociado.  Por ejemplo, un subproceso en segundo plano no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que está asociada la <xref:System.Windows.Threading.Dispatcher> en el [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] subproceso.  En orden para el subproceso en segundo plano tener acceso a la <xref:System.Windows.Controls.ContentControl.Content%2A> propiedad de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociados con el [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] subproceso.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se llama en una <xref:System.Windows.Threading.Dispatcher> que se ha cerrado, la propiedad status de devuelto <xref:System.Windows.Threading.DispatcherOperation> está establecido en <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 Todos los métodos en <xref:System.Windows.Threading.Dispatcher>, con la excepción de <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, son de subprocesamiento libre.  
  
 Objetos que derivan de <xref:System.Windows.Threading.DispatcherObject> tienen afinidad de subprocesos.  
  
 Objetos que derivan de <xref:System.Windows.Freezable> quedan libres del subproceso cuando se inmovilizan.  Para obtener más información, consulte [Información general sobre objetos Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo realizar una operación en un <xref:System.Windows.Threading.Dispatcher>.  Para el código fuente completo de este ejemplo, vea [aplicación uniproceso con Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  
  
 En primer lugar, se crea un delegado que no acepta argumentos.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 Después, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> se llama.  Esta llamada a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> toma dos parámetros: la prioridad, que se establece en <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>y la devolución de llamada, que se pasa a través de una instancia del delegado `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ejecuta asincrónicamente un delegado en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica; por lo tanto, control vuelve inmediatamente al objeto que realiza la llamada después de que se llama.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Devuelve un <xref:System.Windows.Threading.DispatcherOperation> objeto que puede usar para interactuar con el delegado al que el delegado en el evento cola.  
  
 El <xref:System.Windows.Threading.DispatcherOperation> objeto devuelto por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> puede utilizarse de varias maneras para interactuar con el delegado especificado, como:  
  
-   Cambiar el <xref:System.Windows.Threading.DispatcherPriority> del delegado ya que está pendiente la ejecución en la cola de eventos.  
  
-   Quitando al delegado de la cola de eventos.  
  
-   Esperando el delegado que se va a devolver.  
  
-   Para obtener el valor que devuelve el delegado después de se ejecuta.  
  
 Si hay varios <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> llamadas se realizan en el mismo <xref:System.Windows.Threading.DispatcherPriority>, se ejecutarán en el orden en que se realizaron las llamadas.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se llama en una <xref:System.Windows.Threading.Dispatcher> que se ha cerrado, la propiedad status de devuelto <xref:System.Windows.Threading.DispatcherOperation> está establecido en <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegado de un método que toma los parámetros especificados en <c>args</c>, que se inserta en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="args">Matriz de objetos cuyos valores se pasan como argumentos al método especificado. Puede ser <see langword="null" />.</param>
        <summary>Ejecuta de forma asincrónica el delegado especificado con los argumentos especificados en el subproceso en el que se creó el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Objeto, que se devuelve inmediatamente después de llamar a <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />, que se puede usar para interactuar con el delegado ya que su ejecución está pendiente en la cola de eventos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Threading.DispatcherOperation> objeto devuelto por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> puede utilizarse de varias maneras para interactuar con el delegado especificado, como:  
  
-   Cambiar el <xref:System.Windows.Threading.DispatcherPriority> del delegado ya que está pendiente la ejecución en la cola de eventos.  
  
-   Quitando al delegado de la cola de eventos.  
  
-   Esperando el delegado que se va a devolver.  
  
-   Para obtener el valor que devuelve el delegado después de se ejecuta.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica; por lo tanto, control vuelve inmediatamente al objeto que realiza la llamada después de que se llama.  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto. Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario. En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario. Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica. La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se llama en una <xref:System.Windows.Threading.Dispatcher> que se ha cerrado, la propiedad status de devuelto <xref:System.Windows.Threading.DispatcherOperation> está establecido en <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Prioridad, relativa a otras operaciones pendientes de la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />, con la que se invoca el método especificado.</param>
        <param name="method">El delegado a un método que no toma ningún argumento, que se inserta en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Ejecuta asincrónicamente el delegado especificado en la prioridad indicada en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Objeto, que se devuelve inmediatamente después de llamar a <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />, que se puede usar para interactuar con el delegado ya que su ejecución está pendiente en la cola de eventos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si hay varios <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> llamadas se realizan en el mismo <xref:System.Windows.Threading.DispatcherPriority>, se ejecutarán en el orden en que se realizaron las llamadas.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Devuelve un <xref:System.Windows.Threading.DispatcherOperation> objeto que puede usar para interactuar con el delegado al que el delegado en el evento cola.  
  
 El <xref:System.Windows.Threading.DispatcherOperation> objeto devuelto por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> puede utilizarse de varias maneras para interactuar con el delegado especificado, como:  
  
-   Cambiar el <xref:System.Windows.Threading.DispatcherPriority> del delegado ya que está pendiente la ejecución en la cola de eventos.  
  
-   Quitando al delegado de la cola de eventos.  
  
-   Esperando el delegado que se va a devolver.  
  
-   Para obtener el valor que devuelve el delegado después de se ejecuta.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica; por lo tanto, control vuelve inmediatamente al objeto que realiza la llamada después de que se llama.  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se llama en una <xref:System.Windows.Threading.Dispatcher> que se ha cerrado, la propiedad status de devuelto <xref:System.Windows.Threading.DispatcherOperation> está establecido en <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo realizar una operación en un <xref:System.Windows.Threading.Dispatcher>.  Para el código fuente completo de este ejemplo, vea [aplicación uniproceso con Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  
  
 En primer lugar, se crea un delegado que no acepta argumentos.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberinit)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberinit)]   
  
 Después, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> se llama.  Dado que cada <xref:System.Windows.Threading.DispatcherObject> tiene una propiedad que devuelve el <xref:System.Windows.Threading.Dispatcher> está asociado a, lo que se desea <xref:System.Windows.Threading.Dispatcher> se obtiene consultando la <xref:System.Windows.Threading.DispatcherObject>, en este caso un <xref:System.Windows.Controls.Button> denominado `startStopButton`.   La llamada a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> toma dos parámetros: la prioridad, que se establece en <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>y la devolución de llamada, que se pasa a través de una instancia del delegado `NextPrimeDelegate`.  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberbegininvoke)] 
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberBeginInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberbegininvoke)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> no es un <see cref="T:System.Windows.Threading.DispatcherPriority" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegado de un método que toma los parámetros especificados en <c>args</c>, que se inserta en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="priority">Prioridad, relativa a otras operaciones pendientes de la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />, con la que se invoca el método especificado.</param>
        <param name="args">Matriz de objetos cuyos valores se pasan como argumentos al método especificado. Puede ser <see langword="null" />.</param>
        <summary>Ejecuta de forma asincrónica el delegado especificado, con la prioridad indicada y los argumentos especificados, en el subproceso en el que se creó el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Objeto, que se devuelve inmediatamente después de llamar a <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />, que se puede usar para interactuar con el delegado ya que su ejecución está pendiente en la cola de eventos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Threading.DispatcherOperation> objeto devuelto por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> puede utilizarse de varias maneras para interactuar con el delegado especificado, como:  
  
-   Cambiar el <xref:System.Windows.Threading.DispatcherPriority> del delegado ya que está pendiente la ejecución en la cola de eventos.  
  
-   Quitando al delegado de la cola de eventos.  
  
-   Esperando el delegado que se va a devolver.  
  
-   Para obtener el valor que devuelve el delegado después de se ejecuta.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica; por lo tanto, control vuelve inmediatamente al objeto que realiza la llamada después de que se llama.  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto. Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario. En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario. Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica. La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se llama en una <xref:System.Windows.Threading.Dispatcher> que se ha cerrado, la propiedad status de devuelto <xref:System.Windows.Threading.DispatcherOperation> está establecido en <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Prioridad, relativa a otras operaciones pendientes de la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />, con la que se invoca el método especificado.</param>
        <param name="method">Delegado a un método que toma un argumento, que se inserta en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Objeto que se va a pasar como argumento al método especificado.</param>
        <summary>Ejecuta asincrónicamente el delegado especificado en la prioridad indicada y con el argumento especificado en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Objeto, que se devuelve inmediatamente después de llamar a <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />, que se puede usar para interactuar con el delegado ya que su ejecución está pendiente en la cola de eventos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` puede ser `null` si no se necesita ningún argumento.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Devuelve un <xref:System.Windows.Threading.DispatcherOperation> objeto que puede usar para interactuar con el delegado al que el delegado en el evento cola.  
  
 El <xref:System.Windows.Threading.DispatcherOperation> objeto devuelto por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> puede utilizarse de varias maneras para interactuar con el delegado especificado, como:  
  
-   Cambiar el <xref:System.Windows.Threading.DispatcherPriority> del delegado ya que está pendiente la ejecución en la cola de eventos.  
  
-   Quitando al delegado de la cola de eventos.  
  
-   Esperando el delegado que se va a devolver.  
  
-   Para obtener el valor que devuelve el delegado después de se ejecuta.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica; por lo tanto, control vuelve inmediatamente al objeto que realiza la llamada después de que se llama.  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si hay varios <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> llamadas se realizan en el mismo <xref:System.Windows.Threading.DispatcherPriority>, se ejecutarán en el orden en que se realizaron las llamadas.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se llama en una <xref:System.Windows.Threading.Dispatcher> que se ha cerrado, la propiedad status de devuelto <xref:System.Windows.Threading.DispatcherOperation> está establecido en <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo realizar una operación en un <xref:System.Windows.Threading.Dispatcher>.  
  
 En primer lugar, se crea un delegado que acepta un argumento, en este caso una cadena.  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdelegates)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdelegates)]  
  
 Después, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> se llama.  Dado que cada <xref:System.Windows.Threading.DispatcherObject> tiene una propiedad que devuelve el <xref:System.Windows.Threading.Dispatcher> está asociado a, lo que se desea <xref:System.Windows.Threading.Dispatcher> se obtiene consultando la <xref:System.Windows.Threading.DispatcherObject>, en este caso un <xref:System.Windows.Controls.Grid> denominado `tomorrowsWeather`. La llamada a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%2CSystem.Object%29> toma tres parámetros: la prioridad, que se establece en <xref:System.Windows.Threading.DispatcherPriority.Normal?displayProperty=nameWithType>; la devolución de llamada, que se pasa a través de una instancia del delegado `OneArgDelegate`; y una cadena denominada `weather`, que es el argumento para la devolución de llamada.  
  
 [!code-csharp[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherdispatcheronearge)]
 [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherdispatcheronearge)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> no es un <see cref="T:System.Windows.Threading.DispatcherPriority" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation BeginInvoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ BeginInvoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Prioridad, relativa a otras operaciones pendientes de la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />, con la que se invoca el método especificado.</param>
        <param name="method">Delegado de un método que toma varios argumentos y se inserta en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Objeto que se va a pasar como argumento al método especificado.</param>
        <param name="args">Matriz de objetos cuyos valores se pasan como argumentos al método especificado.</param>
        <summary>Ejecuta asincrónicamente el delegado especificado en la prioridad indicada y con la matriz de argumentos indicada en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Objeto, que se devuelve inmediatamente después de llamar a <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />, que se puede usar para interactuar con el delegado ya que su ejecución está pendiente en la cola de <see cref="T:System.Windows.Threading.Dispatcher" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `arg` parámetro puede ser `null` si no se necesita ningún argumento.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> Devuelve un <xref:System.Windows.Threading.DispatcherOperation> objeto que puede usar para interactuar con el delegado al que el delegado en el evento cola.  
  
 El <xref:System.Windows.Threading.DispatcherOperation> objeto devuelto por <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> puede utilizarse de varias maneras para interactuar con el delegado especificado, como:  
  
-   Cambiar el <xref:System.Windows.Threading.DispatcherPriority> del delegado ya que está pendiente la ejecución en la cola de eventos.  
  
-   Quitando al delegado de la cola de eventos.  
  
-   Esperando el delegado que se va a devolver.  
  
-   Para obtener el valor que devuelve el delegado después de se ejecuta.  
  
 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica; por lo tanto, control vuelve inmediatamente al objeto que realiza la llamada después de que se llama.  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 Si hay varios <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> llamadas se realizan en el mismo <xref:System.Windows.Threading.DispatcherPriority>, se ejecutarán en el orden en que se realizaron las llamadas.  
  
 Si <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> se llama en una <xref:System.Windows.Threading.Dispatcher> que se ha cerrado, la propiedad status de devuelto <xref:System.Windows.Threading.DispatcherOperation> está establecido en <xref:System.Windows.Threading.DispatcherOperationStatus.Aborted>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <see cref="T:System.Windows.Threading.DispatcherPriority" /> no es una prioridad válida.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginInvokeShutdown">
      <MemberSignature Language="C#" Value="public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginInvokeShutdown(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInvokeShutdown (priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginInvokeShutdown(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">Prioridad en la que empezar a cerrar el distribuidor.</param>
        <summary>Inicia asincrónicamente el cierre de <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.BeginInvokeShutdown%2A> peticiones no restringido de permisos de la interfaz de usuario.  
  
 Cuando el <xref:System.Windows.Threading.Dispatcher> empieza a cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> evento se desencadena y <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> está establecido en `true`.  
  
 El <xref:System.Windows.Threading.Dispatcher> no se cierra por completo hasta que se desenrede la cola de eventos.  
  
 Cuando el distribuidor termina de cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> evento se desencadena y <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propiedad está establecida en `true`.  
  
 Una vez iniciado el proceso de cierre, trabajo pendiente se anulan los elementos en la cola.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para cerrar el distribuidor.  Enumeraciones asociadas:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CheckAccess">
      <MemberSignature Language="C#" Value="public bool CheckAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckAccess () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckAccess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina si el subproceso de la llamada es el subproceso asociado a este objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>
          Es <see langword="true" /> si el subproceso de la llamada es el subproceso asociado a este objeto <see cref="T:System.Windows.Threading.Dispatcher" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo el <xref:System.Windows.Threading.Dispatcher> que un <xref:System.Windows.Threading.DispatcherObject> se crea en puede tener acceso al objeto.  Use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> para tener acceso al objeto desde un subproceso diferente.  
  
 <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> puede llamar desde cualquier subproceso.  
  
 La diferencia entre <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> y <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> es <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> devuelve un valor booleano que indica si el subproceso que realiza la llamada tiene acceso a la <xref:System.Windows.Threading.Dispatcher> y <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> produce una excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> para determinar si un subproceso tiene acceso a un <xref:System.Windows.Controls.Button>.  El <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> método en el <xref:System.Windows.Threading.Dispatcher> asociados con el <xref:System.Windows.Controls.Button> se llama para comprobar el acceso al subproceso.  Si el subproceso que realiza la llamada tiene acceso a la <xref:System.Windows.Threading.Dispatcher>, el <xref:System.Windows.Controls.Button> se actualiza mediante el acceso a los miembros de la <xref:System.Windows.Controls.Button>; en caso contrario, un delegado, que acepta un <xref:System.Windows.Controls.Button> como argumento, se coloca en el <xref:System.Windows.Threading.Dispatcher>.  El <xref:System.Windows.Threading.Dispatcher> delegará el trabajo de actualización de la <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccesscheckaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccesscheckaccess)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDispatcher">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Threading.Dispatcher CurrentDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.CurrentDispatcher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDispatcher As Dispatcher" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Threading::Dispatcher ^ CurrentDispatcher { System::Windows::Threading::Dispatcher ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene <see cref="T:System.Windows.Threading.Dispatcher" /> del subproceso que se ejecuta actualmente y crea un nuevo objeto <see cref="T:System.Windows.Threading.Dispatcher" /> si aún no hay ninguno asociado al subproceso.</summary>
        <value>Distribuidor asociado al subproceso actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un <xref:System.Windows.Threading.Dispatcher> no está asociado con el subproceso actual, un nuevo <xref:System.Windows.Threading.Dispatcher> se creará.  Esto no sucede así con el método <xref:System.Windows.Threading.Dispatcher.FromThread%2A>.  <xref:System.Windows.Threading.Dispatcher.FromThread%2A> devolverá `null` si no es un distribuidor asociado al subproceso especificado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableProcessing">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.DisableProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Function DisableProcessing () As DispatcherProcessingDisabled" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherProcessingDisabled DisableProcessing();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherProcessingDisabled</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deshabilita el procesamiento de la cola de <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Estructura usada para volver a habilitar el procesamiento del distribuidor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deshabilitar el procesamiento del distribuidor es un método avanzado que está pensado para eliminar la posibilidad de reentrada no relacionada.  
  
 Los efectos de deshabilitar el procesamiento son los siguientes:  
  
-   Bloqueos CLR no suministrarán mensajes internamente.  
  
-   <xref:System.Windows.Threading.DispatcherFrame> no se permiten objetos que se van a insertar.  
  
-   No se permite el procesamiento de mensajes.  
  
 El <xref:System.Windows.Threading.DispatcherProcessingDisabled> estructura <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> devuelve cuando se llama puede utilizarse para volver a habilitar el procesamiento del distribuidor.  Al llamar a <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> en el <xref:System.Windows.Threading.DispatcherProcessingDisabled> estructura vuelve a habilita el procesamiento.  
  
 <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> sólo se puede llamar en el subproceso de la <xref:System.Windows.Threading.Dispatcher> está asociado.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo deshabilitar el procesamiento del distribuidor y volver a habilitar el procesamiento del distribuidor.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> se llama una **con** instrucción.  <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> Devuelve un <xref:System.Windows.Threading.DispatcherProcessingDisabled> estructura que se utiliza como el objeto sea eliminado cuando la **con** bloquear finalice.  Cuando <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> se llama en el <xref:System.Windows.Threading.DispatcherProcessingDisabled> estructura, el procesamiento del distribuidor se vuelve a habilitar.  
  
 [!code-csharp[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdisableprocessing)]
 [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdisableprocessing)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExitAllFrames">
      <MemberSignature Language="C#" Value="public static void ExitAllFrames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitAllFrames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitAllFrames ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitAllFrames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Solicita que todos salgan los fotogramas, incluidos los fotogramas anidados.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para llamar a este método. Enumeraciones asociadas:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
        <altmember cref="T:System.Windows.Threading.DispatcherFrame" />
      </Docs>
    </Member>
    <Member MemberName="FromThread">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Threading.Dispatcher FromThread(class System.Threading.Thread thread) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::Dispatcher ^ FromThread(System::Threading::Thread ^ thread);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.Dispatcher</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="System.Threading.Thread" />
      </Parameters>
      <Docs>
        <param name="thread">Subproceso del que se va a obtener <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Obtiene el objeto <see cref="T:System.Windows.Threading.Dispatcher" /> del subproceso especificado.</summary>
        <returns>Distribuidor de <paramref name="thread" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no está disponible para el subproceso especificado, un distribuidor `null` se devolverá.  
  
 <xref:System.Windows.Threading.Dispatcher.FromThread%2A> no se crea un <xref:System.Windows.Threading.Dispatcher> en un subproceso que no tiene un <xref:System.Windows.Threading.Dispatcher>.   Un nuevo <xref:System.Windows.Threading.Dispatcher> se crea en un subproceso que aún no tiene un <xref:System.Windows.Threading.Dispatcher> al intentar obtener la <xref:System.Windows.Threading.Dispatcher> utilizando el <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownFinished">
      <MemberSignature Language="C#" Value="public bool HasShutdownFinished { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownFinished" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownFinished As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownFinished { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina si <see cref="T:System.Windows.Threading.Dispatcher" /> ha terminado de cerrarse.</summary>
        <value>
          Es <see langword="true" /> si el distribuidor ha terminado de cerrarse; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Windows.Threading.Dispatcher> empieza a cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> evento se desencadena y <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> está establecido en `true`.  
  
 El <xref:System.Windows.Threading.Dispatcher> no se apaga completamente hasta que se desenrede la cola de eventos.  
  
 Cuando el distribuidor termina de cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> evento se desencadena y <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propiedad está establecida en `true`.  
  
 Una vez iniciado el proceso de cierre, trabajo pendiente se anulan los elementos en la cola.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasShutdownStarted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina si <see cref="T:System.Windows.Threading.Dispatcher" /> se está cerrando.</summary>
        <value>
          Es <see langword="true" /> si <see cref="T:System.Windows.Threading.Dispatcher" /> se ha empezado a cerrar; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Windows.Threading.Dispatcher> empieza a cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> evento se desencadena y <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> está establecido en `true`.  
  
 El <xref:System.Windows.Threading.Dispatcher> no se cierra por completo hasta que se desenrede la cola de eventos.  
  
 Cuando el distribuidor termina de cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> evento se desencadena y <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propiedad está establecida en `true`.  
  
 Una vez iniciado el proceso de cierre, trabajo pendiente se anulan los elementos en la cola.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hooks">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherHooks Hooks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Threading.DispatcherHooks Hooks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Hooks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Hooks As DispatcherHooks" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Threading::DispatcherHooks ^ Hooks { System::Windows::Threading::DispatcherHooks ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherHooks</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección de enlaces que proporcionan la información de evento adicional sobre <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <value>Enlaces asociados a este objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Threading.DispatcherHooks> clase proporciona información adicional del evento sobre la <xref:System.Windows.Threading.Dispatcher>, como cuando la <xref:System.Windows.Threading.Dispatcher> está inactivo o cuando se complete una operación.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Para obtener esta propiedad.  Enumeraciones asociadas:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ejecuta sincrónicamente el delegado especificado en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no devolverá para el objeto que realiza la llamada hasta que después de que vuelva la devolución de llamada.  
  
   
  
## Examples  
 En el ejemplo siguiente se coloca un delegado en un <xref:System.Windows.Threading.Dispatcher> en <xref:System.Windows.Threading.DispatcherPriority.Normal> con <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado para invocar a través del distribuidor.</param>
        <summary>Ejecuta sincrónicamente el <see cref="T:System.Action" /> especificado en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invoke (callback As Action, priority As DispatcherPriority)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado para invocar a través del distribuidor.</param>
        <param name="priority">Prioridad que determina en qué orden se invoca la devolución de llamada especificada con respecto a las demás operaciones pendientes de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Ejecuta sincrónicamente el <see cref="T:System.Action" /> especificado en la prioridad indicada en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegado de un método que toma los parámetros especificados en <c>args</c>, que se inserta en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="args">Matriz de objetos cuyos valores se pasan como argumentos al método especificado. Puede ser <see langword="null" />.</param>
        <summary>Ejecuta de forma sincrónica el delegado especificado con los argumentos especificados en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Es el valor devuelto desde el delegado al que se invoca o es <see langword="null" /> si el delegado no devuelve ningún valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto. Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario. En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario. Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica. La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no devolverá para el objeto que realiza la llamada hasta que después de que vuelva la devolución de llamada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Prioridad, relativa a otras operaciones pendientes de la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />, con la que se invoca el método especificado.</param>
        <param name="method">Un delegado a un método que no toma ningún argumento, que se inserta en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Ejecuta sincrónicamente el delegado especificado en la prioridad indicada en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Es el valor devuelto desde el delegado al que se invoca o es <see langword="null" /> si el delegado no devuelve ningún valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no devolverá para el objeto que realiza la llamada hasta que después de que vuelva la devolución de llamada.  
  
   
  
## Examples  
 En el ejemplo siguiente se coloca un delegado en un <xref:System.Windows.Threading.Dispatcher> en <xref:System.Windows.Threading.DispatcherPriority.Normal> con <xref:System.Windows.Threading.Dispatcher.Invoke%2A>.  
  
 [!code-csharp[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/csharp/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/CSharp/Window1.xaml.cs#systemtimerdispatcherinvoke)]
 [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InvalidateRequeryWithSystemTimer/visualbasic/window1.xaml.vb#systemtimerdispatcherinvoke)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> es igual a <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> no es una prioridad válida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado para invocar a través del distribuidor.</param>
        <param name="priority">Prioridad que determina en qué orden se invoca la devolución de llamada especificada con respecto a las demás operaciones pendientes de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Un objeto que indica si cancelar la acción.</param>
        <summary>Ejecuta sincrónicamente el <see cref="T:System.Action" /> especificado en la prioridad indicada en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegado de un método que toma los parámetros especificados en <c>args</c>, que se inserta en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="timeout">Tiempo máximo que se esperará a que se complete la operación.</param>
        <param name="args">Matriz de objetos cuyos valores se pasan como argumentos al método especificado. Puede ser <see langword="null" />.</param>
        <summary>Ejecuta de forma sincrónica el delegado especificado dentro del intervalo de tiempo designado y con la prioridad y los argumentos especificados en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Es el valor devuelto desde el delegado al que se invoca o es <see langword="null" /> si el delegado no devuelve ningún valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto. Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario. En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario. Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica. La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no devolverá para el objeto que realiza la llamada hasta que después de que vuelva la devolución de llamada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegado de un método que toma los parámetros especificados en <c>args</c>, que se inserta en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="priority">Prioridad, relativa a otras operaciones pendientes de la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />, con la que se invoca el método especificado.</param>
        <param name="args">Matriz de objetos cuyos valores se pasan como argumentos al método especificado. Puede ser <see langword="null" />.</param>
        <summary>Ejecuta el delegado especificado en la prioridad indicada con los argumentos especificados sincrónicamente en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Es el valor devuelto desde el delegado al que se invoca o es <see langword="null" /> si el delegado no devuelve ningún valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto. Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario. En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario. Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica. La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no devolverá para el objeto que realiza la llamada hasta que después de que vuelva la devolución de llamada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Prioridad, relativa a otras operaciones pendientes de la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />, con la que se invoca el método especificado.</param>
        <param name="method">Delegado a un método que toma un argumento, que se inserta en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Objeto cuyos valores se pasan como argumento al método especificado.</param>
        <summary>Ejecuta el delegado especificado en la prioridad indicada con el argumento especificado sincrónicamente en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Es el valor devuelto desde el delegado al que se invoca o es <see langword="null" /> si el delegado no devuelve ningún valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` puede ser `null` si no se necesita un argumento  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no devolverá para el objeto que realiza la llamada hasta que después de que vuelva la devolución de llamada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> es igual a <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> no es una prioridad válida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="priority">Prioridad, relativa a otras operaciones pendientes de la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />, con la que se invoca el método especificado.</param>
        <param name="timeout">Tiempo máximo de espera para que finalice la operación.</param>
        <param name="method">El delegado a un método que no toma ningún argumento, que se inserta en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Ejecuta sincrónicamente el delegado especificado en la prioridad indicada y con el valor de tiempo de espera especificado en el subproceso que creó <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Es el valor devuelto desde el delegado al que se invoca o es <see langword="null" /> si el delegado no devuelve ningún valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no devolverá para el objeto que realiza la llamada hasta que después de que vuelva la devolución de llamada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invoke(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invoke(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado para invocar a través del distribuidor.</param>
        <param name="priority">Prioridad que determina en qué orden se invoca la devolución de llamada especificada con respecto a las demás operaciones pendientes de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Un objeto que indica si cancelar la acción.</param>
        <param name="timeout">Tiempo mínimo que se esperará a que se inicie la operación.</param>
        <summary>Ejecuta sincrónicamente el <see cref="T:System.Action" /> especificado en la prioridad indicada en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method, valuetype System.TimeSpan timeout, valuetype System.Windows.Threading.DispatcherPriority priority, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, timeout As TimeSpan, priority As DispatcherPriority, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method, TimeSpan timeout, System::Windows::Threading::DispatcherPriority priority, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegado de un método que toma los parámetros especificados en <c>args</c>, que se inserta en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="timeout">Tiempo máximo que se esperará a que se complete la operación.</param>
        <param name="priority">Prioridad, relativa a otras operaciones pendientes de la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />, con la que se invoca el método especificado.</param>
        <param name="args">Matriz de objetos cuyos valores se pasan como argumentos al método especificado. Puede ser <see langword="null" />.</param>
        <summary>Ejecuta de forma sincrónica el delegado especificado dentro del intervalo de tiempo designado y con la prioridad y los argumentos especificados en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Es el valor devuelto desde el delegado al que se invoca o es <see langword="null" /> si el delegado no devuelve ningún valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto. Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario. En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario. Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>. <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica. La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no devolverá para el objeto que realiza la llamada hasta que después de que vuelva la devolución de llamada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Prioridad, relativa a otras operaciones pendientes de la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />, con la que se invoca el método especificado.</param>
        <param name="method">Delegado de un método que toma varios argumentos y se inserta en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Objeto cuyos valores se pasan como argumento al método especificado.</param>
        <param name="args">Matriz de objetos cuyos valores se pasan como argumentos al método especificado.</param>
        <summary>Ejecuta el delegado especificado en la prioridad indicada con los argumentos especificados sincrónicamente en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Es el valor devuelto desde el delegado al que se invoca o es <see langword="null" /> si el delegado no devuelve ningún valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` puede ser `null` si no se necesita un argumento  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no devolverá para el objeto que realiza la llamada hasta que después de que vuelva la devolución de llamada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> es igual a <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> no es una prioridad válida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="priority">Prioridad, relativa a otras operaciones pendientes de la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />, con la que se invoca el método especificado.</param>
        <param name="timeout">Tiempo máximo de espera para que finalice la operación.</param>
        <param name="method">Delegado de un método que toma varios argumentos y se inserta en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Objeto cuyos valores se pasan como argumento al método especificado. Puede ser <see langword="null" /> si no se necesita ningún argumento.</param>
        <summary>Ejecuta el delegado especificado en la prioridad indicada con el argumento especificado sincrónicamente en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Es el valor devuelto desde el delegado al que se invoca o es <see langword="null" /> si el delegado no devuelve ningún valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` puede ser `null` si no se necesita un argumento  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no devolverá para el objeto que realiza la llamada hasta que después de que vuelva la devolución de llamada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> es igual a <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> no es una prioridad válida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.TimeSpan timeout, class System.Delegate method, object arg, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (priority As DispatcherPriority, timeout As TimeSpan, method As Delegate, arg As Object, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(System::Windows::Threading::DispatcherPriority priority, TimeSpan timeout, Delegate ^ method, System::Object ^ arg, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="priority">Prioridad, relativa a otras operaciones pendientes de la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />, con la que se invoca el método especificado.</param>
        <param name="timeout">Tiempo máximo de espera para que finalice la operación.</param>
        <param name="method">Delegado de un método que toma varios argumentos y se inserta en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="arg">Objeto que se va a pasar como un argumento al método especificado.</param>
        <param name="args">Matriz de objetos cuyos valores se pasan como argumentos al método especificado.</param>
        <summary>Ejecuta el delegado especificado en la prioridad indicada con los argumentos especificados sincrónicamente en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Es el valor devuelto desde el delegado al que se invoca o es <see langword="null" /> si el delegado no devuelve ningún valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Arg` puede ser `null` si no se necesita un argumento.  
  
 En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], sólo el subproceso que creó un <xref:System.Windows.Threading.DispatcherObject> puede tener acceso a ese objeto.  Por ejemplo, un subproceso en segundo plano que es el resultado indirecto desde el subproceso de interfaz de usuario principal no puede actualizar el contenido de un <xref:System.Windows.Controls.Button> que se creó en el subproceso de interfaz de usuario.  En orden para el subproceso en segundo plano tener acceso a la propiedad de contenido de la <xref:System.Windows.Controls.Button>, el subproceso en segundo plano debe delegar el trabajo para el <xref:System.Windows.Threading.Dispatcher> asociado al subproceso de interfaz de usuario.  Esto se logra mediante el uso <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.  <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es sincrónico y <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es asincrónica.  La operación se agrega a la cola de eventos de la <xref:System.Windows.Threading.Dispatcher> en el índice especificado <xref:System.Windows.Threading.DispatcherPriority>.  
  
 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> es una operación sincrónica; por lo tanto, control no devolverá para el objeto que realiza la llamada hasta que después de que vuelva la devolución de llamada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="priority" /> es igual a <see cref="F:System.Windows.Threading.DispatcherPriority.Inactive" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> no es un <see cref="T:System.Windows.Threading.DispatcherPriority" /> válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del valor devuelto del delegado especificado.</typeparam>
        <param name="callback">Delegado para invocar a través del distribuidor.</param>
        <summary>Ejecuta sincrónicamente el <see cref="T:System.Func`1" /> especificado en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del valor devuelto del delegado especificado.</typeparam>
        <param name="callback">Delegado para invocar a través del distribuidor.</param>
        <param name="priority">Prioridad que determina en qué orden se invoca la devolución de llamada especificada con respecto a las demás operaciones pendientes de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Ejecuta sincrónicamente el <see cref="T:System.Func`1" /> especificado en la prioridad indicada en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del valor devuelto del delegado especificado.</typeparam>
        <param name="callback">Delegado para invocar a través del distribuidor.</param>
        <param name="priority">Prioridad que determina en qué orden se invoca la devolución de llamada especificada con respecto a las demás operaciones pendientes de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Un objeto que indica si cancelar la operación.</param>
        <summary>Ejecuta sincrónicamente el <see cref="T:System.Func`1" /> especificado en la prioridad indicada en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public TResult Invoke&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TResult Invoke&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; TResult Invoke(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del valor devuelto del delegado especificado.</typeparam>
        <param name="callback">Delegado para invocar a través del distribuidor.</param>
        <param name="priority">Prioridad que determina en qué orden se invoca la devolución de llamada especificada con respecto a las demás operaciones pendientes de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Un objeto que indica si cancelar la operación.</param>
        <param name="timeout">Tiempo mínimo que se esperará a que se inicie la operación.</param>
        <summary>Ejecuta sincrónicamente el <see cref="T:System.Func`1" /> especificado en la prioridad indicada en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por `callback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeAsync">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ejecuta asincrónicamente el delegado especificado en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado para invocar a través del distribuidor.</param>
        <summary>Ejecuta asincrónicamente el <see cref="T:System.Action" /> especificado en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Objeto, que se devuelve inmediatamente después de llamar a <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)" />, que se puede usar para interactuar con el delegado ya que su ejecución está pendiente en la cola de eventos.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync (callback As Action, priority As DispatcherPriority) As DispatcherOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado para invocar a través del distribuidor.</param>
        <param name="priority">Prioridad que determina en qué orden se invoca la devolución de llamada especificada con respecto a las demás operaciones pendientes de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Ejecuta asincrónicamente el <see cref="T:System.Action" /> especificado en la prioridad indicada en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Objeto, que se devuelve inmediatamente después de llamar a <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)" />, que se puede usar para interactuar con el delegado ya que su ejecución está pendiente en la cola de eventos.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation InvokeAsync(class System.Action callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Threading::DispatcherOperation ^ InvokeAsync(Action ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="callback">Delegado para invocar a través del distribuidor.</param>
        <param name="priority">Prioridad que determina en qué orden se invoca la devolución de llamada especificada con respecto a las demás operaciones pendientes de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Un objeto que indica si cancelar la acción.</param>
        <summary>Ejecuta asincrónicamente el <see cref="T:System.Action" /> especificado en la prioridad indicada en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Objeto, que se devuelve inmediatamente después de llamar a <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />, que se puede usar para interactuar con el delegado ya que su ejecución está pendiente en la cola de eventos.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult)) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del valor devuelto del delegado especificado.</typeparam>
        <param name="callback">Delegado para invocar a través del distribuidor.</param>
        <summary>Ejecuta asincrónicamente el <see cref="T:System.Func`1" /> especificado en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Objeto, que se devuelve inmediatamente después de llamar a <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})" />, que se puede usar para interactuar con el delegado ya que su ejecución está pendiente en la cola de eventos.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeAsync(Of TResult) (callback As Func(Of TResult), priority As DispatcherPriority) As DispatcherOperation(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del valor devuelto del delegado especificado.</typeparam>
        <param name="callback">Delegado para invocar a través del distribuidor.</param>
        <param name="priority">Prioridad que determina en qué orden se invoca la devolución de llamada especificada con respecto a las demás operaciones pendientes de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <summary>Ejecuta asincrónicamente el <see cref="T:System.Func`1" /> especificado en la prioridad indicada en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Objeto, que se devuelve inmediatamente después de llamar a <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)" />, que se puede usar para interactuar con el delegado ya que su ejecución está pendiente en la cola de eventos.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Windows.Threading.DispatcherOperation&lt;TResult&gt; InvokeAsync&lt;TResult&gt; (Func&lt;TResult&gt; callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Threading.DispatcherOperation`1&lt;!!TResult&gt; InvokeAsync&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; callback, valuetype System.Windows.Threading.DispatcherPriority priority, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Windows::Threading::DispatcherOperation&lt;TResult&gt; ^ InvokeAsync(Func&lt;TResult&gt; ^ callback, System::Windows::Threading::DispatcherPriority priority, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherOperation&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo del valor devuelto del delegado especificado.</typeparam>
        <param name="callback">Delegado para invocar a través del distribuidor.</param>
        <param name="priority">Prioridad que determina en qué orden se invoca la devolución de llamada especificada con respecto a las demás operaciones pendientes de <see cref="T:System.Windows.Threading.Dispatcher" />.</param>
        <param name="cancellationToken">Un objeto que indica si cancelar la operación.</param>
        <summary>Ejecuta sincrónicamente el <see cref="T:System.Func`1" /> especificado en la prioridad indicada en el subproceso al que está asociado el objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <returns>Objeto, que se devuelve inmediatamente después de llamar a <see cref="M:System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)" />, que se puede usar para interactuar con el delegado ya que su ejecución está pendiente en la cola de eventos.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeShutdown">
      <MemberSignature Language="C#" Value="public void InvokeShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeShutdown();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia sincrónicamente el proceso de cierre de <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Threading.Dispatcher.InvokeShutdown%2A> peticiones no restringido de permisos de la interfaz de usuario.  
  
 Cuando el <xref:System.Windows.Threading.Dispatcher> empieza a cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> evento se desencadena y <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> está establecido en `true`.  
  
 El <xref:System.Windows.Threading.Dispatcher> no se cierra por completo hasta que se desenrede la cola de eventos.  
  
 Cuando el distribuidor termina de cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> evento se desencadena y <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propiedad está establecida en `true`.  
  
 Una vez iniciado el proceso de cierre, trabajo pendiente se anulan los elementos en la cola.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para cerrar el distribuidor.  Enumeraciones asociadas:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PushFrame">
      <MemberSignature Language="C#" Value="public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PushFrame(class System.Windows.Threading.DispatcherFrame frame) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PushFrame (frame As DispatcherFrame)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PushFrame(System::Windows::Threading::DispatcherFrame ^ frame);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frame" Type="System.Windows.Threading.DispatcherFrame" />
      </Parameters>
      <Docs>
        <param name="frame">Fotograma del distribuidor que se va a procesar.</param>
        <summary>Escribe un bucle de ejecución.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Threading.DispatcherFrame> representa un bucle que procesa los elementos de trabajo pendiente.  
  
 El distribuidor procesa la cola de elementos de trabajo en un bucle.  El bucle se conoce como una trama.  El bucle inicial normalmente se inicia la aplicación mediante una llamada a <xref:System.Windows.Threading.Dispatcher.Run%2A>.  
  
 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> entra en un bucle representado por el parámetro `frame`.  En cada iteración del bucle, la <xref:System.Windows.Threading.Dispatcher> comprobará la <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> propiedad en la <xref:System.Windows.Threading.DispatcherFrame> clase para determinar si el bucle debe continuar o si debe detenerse.  
  
 <xref:System.Windows.Threading.DispatcherFrame> permite la <xref:System.Windows.Threading.DispatcherFrame.Continue%2A> propiedad se establece explícitamente y respeta la <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> propiedad en el <xref:System.Windows.Threading.Dispatcher>.  Esto significa que cuando el <xref:System.Windows.Threading.Dispatcher> empieza a cerrar, marcos que utilizan el valor predeterminado <xref:System.Windows.Threading.DispatcherFrame> implementación se cerrará, lo que permite anidadas todos los marcos salir.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar un <xref:System.Windows.Threading.DispatcherFrame> para lograr resultados similares como el [!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)] <xref:System.Windows.Forms.Application.DoEvents%2A> método.  
  
 [!code-csharp[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherSnippets/CSharp/Window1.xaml.cs#dispatcherdispatcherframedoevents)]
 [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherSnippets/visualbasic/window1.xaml.vb#dispatcherdispatcherframedoevents)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="frame" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" /> es <see langword="true" />  
  
 O bien  
  
 <paramref name="frame" /> se ejecuta en un objeto <see cref="T:System.Windows.Threading.Dispatcher" /> diferente.  
  
 O bien  
  
 Se ha deshabilitado el procesamiento del distribuidor.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para insertar un fotograma de ejecución.  Enumeraciones asociadas:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Windows.Threading.Dispatcher.ExitAllFrames" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserta el fotograma de ejecución principal en la cola de eventos de <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Threading.Dispatcher> procesa la cola de eventos en un bucle.  El bucle se conoce como una trama.  El bucle inicial normalmente se inicia la aplicación mediante una llamada a <xref:System.Windows.Threading.Dispatcher.Run%2A>.  
  
 El marco de ejecución principal continuará hasta que el <xref:System.Windows.Threading.Dispatcher> está apagada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShutdownFinished">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownFinished;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownFinished" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownFinished As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownFinished;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando <see cref="T:System.Windows.Threading.Dispatcher" /> termina de cerrarse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el proceso de cierre de un <xref:System.Windows.Threading.Dispatcher> se inicia, el <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> evento se desencadena y <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> está establecido en `true`.  
  
 El <xref:System.Windows.Threading.Dispatcher> no se apaga completamente hasta que se desenrede la cola de eventos.  
  
 Cuando el distribuidor termina de cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> evento se desencadena y <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propiedad está establecida en `true`.  
  
 Una vez iniciado el proceso de cierre, trabajo pendiente se anulan los elementos en la cola.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownFinished" />
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownStarted">
      <MemberSignature Language="C#" Value="public event EventHandler ShutdownStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShutdownStarted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.ShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Event ShutdownStarted As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShutdownStarted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando <see cref="T:System.Windows.Threading.Dispatcher" /> empieza a cerrarse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el proceso de cierre de un <xref:System.Windows.Threading.Dispatcher> se inicia, el <xref:System.Windows.Threading.Dispatcher.ShutdownStarted> evento se desencadena y <xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> está establecido en `true`.  
  
 El <xref:System.Windows.Threading.Dispatcher> no se apaga completamente hasta que se desenrede la cola de eventos.  
  
 Cuando el distribuidor termina de cerrarse, el <xref:System.Windows.Threading.Dispatcher.ShutdownFinished> evento se desencadena y <xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> propiedad está establecida en `true`.  
  
 Una vez iniciado el proceso de cierre, trabajo pendiente se anulan los elementos en la cola.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Threading.Dispatcher.HasShutdownStarted" />
        <altmember cref="E:System.Windows.Threading.Dispatcher.ShutdownFinished" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)" />
        <altmember cref="M:System.Windows.Threading.Dispatcher.InvokeShutdown" />
      </Docs>
    </Member>
    <Member MemberName="Thread">
      <MemberSignature Language="C#" Value="public System.Threading.Thread Thread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Thread Thread" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Threading.Dispatcher.Thread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Thread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Thread ^ Thread { System::Threading::Thread ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el subproceso al que está asociado este objeto <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <value>Subproceso.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Event UnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se produce y no se detecta una excepción de subproceso durante la ejecución de un delegado mediante los métodos <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> o <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena cuando una excepción que se produjo durante la ejecución de un delegado por medio de <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> es no detectada.  
  
 Un controlador puede marcar la excepción como controlado, lo que impide que el controlador de excepción interna que se la llame.  
  
 Controladores de eventos para este evento se deben escribir con cuidado para evitar crear excepciones secundarias y detectar cualquiera que se produzca. Se recomienda para evitar la asignación de memoria o realizar operaciones intensivas en el controlador de cualquier recurso.  
  
 El <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> eventos proporcionan un medio para que no genere la <xref:System.Windows.Threading.Dispatcher.UnhandledException> eventos.  El <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> evento se desencadena en primer lugar y si <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> en el <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> está establecido en `false`, el <xref:System.Windows.Threading.Dispatcher.UnhandledException> no se producen eventos.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledExceptionFilter">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledExceptionFilter As DispatcherUnhandledExceptionFilterEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionFilterEventHandler ^ UnhandledExceptionFilter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se produce y no se detecta una excepción de subproceso durante la ejecución de un delegado mediante los métodos <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> o <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> mientras se está en la fase de filtrado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se produce durante la fase de filtrado para una excepción que se produce durante la ejecución de un delegado por medio de <xref:System.Windows.Threading.Dispatcher.Invoke%2A> o <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> y no detectada.  
  
 La pila de llamadas no se desenreda en este momento (excepciones de primera oportunidad).  
  
 Controladores de eventos para este evento se deben escribir con cuidado para evitar crear excepciones secundarias y detectar cualquiera que se produzca.  Se recomienda para evitar la asignación de memoria o realizar operaciones intensivas en el controlador de cualquier recurso.  
  
 El <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> eventos proporcionan un medio para que no genere la <xref:System.Windows.Threading.Dispatcher.UnhandledException> eventos.  El <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter> evento se desencadena en primer lugar y si <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> en el <xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> está establecido en `false`, el <xref:System.Windows.Threading.Dispatcher.UnhandledException> no se producen eventos.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Para agregar o quitar un controlador para este evento.  Enumeraciones asociadas:  <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler" />
        <altmember cref="T:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ValidatePriority">
      <MemberSignature Language="C#" Value="public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ValidatePriority(valuetype System.Windows.Threading.DispatcherPriority priority, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ValidatePriority (priority As DispatcherPriority, parameterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ValidatePriority(System::Windows::Threading::DispatcherPriority priority, System::String ^ parameterName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
        <Parameter Name="parameterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="priority">Prioridad que se va a comprobar.</param>
        <param name="parameterName">Cadena que devolverá la excepción que se produce si la prioridad no es válida.</param>
        <summary>Determina si el objeto <see cref="T:System.Windows.Threading.DispatcherPriority" /> especificado tiene una prioridad válida.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="priority" /> no es un <see cref="T:System.Windows.Threading.DispatcherPriority" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyAccess">
      <MemberSignature Language="C#" Value="public void VerifyAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void VerifyAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.VerifyAccess" />
      <MemberSignature Language="VB.NET" Value="Public Sub VerifyAccess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void VerifyAccess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina si el subproceso de la llamada tiene acceso a <see cref="T:System.Windows.Threading.Dispatcher" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo el subproceso de la <xref:System.Windows.Threading.Dispatcher> se crea en puede tener acceso a la <xref:System.Windows.Threading.Dispatcher>.  
  
 Este método es público; por lo tanto, cualquier subproceso puede comprobar si tiene acceso a la <xref:System.Windows.Threading.Dispatcher>.  
  
 La diferencia entre <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> y <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> es <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> devuelve un valor booleano si el subproceso que realiza la llamada no tiene acceso a la <xref:System.Windows.Threading.Dispatcher> y <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> produce una excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> para determinar si un subproceso tiene acceso al subproceso que un <xref:System.Windows.Controls.Button> se ha creado.  El método toma un objeto como argumento, que se convierte en un <xref:System.Windows.Controls.Button>.  El <xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> método en el <xref:System.Windows.Threading.Dispatcher> de la <xref:System.Windows.Controls.Button> se llama para comprobar el acceso al subproceso.  
  
 Si el subproceso que realiza la llamada tiene acceso a la <xref:System.Windows.Threading.Dispatcher>, <xref:System.Windows.Controls.Button> se actualiza mediante el acceso solo a los miembros de la <xref:System.Windows.Controls.Button>.  
  
 Si el subproceso que realiza la llamada no tiene acceso, un <xref:System.InvalidOperationException> se produce.  Este ejemplo detecta la excepción e inserta un delegado, que acepta un <xref:System.Windows.Controls.Button> como argumento, en la <xref:System.Windows.Threading.Dispatcher> de la <xref:System.Windows.Controls.Button>.  Esto <xref:System.Windows.Threading.Dispatcher> realizará el trabajo de actualización de la <xref:System.Windows.Controls.Button>.  
  
 [!code-csharp[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/csharp/VS_Snippets_Wpf/DispatcherAccessSample/CSharp/Window1.xaml.cs#dispatcheraccessverifyaccess)]
 [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DispatcherAccessSample/visualbasic/window1.xaml.vb#dispatcheraccessverifyaccess)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El subproceso de la llamada no tiene acceso a <see cref="T:System.Windows.Threading.Dispatcher" />.</exception>
        <altmember cref="M:System.Windows.Threading.Dispatcher.CheckAccess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Yield">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un objeto que admite await que devuelve el control de forma asincrónica al distribuidor actual y proporciona una oportunidad para que el distribuidor procese otros eventos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un objeto que admite await que devuelve el control de forma asincrónica al distribuidor actual y proporciona una oportunidad para que el distribuidor procese otros eventos.</summary>
        <returns>Objeto que admite await que devuelve el control de forma asincrónica al distribuidor actual y proporciona una oportunidad para que el distribuidor procese otros eventos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método proporciona una manera de liberar temporalmente el control de ejecución para el distribuidor actual por lo que puede hacer otro trabajo, como procesar otros eventos. Use la `await`, o `Await` en Visual Basic, operador en el valor devuelto para devolver el control para el distribuidor actual. Utilice este método si desea dar una oportunidad para procesar eventos mientras la aplicación está realizando una gran cantidad de trabajo en el subproceso de interfaz de usuario de la aplicación. Por ejemplo, puede usar este método en un bucle de ejecución prolongada que actualiza un control.  
  
 Este método es equivalente a llamar a la <xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29> método y pasando <xref:System.Windows.Threading.DispatcherPriority.Background?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Threading.DispatcherPriorityAwaitable Yield(valuetype System.Windows.Threading.DispatcherPriority priority) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield (priority As DispatcherPriority) As DispatcherPriorityAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Threading::DispatcherPriorityAwaitable Yield(System::Windows::Threading::DispatcherPriority priority);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherPriorityAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="priority" Type="System.Windows.Threading.DispatcherPriority" />
      </Parameters>
      <Docs>
        <param name="priority">Prioridad con la que se programa la continuación.</param>
        <summary>Crea un objeto que admite await que devuelve el control de forma asincrónica al distribuidor actual y proporciona una oportunidad para que el distribuidor procese otros eventos.  El trabajo que se produce cuando el control vuelve al código que espera el resultado de este método se programa con la prioridad especificada.</summary>
        <returns>Objeto que admite await que devuelve el control de forma asincrónica al distribuidor actual y proporciona una oportunidad para que el distribuidor procese otros eventos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método proporciona una manera de liberar temporalmente el control de ejecución para el distribuidor actual por lo que puede hacer otro trabajo, como procesar otros eventos. Use la `await`, o `Await` en Visual Basic, operador en el valor devuelto para devolver el control para el distribuidor actual. Utilice este método si desea dar una oportunidad para procesar eventos mientras la aplicación está realizando una gran cantidad de trabajo en el subproceso de interfaz de usuario de la aplicación. Por ejemplo, puede usar este método en un bucle de ejecución prolongada que actualiza un control.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>