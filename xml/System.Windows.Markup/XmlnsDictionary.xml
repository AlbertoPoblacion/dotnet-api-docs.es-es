<Type Name="XmlnsDictionary" FullName="System.Windows.Markup.XmlnsDictionary">
  <Metadata><Meta Name="ms.openlocfilehash" Value="717569b0a784f58409e85539ac135c4ac5bf8e26" /><Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/09/2018" /><Meta Name="ms.locfileid" Value="51324631" /></Metadata><TypeSignature Language="C#" Value="public class XmlnsDictionary : System.Collections.IDictionary, System.Xaml.IXamlNamespaceResolver" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlnsDictionary extends System.Object implements class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.Xaml.IXamlNamespaceResolver" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.XmlnsDictionary" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlnsDictionary&#xA;Implements IDictionary, IXamlNamespaceResolver" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlnsDictionary : System::Collections::IDictionary, System::Xaml::IXamlNamespaceResolver" />
  <TypeSignature Language="F#" Value="type XmlnsDictionary = class&#xA;    interface IDictionary&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface IXamlNamespaceResolver" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xaml.IXamlNamespaceResolver</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa un diccionario que contiene asignaciones de xmlns para espacios de nombres XAML en WPF.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.XmlnsDictionary> asigna los prefijos de espacio de nombres XAML para el espacio de nombres XAML completa URI. Para el uso XAML en las aplicaciones y los espacios de nombres XAML en general, el URI a menudo no es un URI de estilo de esquema que incluye `http://`. En realidad es una asignación definida por el usuario a un espacio de nombres CLR y el ensamblado. Que el ensamblado contiene la copia de seguridad los tipos que se hace referencia a. Para obtener más información, consulte [los espacios de nombres XAML y Namespace Mapping for WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).  
  
 El <xref:System.Windows.Markup.XmlnsDictionary> agrega el concepto de ámbito para un espacio de nombres XAML. Valor predeterminado es <xref:System.Collections.IDictionary> podría contener claves de prefijo y los valores de URI de espacio de nombres XML. El concepto de ámbito en <xref:System.Windows.Markup.XmlnsDictionary> el concepto XML que podría volver a definir un prefijo es similar. Si es así, la redefinición sólo se aplica en ese nivel o una versión inferior en una vista del DOM de XML (la definición anterior se aplica en el nivel superior en el DOM). El concepto de ámbito es principalmente abstraen en el <xref:System.Windows.Markup.XmlnsDictionary> API, por ejemplo, puede llamar a las API como <xref:System.Windows.Markup.XmlnsDictionary.LookupNamespace%2A> sin tener que preocuparse acerca del ámbito. Sin embargo, <xref:System.Windows.Markup.XmlnsDictionary> exponer <xref:System.Windows.Markup.XmlnsDictionary.PushScope%2A> y <xref:System.Windows.Markup.XmlnsDictionary.PopScope%2A> para que un personalizado <xref:System.Windows.Markup.ParserContext> implementación que cambia el ámbito puede sincronizar con el ámbito para el <xref:System.Windows.Markup.XmlnsDictionary>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.ResourceDictionary" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlnsDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlnsDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlnsDictionary (System.Windows.Markup.XmlnsDictionary xmlnsDictionary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Markup.XmlnsDictionary xmlnsDictionary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.#ctor(System.Windows.Markup.XmlnsDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlnsDictionary(System::Windows::Markup::XmlnsDictionary ^ xmlnsDictionary);" />
      <MemberSignature Language="F#" Value="new System.Windows.Markup.XmlnsDictionary : System.Windows.Markup.XmlnsDictionary -&gt; System.Windows.Markup.XmlnsDictionary" Usage="new System.Windows.Markup.XmlnsDictionary xmlnsDictionary" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlnsDictionary" Type="System.Windows.Markup.XmlnsDictionary" />
      </Parameters>
      <Docs>
        <param name="xmlnsDictionary">Diccionario que va a servir de base para el nuevo objeto <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Markup.XmlnsDictionary" /> usando como origen de copia el diccionario especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los valores del origen `xmlnsDictionary` incluidas las entradas de índice se copian, excepto para <xref:System.Windows.Markup.XmlnsDictionary.Sealed%2A>, que se establece en `false` en la nueva instancia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="xmlnsDictionary" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega un par de prefijo e identificador URI a este objeto <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object prefix, object xmlNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(object prefix, object xmlNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (prefix As Object, xmlNamespace As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Object ^ prefix, System::Object ^ xmlNamespace);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj * obj -&gt; unit&#xA;override this.Add : obj * obj -&gt; unit" Usage="xmlnsDictionary.Add (prefix, xmlNamespace)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.Object" />
        <Parameter Name="xmlNamespace" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefijo del espacio de nombres XAML que se va a agregar.</param>
        <param name="xmlNamespace">Identificador URI de espacio de nombres XAML al que se va a asignar el prefijo.</param>
        <summary>Agrega un par de prefijo e identificador URI a este objeto <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de la comprobación de tipos inicial, esta implementación reenvía al método con seguridad de tipos <xref:System.Windows.Markup.XmlnsDictionary.Add%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="prefix" /> o <paramref name="xmlNamespace" /> no es una cadena.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="prefix" /> o <paramref name="xmlNamespace" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Markup.XmlnsDictionary" /> es de tipo sealed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string prefix, string xmlNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(string prefix, string xmlNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.Add(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (prefix As String, xmlNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::String ^ prefix, System::String ^ xmlNamespace);" />
      <MemberSignature Language="F#" Value="member this.Add : string * string -&gt; unit" Usage="xmlnsDictionary.Add (prefix, xmlNamespace)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="xmlNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefijo de este espacio de nombres XML.</param>
        <param name="xmlNamespace">Identificador URI de espacio de nombres XML al que se va a asignar el prefijo.</param>
        <summary>Agrega un par de prefijo e identificador URI a este objeto <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="prefix" /> o <paramref name="xmlNamespace" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Markup.XmlnsDictionary" /> es de tipo sealed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="xmlnsDictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todas las entradas de esta instancia de <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Markup.XmlnsDictionary" /> es de tipo sealed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="xmlnsDictionary.Contains key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clave de prefijo que se va a buscar.</param>
        <summary>Devuelve un valor que indica si la clave de prefijo especificada se encuentra en este objeto <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</summary>
        <returns>Es <see langword="true" /> si la clave de prefijo solicitada está en el diccionario; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia las entradas de la clase <see cref="T:System.Windows.Markup.XmlnsDictionary" /> en la matriz especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="xmlnsDictionary.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matriz en la que se van a copiar los datos de la tabla.</param>
        <param name="index">Índice de base cero de la matriz de destino donde se comienza a copiar.</param>
        <summary>Copia las entradas de la clase <see cref="T:System.Windows.Markup.XmlnsDictionary" /> en la matriz especificada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.DictionaryEntry[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Collections.DictionaryEntry[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.CopyTo(System.Collections.DictionaryEntry[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As DictionaryEntry(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Collections::DictionaryEntry&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Collections.DictionaryEntry[] * int -&gt; unit" Usage="xmlnsDictionary.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.DictionaryEntry[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matriz en la que se van a copiar los datos de la tabla.</param>
        <param name="index">Índice de base cero de la matriz de destino donde se comienza a copiar.</param>
        <summary>Copia las entradas de la clase <see cref="T:System.Windows.Markup.XmlnsDictionary" /> en la matriz <see cref="T:System.Collections.DictionaryEntry" /> especificada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.XmlnsDictionary.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.Markup.XmlnsDictionary.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de elementos de <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</summary>
        <value>Número de elementos en <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultNamespace">
      <MemberSignature Language="C#" Value="public string DefaultNamespace ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string DefaultNamespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.DefaultNamespace" />
      <MemberSignature Language="VB.NET" Value="Public Function DefaultNamespace () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ DefaultNamespace();" />
      <MemberSignature Language="F#" Value="member this.DefaultNamespace : unit -&gt; string" Usage="xmlnsDictionary.DefaultNamespace " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Busca el espacio de nombres XAML correspondiente al espacio de nombres XAML predeterminado.</summary>
        <returns>Espacio de nombres correspondiente al espacio de nombres XAML predeterminado si existe; de lo contrario, devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Desde una perspectiva de asignación, el espacio de nombres XML predeterminado es el espacio de nombres XML que se asigna a una cadena vacía. En el análisis de XAML de WPF para fines de la aplicación, el que actúa el espacio de nombres predeterminado es el identificador [!INCLUDE[TLA#tla_wpfxmlnsv1](~/includes/tlasharptla-wpfxmlnsv1-md.md)], pero este valor no se devuelve explícitamente por esta API.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDictionaryEnumerator">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionaryEnumerator GetDictionaryEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Collections.IDictionaryEnumerator GetDictionaryEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.GetDictionaryEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetDictionaryEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Collections::IDictionaryEnumerator ^ GetDictionaryEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetDictionaryEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="xmlnsDictionary.GetDictionaryEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador de diccionario que recorre en iteración este objeto <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</summary>
        <returns>Enumerador de este diccionario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta API existe para que las clases derivadas puedan obtener un enumerador que se notifica el concepto de ámbito para los espacios de nombres XML como una dimensión del enumerador de diccionario.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="xmlnsDictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que itera por este objeto <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</summary>
        <returns>Enumerador de este diccionario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta API existe para que las clases derivadas puedan obtener un enumerador. Esta enumeración proporciona a través de la <xref:System.Windows.Markup.XmlnsDictionary.Keys%2A> colección.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamespace">
      <MemberSignature Language="C#" Value="public string GetNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.GetNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetNamespace(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member GetNamespace : string -&gt; string&#xA;override this.GetNamespace : string -&gt; string" Usage="xmlnsDictionary.GetNamespace prefix" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xaml.IXamlNamespaceResolver.GetNamespace(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefijo para el cual se va a recuperar el espacio de nombres XAML.</param>
        <summary>Recupera un espacio de nombres XAML para la cadena de prefijo especificada.</summary>
        <returns>Identificador URI del espacio de nombres XAML solicitado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamespacePrefixes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xaml.NamespaceDeclaration&gt; GetNamespacePrefixes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.NamespaceDeclaration&gt; GetNamespacePrefixes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.GetNamespacePrefixes" />
      <MemberSignature Language="VB.NET" Value="Public Iterator Overridable NotOverridable Function GetNamespacePrefixes () As IEnumerable(Of NamespaceDeclaration)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::NamespaceDeclaration ^&gt; ^ GetNamespacePrefixes();" />
      <MemberSignature Language="F#" Value="abstract member GetNamespacePrefixes : unit -&gt; seq&lt;System.Xaml.NamespaceDeclaration&gt;&#xA;override this.GetNamespacePrefixes : unit -&gt; seq&lt;System.Xaml.NamespaceDeclaration&gt;" Usage="xmlnsDictionary.GetNamespacePrefixes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xaml.IXamlNamespaceResolver.GetNamespacePrefixes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Windows.Markup.XmlnsDictionary/&lt;GetNamespacePrefixes&gt;d__15))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Windows.Markup.XmlnsDictionary/&lt;GetNamespacePrefixes&gt;d__1))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.NamespaceDeclaration&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve todas las posibles asignaciones entre espacios de nombres XAML y prefijos (valores de valores<see cref="T:System.Xaml.NamespaceDeclaration" /> ) que están disponibles en el contexto de esquema activo.</summary>
        <returns>Conjunto enumerable de valores de <see cref="T:System.Xaml.NamespaceDeclaration" />. Para obtener específicamente las cadenas de prefijo, obtenga el valor de la propiedad <see cref="P:System.Xaml.NamespaceDeclaration.Prefix" /> de cada valor devuelto.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.XmlnsDictionary.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Windows.Markup.XmlnsDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el tamaño de <see cref="T:System.Windows.Markup.XmlnsDictionary" /> es fijo.</summary>
        <value>Es <see langword="true" /> si el tamaño es fijo; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación siempre devuelve `false`, incluso si <xref:System.Windows.Markup.XmlnsDictionary.IsReadOnly%2A> es `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.XmlnsDictionary.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Windows.Markup.XmlnsDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Windows.Markup.XmlnsDictionary" /> es de solo lectura.</summary>
        <value>Es <see langword="true" /> si el diccionario es de solo lectura; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Markup.XmlnsDictionary> es de solo lectura después de <xref:System.Windows.Markup.XmlnsDictionary.Seal%2A> se llama.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.XmlnsDictionary.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Windows.Markup.XmlnsDictionary.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el acceso a este objeto <see cref="T:System.Windows.Markup.XmlnsDictionary" /> es seguro para subprocesos.</summary>
        <value>Es <see langword="true" /> si el acceso a este diccionario es seguro para subprocesos; de lo contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene o establece el identificador URI de espacio de nombres XML asociado al prefijo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object prefix] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.XmlnsDictionary.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(prefix As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ prefix); void set(System::Object ^ prefix, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.Markup.XmlnsDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefijo del que se va a obtener o establecer el identificador URI de espacio de nombres XML asociado.</param>
        <summary>Obtiene o establece el identificador URI de espacio de nombres XAML asociado al prefijo especificado.</summary>
        <value>Identificador URI de espacio de nombres XAML correspondiente.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="prefix" /> no es una cadena 
O bien 
El valor que se va a establecer no es una cadena.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="prefix" /> es <see langword="null" />  
  
O bien 
El valor a establecer es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public string this[string prefix] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.XmlnsDictionary.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ prefix); void set(System::String ^ prefix, System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string with get, set" Usage="System.Windows.Markup.XmlnsDictionary.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefijo a partir del que se va a obtener o a establecer el espacio de nombres asociado.</param>
        <summary>Obtiene o establece el identificador URI de espacio de nombres XAML asociado al prefijo especificado.</summary>
        <value>Identificador URI de espacio de nombres XML correspondiente.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="prefix" /> es <see langword="null" />  
  
O bien 
El valor a establecer es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.XmlnsDictionary.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.ICollection" Usage="System.Windows.Markup.XmlnsDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de todas las claves de <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</summary>
        <value>Colección de todas las claves del diccionario.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="member this.LookupNamespace : string -&gt; string" Usage="xmlnsDictionary.LookupNamespace prefix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Prefijo de espacio de nombres XAML que se va a buscar.</param>
        <summary>Devuelve el identificador URI de espacio de nombres XAML correspondiente al prefijo de espacio de nombres XML especificado.</summary>
        <returns>Identificador URI de espacio de nombres XAML correspondiente al prefijo especificado si existe en este objeto <see cref="T:System.Windows.Markup.XmlnsDictionary" />; de lo contrario, devuelve <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="prefix" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LookupPrefix">
      <MemberSignature Language="C#" Value="public string LookupPrefix (string xmlNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string LookupPrefix(string xmlNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.LookupPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LookupPrefix (xmlNamespace As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ LookupPrefix(System::String ^ xmlNamespace);" />
      <MemberSignature Language="F#" Value="member this.LookupPrefix : string -&gt; string" Usage="xmlnsDictionary.LookupPrefix xmlNamespace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlNamespace">Identificador URI de espacio de nombres XAML que se va a buscar.</param>
        <summary>Devuelve el prefijo correspondiente al identificador URI de espacio de nombres XAML especificado.</summary>
        <returns>Prefijo XML correspondiente al espacio de nombres especificado; de lo contrario, devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se solicita el prefijo de espacio de nombres predeterminado, se devuelve una cadena vacía.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="xmlNamespace" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="PopScope">
      <MemberSignature Language="C#" Value="public void PopScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PopScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.PopScope" />
      <MemberSignature Language="VB.NET" Value="Public Sub PopScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PopScope();" />
      <MemberSignature Language="F#" Value="member this.PopScope : unit -&gt; unit" Usage="xmlnsDictionary.PopScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Extrae el ámbito de <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método solo si está implementando un <xref:System.Windows.Markup.ParserContext> que también funciona en un nivel de ámbito de elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Markup.XmlnsDictionary" /> es de tipo sealed.</exception>
      </Docs>
    </Member>
    <Member MemberName="PushScope">
      <MemberSignature Language="C#" Value="public void PushScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.PushScope" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushScope();" />
      <MemberSignature Language="F#" Value="member this.PushScope : unit -&gt; unit" Usage="xmlnsDictionary.PushScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserta el ámbito de <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método solo si está implementando un <xref:System.Windows.Markup.ParserContext> que también funciona en un nivel de ámbito de elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Markup.XmlnsDictionary" /> es de tipo sealed.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita del objeto <see cref="T:System.Windows.Markup.XmlnsDictionary" /> el elemento con la clave de prefijo especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (object prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (prefix As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="xmlnsDictionary.Remove prefix" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="prefix">Clave de prefijo que se va a quitar.</param>
        <summary>Quita del objeto <see cref="T:System.Windows.Markup.XmlnsDictionary" /> el elemento con la clave de prefijo especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación reenvía al método con seguridad de tipos <xref:System.Windows.Markup.XmlnsDictionary.Remove%28System.String%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Markup.XmlnsDictionary" /> es de tipo sealed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (prefix As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="member this.Remove : string -&gt; unit" Usage="xmlnsDictionary.Remove prefix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Clave de prefijo que se va a quitar.</param>
        <summary>Quita del objeto <see cref="T:System.Windows.Markup.XmlnsDictionary" /> el elemento con la clave de prefijo especificada.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Markup.XmlnsDictionary" /> es de tipo sealed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seal">
      <MemberSignature Language="C#" Value="public void Seal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.Seal" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seal ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seal();" />
      <MemberSignature Language="F#" Value="member this.Seal : unit -&gt; unit" Usage="xmlnsDictionary.Seal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bloquea el diccionario para que no se pueda modificar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esto debe hacerse antes de establecer el <xref:System.Windows.Markup.XmlnsDictionary> a una propiedad (normalmente en un <xref:System.Windows.Markup.ParserContext>). Al intentar modificar el diccionario después de la <xref:System.Windows.Markup.XmlnsDictionary> está sellado produce una <xref:System.InvalidOperationException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sealed">
      <MemberSignature Language="C#" Value="public bool Sealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Sealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.XmlnsDictionary.Sealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Sealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Sealed : bool" Usage="System.Windows.Markup.XmlnsDictionary.Sealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Windows.Markup.XmlnsDictionary" /> está sellado.</summary>
        <value>Es <see langword="true" /> si el diccionario está sellado; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es un alias para <xref:System.Windows.Markup.XmlnsDictionary.IsReadOnly%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.XmlnsDictionary.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Windows.Markup.XmlnsDictionary.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</summary>
        <value>Objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.System#Collections#IDictionary#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IDictionaryEnumerator Implements IDictionary.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionaryEnumerator ^ System.Collections.IDictionary.GetEnumerator() = System::Collections::IDictionary::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.Collections.IDictionary.GetEnumerator" />.</summary>
        <returns>Objeto <see cref="T:System.Collections.IDictionaryEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Markup.XmlnsDictionary.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XmlnsDictionary.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.Collections.IEnumerable.GetEnumerator" />.</summary>
        <returns>Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection Values" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.XmlnsDictionary.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.ICollection" Usage="System.Windows.Markup.XmlnsDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de todos los valores de <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</summary>
        <value>Colección de todos los valores de <see cref="T:System.Windows.Markup.XmlnsDictionary" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>