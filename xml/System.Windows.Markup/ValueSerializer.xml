<Type Name="ValueSerializer" FullName="System.Windows.Markup.ValueSerializer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="65a7488a614c640ae3cdd3cf8bb8adf47c3ea15d" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="64994683" /></Metadata><TypeSignature Language="C#" Value="public abstract class ValueSerializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ValueSerializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.ValueSerializer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ValueSerializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class ValueSerializer abstract" />
  <TypeSignature Language="F#" Value="type ValueSerializer = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Clase abstracta que define el comportamiento de conversión para la serialización de una representación de objeto.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La cadena que devuelve un convertidor de tipos para la serialización debe ser menor de pérdida y el convertidor siempre debe devolver la misma cadena de un valor determinado.  Si un convertidor de tipos (derivado de <xref:System.ComponentModel.TypeConverter>) no cumple estos requisitos en su `ConvertTo` implementaciones para la salida de la cadena, un personalizado <xref:System.Windows.Markup.ValueSerializer> debe declararse. Ya sea el <xref:System.Windows.Markup.ValueSerializer> debe cumplir los requisitos, o un valor null <xref:System.Windows.Markup.ValueSerializer> debe asociarse con el tipo. Un <xref:System.Windows.Markup.ValueSerializer> está asociado con un tipo aplicando el <xref:System.Windows.Markup.ValueSerializerAttribute> atributo.  
  
 Un valor null <xref:System.Windows.Markup.ValueSerializer> indica que se debe omitir el convertidor de tipos para convertir a cadena conversiones del gráfico de objetos.  
  
> [!IMPORTANT]
>  Implementación de <xref:System.Windows.Markup.ValueSerializer> debe evitar generar excepciones. Las excepciones producidas podrían finalizar la serialización.  
  
 <xref:System.Windows.Markup.IValueSerializerContext> para un <xref:System.Windows.Markup.ValueSerializer> y sus API es análogo a <xref:System.ComponentModel.ITypeDescriptorContext> para un <xref:System.ComponentModel.TypeConverter>. De hecho, <xref:System.Windows.Markup.IValueSerializerContext> hereda <xref:System.ComponentModel.ITypeDescriptorContext>. Cuando un <xref:System.Windows.Markup.ValueSerializer> se llama a la API de la clase derivada, el llamador (normalmente un proceso de serializador) pasa un contexto que puede proporcionar ciertos servicios. Debido a las instrucciones generales que un <xref:System.Windows.Markup.ValueSerializer> no deben producir excepciones. Error al devolver un servicio determinado desde el contexto también debe no produce ninguna excepción.  
  
 En versiones anteriores de .NET Framework, esta clase existía en el ensamblado específico de WPF WindowsBase. En [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Windows.Markup.ValueSerializer> está en el ensamblado System.Xaml. Para obtener más información, consulta [Types Migrated from WPF to System.Xaml](~/docs/framework/xaml-services/types-migrated-from-wpf-to-system-xaml.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlXmlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ValueSerializer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El cuerpo de este constructor está vacío; la <xref:System.Windows.Markup.ValueSerializer> clase no tiene ningún valor que requieren inicialización.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertFromString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertFromString (value As String, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a evaluar para la conversión.</param>
        <param name="context">Información contextual usada para la conversión.</param>
        <summary>Si se reemplaza en una clase derivada, determina si el elemento <see cref="T:System.String" /> especificado se puede convertir en una instancia del tipo que admite la implementación de <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns><see langword="true" /> si el valor se puede convertir; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación base siempre devuelve `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertToString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertToString (value As Object, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a evaluar para la conversión.</param>
        <param name="context">Información contextual usada para la conversión.</param>
        <summary>Si se reemplaza en una clase derivada, determina si el objeto especificado se puede convertir en una <see cref="T:System.String" />.</summary>
        <returns><see langword="true" /> si <paramref name="value" /> se puede convertir en <see cref="T:System.String" />; en caso contrario, <see langword="false." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación base siempre devuelve `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertFromString">
      <MemberSignature Language="C#" Value="public virtual object ConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertFromString (value As String, context As IValueSerializerContext) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj&#xA;override this.ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj" Usage="valueSerializer.ConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a convertir.</param>
        <param name="context">Información contextual usada para la conversión.</param>
        <summary>Si se reemplaza en una clase derivada, convierte una <see cref="T:System.String" /> en una instancia del tipo que la implementación de <see cref="T:System.Windows.Markup.ValueSerializer" /> admite.</summary>
        <returns>Nueva instancia del tipo que la implementación de <see cref="T:System.Windows.Markup.ValueSerializer" /> admite basada en el <paramref name="value" /> proporcionado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación base siempre produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> no se puede convertir.</exception>
        <block subset="none" type="overrides"><para>Evitar producir excepciones de las implementaciones. Vea <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ConvertToString">
      <MemberSignature Language="C#" Value="public virtual string ConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertToString (value As Object, context As IValueSerializerContext) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string&#xA;override this.ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string" Usage="valueSerializer.ConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a convertir en una cadena.</param>
        <param name="context">Información contextual usada para la conversión.</param>
        <summary>Si se reemplaza en una clase derivada, convierte el objeto especificado en una <see cref="T:System.String" />.</summary>
        <returns>Representación de cadena del objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación base siempre produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> no se puede convertir.</exception>
        <block subset="none" type="overrides"><para>Evitar producir excepciones de las implementaciones. Vea <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetConvertFromException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertFromException (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertFromException(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertFromException(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertFromException (value As Object) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertFromException(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetConvertFromException : obj -&gt; Exception" Usage="valueSerializer.GetConvertFromException value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que no se pudo convertir.</param>
        <summary>Devuelve una excepción que se debe iniciar cuando no se puede realizar una conversión.</summary>
        <returns>Objeto <see cref="T:System.Exception" /> de la excepción que se debe iniciar cuando no se puede realizar una conversión <see langword="ConvertFrom" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Real `throw` palabra clave no se invoca este método, por lo tanto, el uso típico es `throw GetConvertFromException` (con los parámetros proporcionados).  
  
 La excepción específica devuelto es <xref:System.InvalidOperationException>, con `value` pasa el mensaje de excepción. El patrón de uso es el mismo que las utilidades de excepción en <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConvertToException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertToException (object value, Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertToException(object value, class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertToException(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertToException (value As Object, destinationType As Type) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertToException(System::Object ^ value, Type ^ destinationType);" />
      <MemberSignature Language="F#" Value="member this.GetConvertToException : obj * Type -&gt; Exception" Usage="valueSerializer.GetConvertToException (value, destinationType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="destinationType" Type="System.Type" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que no se pudo convertir.</param>
        <param name="destinationType">Tipo que representa el tipo al que la conversión se intentaba convertir.</param>
        <summary>Devuelve una excepción que se debe iniciar cuando no se puede realizar una conversión.</summary>
        <returns>Objeto <see cref="T:System.Exception" /> de la excepción que se debe iniciar cuando no se puede realizar una conversión <see langword="ConvertTo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Real `throw` palabra clave no se invoca este método, por lo tanto, el uso típico es `throw GetConvertToException` (con `value` parámetro proporcionado).  
  
 La excepción específica devuelto es <xref:System.InvalidOperationException>, con `value` pasa el mensaje de excepción. El patrón de uso es el mismo que las utilidades de excepción en <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSerializerFor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene el <see cref="T:System.Windows.Markup.ValueSerializer" /> para un objeto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor descriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" Index="0" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="descriptor">El descriptor de propiedad CLR para la propiedad que se va a serializar.</param>
        <summary>Obtiene la clase <see cref="T:System.Windows.Markup.ValueSerializer" /> declarada para una propiedad, al pasar un descriptor de propiedad CLR para la propiedad.</summary>
        <returns>Serializador asociado a la propiedad especificada. Puede devolver <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Markup.ValueSerializer> para una propiedad o un tipo que se utiliza como el valor para una propiedad, se indica mediante la aplicación de la <xref:System.Windows.Markup.ValueSerializerAttribute> atributo en la declaración de propiedad o tipo. El <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> método es un método de utilidad que lee la información de sistema de tipos CLR y devuelve un nuevo <xref:System.Windows.Markup.ValueSerializer> clase se basa en el atributo si se encuentran en la propiedad, o si, a continuación, se encuentra en el tipo de propiedad. `null` se podría devolver si no existiera el serializador. `null` También se podría devolver si se atribuye deliberadamente un tipo o una propiedad con un valor null <xref:System.Windows.Markup.ValueSerializerAttribute>.  
  
 Otro modo que <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> admite devuelve interno `TypeConverterValueSerializer` (clase), que es un <xref:System.Windows.Markup.ValueSerializer> implementación que ajusta un <xref:System.ComponentModel.TypeConverter> y traduce el `Convert` métodos para `Convert*String` métodos (por ejemplo <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>se llama con la entrada de la <xref:System.String> escriba y se convierte en <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>. Esto se realiza solo en casos donde todos los elementos siguientes son verdaderas:  
  
-   Un <xref:System.ComponentModel.TypeConverterAttribute> se encuentra en la propiedad correspondiente o tipo de la propiedad relevante.  
  
-   El texto indicado <xref:System.ComponentModel.TypeConverter> puede crearse correctamente.  
  
-   El <xref:System.ComponentModel.TypeConverter> devuelve `true` para <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>, llamado que hacen referencia a la <xref:System.String> tipo.  
  
-   El <xref:System.ComponentModel.TypeConverter> devuelve `true` para <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>, llamado que hacen referencia a la <xref:System.String> tipo.  
  
-   El <xref:System.ComponentModel.TypeConverter> devuelve `true` para <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>, llamado que hacen referencia a la <xref:System.String> tipo.  
  
> [!NOTE]
>  Los siguientes son casos especiales: <xref:System.DateTime> tipos devuelven un <xref:System.Windows.Markup.DateTimeValueSerializer>; <xref:System.String> tipos devuelven un serializador interno pero funcional (`StringValueSerializer`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="descriptor" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="type">Tipo para el que se va a obtener <see cref="T:System.Windows.Markup.ValueSerializer" />.</param>
        <summary>Obtiene el <see cref="T:System.Windows.Markup.ValueSerializer" /> declarado para el tipo especificado.</summary>
        <returns>Serializador asociado al tipo especificado. Puede devolver <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Markup.ValueSerializer> para un tipo se indica aplicando el <xref:System.Windows.Markup.ValueSerializerAttribute> atributo en la declaración de tipos. El <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> método es un método de utilidad que lee la información de sistema de tipos CLR y devuelve un nuevo <xref:System.Windows.Markup.ValueSerializer> clase se basa en el atributo si se encuentra en el objeto `type`. `null` se podría devolver si no existiera el serializador. `null` También podría mostrarse si un tipo se atribuye deliberadamente con un valor null <xref:System.Windows.Markup.ValueSerializerAttribute>.  
  
 Otro modo que <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> admite devuelve interno `TypeConverterValueSerializer` (clase), que es un <xref:System.Windows.Markup.ValueSerializer> implementación que ajusta un <xref:System.ComponentModel.TypeConverter> y traduce el `Convert` métodos para `Convert*String` métodos (por ejemplo <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>se llama con la entrada de la <xref:System.String> escriba y se convierte en <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>. Esto se realiza solo en casos donde todos los elementos siguientes son verdaderas:  
  
-   Un <xref:System.ComponentModel.TypeConverterAttribute> se encuentra en `type`.  
  
-   El texto indicado <xref:System.ComponentModel.TypeConverter> puede crearse correctamente.  
  
-   El <xref:System.ComponentModel.TypeConverter> devuelve `true` para <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>, llamado que hacen referencia a la <xref:System.String> tipo.  
  
-   El <xref:System.ComponentModel.TypeConverter> devuelve `true` para <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>, llamado que hacen referencia a la <xref:System.String> tipo.  
  
-   El <xref:System.ComponentModel.TypeConverter> devuelve `true` para <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>, llamado que hacen referencia a la <xref:System.String> tipo.  
  
> [!NOTE]
>  Los siguientes son casos especiales: <xref:System.DateTime> tipos devuelven un <xref:System.Windows.Markup.DateTimeValueSerializer>; <xref:System.String> tipos devuelven un serializador interno pero funcional (`StringValueSerializer`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor, context As IValueSerializerContext) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (descriptor, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="descriptor">Descriptor de la propiedad que se va a serializar.</param>
        <param name="context">Información contextual usada para la conversión.</param>
        <summary>Obtiene la clase <see cref="T:System.Windows.Markup.ValueSerializer" /> declarada para la propiedad especificada, mediante el contexto especificado.</summary>
        <returns>Serializador asociado a la propiedad especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En lugar de confiar únicamente en los atributos notificados en el sistema de tipos CLR, esta sobrecarga se utiliza el `context` como un servicio y llama a la implementación del servicio <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>. El <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> implementación sería normalmente también dependen de la `descriptor`, pero podría implementar un comportamiento especial para ciertos contextos.  
  
 Este método se debe llamar cuando el llamador tiene un disponibles <xref:System.Windows.Markup.IValueSerializerContext> desde un servicio.  Esto garantizará que el valor correcto <xref:System.Windows.Markup.ValueSerializer> se devuelve para el contexto específico.  
  
 Si devuelve el contexto `null` desde su <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> para el elemento especificado `descriptor`, o si el contexto que especifique es `null`, a continuación, el comportamiento es idéntico a llamar a la <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.ComponentModel.PropertyDescriptor%29> sobrecargar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="descriptor" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (type, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="type">Tipo para el que se va a obtener <see cref="T:System.Windows.Markup.ValueSerializer" />.</param>
        <param name="context">Información contextual usada para la conversión.</param>
        <summary>Obtiene la clase <see cref="T:System.Windows.Markup.ValueSerializer" /> declarada para el tipo especificado, mediante el contexto especificado.</summary>
        <returns>Serializador asociado al tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En lugar de confiar únicamente en los atributos notificados en el sistema de tipos CLR, esta sobrecarga se utiliza el `context` como un servicio y llama a la implementación del servicio <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>. El <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> implementación sería normalmente también dependen de la `type`, pero podría implementar un comportamiento especial para ciertos contextos.  
  
 Este método se debe llamar cuando el llamador tiene un disponibles <xref:System.Windows.Markup.IValueSerializerContext> desde un servicio. Esto garantizará que el valor correcto <xref:System.Windows.Markup.ValueSerializer> se devuelve para el contexto específico.  
  
 Si devuelve el contexto `null` desde su <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> para el elemento especificado `type`, o si el contexto que especifique es `null`, a continuación, el comportamiento es idéntico a llamar a la <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.Type%29> sobrecargar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeReferences">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; TypeReferences (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; TypeReferences(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.TypeReferences(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TypeReferences (value As Object, context As IValueSerializerContext) As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ TypeReferences(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;&#xA;override this.TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;" Usage="valueSerializer.TypeReferences (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se serializa.</param>
        <param name="context">Información contextual usada para la conversión.</param>
        <summary>Obtiene una enumeración de los tipos a los que <see cref="T:System.Windows.Markup.ValueSerializer" /> hace referencia.</summary>
        <returns>Tipos convertidos por este serializador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los tipos de un <xref:System.Windows.Markup.ValueSerializer> convierte debe incluirse en la enumeración devuelta.  Esto permite que un serializador para asegurarse de que un deserializador tiene suficiente información sobre los tipos que convierte este serializador.  
  
 Invalidación de este método es un escenario avanzado. Invalidar solo debería ser necesario si va a implementar un sistema donde CLR del sistema tipoDePropietario propiedad relaciones entre tipos disponibles para un contexto de esquema XAML no notifican suficiente información.  
  
## <a name="wpf-usage-notes"></a>Notas de uso WPF  
 El [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propiedades implementa un serializador de valor interno que invalida <xref:System.Windows.Markup.ValueSerializer.TypeReferences%2A> porque una propiedad de dependencia tiene un concepto que puede haber agregado propietarios. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] las expresiones también tienen control interno especial.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>