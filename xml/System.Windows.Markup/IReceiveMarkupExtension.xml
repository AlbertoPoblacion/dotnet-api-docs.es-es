<Type Name="IReceiveMarkupExtension" FullName="System.Windows.Markup.IReceiveMarkupExtension">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6fb09fe5cc8a4724ed66485bbee00bd70974cc2d" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37560033" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IReceiveMarkupExtension" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IReceiveMarkupExtension" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.IReceiveMarkupExtension" />
  <TypeSignature Language="VB.NET" Value="Public Interface IReceiveMarkupExtension" />
  <TypeSignature Language="C++ CLI" Value="public interface class IReceiveMarkupExtension" />
  <TypeSignature Language="F#" Value="type IReceiveMarkupExtension = interface" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Obsolete("IReceiveMarkupExtension has been deprecated. This interface is no longer in use.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides a mechanism whereby types can declare that they can receive an expression (or another class) from a markup extension, where the output is a different property type than the target property. Do not use for .NET Framework 4 implementations.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)], <xref:System.Windows.Markup.IReceiveMarkupExtension> fue una técnica específica para WPF para permitir tipos escribir un codepath diferente cada vez que cualquiera de sus miembros accesibles de XAML donde se establece como extensiones de marcado durante el análisis de XAML. En [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], esta interfaz está obsoleta y se reemplaza con una implementación de servicios XAML de .NET Framework para cómo las extensiones de marcado pueden recibir servicios o tipos pueden invocar la lógica de establecedor específica de extensión de marcado.  
  
 Para [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] implementaciones, si desean que los tipos realizar un procesamiento especial al establecer las propiedades mediante la extensión de marcado en lugar de por otros medios, los tipos se deben definir con <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute> atributos aplicados. El atributo especifica una devolución de llamada, que normalmente se define como un miembro privado del tipo.  
  
 En las implementaciones de infraestructura de clases de WPF, más casos donde <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute> es aplicar referencia un `ReceiveMarkupExtension` método que previamente implementó esta interfaz, pero ahora en su lugar use el contexto a través de la devolución de llamada.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.XamlSetMarkupExtensionAttribute" />
    <altmember cref="T:System.Windows.Markup.XamlSetMarkupExtensionEventArgs" />
  </Docs>
  <Members>
    <Member MemberName="ReceiveMarkupExtension">
      <MemberSignature Language="C#" Value="public void ReceiveMarkupExtension (string property, System.Windows.Markup.MarkupExtension markupExtension, IServiceProvider serviceProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReceiveMarkupExtension(string property, class System.Windows.Markup.MarkupExtension markupExtension, class System.IServiceProvider serviceProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.IReceiveMarkupExtension.ReceiveMarkupExtension(System.String,System.Windows.Markup.MarkupExtension,System.IServiceProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReceiveMarkupExtension(System::String ^ property, System::Windows::Markup::MarkupExtension ^ markupExtension, IServiceProvider ^ serviceProvider);" />
      <MemberSignature Language="F#" Value="abstract member ReceiveMarkupExtension : string * System.Windows.Markup.MarkupExtension * IServiceProvider -&gt; unit" Usage="iReceiveMarkupExtension.ReceiveMarkupExtension (property, markupExtension, serviceProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.String" />
        <Parameter Name="markupExtension" Type="System.Windows.Markup.MarkupExtension" />
        <Parameter Name="serviceProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="property">The name of the target property.</param>
        <param name="markupExtension">The markup extension instance of the incoming data.</param>
        <param name="serviceProvider">Can provide additional services that should be performed when processing the markup extension data for a property value.</param>
        <summary>Provides the handling for markup extensions that provide property values. Do not use for [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] implementations; see <see cref="T:System.Windows.Markup.IReceiveMarkupExtension" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>