<Type Name="IReceiveMarkupExtension" FullName="System.Windows.Markup.IReceiveMarkupExtension">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0d590f413cad5fd1e1bf753c645edf4ec35b2826" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30655399" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IReceiveMarkupExtension" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IReceiveMarkupExtension" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.IReceiveMarkupExtension" />
  <TypeSignature Language="VB.NET" Value="Public Interface IReceiveMarkupExtension" />
  <TypeSignature Language="C++ CLI" Value="public interface class IReceiveMarkupExtension" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Obsolete("IReceiveMarkupExtension has been deprecated. This interface is no longer in use.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona un mecanismo mediante el cual los tipos pueden declarar que pueden recibir una expresión (u otra clase) de una extensión de marcado, donde el resultado es un tipo de propiedad diferente que la propiedad de destino. No lo use para implementaciones de .NET Framework 4.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)], <xref:System.Windows.Markup.IReceiveMarkupExtension> fue una técnica específica de WPF para permitir tipos escribir una codepath diferente cada vez que cualquiera de sus miembros accesibles a XAML donde se establecen como extensiones de marcado durante el análisis de XAML. En [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], esta interfaz está obsoleta y se reemplaza con una implementación de servicios XAML de .NET Framework para cómo las extensiones de marcado pueden recibir servicios o tipos puedan invocar la lógica de establecedor específica de extensión de marcado.  
  
 Para [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] implementaciones, si desean que los tipos realizar un procesamiento especial al establecer las propiedades por extensión de marcado, en lugar de por otros medios, tipos deben definirse con <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute> atributos aplicados. El atributo especifica una devolución de llamada, que normalmente se define como un miembro privado del tipo.  
  
 En las implementaciones de infraestructura de las clases de WPF, más casos donde <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute> es aplicar referencia un `ReceiveMarkupExtension` método que previamente implementó esta interfaz, pero ahora en su lugar utilice contexto a través de la devolución de llamada.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.XamlSetMarkupExtensionAttribute" />
    <altmember cref="T:System.Windows.Markup.XamlSetMarkupExtensionEventArgs" />
  </Docs>
  <Members>
    <Member MemberName="ReceiveMarkupExtension">
      <MemberSignature Language="C#" Value="public void ReceiveMarkupExtension (string property, System.Windows.Markup.MarkupExtension markupExtension, IServiceProvider serviceProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReceiveMarkupExtension(string property, class System.Windows.Markup.MarkupExtension markupExtension, class System.IServiceProvider serviceProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.IReceiveMarkupExtension.ReceiveMarkupExtension(System.String,System.Windows.Markup.MarkupExtension,System.IServiceProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReceiveMarkupExtension(System::String ^ property, System::Windows::Markup::MarkupExtension ^ markupExtension, IServiceProvider ^ serviceProvider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.String" />
        <Parameter Name="markupExtension" Type="System.Windows.Markup.MarkupExtension" />
        <Parameter Name="serviceProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="property">Nombre de la propiedad de destino.</param>
        <param name="markupExtension">Instancia de la extensión de marcado de los datos entrantes.</param>
        <param name="serviceProvider">Puede proporcionar los servicios adicionales que deben realizarse al procesar los datos de extensión de marcado para un valor de propiedad.</param>
        <summary>Proporciona el control para las extensiones de marcado que proporcionan valores de propiedad. No lo use para las implementaciones de [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]; vea <see cref="T:System.Windows.Markup.IReceiveMarkupExtension" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>