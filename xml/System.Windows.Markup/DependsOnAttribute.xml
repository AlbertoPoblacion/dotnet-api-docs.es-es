<Type Name="DependsOnAttribute" FullName="System.Windows.Markup.DependsOnAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7a54265820b84732300967ef429bbd1b8b96d7b3" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30656259" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependsOnAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependsOnAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.DependsOnAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependsOnAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependsOnAttribute sealed : Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indica que la propiedad con atributos depende del valor de otra propiedad.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Markup.XamlWriter.Save%2A> método en <xref:System.Windows.Markup.XamlWriter> procesará la propiedad especificada antes de procesar la propiedad que este atributo está establecido en.  
  
 El `name` valor que se aplica a este atributo debe ser el nombre no calificado simple de una propiedad que exista en el mismo tipo. No puede especificar las propiedades adjuntas como dependientes.  
  
 Al aplicar este atributo, se debe tener cuidado para evitar dependencias circulares.  Las dependencias circulares solo se detectan cuando todas las propiedades en el ciclo se han escrito e incluso así el comportamiento es no determinista.  
  
 Este atributo se aplica a una definición de propiedad garantiza que las propiedades dependientes se procesan primero en la escritura de objeto XAML. Forma parte de las reglas generales de marcado XAML que los valores de atributo aplicados para un objeto creado deben ser capaz de procesar en cualquier orden. Usos de <xref:System.Windows.Markup.DependsOnAttribute> especifican los casos excepcionales de propiedades en tipos donde se debe seguir un orden concreto de análisis para la creación de objeto válido.  
  
 En versiones anteriores de .NET Framework, esta clase existía en el ensamblado específico de WPF WindowsBase. En [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Windows.Markup.DependsOnAttribute> en el ensamblado System.Xaml. Para obtener más información, consulte [tipos migrados de WPF a System.Xaml](~/docs/framework/xaml-services/types-migrated-from-wpf-to-system-xaml.md).  
  
## <a name="wpf-usage-notes"></a>Notas de uso de WPF  
 El <xref:System.Windows.Setter.Value%2A> propiedad en el <xref:System.Windows.Setter> clase es un ejemplo de una propiedad en WPF donde el <xref:System.Windows.Markup.DependsOnAttribute> se aplica el atributo.  <xref:System.Windows.Setter.Value%2A> depende de <xref:System.Windows.Setter.Property%2A> y <xref:System.Windows.Setter.TargetName%2A> que no se procesa en primer lugar, en caso contrario, hay ninguna manera de saber qué tipo se supone que se crean para los casos de convertidor de valor.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependsOnAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.DependsOnAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependsOnAttribute(System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">La propiedad de la que depende la propiedad asociada a este elemento <see cref="T:System.Windows.Markup.DependsOnAttribute" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Markup.DependsOnAttribute" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.DependsOnAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de la propiedad relacionada que se declara en este atributo <see cref="T:System.Windows.Markup.DependsOnAttribute" />.</summary>
        <value>Nombre de la propiedad relacionada.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeId">
      <MemberSignature Language="C#" Value="public override object TypeId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object TypeId" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.DependsOnAttribute.TypeId" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeId As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ TypeId { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un identificador único para esta clase <see cref="T:System.Windows.Markup.DependsOnAttribute" />.</summary>
        <value>Identificador único.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un valor generado que usa un comportamiento de invalidación con el fin de permitir que varios atributos con el mismo <xref:System.Windows.Markup.DependsOnAttribute.Name%2A> que se aplicará. Siempre y cuando las dependencias no son circulares o ambiguas, varias <xref:System.Windows.Markup.DependsOnAttribute> se admiten referencias en el mismo nombre de propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>