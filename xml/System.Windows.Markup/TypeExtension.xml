<Type Name="TypeExtension" FullName="System.Windows.Markup.TypeExtension">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="61ac1224d62662355e58bc4a47a46fdf9e214201" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30658129" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TypeExtension : System.Windows.Markup.MarkupExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TypeExtension extends System.Windows.Markup.MarkupExtension" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.TypeExtension" />
  <TypeSignature Language="VB.NET" Value="Public Class TypeExtension&#xA;Inherits MarkupExtension" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeExtension : System::Windows::Markup::MarkupExtension" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Markup.MarkupExtension</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Markup.TypeExtensionConverter))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.MarkupExtensionReturnType(typeof(System.Type))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementa una extensión de marcado que devuelve un objeto <see cref="T:System.Type" /> basándose en una entrada de cadena.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] información de uso, consulte [extensión de marcado x: Type](~/docs/framework/xaml-services/x-type-markup-extension.md).  
  
> [!NOTE]
>  La `{x:Type}` funcionalidad suele ser para la invocación de código de usuario desde el marcado. Para el código que está implementando la compatibilidad con XAML, los servicios de resolución de tipo proceden de <xref:System.Windows.Markup.IXamlTypeResolver> y están relacionadas con la implementación de la acción contexto de esquema XAML. No intente hacer referencia a <xref:System.Windows.Markup.TypeExtension.ProvideValue%2A> como sustituto de un <xref:System.Windows.Markup.IXamlTypeResolver> proveedor de servicios, el contexto se pasa podría no ser válido para una resolución de tipos y se producirá un error si intenta llamar sin servicios válidos.  
  
## <a name="wpf-usage-notes"></a>Notas de uso de WPF  
 Las referencias de tipos se usan habitualmente para áreas de características de estilo, plantilla y enlace de datos de [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], cuando se hace referencia a estas características de XAML.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Markup.TypeExtension" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TypeExtension ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.TypeExtension.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TypeExtension();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Markup.TypeExtension" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TypeExtension (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.TypeExtension.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (typeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TypeExtension(System::String ^ typeName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Cadena que identifica el tipo al que se va a hacer referencia. Esta cadena usa el formato <c>prefix:className</c>. <c>prefix</c> es el prefijo de asignación de un espacio de nombres XAML y solo es necesario para hacer referencia a tipos que no están asignados al espacio de nombres XAML predeterminado.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Markup.TypeExtension" />, inicializando el valor de <see cref="P:System.Windows.Markup.TypeExtension.TypeName" /> basado en la cadena de <paramref name="typeName" /> proporcionada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor no se evalúa cuando se establece en el constructor. Si el valor no es `null`, se aceptarán inicialmente el valor. El análisis y evaluación del valor real se aplaza hasta que <xref:System.Windows.Markup.TypeExtension.ProvideValue%2A> se llama en esta extensión, cuando se analiza XAML y con contextos de servicio disponibles activos. En este momento la `typeName` se espera que puede resolver como un tipo dentro de un contexto de esquema XAML y ese tipo se devuelven.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Se intenta especificar <paramref name="typeName" /> como <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TypeExtension (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.TypeExtension.#ctor(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TypeExtension(Type ^ type);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Tipo que va a ser representado por <see cref="T:System.Windows.Markup.TypeExtension" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Markup.TypeExtension" />, declarando directamente el tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un método auxiliar para los usos de código de tiempo de ejecución de <xref:System.Windows.Markup.TypeExtension> y no forma parte del modelo de implementación normal para una extensión de marcado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ProvideValue">
      <MemberSignature Language="C#" Value="public override object ProvideValue (IServiceProvider serviceProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object ProvideValue(class System.IServiceProvider serviceProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.TypeExtension.ProvideValue(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ProvideValue (serviceProvider As IServiceProvider) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ ProvideValue(IServiceProvider ^ serviceProvider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="serviceProvider">Objeto que puede ofrecer servicios para la extensión de marcado. Se espera que el proveedor proporcione un servicio para <see cref="T:System.Windows.Markup.IXamlTypeResolver" />.</param>
        <summary>Devuelve un objeto que se debe establecer en la propiedad donde se aplique esta extensión. Para <see cref="T:System.Windows.Markup.TypeExtension" />, es el valor de <see cref="T:System.Type" /> que se evalúa para el nombre de tipo solicitado.</summary>
        <returns>
          <see cref="T:System.Type" /> que se va a establecer en la propiedad donde se aplica la extensión.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede pasar `null` para `serviceProvider`, pero solo si este <xref:System.Windows.Markup.TypeExtension> se ha establecido el valor de instancia con un tipo real inicial en el constructor en lugar de un `typeName`. En caso contrario, esta implementación de extensión de marcado se basa en los servicios basados en el pasado `serviceProvider`. No debe ser `null`. El `serviceProvider` se espera que proporcione un servicio para <xref:System.Windows.Markup.IXamlTypeResolver>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          El valor de <paramref name="member" /> para la extensión es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Alguna parte de la cadena <paramref name="typeName" /> no se analizó correctamente.  
  
 O bien  
  
 <paramref name="serviceProvider" /> no proporcionó un servicio para <see cref="T:System.Windows.Markup.IXamlTypeResolver" />  
  
 O bien  
  
 El valor <paramref name="typeName" /> no se resolvió como un tipo.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="serviceProvider" /> es <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public Type Type { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.TypeExtension.Type" />
      <MemberSignature Language="VB.NET" Value="Public Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ Type { Type ^ get(); void set(Type ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.ConstructorArgument("type")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la información de tipo de esta extensión.</summary>
        <value>Tipo establecido. En tiempo de ejecución, puede ser <see langword="null" /> para obtener acceso, pero no puede estar establecido en <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A menos que esta instancia se creara deliberadamente con el <xref:System.Windows.Markup.TypeExtension.%23ctor%28System.Type%29> constructor de firma, este valor será `null`. Esta propiedad no se puede restablecer cuando <xref:System.Windows.Markup.TypeExtension.ProvideValue%2A> se llama. Si desea que el tipo auténtico siempre debe llamar a <xref:System.Windows.Markup.TypeExtension.ProvideValue%2A> en lugar de comprobar esta propiedad.  
  
 Esta propiedad es configurable mediante reglas normales con respecto al uso de la extensión de marcado. Sin embargo, si va a configurar con un <xref:System.Type>, a continuación, el propósito de esta extensión de marcado es irrelevante, porque el mismo <xref:System.Type> se devuelve desde un <xref:System.Windows.Markup.TypeExtension.ProvideValue%2A> llamar a.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Se ha intentado establecer en <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeName">
      <MemberSignature Language="C#" Value="public string TypeName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TypeName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.TypeExtension.TypeName" />
      <MemberSignature Language="VB.NET" Value="Public Property TypeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TypeName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del tipo representado por esta extensión de marcado.</summary>
        <value>Cadena que identifica el tipo. Esta cadena usa el formato *prefijo*<c>:</c>*className*. (*prefijo* es el prefijo de asignación de un espacio de nombres XML y solo es necesario hacer referencia a tipos que no están asignados al espacio de nombres XML predeterminado para WPF ([!INCLUDE[TLA#tla_wpfxmlnsv1](~/includes/tlasharptla-wpfxmlnsv1-md.md)]).</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Se ha intentado establecer en <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>