<Type Name="XamlReader" FullName="System.Windows.Markup.XamlReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="576d952bef27932173a6f1898d9b6f595dd80d4a" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37502547" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlReader extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.XamlReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlReader" />
  <TypeSignature Language="F#" Value="type XamlReader = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Lee datos de entrada XAML y crea un gráfico de objetos usando el lector XAML predeterminado de WPF y un sistema de escritura de objetos XAML asociado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sincrónico <xref:System.Windows.Markup.XamlReader.Load%2A> métodos son estáticos, pero asincrónico <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> métodos no son estáticos y requieren una instancia de la <xref:System.Windows.Markup.XamlReader> clase se debe utilizar.  
  
 La salida de la `Load` métodos es un objeto único, que representa el objeto raíz de un gráfico de objeto o árbol de objetos creado. Objeto de gráficos que se crean mediante <xref:System.Windows.Markup.XamlReader> normalmente se agregan al árbol de objetos existentes de una aplicación de WPF en tiempo de ejecución. En caso contrario, el nuevo gráfico de objeto se considera desconectado para los propósitos del modelo de aplicación de WPF. Esto significa que no se representará y no puede que se tiene acceso utilizando cualquiera de las técnicas de árbol de objetos como aplicarse al árbol de objetos principales de la aplicación de WPF (por ejemplo, las API <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>). Para obtener más información sobre los conceptos del árbol de objetos, consulte [árboles en WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 <xref:System.Windows.Markup.XamlReader> admite los siguientes escenarios principales:  
  
-   **Generador de objetos/clonación**: sin mecanismos adicionales, un tipo de referencia por lo general no puede incluirse en más de una posición en un árbol de objetos WPF. (Ejemplos de mecanismos adicionales que ofrecen compatibilidad para compartir o volver a utilizar en WPF, los objetos que se basan en <xref:System.Windows.Freezable>, o se admiten para los objetos pueden compartirse con frecuencia, como <xref:System.Windows.Media.Brush> que se hace referencia como un elemento de un <xref:System.Windows.ResourceDictionary>.) Una manera de clonar un objeto que ya está en el árbol de objetos es serializar el objeto mediante <xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType>. A continuación, use la cadena serializada como entrada para una llamada a <xref:System.Windows.Markup.XamlReader.Load%2A>, con una secuencia o <xref:System.Xml.XmlReader> como intermediario.  
  
-   **Construir objetos según la información de just-in-time**: a menudo hay otras formas de entrada de enlace o proporcionado por el usuario cambia el estado de los objetos existentes. Por ejemplo podría usar el mismo valor para establecer más de una propiedad o usar el enlace de datos. Pero si tiene un escenario donde incluso el tipo de objeto para crear sólo es determinar en tiempo de ejecución o con la interacción del usuario, debe crear este tipo de objeto mediante la creación de una cadena para <xref:System.Windows.Markup.XamlReader.Load%2A> entrada suele ser una técnica útil.  
  
-   **Mediante las técnicas de recurso existentes**: el <xref:System.IO.Stream> tipo se usa con frecuencia en otros marcos o tecnologías para la transferencia de datos u objetos a través de límites de la aplicación o situaciones similares. A continuación, puede usar el <xref:System.IO.Stream> técnicas para almacenar u obtener datos en formato XAML que finalmente se usan para crear un objeto como parte de la aplicación.  
  
-   **Se ha corregido documentos:** su aplicación podría cargar documentos XPS descargados o locales para su inclusión en un árbol de objetos de aplicación de WPF y una interfaz de usuario.  
  
> [!NOTE]
>  A veces, esta documentación describe un gráfico de objetos, en lugar de un árbol de objetos. Una relación de elementos primarios y secundarios estricta no siempre existe en las relaciones de objeto de tiempo de ejecución de una aplicación WPF de tiempo de ejecución, por lo que un gráfico de objetos es una terminología más ampliamente aplicable. Sin embargo, dado que WPF también incluye dos conceptualización de árbol diferentes API (<xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>) la metáfora de árbol se sigue aplicando adecuadamente a la mayoría de los casos reales en WPF. Desde la perspectiva del lenguaje XAML, sin embargo, el gráfico de objetos suele ser la mejor manera de pensar acerca de cómo se crean los objetos fuera de XAML, porque el propio lenguaje XAML no especifica necesariamente metodologías de clase auxiliar que llevan más las relaciones en un Vuelva a la estructura de árbol.  
  
## <a name="code-access-security-loose-xaml-and-xamlreader"></a>Seguridad de acceso del código XAML flexible y XamlReader  
 XAML es un lenguaje de marcado que representa directamente la creación de instancias y la ejecución de objetos. Por consiguiente, los elementos creados en código XAML tienen la misma capacidad de interactuar con los recursos del sistema (por ejemplo, el acceso a la red y la E/S del sistema de archivos) que el código generado equivalente.  
  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] admite la [!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)] marco de seguridad [!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]. Esto significa que el contenido de [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] que se ejecuta en la zona de Internet tiene permisos de ejecución reducidos. "Pierden el XAML" (las páginas de XAML no compilado interpretan en tiempo de carga con un visor XAML) y [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] normalmente se ejecutan en esta zona de internet y use el mismo conjunto de permisos.  Sin embargo, XAML cargado en una aplicación de plena confianza tiene el mismo acceso a los recursos del sistema, como hace la aplicación de hospedaje. Para obtener más información, vea [Seguridad de confianza parcial de WPF](~/docs/framework/wpf/wpf-partial-trust-security.md).  
  
 Las implicaciones de estas instrucciones para <xref:System.Windows.Markup.XamlReader> es que el diseño de la aplicación debe realizar decisiones de confianza sobre el XAML que decide cargar. Si va a cargar el XAML que no sea de confianza, considere la posibilidad de implementar su propia técnica de espacio aislado para cargar el gráfico de objetos resultante.  
  
 <xref:System.Windows.Markup.XamlReader> También se puede llamar mediante código de confianza parcial. En este caso, la zona de seguridad de Internet se aplica para la seguridad de acceso del código. Si nada en el XAML cargado es válido para la zona de seguridad de Internet, se produce una excepción de análisis XAML. En la aplicación XBAP y otros casos que son de confianza parcial en el nivel de plataforma, donde <xref:System.Windows.Markup.XamlReader> forma parte de la ejecución, obtendrá el mismo comportamiento de excepción al igual que con las llamadas de confianza parcial explícita.  
  
## <a name="wpf-xaml-xaml-readerswriters-and-xaml-language-versioning"></a>Control de versiones de lenguaje XAML, lectores/escritores XAML y XAML de WPF  
 [!INCLUDE[xaml2009](~/includes/xaml2009-md.md)] incluye características de lenguaje como y. Puede usar firmas de `Load` o `Parse` para cargar XAML que usa estas características. Sin embargo, no se admiten las características del lenguaje para XAML que deba estar compilado por marcado (como XAML para el **página** acción en una aplicación WPF o cualquier XAML que implica la tarea de compilación de marcado en las acciones de compilación de compilación).  
  
 Tipos de WPF y la tecnología WPF en general admiten conceptos que se basan en el acceso a información interna de WPF. Por ejemplo, cómo WPF implementa las propiedades de dependencia se basa en las técnicas internas de búsqueda eficaz de miembro de tipo. Acceso a estos elementos internos se habilita mediante el XAML de lectura y escritura de las API proporcionadas en <xref:System.Windows.Markup.XamlWriter> y <xref:System.Windows.Markup.XamlReader> desde el <xref:System.Windows.Markup> espacio de nombres y el ensamblado PresentationFramework. Sin embargo, los lectores XAML de nivel inferior y los escritores XAML desde el ensamblado System.Xaml (clases basadas en <xref:System.Xaml.XamlReader?displayProperty=nameWithType>, <xref:System.Xaml.XamlWriter?displayProperty=nameWithType>) no tiene acceso a los aspectos internos WPF. No hay ninguna dependencia de System.Xaml a cualquier ensamblado específico de WPF. Sin acceso a los aspectos internos WPF, escritores y lectores de System.Xaml correctamente no se pueden cargar o guardar WPF todos los tipos o tipos basan en tipos WPF. En concreto, los lectores de System.Xaml y escritores no entienden conceptos tales como la propiedad de dependencia WPF de seguridad de almacén de propiedades y los detalles de cómo WPF usa estilos, diccionarios de recursos y plantillas. Por lo tanto, tiene que tomar una decisión:  
  
-   Si va a cargar tipos WPF o usa XAML en formato BAML de cualquier manera, utilice los lectores de PresentationFramework XAML y escritores XAML.  
  
-   Si no confía en los tipos WPF o el formulario BAML de XAML y no usa del otra tecnología específica lector XAML o implementación de sistema de escritura XAML por motivos que son específicos de ese marco de trabajo, utilice los lectores de System.Xaml XAML y escritores XAML.  
  
## <a name="systemxaml-backing-implementation-in-net-4"></a>Implementación en .NET 4 de respaldo de System.Xaml  
 <xref:System.Windows.Markup.XamlReader> es la superficie de API que se puede llamar para el analizador XAML de nivel de marco WPF. El mismo analizador XAML subyacente también realiza el XAML de tiempo de ejecución carga y el análisis para aplicaciones de WPF que tienen como destino [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] y [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)].  
  
 Si desea usar [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], la API externa es el mismo, pero las partes de la implementación se basan en el [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] implementación general de XAML en el ensamblado System.Xaml, que mejora muchos de los aspectos técnicos e informes de análisis de XAML. Destinatarios [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] necesariamente tipos definidos por el conlleva incluidos System.Xaml como una referencia y los detalles de implementación, como las excepciones notificadas pueden proceder de System.Xaml.  
  
## Examples  
 El ejemplo siguiente se convierte un <xref:System.Windows.Controls.Button> en una cadena con el <xref:System.Windows.Markup.XamlWriter> clase.  La cadena es, a continuación, volver a cargar en un <xref:System.Windows.Controls.Button> mediante estático <xref:System.Windows.Markup.XamlReader.Load%2A> método en el <xref:System.Windows.Markup.XamlReader> clase.  
  
 [!code-csharp[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.XamlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Markup.XamlReader" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="xamlReader.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anula la operación de carga asincrónica actual si hay alguna pendiente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.XamlReader.CancelAsync%2A> es una operación asincrónica; por lo tanto, algunos pueden cargarse antes de que se anula la operación.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWpfSchemaContext">
      <MemberSignature Language="C#" Value="public static System.Xaml.XamlSchemaContext GetWpfSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xaml.XamlSchemaContext GetWpfSchemaContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetWpfSchemaContext () As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xaml::XamlSchemaContext ^ GetWpfSchemaContext();" />
      <MemberSignature Language="F#" Value="static member GetWpfSchemaContext : unit -&gt; System.Xaml.XamlSchemaContext" Usage="System.Windows.Markup.XamlReader.GetWpfSchemaContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Xaml.XamlSchemaContext" /> que representa el valor de contexto de esquema de WPF para <see cref="T:System.Windows.Markup.XamlReader" />.</summary>
        <returns>Objeto <see cref="T:System.Xaml.XamlSchemaContext" /> que representa el valor de contexto de esquema de WPF para <see cref="T:System.Windows.Markup.XamlReader" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lee la entrada XAML y devuelve la raíz del árbol de objetos correspondiente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">El XAML que se va a cargar, con formato de secuencia.</param>
        <summary>Lee la entrada XAML del objeto <see cref="T:System.IO.Stream" /> especificado y devuelve un objeto <see cref="T:System.Object" /> que es la raíz del árbol de objetos correspondiente.</summary>
        <returns>Objeto en la raíz del árbol de objetos creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se guarda un <xref:System.Windows.Controls.Button> en un <xref:System.IO.MemoryStream> utilizando la <xref:System.Windows.Markup.XamlWriter> clase. La secuencia es, a continuación, volver a cargar en un <xref:System.Windows.Controls.Button> mediante estático <xref:System.Windows.Markup.XamlReader.Load%2A> método en el <xref:System.Windows.Markup.XamlReader> clase.  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xaml.XamlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xaml.XamlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XamlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xaml::XamlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xaml.XamlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xaml.XamlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Un objeto <see cref="T:System.Xaml.XamlReader" />. Se espera que se inicialice con el XAML de entrada.</param>
        <summary>Lee la entrada XAML a través del objeto <see cref="T:System.Xaml.XamlReader" /> especificado y devuelve un objeto que es la raíz del árbol de objetos correspondiente.</summary>
        <returns>Objeto que es la raíz del árbol de objetos creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La entrada <xref:System.Xaml.XamlReader> puede ser <xref:System.Windows.Baml2006.Baml2006Reader>. Se trata de cómo puede cargar BAML en tiempo de ejecución, o con fines de herramienta de localización.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> que ya ha cargado la entrada XAML con formato XML.</param>
        <summary>Lee la entrada XAML del objeto <see cref="T:System.Xml.XmlReader" /> especificado y devuelve un objeto que es la raíz del árbol de objetos correspondiente.</summary>
        <returns>Objeto que es la raíz del árbol de objetos creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se convierte un <xref:System.Windows.Controls.Button> en una cadena con el <xref:System.Windows.Markup.XamlWriter> clase.  La cadena es, a continuación, volver a cargar en un <xref:System.Windows.Controls.Button> mediante estático <xref:System.Windows.Markup.XamlReader.Load%2A> método en el <xref:System.Windows.Markup.XamlReader> clase.  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream">Secuencia que contiene la entrada XAML que se va a cargar.</param>
        <param name="parserContext">Información de contexto utilizada por el analizador.</param>
        <summary>Lee la entrada XAML del objeto <see cref="T:System.IO.Stream" /> especificado y devuelve un objeto que es la raíz del árbol de objetos correspondiente.</summary>
        <returns>Objeto que es la raíz del árbol de objetos creado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> es <see langword="null" />.  -o bien- <paramref name="parserContext" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadAsync">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lee el marcado XAML y devuelve un objeto que corresponde a la raíz del marcado especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream -&gt; obj" Usage="xamlReader.LoadAsync stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Secuencia que contiene la entrada XAML que se va a cargar.</param>
        <summary>Lee la entrada XAML del objeto <see cref="T:System.IO.Stream" /> especificado y devuelve la raíz del árbol de objetos correspondiente.</summary>
        <returns>Objeto que es la raíz del árbol de objetos creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una operación de carga asincrónica de XAML inicialmente devolverá un objeto que es simplemente el objeto raíz. De forma asincrónica, continúa el análisis de XAML, a continuación, y los objetos secundarios se rellenan en el directorio raíz. Esto difiere de la típica XAML WPF comportamiento y su interacción con los conceptos WPF de duración del objeto de procesamiento. En la interacción típica (no asincrónica), todas las propiedades de un objeto incluidas todas las colecciones secundarias se rellenan antes de devolver un elemento y notificarlo como cargado. Ese comportamiento equivale a una metodología de abajo a arriba para crear el árbol donde el objeto raíz es el último objeto esté disponible.  
  
 Es normalmente el objeto devuelto a alguna ubicación en el árbol de objetos de la aplicación WPF, con el conocimiento que el contenido todavía se podrían estar rellenando y podrían hacer que las actualizaciones de diseño incremental si todo el contenido se expone como parte de la interfaz de usuario. Por este motivo es típico para aislar o virtualizar los objetos cargados de forma asincrónica de XAML y utilizar la lógica específica de la aplicación o el estado de la aplicación para notificar cuando <xref:System.Windows.Markup.XamlReader.LoadCompleted> se controla.  
  
 En orden para <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> para cargar el XAML de entrada de forma asincrónica, el elemento raíz en el XAML de entrada debe contener el atributo y valor `x:SynchronousMode="Async"`. El valor se distinguen mayúsculas de minúsculas. Si la raíz de entrada de XAML no contiene `x:SynchronousMode="Async"`, se produce ninguna excepción y la llamada se procesa como una carga sincrónica (vea <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>).  
  
 Una única operación de carga asincrónica por cada instancia de la <xref:System.Windows.Markup.XamlReader> clase se puede realizar a la vez.  Si se intenta realizar más de una operación asincrónica en la misma instancia de la <xref:System.Windows.Markup.XamlReader> clase un <xref:System.InvalidOperationException> se produce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se realizan simultáneamente varias operaciones de carga con el mismo objeto <see cref="T:System.Windows.Markup.XamlReader" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadAsync (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.Xml.XmlReader -&gt; obj" Usage="xamlReader.LoadAsync reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> existente que ya ha cargado o leído la entrada XAML.</param>
        <summary>Lee la entrada XAML del objeto <see cref="T:System.Xml.XmlReader" /> especificado y devuelve la raíz del árbol de objetos correspondiente.</summary>
        <returns>Raíz del árbol de objetos creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una operación de carga asincrónica de XAML inicialmente devolverá un objeto que es simplemente el objeto raíz. De forma asincrónica, continúa el análisis de XAML, a continuación, y los objetos secundarios se rellenan en el directorio raíz. Esto difiere de la típica XAML WPF comportamiento y su interacción con los conceptos WPF de duración del objeto de procesamiento. En la interacción típica (no asincrónica), todas las propiedades de un objeto incluidas todas las colecciones secundarias se rellenan antes de devolver un elemento y notificarlo como cargado. Ese comportamiento equivale a una metodología de abajo a arriba para crear el árbol donde el objeto raíz es el último objeto esté disponible.  
  
 Normalmente, podría asignar el objeto devuelto desde <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> a alguna ubicación en el árbol de objetos de la aplicación, con el conocimiento que el contenido es posible que todavía se rellenando y podría hacer que las actualizaciones de diseño incremental si todo el contenido se expone como parte de la INTERFAZ DE USUARIO. Por este motivo es típico para aislar o virtualizar los objetos cargados de forma asincrónica de XAML y utilizar la lógica específica de la aplicación o el estado de la aplicación para notificar cuando <xref:System.Windows.Markup.XamlReader.LoadCompleted> se controla.  
  
 En orden para <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> para cargar el XAML de entrada de forma asincrónica, el elemento raíz en el marcado XAML debe contener el atributo y valor `x:SynchronousMode="Async"`. El valor se distinguen mayúsculas de minúsculas. Si la raíz del marcado XAML no contiene `x:SynchronousMode="Async"`, se produce ninguna excepción y la llamada en su lugar, se procesa como una carga sincrónica (vea <xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>).  
  
 Una única operación de carga asincrónica por cada instancia de la <xref:System.Windows.Markup.XamlReader> clase se puede realizar a la vez.  Si se intenta realizar más de una operación asincrónica en la misma instancia de la <xref:System.Windows.Markup.XamlReader> clase un <xref:System.InvalidOperationException> se produce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se realizan simultáneamente varias operaciones de carga con el mismo objeto <see cref="T:System.Windows.Markup.XamlReader" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="xamlReader.LoadAsync (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream">Secuencia que contiene la entrada XAML que se va a cargar.</param>
        <param name="parserContext">Información de contexto utilizada por el analizador.</param>
        <summary>Lee la entrada XAML del objeto <see cref="T:System.IO.Stream" /> especificado y devuelve la raíz del árbol de objetos correspondiente.</summary>
        <returns>Raíz del árbol de objetos creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una operación de carga asincrónica de XAML inicialmente devolverá un objeto que es simplemente el objeto raíz. De forma asincrónica, continúa el análisis de XAML, a continuación, y los objetos secundarios se rellenan en el directorio raíz. Esto difiere de la típica XAML WPF comportamiento y su interacción con los conceptos WPF de duración del objeto de procesamiento. En la interacción típica (no asincrónica), todas las propiedades de un objeto incluidas todas las colecciones secundarias se rellenan antes de devolver un elemento y notificarlo como cargado. Ese comportamiento equivale a una metodología de abajo a arriba para crear el árbol donde el objeto raíz es el último objeto esté disponible.  
  
 Es normalmente el objeto devuelto a alguna ubicación en el árbol de objetos de la aplicación, con el conocimiento que el contenido todavía se podrían estar rellenando y podrían hacer que las actualizaciones de diseño incremental si todo el contenido se expone como parte de la interfaz de usuario. Por este motivo es típico para aislar o virtualizar los objetos cargados de forma asincrónica de XAML y utilizar la lógica específica de la aplicación o el estado de la aplicación para notificar cuando <xref:System.Windows.Markup.XamlReader.LoadCompleted> se controla.  
  
 En orden para <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> para cargar asincrónicamente el marcado, el elemento raíz en el marcado XAML debe contener el atributo y valor `x:SynchronousMode="Async"`. El valor se distinguen mayúsculas de minúsculas. Si la raíz del marcado XAML no contiene `x:SynchronousMode="Async"`, se produce ninguna excepción y la llamada se procesa como una carga sincrónica (vea <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>).  
  
 Una única operación de carga asincrónica por cada instancia de la <xref:System.Windows.Markup.XamlReader> clase se puede realizar a la vez.  Si se intenta realizar más de una operación asincrónica en la misma instancia de la <xref:System.Windows.Markup.XamlReader> clase un <xref:System.InvalidOperationException> se produce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se realizan simultáneamente varias operaciones de carga con el mismo objeto <see cref="T:System.Windows.Markup.XamlReader" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AsyncCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AsyncCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Markup.XamlReader.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As AsyncCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AsyncCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " Usage="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AsyncCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se completa una operación de carga asincrónica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.XamlReader.LoadCompleted> También se genera cuando se anula una operación de carga asincrónica.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.AsyncCompletedEventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lee el marcado de la cadena de texto especificada y devuelve un objeto que corresponde a la raíz del marcado especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (xamlText As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse xamlText" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlText">XAML de entrada, como cadena de texto única.</param>
        <summary>Lee la entrada XAML de la cadena de texto especificada y devuelve un objeto que corresponde a la raíz del marcado especificado.</summary>
        <returns>Raíz del árbol de objetos creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación llama <xref:System.Windows.Markup.XamlReader.Load%2A> internamente después de crear una secuencia de la cadena. Consulte <xref:System.Windows.Markup.XamlReader.Load%2A> para obtener más información, como las posibles excepciones.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse (xamlText, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="xamlText">XAML de entrada, como cadena de texto única.</param>
        <param name="parserContext">Información de contexto utilizada por el analizador.</param>
        <summary>Lee el marcado XAML de la cadena de texto especificada (usando el contexto <see cref="T:System.Windows.Markup.ParserContext" /> especificado) y devuelve un objeto que corresponde a la raíz del marcado especificado.</summary>
        <returns>Raíz del árbol de objetos creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación llama <xref:System.Windows.Markup.XamlReader.Load%2A> internamente después de crear una secuencia de la cadena. Consulte <xref:System.Windows.Markup.XamlReader.Load%2A> para obtener más información, como las posibles excepciones.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>