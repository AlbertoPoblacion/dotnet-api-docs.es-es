<Type Name="RouteCollection" FullName="System.Web.Routing.RouteCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="71c8f23d2a321f2619c22cefbc0568682f299389" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51917066" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RouteCollection : System.Collections.ObjectModel.Collection&lt;System.Web.Routing.RouteBase&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RouteCollection extends System.Collections.ObjectModel.Collection`1&lt;class System.Web.Routing.RouteBase&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Web.Routing.RouteCollection" />
  <TypeSignature Language="VB.NET" Value="Public Class RouteCollection&#xA;Inherits Collection(Of RouteBase)" />
  <TypeSignature Language="C++ CLI" Value="public ref class RouteCollection : System::Collections::ObjectModel::Collection&lt;System::Web::Routing::RouteBase ^&gt;" />
  <TypeSignature Language="F#" Value="type RouteCollection = class&#xA;    inherit Collection&lt;RouteBase&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Web.Routing</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;System.Web.Routing.RouteBase&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="!0">System.Web.Routing.RouteBase</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Web.Routing, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona una colección de rutas para el enrutamiento de ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.Routing.RouteCollection> clase proporciona métodos que permiten administrar una colección de objetos que derivan de la <xref:System.Web.Routing.RouteBase> clase.  
  
 Normalmente, usará el `static` <xref:System.Web.Routing.RouteTable.Routes%2A> propiedad de la <xref:System.Web.Routing.RouteTable> clase para recuperar un <xref:System.Web.Routing.RouteCollection> objeto. El <xref:System.Web.Routing.RouteTable.Routes%2A> propiedad almacena todas las rutas para una aplicación ASP.NET. Enrutamiento de ASP.NET recorre en iteración las rutas en el <xref:System.Web.Routing.RouteTable.Routes%2A> propiedad para buscar la ruta que coincide con una dirección URL.  
  
 Para construir una dirección URL, llame a la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> método y pasar una colección de valores. El <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> método busca la primera ruta con parámetros que coinciden con los valores que pasa y devuelve un <xref:System.Web.Routing.VirtualPathData> objeto que contiene información sobre la ruta coincidente. Recuperar la dirección URL a través de la <xref:System.Web.Routing.VirtualPathData.VirtualPath%2A> propiedad de la <xref:System.Web.Routing.VirtualPathData> objeto.  
  
 Puede agregar una ruta con un nombre o sin nombre. Incluya un nombre permite distinguir entre rutas similares cuando se construyen las direcciones URL. Si no especifica un nombre, el enrutamiento de ASP.NET utiliza la primera ruta coincidente en la colección para construir una dirección URL.  
  
 Cuando se agrega una ruta sin nombre para el <xref:System.Web.Routing.RouteCollection> de objeto, no se puede agregar una ruta que ya está en la colección. Cuando se agrega una ruta con nombre, no puede usar un nombre que ya se identifica una ruta en la colección.  
  
 Usa el <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> método y el <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> método para asegurarse de que interactúa con la colección sin conflictos de otros procesos.  
  
 Para obtener más información sobre cómo agregar una ruta a una colección de rutas, consulte [enrutamiento de ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Web.Routing.RouteCollection" />.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RouteCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RouteCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Web.Routing.RouteCollection" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RouteCollection (System.Web.Hosting.VirtualPathProvider virtualPathProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.Hosting.VirtualPathProvider virtualPathProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.#ctor(System.Web.Hosting.VirtualPathProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RouteCollection(System::Web::Hosting::VirtualPathProvider ^ virtualPathProvider);" />
      <MemberSignature Language="F#" Value="new System.Web.Routing.RouteCollection : System.Web.Hosting.VirtualPathProvider -&gt; System.Web.Routing.RouteCollection" Usage="new System.Web.Routing.RouteCollection virtualPathProvider" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="virtualPathProvider" Type="System.Web.Hosting.VirtualPathProvider" />
      </Parameters>
      <Docs>
        <param name="virtualPathProvider">Proveedor para recuperar recursos de un sistema de archivos virtual.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Web.Routing.RouteCollection" /> mediante el proveedor de ruta de acceso virtual especificado.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (string name, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(string name, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Add(System.String,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (name As String, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::String ^ name, System::Web::Routing::RouteBase ^ item);" />
      <MemberSignature Language="F#" Value="override this.Add : string * System.Web.Routing.RouteBase -&gt; unit" Usage="routeCollection.Add (name, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="name">Valor que identifica la ruta. El valor puede ser <see langword="null" /> o una cadena vacía.</param>
        <param name="item">Ruta que se va agregar al final de la colección.</param>
        <summary>Agrega una ruta al final del objeto <see cref="T:System.Web.Routing.RouteCollection" /> y asigna el nombre especificado a la ruta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.Routing.RouteCollection.Add%2A> método le permite definir un nombre para una ruta al agregarlo a la colección de rutas. Al definir un nombre para la ruta, puede especificar una ruta determinada que se usa cuando se usa el enrutamiento para construir una dirección URL. Especificar una ruta concreta es importante cuando más de una ruta coincide con los valores que se pasan a la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> método. Si no especifica una ruta con nombre, el enrutamiento de ASP.NET usará la primera ruta de la colección que coincide con los valores. Para obtener más información, consulte [Cómo: construir las direcciones URL de las rutas](https://msdn.microsoft.com/library/1ffd4085-71f6-4822-be8f-f682ca638650).  
  
 Se puede usar solo una vez en un nombre de la <xref:System.Web.Routing.RouteCollection> objeto.  
  
 Si no tiene que especificar un nombre para la ruta, puede agregar la ruta mediante una llamada a la <xref:System.Collections.ObjectModel.Collection%601.Add%2A> método.  
  
 Use la <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> método y el <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> método para asegurarse de que interactúa con la colección sin conflictos de otros procesos.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo agregar una ruta a un <xref:System.Web.Routing.RouteCollection> de objeto y asígnele un nombre a la ruta.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#1)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="item" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> ya se usa en la colección.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AppendTrailingSlash">
      <MemberSignature Language="C#" Value="public bool AppendTrailingSlash { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AppendTrailingSlash" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.AppendTrailingSlash" />
      <MemberSignature Language="VB.NET" Value="Public Property AppendTrailingSlash As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AppendTrailingSlash { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AppendTrailingSlash : bool with get, set" Usage="System.Web.Routing.RouteCollection.AppendTrailingSlash" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se deben agregar barras diagonales cuando las rutas de acceso virtuales se normalizan.</summary>
        <value>
          <see langword="true" /> si se agregan barras diagonales finales; si no, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberSignature Language="F#" Value="override this.ClearItems : unit -&gt; unit" Usage="routeCollection.ClearItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los elementos del objeto <see cref="T:System.Web.Routing.RouteCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> método y el <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> método para asegurarse de que interactúa con la colección sin conflictos de otros procesos.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetReadLock">
      <MemberSignature Language="C#" Value="public IDisposable GetReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable GetReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReadLock () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ GetReadLock();" />
      <MemberSignature Language="F#" Value="member this.GetReadLock : unit -&gt; IDisposable" Usage="routeCollection.GetReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Proporciona un objeto para administrar la seguridad para subprocesos al recuperar un objeto de la colección.</summary>
        <returns>Objeto que administra la seguridad para subprocesos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Web.Routing.RouteCollection> objeto está disponible para varios procesos en la aplicación. Por lo tanto, si tiene que recuperar una ruta cuando se ejecuta la aplicación, use el <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> método con el fin de garantizar la seguridad para subprocesos. Al obtener un bloqueo de lectura en la colección de rutas, asegúrese de que no se modificará la colección mientras intenta recuperarlo.  
  
 El <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> método detiene el subproceso hasta que se puede adquirir el bloqueo. Si es un bloqueo de escritura en su lugar, el subproceso espera hasta que se complete la actualización y se libera el bloqueo de escritura. Se libera el bloqueo de lectura en la colección de rutas cuando el <xref:System.IDisposable> se desecha el objeto devuelto por este método.  
  
 Si no usas <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>, podría obtener un error mientras se está leyendo el <xref:System.Web.Routing.RouteCollection> colección. Por ejemplo, suponga que recorra en iteración los objetos en el <xref:System.Web.Routing.RouteCollection> colección leerlos, sin llamar a <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>. Mientras que se está realizando, podría llamar otro subproceso de otra solicitud <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> y agregue una ruta a la colección. El primer subproceso, a continuación, se producirá un error.  
  
 Hay dos escenarios en los que no es necesario llamar a <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>:  
  
-   Métodos públicos de la <xref:System.Web.Routing.RouteCollection> como clase <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A> y <xref:System.Web.Routing.RouteCollection.GetRouteData%2A> llamar <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> internamente. Por lo tanto, no es necesario llamar explícitamente a <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> cuando se llama a un método público de la <xref:System.Web.Routing.RouteCollection> clase para recuperar datos de la colección.  
  
-   Cuando la aplicación se está iniciando y todavía no está procesando solicitudes, como en el `Application_Start` controlador de eventos, sólo un subproceso se está ejecutando. Dado que no hay ningún otro subproceso que podría actualizar la colección mientras se está leyendo, no es necesario llamar a <xref:System.Web.Routing.RouteCollection.GetReadLock%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> método al recuperar una ruta mientras se ejecuta la aplicación. El `Using` instrucción garantiza que independientemente de lo que sucede en tiempo de ejecución cuando lee en la colección (si el código se completa con normalidad o se produce una excepción) el bloqueo se con seguridad publicará al final de la `Using` bloque de código.  
  
  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetRouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData GetRouteData (System.Web.HttpContextBase httpContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.RouteData GetRouteData(class System.Web.HttpContextBase httpContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetRouteData(System.Web.HttpContextBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteData (httpContext As HttpContextBase) As RouteData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::RouteData ^ GetRouteData(System::Web::HttpContextBase ^ httpContext);" />
      <MemberSignature Language="F#" Value="member this.GetRouteData : System.Web.HttpContextBase -&gt; System.Web.Routing.RouteData" Usage="routeCollection.GetRouteData httpContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="httpContext" Type="System.Web.HttpContextBase" />
      </Parameters>
      <Docs>
        <param name="httpContext">Objeto que encapsula la información sobre la solicitud HTTP.</param>
        <summary>Devuelve información sobre la ruta de la colección que coincide con los valores especificados.</summary>
        <returns>Objeto que contiene los valores de la definición de la ruta.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="context" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Web.HttpContextBase.Request" /> del objeto del parámetro <paramref name="context" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetVirtualPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve información sobre la ruta de acceso de la dirección URL que está asociada a la ruta.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetVirtualPath">
      <MemberSignature Language="C#" Value="public System.Web.Routing.VirtualPathData GetVirtualPath (System.Web.Routing.RequestContext requestContext, System.Web.Routing.RouteValueDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.VirtualPathData GetVirtualPath(class System.Web.Routing.RequestContext requestContext, class System.Web.Routing.RouteValueDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetVirtualPath(System.Web.Routing.RequestContext,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::VirtualPathData ^ GetVirtualPath(System::Web::Routing::RequestContext ^ requestContext, System::Web::Routing::RouteValueDictionary ^ values);" />
      <MemberSignature Language="F#" Value="member this.GetVirtualPath : System.Web.Routing.RequestContext * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.VirtualPathData" Usage="routeCollection.GetVirtualPath (requestContext, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.VirtualPathData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestContext" Type="System.Web.Routing.RequestContext" />
        <Parameter Name="values" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="requestContext">Objeto que encapsula información sobre la ruta solicitada.</param>
        <param name="values">Objeto que contiene los parámetros de una ruta.</param>
        <summary>Devuelve información sobre la ruta de acceso de la dirección URL asociada a la ruta, según el contexto especificado y los valores de parámetro.</summary>
        <returns>Objeto que contiene información sobre la ruta de acceso de la dirección URL que está asociada a la ruta.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetVirtualPath">
      <MemberSignature Language="C#" Value="public System.Web.Routing.VirtualPathData GetVirtualPath (System.Web.Routing.RequestContext requestContext, string name, System.Web.Routing.RouteValueDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.VirtualPathData GetVirtualPath(class System.Web.Routing.RequestContext requestContext, string name, class System.Web.Routing.RouteValueDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetVirtualPath(System.Web.Routing.RequestContext,System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::VirtualPathData ^ GetVirtualPath(System::Web::Routing::RequestContext ^ requestContext, System::String ^ name, System::Web::Routing::RouteValueDictionary ^ values);" />
      <MemberSignature Language="F#" Value="member this.GetVirtualPath : System.Web.Routing.RequestContext * string * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.VirtualPathData" Usage="routeCollection.GetVirtualPath (requestContext, name, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.VirtualPathData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestContext" Type="System.Web.Routing.RequestContext" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="values" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="requestContext">Objeto que encapsula información sobre la ruta solicitada.</param>
        <param name="name">El nombre de la ruta que se usa cuando se recupera información sobre la ruta de acceso de la dirección URL.</param>
        <param name="values">Objeto que contiene los parámetros de una ruta.</param>
        <summary>Devuelve información sobre la ruta de acceso de la dirección URL asociada a la ruta con nombre, según el contexto especificado, el nombre de ruta y los valores de parámetro.</summary>
        <returns>Objeto que contiene información sobre la ruta de acceso de la dirección URL que está asociada a la ruta.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">No se encontró ninguna ruta con el nombre especificado en el parámetro <paramref name="name" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetWriteLock">
      <MemberSignature Language="C#" Value="public IDisposable GetWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable GetWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.GetWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWriteLock () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ GetWriteLock();" />
      <MemberSignature Language="F#" Value="member this.GetWriteLock : unit -&gt; IDisposable" Usage="routeCollection.GetWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Proporciona un objeto para administrar la seguridad para subprocesos cuando se agregan o quitan elementos de la colección.</summary>
        <returns>Objeto que administra la seguridad para subprocesos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El enfoque recomendado para definir las rutas en una aplicación ASP.NET es agregar las rutas a la <xref:System.Web.Routing.RouteTable.Routes%2A> propiedad en un controlador de eventos para el `Application_Start` eventos en el archivo Global.asax. Para obtener más información, vea <xref:System.Web.Routing.RouteCollection>.  
  
 Si tiene que agregar una ruta cuando se ejecuta la aplicación, usa el <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> método para garantizar la seguridad para subprocesos. Se libera el bloqueo de escritura en la colección de rutas cuando el <xref:System.IDisposable> se desecha el objeto devuelto por este método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> método cuando se agrega una ruta mientras se ejecuta la aplicación.  
  
  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ignore">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define un modelo de dirección URL que no debe compararse con las rutas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea una ruta que se asigna a la <xref:System.Web.Routing.StopRoutingHandler> controlador de ruta. Después de llamar a este método, no se procesará las solicitudes que coinciden con el patrón de URL especificado enrutar las solicitudes.  
  
 Enrutamiento de ASP.NET omite automáticamente las solicitudes cuando la dirección URL coincide con un archivo físico, como un archivo de imagen. En algunos casos es posible que también desee enrutamiento para omitir las solicitudes cuando no hay ningún archivo físico. Por ejemplo, las solicitudes que ASP.NET realiza automáticamente para los archivos .axd no deben tratarse como de enrutar las solicitudes, aunque no hay ningún archivo físico que se corresponde con la extensión de nombre de archivo .axd.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public void Ignore (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Ignore(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Ignore(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Ignore (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Ignore(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Ignore : string -&gt; unit" Usage="routeCollection.Ignore url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Modelo de dirección URL que se va a omitir.</param>
        <summary>Define un modelo de dirección URL que no debe compararse con las rutas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea una ruta que se asigna a la <xref:System.Web.Routing.StopRoutingHandler> controlador de ruta. Después de llamar a este método, no se procesará las solicitudes que coinciden con el patrón de URL especificado enrutar las solicitudes.  
  
 Enrutamiento de ASP.NET omite automáticamente las solicitudes cuando la dirección URL coincide con un archivo físico, como un archivo de imagen. En algunos casos es posible que también desee enrutamiento para omitir las solicitudes cuando no hay ningún archivo físico. Por ejemplo, las solicitudes que ASP.NET realiza automáticamente para los archivos .axd no deben tratarse como de enrutar las solicitudes, aunque no hay ningún archivo físico que se corresponde con la extensión de nombre de archivo .axd.  
  
   
  
## Examples  
 La plantilla predeterminada para los proyectos de MVC usa este método para excluir archivos .axd del enrutamiento, como se muestra en el ejemplo siguiente:  
  
 [!code-csharp[MvcDefaultApp#2](~/samples/snippets/csharp/VS_Snippets_WebNet/mvcdefaultapp/cs/global.asax.cs#2)]
 [!code-vb[MvcDefaultApp#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/mvcdefaultapp/vb/global.asax.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Ignore">
      <MemberSignature Language="C#" Value="public void Ignore (string url, object constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Ignore(string url, object constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.Ignore(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Ignore (url As String, constraints As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Ignore(System::String ^ url, System::Object ^ constraints);" />
      <MemberSignature Language="F#" Value="member this.Ignore : string * obj -&gt; unit" Usage="routeCollection.Ignore (url, constraints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="constraints" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="url">Modelo de dirección URL que se va a omitir.</param>
        <param name="constraints">Criterios adicionales que determinan si se va a omitir una solicitud que coincide con el modelo de dirección URL.</param>
        <summary>Define un modelo de dirección URL que no debe compararse con las rutas si la dirección URL de una solicitud cumple las restricciones especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea una ruta que se asigna a la <xref:System.Web.Routing.StopRoutingHandler> controlador de ruta. Después de llamar a este método, no se procesará las solicitudes que coinciden con el patrón de URL especificado enrutar las solicitudes.  
  
 Enrutamiento de ASP.NET omite automáticamente las solicitudes cuando la dirección URL coincide con un archivo físico, como un archivo de imagen. En algunos casos es posible que también desee enrutamiento para omitir las solicitudes cuando no hay ningún archivo físico. Por ejemplo, las solicitudes que ASP.NET realiza automáticamente para los archivos .axd no deben tratarse como de enrutar las solicitudes, aunque no hay ningún archivo físico que se corresponde con la extensión de nombre de archivo .axd.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar este método para pasar por alto todas las direcciones URL que tienen una extensión de aspx. Es posible que desee hacerlo si registra un controlador HTTP personalizado para controlar todas las direcciones URL para los archivos que tienen la extensión ".aspx". Un patrón de URL único que coincidiría con todas las solicitudes de .aspx requeriría dos parámetros de selección (catchall) como `{*path}.aspx/{*pathinfo}`. (Este patrón coincidiría con cualquier dirección URL que termina en .aspx, incluidos aquellos que tienen parámetros de cadena de consulta). Sin embargo, el enrutamiento permite solo un parámetro de selección (catchall) al final. Como alternativa, puede especificar un patrón de dirección URL que tiene un único parámetro de selección (catchall) que coincide con todas las direcciones URL y, a continuación, especificar restricciones que todo lo que no tiene la extensión .aspx, excluyen como se muestra en el ejemplo siguiente:  
  
```vb  
routes.Ignore("{*allaspx}", new With {.allaspx = ".*\.aspx(/.*)?"})  
```  
  
```csharp  
routes.Ignore("{*allaspx}", new {allaspx=@".*\.aspx(/.*)?"});  
```  
  
 La línea de código anterior se agregaría normalmente a un método que se llama desde el `Application_Start` método en Global.asax, como se muestra en el ejemplo de la <xref:System.Web.Routing.RouteCollection.Ignore%28System.String%29> de sobrecarga.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="url" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.InsertItem(System.Int32,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, System::Web::Routing::RouteBase ^ item);" />
      <MemberSignature Language="F#" Value="override this.InsertItem : int * System.Web.Routing.RouteBase -&gt; unit" Usage="routeCollection.InsertItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero en el que se inserta <c>item</c>.</param>
        <param name="item">Ruta que se va a insertar.</param>
        <summary>Inserta la ruta especificada en el objeto <see cref="T:System.Web.Routing.RouteCollection" /> en el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se agrega una ruta sin nombre para el <xref:System.Web.Routing.RouteCollection> de objeto, no se puede agregar una ruta que ya está en la colección.  
  
 Use la <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> método y el <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> método para asegurarse de que interactúa con la colección sin conflictos de otros procesos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="item" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> ya está en la colección.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteBase this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteBase Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(name As String) As RouteBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RouteBase ^ default[System::String ^] { System::Web::Routing::RouteBase ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : System.Web.Routing.RouteBase" Usage="System.Web.Routing.RouteCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Valor que identifica la ruta que se debe obtener.</param>
        <summary>Obtiene la ruta de la colección que tiene el nombre especificado.</summary>
        <value>Objeto que tiene el nombre especificado, o <see langword="null" /> si <paramref name="name" /> es <see langword="null" />, es una cadena vacía o no coincide con ninguna ruta de la colección.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> método y el <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> método para asegurarse de que interactúa con la colección sin conflictos de otros procesos.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="LowercaseUrls">
      <MemberSignature Language="C#" Value="public bool LowercaseUrls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LowercaseUrls" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.LowercaseUrls" />
      <MemberSignature Language="VB.NET" Value="Public Property LowercaseUrls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LowercaseUrls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.LowercaseUrls : bool with get, set" Usage="System.Web.Routing.RouteCollection.LowercaseUrls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si las direcciones URL se convierten a minúsculas cuando las rutas de acceso virtuales se normalizan.</summary>
        <value>
          <see langword="true" /> para convertir las direcciones URL a minúsculas; si no <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si una cadena de consulta se incluye en la dirección URL, esa parte de la dirección URL no se convierte a minúsculas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPageRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Permite definir rutas para las aplicaciones de formularios Web Forms.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.Routing.RouteCollection.Add%2A> método y pasando un <xref:System.Web.Routing.Route> objeto que se crea mediante la <xref:System.Web.Routing.PageRouteHandler> clase.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo definir rutas para una aplicación de formularios Web Forms mediante el uso de este método. El ejemplo muestra un método denominado `RegisterRoutes` que se llama desde `Application_Start` en el archivo Global.asax. El método usa cada sobrecarga de <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> para agregar una ruta a la aplicación. Para obtener más información acerca de cómo definir rutas para las aplicaciones de formularios Web Forms, consulte [Cómo: definir rutas para las aplicaciones de formularios Web](https://msdn.microsoft.com/library/200fe812-d0a6-4531-b9b4-cfc4ee83a678).  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#122](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#122)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#122](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#122)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nombre de la ruta.</param>
        <param name="routeUrl">Patrón de URL de la ruta.</param>
        <param name="physicalFile">Dirección URL física de la ruta.</param>
        <summary>Permite definir rutas para las aplicaciones de formularios Web Forms.</summary>
        <returns>Ruta que se agrega a la colección de rutas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.Routing.RouteCollection.Add%2A> método y pasando un <xref:System.Web.Routing.Route> objeto que se crea mediante la <xref:System.Web.Routing.PageRouteHandler> clase.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo definir una ruta mediante este método. La primera instrucción define una ruta que no tiene un nombre. La segunda instrucción define una ruta con nombre. Este ejemplo forma parte de un ejemplo más extenso que está disponible en el <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> información general del método.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#140](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#140)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#140](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#140)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routeName">Nombre de la ruta.</param>
        <param name="routeUrl">Patrón de URL de la ruta.</param>
        <param name="physicalFile">Dirección URL física de la ruta.</param>
        <param name="checkPhysicalUrlAccess">Valor que indica si ASP.NET debe validar que el usuario está autorizado para obtener acceso a la dirección URL física (siempre se comprueba la dirección URL de la ruta). Este parámetro establece la propiedad <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" />.</param>
        <summary>Permite definir rutas para las aplicaciones de formularios Web Forms.</summary>
        <returns>Ruta que se agrega a la colección de rutas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.Routing.RouteCollection.Add%2A> método y pasando un <xref:System.Web.Routing.Route> objeto que se crea mediante la <xref:System.Web.Routing.PageRouteHandler> clase.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo definir una ruta mediante este método. Este ejemplo forma parte de un ejemplo más extenso que está disponible en el <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> información general del método.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#145](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#145)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#145](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#145)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess, defaults)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nombre de la ruta.</param>
        <param name="routeUrl">Patrón de URL de la ruta.</param>
        <param name="physicalFile">Dirección URL física de la ruta.</param>
        <param name="checkPhysicalUrlAccess">Valor que indica si ASP.NET debe validar que el usuario está autorizado para obtener acceso a la dirección URL física (siempre se comprueba la dirección URL de la ruta). Este parámetro establece la propiedad <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" />.</param>
        <param name="defaults">Valores predeterminados de los parámetros de la ruta.</param>
        <summary>Permite definir rutas para las aplicaciones de formularios Web Forms.</summary>
        <returns>Ruta que se agrega a la colección de rutas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.Routing.RouteCollection.Add%2A> método y pasando un <xref:System.Web.Routing.Route> objeto que se crea mediante la <xref:System.Web.Routing.PageRouteHandler> clase.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo definir una ruta mediante este método. Este ejemplo forma parte de un ejemplo más extenso que está disponible en el <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> información general del método.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#150](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#150)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#150](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#150)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults, System.Web.Routing.RouteValueDictionary constraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults, class System.Web.Routing.RouteValueDictionary constraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults, System::Web::Routing::RouteValueDictionary ^ constraints);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool * System.Web.Routing.RouteValueDictionary * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess, defaults, constraints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="constraints" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nombre de la ruta.</param>
        <param name="routeUrl">Patrón de URL de la ruta.</param>
        <param name="physicalFile">Dirección URL física de la ruta.</param>
        <param name="checkPhysicalUrlAccess">Valor que indica si ASP.NET debe validar que el usuario está autorizado para obtener acceso a la dirección URL física (siempre se comprueba la dirección URL de la ruta). Este parámetro establece la propiedad <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" />.</param>
        <param name="defaults">Valores predeterminados de la ruta.</param>
        <param name="constraints">Restricciones que una solicitud de dirección URL debe cumplir para que sea procesada como esta ruta.</param>
        <summary>Permite definir rutas para las aplicaciones de formularios Web Forms.</summary>
        <returns>Ruta que se agrega a la colección de rutas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.Routing.RouteCollection.Add%2A> método y pasando un <xref:System.Web.Routing.Route> objeto que se crea mediante la <xref:System.Web.Routing.PageRouteHandler> clase.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo definir una ruta mediante este método. Este ejemplo forma parte de un ejemplo más extenso que está disponible en el <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> información general del método.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#155](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#155)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#155](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#155)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="MapPageRoute">
      <MemberSignature Language="C#" Value="public System.Web.Routing.Route MapPageRoute (string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, System.Web.Routing.RouteValueDictionary defaults, System.Web.Routing.RouteValueDictionary constraints, System.Web.Routing.RouteValueDictionary dataTokens);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.Routing.Route MapPageRoute(string routeName, string routeUrl, string physicalFile, bool checkPhysicalUrlAccess, class System.Web.Routing.RouteValueDictionary defaults, class System.Web.Routing.RouteValueDictionary constraints, class System.Web.Routing.RouteValueDictionary dataTokens) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.MapPageRoute(System.String,System.String,System.String,System.Boolean,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPageRoute (routeName As String, routeUrl As String, physicalFile As String, checkPhysicalUrlAccess As Boolean, defaults As RouteValueDictionary, constraints As RouteValueDictionary, dataTokens As RouteValueDictionary) As Route" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::Routing::Route ^ MapPageRoute(System::String ^ routeName, System::String ^ routeUrl, System::String ^ physicalFile, bool checkPhysicalUrlAccess, System::Web::Routing::RouteValueDictionary ^ defaults, System::Web::Routing::RouteValueDictionary ^ constraints, System::Web::Routing::RouteValueDictionary ^ dataTokens);" />
      <MemberSignature Language="F#" Value="member this.MapPageRoute : string * string * string * bool * System.Web.Routing.RouteValueDictionary * System.Web.Routing.RouteValueDictionary * System.Web.Routing.RouteValueDictionary -&gt; System.Web.Routing.Route" Usage="routeCollection.MapPageRoute (routeName, routeUrl, physicalFile, checkPhysicalUrlAccess, defaults, constraints, dataTokens)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.Route</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeUrl" Type="System.String" />
        <Parameter Name="physicalFile" Type="System.String" />
        <Parameter Name="checkPhysicalUrlAccess" Type="System.Boolean" />
        <Parameter Name="defaults" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="constraints" Type="System.Web.Routing.RouteValueDictionary" />
        <Parameter Name="dataTokens" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nombre de la ruta.</param>
        <param name="routeUrl">Patrón de URL de la ruta.</param>
        <param name="physicalFile">Dirección URL física de la ruta.</param>
        <param name="checkPhysicalUrlAccess">Valor que indica si ASP.NET debe validar que el usuario está autorizado para obtener acceso a la dirección URL física (siempre se comprueba la dirección URL de la ruta). Este parámetro establece la propiedad <see cref="P:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess" />.</param>
        <param name="defaults">Valores predeterminados de los parámetros de la ruta.</param>
        <param name="constraints">Restricciones que una solicitud de dirección URL debe cumplir para que sea procesada como esta ruta.</param>
        <param name="dataTokens">Valores que están asociados a la ruta pero que no se utilizan para determinar si la ruta coincide con un modelo de dirección URL.</param>
        <summary>Permite definir rutas para las aplicaciones de formularios Web Forms.</summary>
        <returns>Ruta que se agrega a la colección de rutas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.Routing.RouteCollection.Add%2A> método y pasando un <xref:System.Web.Routing.Route> objeto que se crea mediante la <xref:System.Web.Routing.PageRouteHandler> clase.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo definir una ruta mediante este método. Este ejemplo forma parte de un ejemplo más extenso que está disponible en el <xref:System.Web.Routing.RouteCollection.MapPageRoute%2A> información general del método.  
  
 [!code-csharp[System.Web.Routing.RouteCollection.MapPageRoute#160](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/cs/global.asax#160)]
 [!code-vb[System.Web.Routing.RouteCollection.MapPageRoute#160](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.routing.routecollection.mappageroute/vb/global.asax#160)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="routeUrl" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveItem : int -&gt; unit" Usage="routeCollection.RemoveItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero de la ruta que se va a quitar.</param>
        <summary>Quita la ruta del objeto <see cref="T:System.Web.Routing.RouteCollection" /> en el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> método y el <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> método para asegurarse de que interactúa con la colección sin conflictos de otros procesos.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RouteExistingFiles">
      <MemberSignature Language="C#" Value="public bool RouteExistingFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RouteExistingFiles" />
      <MemberSignature Language="DocId" Value="P:System.Web.Routing.RouteCollection.RouteExistingFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property RouteExistingFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RouteExistingFiles { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RouteExistingFiles : bool with get, set" Usage="System.Web.Routing.RouteCollection.RouteExistingFiles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el enrutamiento de ASP.NET debe controlar las direcciones URL que coinciden con un archivo existente.</summary>
        <value>
          <see langword="true" /> si el enrutamiento de ASP.NET controla todas las solicitudes, incluidas aquellas que coinciden con un archivo existente; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque este valor se puede cambiar dinámicamente, se omitirá cualquier cambio realizado después de activar un servicio cuando se usa la integración de enrutamiento de ASP.NET. Para obtener más información, consulte [integración de enrutamiento de ASP.NET](https://go.microsoft.com/fwlink/?LinkId=195235).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, System.Web.Routing.RouteBase item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, class System.Web.Routing.RouteBase item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Routing.RouteCollection.SetItem(System.Int32,System.Web.Routing.RouteBase)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As RouteBase)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, System::Web::Routing::RouteBase ^ item);" />
      <MemberSignature Language="F#" Value="override this.SetItem : int * System.Web.Routing.RouteBase -&gt; unit" Usage="routeCollection.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Web.Routing</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Web.Routing.RouteBase" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero de la ruta que se va a reemplazar.</param>
        <param name="item">Ruta que se va a agregar en el índice especificado.</param>
        <summary>Reemplaza la ruta en el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se agrega una ruta sin nombre para el <xref:System.Web.Routing.RouteCollection> de objeto, no se puede agregar una ruta que ya está en la colección.  
  
 Use la <xref:System.Web.Routing.RouteCollection.GetReadLock%2A> método y el <xref:System.Web.Routing.RouteCollection.GetWriteLock%2A> método para asegurarse de que interactúa con la colección sin conflictos de otros procesos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="item" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> ya está en la colección.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
  </Members>
</Type>