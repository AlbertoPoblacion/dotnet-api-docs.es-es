<Type Name="TypeBuilder" FullName="System.Reflection.Emit.TypeBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30471009" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TypeBuilder extends System.Reflection.TypeInfo implements class System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.TypeBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeBuilder&#xA;Inherits TypeInfo&#xA;Implements _TypeBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeBuilder sealed : System::Reflection::TypeInfo, System::Runtime::InteropServices::_TypeBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._TypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Define y crea nuevas instancias de clases en tiempo de ejecución.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder> es la clase raíz que se utiliza para controlar la creación de clases dinámicas en tiempo de ejecución. Proporciona un conjunto de rutinas que se utilizan para definir clases, agregar métodos y campos y crear la clase dentro de un módulo. Un nuevo <xref:System.Reflection.Emit.TypeBuilder> pueden crearse desde un módulo dinámico mediante una llamada a la <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> método, que devuelve un <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 La emisión de reflexión proporciona las siguientes opciones para definir los tipos:  
  
-   Definir una clase o interfaz con el nombre especificado.  
  
-   Definir una clase o interfaz con el nombre especificado y los atributos.  
  
-   Defina una clase con el nombre especificado, atributos y clases base.  
  
-   Defina una clase con el nombre especificado, atributos, clase base y el conjunto de interfaces que implementa la clase.  
  
-   Defina una clase con el nombre especificado, el atributos, la clase base y el tamaño de empaquetado.  
  
-   Defina una clase con el nombre especificado, atributos, clase base y el tamaño de clase como un todo.  
  
-   Defina una clase con el nombre especificado, atributos, clase base, tamaño de empaquetado y el tamaño de clase como un todo.  
  
 Para crear un tipo de matriz, tipo de puntero o tipo byref para un tipo incompleto representado por un <xref:System.Reflection.Emit.TypeBuilder> objeto, utilice la <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> método <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> método, o <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> método, respectivamente.  
  
 Antes de que se utiliza un tipo, el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> debe llamar al método. **CreateType** completa la creación del tipo. Después de llamar a **CreateType**, el llamador puede crear instancias del tipo mediante el uso de la <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e invocar los miembros del tipo mediante el <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> método. Es un error para invocar métodos que cambian la implementación de un tipo después **CreateType** se ha llamado. Por ejemplo, common language runtime produce una excepción si el llamador intenta agregar a nuevos miembros a un tipo.  
  
 Un inicializador de clase se crea mediante la <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> método. **DefineTypeInitializer** devuelve un <xref:System.Reflection.Emit.ConstructorBuilder> objeto.  
  
 Los tipos anidados se definen mediante una llamada a uno de los <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> métodos.  
  
## <a name="attributes"></a>Atributos  
 El <xref:System.Reflection.Emit.TypeBuilder> clase utiliza el <xref:System.Reflection.TypeAttributes> enumeración para especificar aún más las características del tipo que se creará:  
  
-   Las interfaces se especifican mediante el <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> y <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> atributos.  
  
-   Las clases concretas (clases que no se pueden extender) se especifican utilizando el <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> atributo.  
  
-   Varios atributos determinan la visibilidad de tipos. Vea la descripción de la <xref:System.Reflection.TypeAttributes> enumeración.  
  
-   Si <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> se especifica, el cargador de clases dispone los campos en el orden en que se leen de los metadatos. El cargador de clases tiene en cuenta el tamaño de empaquetado especificado, pero omite los desplazamientos de campo especificado. Los metadatos conservan el orden en que se emiten las definiciones de campo. Incluso a través de una combinación, los metadatos no reordenará las definiciones de campo. El cargador admitirá los desplazamientos de campo especificado sólo si <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> se especifica.  
  
## <a name="known-issues"></a>Problemas conocidos  
  
-   La emisión de reflexión no comprueba si una clase no abstracta que implementa una interfaz ha implementado todos los métodos declarados en la interfaz. Sin embargo, si la clase no implementa todos los métodos declarados en una interfaz, el tiempo de ejecución no carga la clase.  
  
-   Aunque <xref:System.Reflection.Emit.TypeBuilder> se deriva de <xref:System.Type>, algunos de los métodos abstractos definidos en la <xref:System.Type> clase no se implementan totalmente en el <xref:System.Reflection.Emit.TypeBuilder> clase. Llamadas a estas <xref:System.Reflection.Emit.TypeBuilder> métodos lanzan una <xref:System.NotSupportedException> excepción. Obtener la funcionalidad deseada, se puede recuperar el tipo creado mediante el <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y reflejar en el tipo recuperado.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código. El primer ejemplo muestra cómo crear un tipo dinámico con un campo, el constructor, la propiedad y el método. El segundo ejemplo crea un método de forma dinámica desde proporcionados por el usuario.  
  
 **Ejemplo uno**  
  
 En el ejemplo de código siguiente se muestra cómo definir un ensamblado dinámico con un módulo. El módulo en el ensamblado de ejemplo contiene un solo tipo, `MyDynamicType`, que tiene un campo privado, una propiedad que obtiene y establece el campo privado, constructores que inicializan el campo privado y un método que multiplica un número proporcionado por el usuario en el campo privado valor y devuelve el resultado.  
  
 El <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> campo se especifica cuando se crea el ensamblado. El código de ensamblado se usa inmediatamente y el ensamblado también se guarda en el disco para que se pueden examinar con [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) o se usa en otro programa.  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 **El segundo ejemplo**  
  
 El ejemplo de código siguiente muestra cómo crear un tipo dinámico mediante `TypeBuilder`.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">Acción de seguridad que se va a realizar, por ejemplo, Demand, Assert, etc.</param>
        <param name="pset">Conjunto de permisos a los que se aplica la acción.</param>
        <summary>Agrega seguridad declarativa a este tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `AddDeclarativeSecurity` puede llamarse varias veces con cada llamada especifica una acción de seguridad (como Demand, Assert o Deny) y un conjunto de permisos que se aplican a la acción.  
  
> [!NOTE]
>  En las versiones 1.0, 1.1 y 2.0 de .NET Framework, los atributos de seguridad declarativa aplicados a un tipo mediante este método se almacenan en el formato de metadatos XML antiguo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la `AddDeclarativeSecurity` método para agregar una demanda de seguridad para <xref:System.Security.Permissions.SecurityPermission> con el <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> marca a un tipo dinámico denominado `MyDynamicClass`, en un ensamblado denominado EmittedExample.dll. En el ejemplo no se genera ninguna salida de la consola; Después de ejecutarlo, puede usar [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar EmittedExample.dll. En `MyDynamicClass`, abra el `.class public auto ansi` instrucción para ver el permiso declarativo.  
  
 [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CPP/typebuilder_adddeclarativesecurity.cpp#1)]
 [!code-csharp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CS/typebuilder_adddeclarativesecurity.cs#1)]
 [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/VB/typebuilder_adddeclarativesecurity.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="action" /> no es válido (<see langword="RequestMinimum" />, <see langword="RequestOptional" /> y <see langword="RequestRefuse" /> no son válidos).</exception>
        <exception cref="T:System.InvalidOperationException">Tipo contenedor que se ha creado mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 El conjunto de permisos <paramref name="pset" /> contiene una acción que <see langword="AddDeclarativeSecurity" /> agregó anteriormente.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pset" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public void AddInterfaceImplementation (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInterfaceImplementation(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInterfaceImplementation (interfaceType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInterfaceImplementation(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Interfaz que implementa este tipo.</param>
        <summary>Agrega una interfaz que implementa este tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente muestra la implementación de una interfaz en un tipo creado dinámicamente mediante `AddInterfaceImplementation`.  
  
 [!code-cpp[TypeBuilder_Sample_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#3)]
 [!code-csharp[TypeBuilder_Sample_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#3)]
 [!code-vb[TypeBuilder_Sample_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera el ensamblado dinámico que contiene la definición de este tipo.</summary>
        <value>Es de solo lectura. Recupera el ensamblado dinámico que contiene la definición de este tipo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve el nombre completo de este tipo calificado por el nombre de presentación del ensamblado.</summary>
        <value>Es de solo lectura. Nombre completo de este tipo calificado por el nombre de presentación del ensamblado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El formato de la cadena devuelta es la concatenación del nombre completo del tipo (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) y el nombre para mostrar del ensamblado (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), separados por una coma y un espacio.  
  
 Consulte <xref:System.Reflection.AssemblyName> para obtener una descripción del formato del nombre para mostrar de un ensamblado.  
  
## <a name="version-information"></a>Información de versión  
 En las versiones 1.0 y 1.1 de .NET Framework, el valor de esta propiedad no incluye la referencia cultural o la clave pública.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera el tipo base de este tipo.</summary>
        <value>Es de solo lectura. Recupera el tipo base de este tipo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateType">
      <MemberSignature Language="C#" Value="public Type CreateType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type CreateType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateType" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ CreateType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un objeto <see cref="T:System.Type" /> para la clase. Después de definir los campos y métodos en la clase, se llama a <see langword="CreateType" /> para cargar su objeto <see langword="Type" />.</summary>
        <returns>Devuelve el nuevo objeto <see cref="T:System.Type" /> para esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este tipo es un tipo anidado, el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> se debe llamar el método en el tipo envolvente antes de que se llama en el tipo anidado.  
  
 Si el tipo actual se deriva de un tipo incompleto o implementa interfaces incompletas, llame a la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método dependen del tipo de elemento primario y los tipos de interfaz antes de llamarlo en el tipo actual.  
  
 Si el tipo envolvente contiene un campo que es un tipo de valor definido como un tipo anidado (por ejemplo, un campo que sea una enumeración definida como tipo anidado), al llamar a la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método en el tipo envolvente generará un <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> eventos. Esto es porque el cargador no puede determinar el tamaño del tipo envolvente hasta que se ha completado el tipo anidado. El llamador debe definir un controlador para el <xref:System.AppDomain.TypeResolve> eventos para completar la definición del tipo anidado mediante una llamada a <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> en la <xref:System.Reflection.Emit.TypeBuilder> objeto que representa el tipo anidado. El ejemplo de código de este tema muestra cómo definir un controlador de eventos de este tipo.  
  
 Se crea un tipo solo una vez, con independencia de cómo muchas veces el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> se llama al método. Todas las llamadas devuelven el mismo <xref:System.Type> objeto.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo definir un controlador de eventos para el <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> eventos, para poder llamar a la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método en un tipo anidado durante un <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> llame en el tipo envolvente.  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CPP/nestedenum.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CS/nestedenum.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/VB/nestedenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se ha creado el tipo envolvente.  
  
 O bien  
  
 Este tipo no es abstracto y contiene un método abstracto.  
  
 O bien  
  
 Este tipo no es una clase o interfaz abstracta y tiene un método sin cuerpo de método.</exception>
        <exception cref="T:System.NotSupportedException">El tipo contiene código del Lenguaje intermedio de Microsoft (MSIL) no válido.  
  
 O bien  
  
 El destino de bifurcación se especifica con un desplazamiento de 1 byte, pero el destino está a una distancia superior a 127 bytes de la bifurcación.</exception>
        <exception cref="T:System.TypeLoadException">No se puede cargar el tipo. Por ejemplo, contiene un método <see langword="static" /> con la convención de llamada <see cref="F:System.Reflection.CallingConventions.HasThis" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTypeInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeInfo CreateTypeInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.TypeInfo CreateTypeInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTypeInfo () As TypeInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::TypeInfo ^ CreateTypeInfo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Reflection.TypeInfo" /> que representa este tipo.</summary>
        <returns>Objeto que representa este tipo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el método que declaró el parámetro de tipo genérico actual.</summary>
        <value>Un objeto <see cref="T:System.Reflection.MethodBase" /> que representa el método que declaró el tipo actual, si el tipo actual es un parámetro de tipo genérico; en caso contrario, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Al emitir el código, un parámetro de tipo genérico se representa mediante un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto en lugar de un <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve el tipo que declara este tipo.</summary>
        <value>Es de solo lectura. Tipo que declara este tipo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineConstructor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega un nuevo constructor al tipo dinámico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="attributes">Atributos del constructor.</param>
        <param name="callingConvention">Convención de llamada del constructor.</param>
        <param name="parameterTypes">Tipos de parámetro del constructor.</param>
        <summary>Agrega un nuevo constructor al tipo, con los atributos y signatura especificados.</summary>
        <returns>El constructor definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no define un constructor para su tipo dinámico, se proporciona automáticamente un constructor predeterminado y llama al constructor predeterminado de la clase base.  
  
 Si define un constructor para su tipo dinámico, no se proporciona un constructor predeterminado. Tiene las siguientes opciones para proporcionar un constructor predeterminado además del constructor definido:  
  
-   Si desea un constructor predeterminado que llame simplemente al constructor predeterminado de la clase base, puede utilizar el <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> método para crear uno (y opcionalmente restringir el acceso a él). Proporciona una implementación para este constructor predeterminado. Si lo hace, se produce una excepción al intentar usar el constructor. Ninguna excepción se produce cuando el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> se llama al método.  
  
-   Si desea un constructor predeterminado que haga algo más que simplemente llamar el constructor predeterminado de la clase base o que llame a otro constructor de la clase base o que haga algo completamente distinto, debe utilizar el <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> método para crear uno y proporcionar su propia implementación.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra el uso de `DefineConstructor` para establecer la firma determinado y los atributos de un constructor en un tipo dinámico y devolver correspondiente <xref:System.Reflection.Emit.ConstructorBuilder> de población de MSIL.  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes, class System.Type[][] requiredCustomModifiers, class System.Type[][] optionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type(), requiredCustomModifiers As Type()(), optionalCustomModifiers As Type()()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="attributes">Atributos del constructor.</param>
        <param name="callingConvention">Convención de llamada del constructor.</param>
        <param name="parameterTypes">Tipos de parámetro del constructor.</param>
        <param name="requiredCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
        <param name="optionalCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ningún parámetro tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
        <summary>Agrega un nuevo constructor al tipo, con los atributos, la signatura y los modificadores personalizados especificados.</summary>
        <returns>El constructor definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se proporciona para los diseñadores de compiladores administrados.  
  
> [!NOTE]
>  Para obtener más información sobre los modificadores personalizados, consulte la documentación de ECMA Partition II metadatos. La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El tamaño de <paramref name="requiredCustomModifiers" /> o <paramref name="optionalCustomModifiers" /> no es igual al tamaño de <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se creó previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDefaultConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDefaultConstructor (attributes As MethodAttributes) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineDefaultConstructor(System::Reflection::MethodAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">Objeto <see langword="MethodAttributes" /> que representa los atributos que se van a aplicar al constructor.</param>
        <summary>Define el constructor predeterminado. El constructor definido aquí simplemente llamará al constructor predeterminado del elemento principal.</summary>
        <returns>Devuelve el constructor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dado que el constructor predeterminado se define automáticamente, es necesario llamar a este método solo en las situaciones siguientes:  
  
-   Ha definido otro constructor y también desea un constructor predeterminado que simplemente llama al constructor de clase base.  
  
-   Desea establecer los atributos en el constructor predeterminado en un valor distinto de <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, y <xref:System.Reflection.MethodAttributes.RTSpecialName>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra el uso de `DefineConstructor` para establecer la firma determinado y los atributos de un constructor en un tipo dinámico y devolver correspondiente <xref:System.Reflection.Emit.ConstructorBuilder> de población de MSIL.  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El tipo primario (tipo base) no tiene un constructor predeterminado.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EventBuilder DefineEvent(string name, valuetype System.Reflection.EventAttributes attributes, class System.Type eventtype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEvent (name As String, attributes As EventAttributes, eventtype As Type) As EventBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EventBuilder ^ DefineEvent(System::String ^ name, System::Reflection::EventAttributes attributes, Type ^ eventtype);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EventBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="eventtype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del evento. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attributes">Atributos del evento.</param>
        <param name="eventtype">Tipo del evento.</param>
        <summary>Agrega un nuevo evento al tipo, con el nombre, los atributos y el tipo de evento especificados.</summary>
        <returns>El evento definido.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="eventtype" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega un nuevo campo al tipo dinámico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">Nombre del campo. <c>fieldName</c> no puede contener valores null incrustados.</param>
        <param name="type">Tipo del campo.</param>
        <param name="attributes">Atributos del campo.</param>
        <summary>Agrega un nuevo campo al tipo, con el nombre, los atributos y el tipo de campo especificados.</summary>
        <returns>El campo definido.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="fieldName" /> es cero.  
  
 O bien  
  
 <paramref name="type" /> es System.Void.  
  
 O bien  
  
 Se especificó un tamaño total de la clase primaria de este campo.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fieldName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, class System.Type[] requiredCustomModifiers, class System.Type[] optionalCustomModifiers, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, cli::array &lt;Type ^&gt; ^ requiredCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalCustomModifiers, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">Nombre del campo. <c>fieldName</c> no puede contener valores null incrustados.</param>
        <param name="type">Tipo del campo.</param>
        <param name="requiredCustomModifiers">Matriz de tipos que representan los modificadores personalizados necesarios para el campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
        <param name="optionalCustomModifiers">Matriz de tipos que representan los modificadores personalizados opcionales para el campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
        <param name="attributes">Atributos del campo.</param>
        <summary>Agrega un nuevo campo al tipo, con el nombre, los atributos, el tipo de campo y los modificadores personalizados especificados.</summary>
        <returns>El campo definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se proporciona para los diseñadores de compiladores administrados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="fieldName" /> es cero.  
  
 O bien  
  
 <paramref name="type" /> es System.Void.  
  
 O bien  
  
 Se especificó un tamaño total de la clase primaria de este campo.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fieldName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">Matriz de nombres para los parámetros de tipo genérico.</param>
        <summary>Define los parámetros de tipo genérico para el tipo actual, especificando su número y sus nombres, y devuelve una matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que se pueden utilizar para establecer sus restricciones.</summary>
        <returns>Una matriz de objetos <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> que se pueden utilizar para definir las restricciones de los parámetros de tipo genérico para el tipo actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método convierte al tipo actual en un tipo genérico. Si el método se llama de nuevo en el mismo tipo, un <xref:System.InvalidOperationException> se produce.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un tipo genérico con dos parámetros de tipo y los guarda en el ensamblado GenericEmitExample1.dll. Puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para ver los tipos generados. Para obtener una explicación más detallada de los pasos necesarios para definir un tipo genérico dinámico, vea [Cómo: definir un tipo genérico con emisión de reflexión](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).  
  
 [!code-cpp[EmitGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Los parámetros de tipo genérico ya se han definido para este tipo.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="names" /> es <see langword="null" />.  
  
 O bien  
  
 Un elemento de <paramref name="names" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="names" /> es una matriz vacía.</exception>
        <altmember cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Nombre utilizado para hacer referencia a los datos. <c>name</c> no puede contener valores null insertados.</param>
        <param name="data">Objeto binario de datos.</param>
        <param name="attributes">Atributos para el campo.</param>
        <summary>Define un campo de datos inicializado en la sección .sdata del archivo ejecutable portable (PE).</summary>
        <returns>Campo para hacer referencia a los datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El campo que se cree con este método será `static`, incluso si no incluye `FieldAttributes.Static` en el `attributes` parámetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.  
  
 O bien  
  
 El tamaño de los datos es menor o igual que cero, o mayor o igual que 0x3f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="name" /> o <paramref name="data" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          Se ha llamado previamente a <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega un método al tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attributes">Atributos del método.</param>
        <summary>Agrega un nuevo método al tipo, con el nombre y los atributos de método especificados.</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga del método cuando no conozca la firma del método en el momento en que se define el método. Por ejemplo, los tipos de parámetro y el tipo de valor devuelto de un método genérico pueden especificarse mediante los parámetros de tipo genérico del método, que se deben definir una vez se ha agregado el método al tipo. Los parámetros y el tipo de valor devuelto del método se pueden establecer más adelante mediante la <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método.  
  
 Esta sobrecarga del método define un método con <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>. Si necesita definir un método sin una firma con otra convención de llamada, use la <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> sobrecarga del método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se define un método genérico denominado `DemoMethod` cuyo tipo de parámetro y el tipo de valor devuelto se especifican mediante los parámetros de tipo genérico. El método se define sin una firma, utilizando la convención de llamada estándar. El <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método se usa para realizar `DemoMethod` un método genérico y los parámetros de tipo recién definidos, a continuación, se usan para la firma y tipo de valor devuelto.  
  
 Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> método.  
  
 [!code-cpp[GenericMethodBuilder#4](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#4)]
 [!code-csharp[GenericMethodBuilder#4](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#4)]
 [!code-vb[GenericMethodBuilder#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#4)]  
[!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
[!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
[!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.  
  
 O bien  
  
 El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attributes">Atributos del método.</param>
        <param name="callingConvention">Convención de llamada del método.</param>
        <summary>Agrega un nuevo método al tipo, con la convención de llamada, el nombre y los atributos de método especificados.</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga del método cuando no conozca la firma del método en el momento en que se define el método. Por ejemplo, los tipos de parámetro y el tipo de valor devuelto de un método genérico pueden especificarse mediante los parámetros de tipo genérico del método, que se deben definir una vez se ha agregado el método al tipo. Los parámetros y el tipo de valor devuelto del método se pueden establecer más adelante mediante la <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.  
  
 O bien  
  
 El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attributes">Atributos del método.</param>
        <param name="returnType">Tipo de valor devuelto del método.</param>
        <param name="parameterTypes">Tipos de los parámetros del método.</param>
        <summary>Agrega un nuevo método al tipo, con la signatura de método, el nombre y los atributos de método especificados.</summary>
        <returns>El método definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente muestra el uso de `DefineMethod` para establecer la firma determinado y los atributos de un constructor en un tipo dinámico y devolver correspondiente <xref:System.Reflection.Emit.MethodBuilder> de población de MSIL.  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.  
  
 O bien  
  
 El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attributes">Atributos del método.</param>
        <param name="callingConvention">Convención de llamada del método.</param>
        <param name="returnType">Tipo de valor devuelto del método.</param>
        <param name="parameterTypes">Tipos de los parámetros del método.</param>
        <summary>Agrega un nuevo método al tipo, con la signatura de método, la convención de llamada, el nombre y los atributos de método especificados.</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente muestra el uso de `DefineMethod` para establecer la firma determinado y los atributos de un constructor en un tipo dinámico y devolver correspondiente <xref:System.Reflection.Emit.MethodBuilder> de población de MSIL.  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.  
  
 O bien  
  
 El tipo del elemento principal de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attributes">Atributos del método.</param>
        <param name="callingConvention">Convención de llamada del método.</param>
        <param name="returnType">Tipo de valor devuelto del método.</param>
        <param name="returnTypeRequiredCustomModifiers">Matriz de tipos que representa los modificadores personalizados obligatorios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo de valor devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene modificadores personalizados opcionales, especifique <see langword="null" />.</param>
        <param name="parameterTypes">Tipos de los parámetros del método.</param>
        <param name="parameterTypeRequiredCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
        <param name="parameterTypeOptionalCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ningún parámetro tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
        <summary>Agrega un nuevo método al tipo, con el nombre, los atributos de método, la convención de llamada, la signatura de método, y los modificadores personalizados especificados.</summary>
        <returns>Un objeto <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método recién agregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga si necesita especificar modificadores personalizados. Si necesita especificar modificadores personalizados una vez creado el método, como lo haría, por ejemplo, con un método genérico cuyos tipos de parámetro se especifican mediante sus parámetros de tipo genérico, puede usar el <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> o <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> sobrecargas del método para definir el método y, a continuación, usar el <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método para definir el parámetro y devolver tipos con modificadores personalizados.  
  
> [!NOTE]
>  Para obtener más información sobre los modificadores personalizados, consulte la documentación de ECMA Partition II metadatos. La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.  
  
 O bien  
  
 El tipo del elemento primario de este método es una interfaz y este método no es virtual (<see langword="Overridable" /> en Visual Basic).  
  
 O bien  
  
 El tamaño de <paramref name="parameterTypeRequiredCustomModifiers" /> o <paramref name="parameterTypeOptionalCustomModifiers" /> no es igual al tamaño de <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethodOverride">
      <MemberSignature Language="C#" Value="public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineMethodOverride(class System.Reflection.MethodInfo methodInfoBody, class System.Reflection.MethodInfo methodInfoDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineMethodOverride (methodInfoBody As MethodInfo, methodInfoDeclaration As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineMethodOverride(System::Reflection::MethodInfo ^ methodInfoBody, System::Reflection::MethodInfo ^ methodInfoDeclaration);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfoBody" Type="System.Reflection.MethodInfo" />
        <Parameter Name="methodInfoDeclaration" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="methodInfoBody">Cuerpo del método que se va a utilizar. Debería ser un objeto <see langword="MethodBuilder" />.</param>
        <param name="methodInfoDeclaration">Método cuya declaración se va a utilizar.</param>
        <summary>Especifica un cuerpo de método determinado que implementa una declaración de método específica, posiblemente con otro nombre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No utilice este método para invalidar métodos o implementaciones de interfaz. Para reemplazar un método de una clase base o implementar un método de una interfaz, simplemente emita un método con el mismo nombre y firma que el método se reemplaza o implementa, como se muestra en el ejemplo de código.  
  
 El <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> método se utiliza cuando un cuerpo de método y una declaración de método tienen nombres diferentes. Por ejemplo, una clase puede reemplazar un método de clase base y también proporcionar una implementación independiente para un miembro de interfaz con el mismo nombre, como se muestra en el ejemplo de código.  
  
 `DefineMethodOverride` define un `methodimpl`, que consta de un par de tokens de metadatos. Un símbolo (token) señala a una implementación y los demás puntos de símbolo (token) a una declaración que implementa el cuerpo. El cuerpo debe definirse en el tipo de la implementación del método se define en, y el cuerpo debe ser virtual (`Overridable` en Visual Basic). La declaración puede realizarse a un método definido en una interfaz implementada por el tipo, un método en una clase derivada o un método definido en el tipo. Si la declaración es sólo en una interfaz, se modifica la ranura definida por dicha interfaz. Si la declaración se realiza a un método en un tipo base, la ranura para el método se reemplaza y los duplicados para el método reemplazado también se sustituyen. El método invalidado no puede ser el método real que se declara. Si el método está en el mismo tipo, la ranura se reemplaza y los duplicados para los métodos sustituidos se omiten.  
  
> [!NOTE]
>  Para obtener más información acerca de implementaciones de métodos, consulte `MethodImpl` en la documentación de ECMA Partition II metadatos. La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.  
  
> [!IMPORTANT]
>  Después de la <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> método se llama, algunas características de `methodInfoBody` no se puede cambiar. Por ejemplo, no se puede aplicar un atributo a un parámetro de tipo genérico de `methodInfoBody` utilizando el <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> método. Si debe utilizar el <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> método, hacerlo después de todas las características de `methodInfoBody` se han definido.  
  
   
  
## Examples  
 El ejemplo de código siguiente contiene una interfaz `I` con un método `M()`, una clase base `A` que implementa la interfaz y una clase derivada `C` que invalida la implementación de clase base `M()` y también Proporciona una implementación independiente y explícita de `I.M()`.  
  
 El `main()` método del ejemplo de código muestra cómo emitir la clase derivada `C`. La invalidación de `A.M()` se logra simplemente mediante la emisión de un método `M()` con la misma firma. Sin embargo, para proporcionar una implementación independiente de `I.M()`, debe definir un cuerpo de método y, a continuación, usar el <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> método para asociar dicho cuerpo de método con un <xref:System.Reflection.MethodInfo> que representa `I.M()`. El nombre del cuerpo del método no importa.  
  
 El ejemplo de código crea una instancia de la clase emitida. Obtiene un <xref:System.Reflection.MethodInfo> objeto `I.M()`, y se utiliza para invocar la clase emitida 's explícito de implementación de interfaces. A continuación, obtiene un <xref:System.Reflection.MethodInfo> objeto `A.M()`y lo utiliza para invocar la invalidación de la clase emitida de ese método.  
  
 [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cpp/source.cpp#1)]
 [!code-csharp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cs/source.cs#1)]
 [!code-vb[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="methodInfoBody" /> no pertenece a esta clase.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="methodInfoBody" /> o <paramref name="methodInfoDeclaration" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 El tipo declarativo de <paramref name="methodInfoBody" /> no es el tipo representado por este <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineNestedType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define un tipo anidado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre corto del tipo. <c>name</c> no puede contener valores null insertados.</param>
        <summary>Define un tipo anidado a partir de su nombre.</summary>
        <returns>El tipo anidado definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede utilizarse para crear anidada tipos incluso después del <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método se ha llamado en el tipo envolvente.  
  
 El tipo anidado debe estar completo antes de poder reflejarse en él mediante <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.  
  
 Vea la descripción de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para el orden en el que se deben completar los tipos anidados y los tipos.  
  
 No se crea necesariamente un nombre duplicado si `name` es idéntico al nombre de un tipo anidado o un tipo definido previamente. Para ser duplicados, los nombres completos deben coincidir, incluido el espacio de nombres y todos los tipos de anidamiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero o mayor que 1023.  
  
 O bien  
  
 Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Nombre corto del tipo. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attr">Atributos del tipo.</param>
        <summary>Define un tipo anidado a partir del nombre y los atributos.</summary>
        <returns>El tipo anidado definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede utilizarse para crear anidada tipos incluso después del <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método se ha llamado en el tipo envolvente.  
  
 El tipo anidado debe estar completo antes de poder reflejarse en él mediante <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.  
  
 Vea la descripción de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para el orden en el que se deben completar los tipos anidados y los tipos.  
  
 No se crea necesariamente un nombre duplicado si `name` es idéntico al nombre de un tipo anidado o un tipo definido previamente. Para ser duplicados, los nombres completos deben coincidir, incluido el espacio de nombres y todos los tipos de anidamiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El atributo anidado no está especificado.  
  
 O bien  
  
 Este tipo está sellado.  
  
 O bien  
  
 Este tipo es una matriz.  
  
 O bien  
  
 Este tipo es una interfaz, pero el tipo anidado no es una interfaz.  
  
 O bien  
  
 La longitud de <paramref name="name" /> es cero o mayor que 1023.  
  
 O bien  
  
 Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nombre corto del tipo. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attr">Atributos del tipo.</param>
        <param name="parent">Tipo que extiende el tipo anidado.</param>
        <summary>Define un tipo anidado a partir del nombre, los atributos y el tipo que extiende.</summary>
        <returns>El tipo anidado definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede utilizarse para crear anidada tipos incluso después del <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método se ha llamado en el tipo envolvente.  
  
 El tipo anidado debe estar completo antes de poder reflejarse en él mediante <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.  
  
 Vea la descripción de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para el orden en el que se deben completar los tipos anidados y los tipos.  
  
 No se crea necesariamente un nombre duplicado si `name` es idéntico al nombre de un tipo anidado o un tipo definido previamente. Para ser duplicados, los nombres completos deben coincidir, incluido el espacio de nombres y todos los tipos de anidamiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El atributo anidado no está especificado.  
  
 O bien  
  
 Este tipo está sellado.  
  
 O bien  
  
 Este tipo es una matriz.  
  
 O bien  
  
 Este tipo es una interfaz, pero el tipo anidado no es una interfaz.  
  
 O bien  
  
 La longitud de <paramref name="name" /> es cero o mayor que 1023.  
  
 O bien  
  
 Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Nombre corto del tipo. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attr">Atributos del tipo.</param>
        <param name="parent">Tipo que extiende el tipo anidado.</param>
        <param name="typeSize">Tamaño total del tipo.</param>
        <summary>Define un tipo anidado a partir del nombre, los atributos, el tamaño total del tipo y el tipo que extiende.</summary>
        <returns>El tipo anidado definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede utilizarse para crear anidada tipos incluso después del <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método se ha llamado en el tipo envolvente.  
  
 El tipo anidado debe estar completo antes de poder reflejarse en él mediante <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.  
  
 Vea la descripción de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para el orden en el que se deben completar los tipos anidados y los tipos.  
  
 No se crea necesariamente un nombre duplicado si `name` es idéntico al nombre de un tipo anidado o un tipo definido previamente. Para ser duplicados, los nombres completos deben coincidir, incluido el espacio de nombres y todos los tipos de anidamiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El atributo anidado no está especificado.  
  
 O bien  
  
 Este tipo está sellado.  
  
 O bien  
  
 Este tipo es una matriz.  
  
 O bien  
  
 Este tipo es una interfaz, pero el tipo anidado no es una interfaz.  
  
 O bien  
  
 La longitud de <paramref name="name" /> es cero o mayor que 1023.  
  
 O bien  
  
 Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">Nombre corto del tipo. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attr">Atributos del tipo.</param>
        <param name="parent">Tipo que extiende el tipo anidado.</param>
        <param name="packSize">Tamaño de empaquetado del tipo.</param>
        <summary>Define un tipo anidado a partir del nombre, los atributos, el tipo que extiende y el tamaño de empaquetado.</summary>
        <returns>El tipo anidado definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede utilizarse para crear anidada tipos incluso después del <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método se ha llamado en el tipo envolvente.  
  
 El tipo anidado debe estar completo antes de poder reflejarse en él mediante <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.  
  
 Vea la descripción de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para el orden en el que se deben completar los tipos anidados y los tipos.  
  
 No se crea necesariamente un nombre duplicado si `name` es idéntico al nombre de un tipo anidado o un tipo definido previamente. Para ser duplicados, los nombres completos deben coincidir, incluido el espacio de nombres y todos los tipos de anidamiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El atributo anidado no está especificado.  
  
 O bien  
  
 Este tipo está sellado.  
  
 O bien  
  
 Este tipo es una matriz.  
  
 O bien  
  
 Este tipo es una interfaz, pero el tipo anidado no es una interfaz.  
  
 O bien  
  
 La longitud de <paramref name="name" /> es cero o mayor que 1023.  
  
 O bien  
  
 Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Nombre corto del tipo. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attr">Atributos del tipo.</param>
        <param name="parent">El tipo que extiende el tipo anidado.</param>
        <param name="interfaces">Interfaz que implementa el tipo anidado.</param>
        <summary>Define un tipo anidado a partir del nombre, los atributos, el tipo que extiende y las interfaces que implementa.</summary>
        <returns>El tipo anidado definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede utilizarse para crear anidada tipos incluso después del <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método se ha llamado en el tipo envolvente.  
  
 El tipo anidado debe estar completo antes de poder reflejarse en él mediante <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.  
  
 Vea la descripción de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para el orden en el que se deben completar los tipos anidados y los tipos.  
  
 No se crea necesariamente un nombre duplicado si `name` es idéntico al nombre de un tipo anidado o un tipo definido previamente. Para ser duplicados, los nombres completos deben coincidir, incluido el espacio de nombres y todos los tipos de anidamiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El atributo anidado no está especificado.  
  
 O bien  
  
 Este tipo está sellado.  
  
 O bien  
  
 Este tipo es una matriz.  
  
 O bien  
  
 Este tipo es una interfaz, pero el tipo anidado no es una interfaz.  
  
 O bien  
  
 La longitud de <paramref name="name" /> es cero o mayor que 1023.  
  
 O bien  
  
 Esta operación crearía un tipo con un valor de <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicado en el ensamblado actual.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
 O bien  
  
 Un elemento de la matriz <paramref name="interfaces" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize, int typeSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Nombre corto del tipo. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attr">Atributos del tipo.</param>
        <param name="parent">Tipo que extiende el tipo anidado.</param>
        <param name="packSize">Tamaño de empaquetado del tipo.</param>
        <param name="typeSize">Tamaño total del tipo.</param>
        <summary>Define un tipo anidado a partir del nombre, los atributos, el tamaño y el tipo que extiende.</summary>
        <returns>El tipo anidado definido.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define un método <see langword="PInvoke" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método <see langword="PInvoke" />. <c>name</c> no puede contener valores null insertados.</param>
        <param name="dllName">Nombre del archivo DLL en que está definido el método <see langword="PInvoke" />.</param>
        <param name="attributes">Atributos del método.</param>
        <param name="callingConvention">Convención de llamadas del método.</param>
        <param name="returnType">Tipo de valor devuelto del método.</param>
        <param name="parameterTypes">Tipos de los parámetros del método.</param>
        <param name="nativeCallConv">Convención nativa de llamadas.</param>
        <param name="nativeCharSet">Juego nativo de caracteres del método.</param>
        <summary>Define un método <see langword="PInvoke" /> a partir del nombre, el nombre de la DLL en la que se define el método, los atributos del método, la convención de llamadas del método, el tipo de valor devuelto del método, los tipos de los parámetros del método y las marcas de <see langword="PInvoke" />.</summary>
        <returns>Método <see langword="PInvoke" /> que se ha definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atributos de importación de algunas DLL (vea la descripción de <xref:System.Runtime.InteropServices.DllImportAttribute>) no se pueden especificar como argumentos para este método. Por ejemplo, el atributo de la importación de la DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> debe agregarse después de la `PInvoke` se crea el método si el método devuelve un valor. En el ejemplo se muestra cómo hacerlo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> método para crear un `PInvoke` método y cómo agregar la <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> marca a los marcadores de implementación del método después de crear el <xref:System.Reflection.Emit.MethodBuilder>, mediante el uso de la <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> y <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>métodos.  
  
> [!IMPORTANT]
>  Para obtener un valor devuelto distinto de cero, debe agregar el <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> marca.  
  
 En el ejemplo se crea un ensamblado dinámico con un módulo dinámico y un tipo único, `MyType`, que contiene el `PInvoke` método. El `PInvoke` método representa Win32 `GetTickCount` función.  
  
 Cuando se ejecuta el ejemplo, se ejecuta el `PInvoke` método. También se guarda el ensamblado dinámico como PInvokeTest.dll. Puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el `MyType` clase y la `static` (`Shared` en Visual Basic) `PInvoke` contiene el método. Puede compilar un programa de Visual Basic o C# que utiliza el método estático `MyType.GetTickCount` método incluye una referencia al archivo DLL cuando ejecute csc.exe o vbc.exe; por ejemplo, `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Método no estático.  
  
 O bien  
  
 El tipo principal es una interfaz.  
  
 O bien  
  
 Método abstracto.  
  
 O bien  
  
 El método se definió anteriormente.  
  
 O bien  
  
 La longitud de <paramref name="name" /> o <paramref name="dllName" /> es cero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> o <paramref name="dllName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo contenedor se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método <see langword="PInvoke" />. <c>name</c> no puede contener valores null insertados.</param>
        <param name="dllName">Nombre del archivo DLL en que está definido el método <see langword="PInvoke" />.</param>
        <param name="entryName">El nombre del punto de entrada del archivo DLL.</param>
        <param name="attributes">Atributos del método.</param>
        <param name="callingConvention">Convención de llamadas del método.</param>
        <param name="returnType">Tipo de valor devuelto del método.</param>
        <param name="parameterTypes">Tipos de los parámetros del método.</param>
        <param name="nativeCallConv">Convención nativa de llamadas.</param>
        <param name="nativeCharSet">Juego nativo de caracteres del método.</param>
        <summary>Define un método <see langword="PInvoke" /> a partir del nombre, el nombre de la DLL en la que se define el método, el nombre del punto de entrada, los atributos del método, la convención de llamadas del método, el tipo de valor devuelto del método, los tipos de los parámetros del método y las marcas de <see langword="PInvoke" />.</summary>
        <returns>Método <see langword="PInvoke" /> que se ha definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atributos de importación de algunas DLL (vea la descripción de <xref:System.Runtime.InteropServices.DllImportAttribute>) no se pueden especificar como argumentos para este método. Por ejemplo, el atributo de la importación de la DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> debe agregarse después de la `PInvoke` se crea el método si el método devuelve un valor. En el ejemplo se muestra cómo hacerlo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> método para crear un `PInvoke` método y cómo agregar la <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> marca a los marcadores de implementación del método después de crear el <xref:System.Reflection.Emit.MethodBuilder>, mediante el uso de la <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> y <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> métodos.  
  
> [!IMPORTANT]
>  Para obtener un valor devuelto distinto de cero, debe agregar el <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> marca.  
  
 En el ejemplo se crea un ensamblado dinámico con un módulo dinámico y un tipo único, `MyType`, que contiene el `PInvoke` método. El `PInvoke` método representa Win32 `GetTickCount` función.  
  
 Cuando se ejecuta el ejemplo, se ejecuta el `PInvoke` método. También se guarda el ensamblado dinámico como PInvokeTest.dll. Puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el `MyType` clase y la `static` (`Shared` en Visual Basic) `PInvoke` contiene el método. Puede compilar un programa de Visual Basic o C# que utiliza el método estático `MyType.GetTickCount` método incluye una referencia al archivo DLL cuando ejecute csc.exe o vbc.exe; por ejemplo, `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Método no estático.  
  
 O bien  
  
 El tipo principal es una interfaz.  
  
 O bien  
  
 Método abstracto.  
  
 O bien  
  
 El método se definió anteriormente.  
  
 O bien  
  
 La longitud de <paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> es cero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo contenedor se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del método <see langword="PInvoke" />. <c>name</c> no puede contener valores null insertados.</param>
        <param name="dllName">Nombre del archivo DLL en que está definido el método <see langword="PInvoke" />.</param>
        <param name="entryName">El nombre del punto de entrada del archivo DLL.</param>
        <param name="attributes">Atributos del método.</param>
        <param name="callingConvention">Convención de llamadas del método.</param>
        <param name="returnType">Tipo de valor devuelto del método.</param>
        <param name="returnTypeRequiredCustomModifiers">Matriz de los tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizado requerido, especifique <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto del método. Si el tipo de valor devuelto no tiene ningún modificador personalizados opcional, especifique <see langword="null" />.</param>
        <param name="parameterTypes">Tipos de los parámetros del método.</param>
        <param name="parameterTypeRequiredCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
        <param name="parameterTypeOptionalCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
        <param name="nativeCallConv">Convención nativa de llamadas.</param>
        <param name="nativeCharSet">Juego nativo de caracteres del método.</param>
        <summary>Define un método <see langword="PInvoke" /> a partir del nombre, el nombre de la DLL en la que se define el método, el nombre del punto de entrada, los atributos del método, la convención de llamadas del método, el tipo de valor devuelto del método, los tipos de los parámetros del método, las marcas de <see langword="PInvoke" /> y los modificadores personalizados de los parámetros y del tipo de valor devuelto.</summary>
        <returns>
          <see cref="T:System.Reflection.Emit.MethodBuilder" /> que representa el método <see langword="PInvoke" /> definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atributos de importación de algunas DLL (vea la descripción de <xref:System.Runtime.InteropServices.DllImportAttribute>) no se pueden especificar como argumentos para este método. Por ejemplo, el atributo de la importación de la DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> debe agregarse después de la `PInvoke` se crea el método si el método devuelve un valor. En el ejemplo se muestra cómo hacerlo.  
  
> [!NOTE]
>  Para obtener más información sobre los modificadores personalizados, consulte la documentación de ECMA Partition II metadatos. La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el [\], tipo\[\], tipo\[\], tipo\[\]\[\], tipo\[ \] \<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A > método para crear un `PInvoke` método y cómo agregar el <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> marca a los marcadores de implementación del método después de crear el <xref:System.Reflection.Emit.MethodBuilder>, mediante el uso de la <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> y <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> métodos.  
  
 En el ejemplo se crea un ensamblado dinámico con un módulo dinámico y un tipo único, `MyType`, que contiene el `PInvoke` método. El `PInvoke` método representa Win32 `GetTickCount` función.  
  
> [!IMPORTANT]
>  Para obtener un valor devuelto distinto de cero, debe agregar el <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> marca.  
  
> [!NOTE]
>  En el ejemplo se usa una sobrecarga que no especifica modificadores personalizados. Para especificar los modificadores personalizados, cambie el código de ejemplo para utilizar esta sobrecarga del método en su lugar.  
  
 Cuando se ejecuta el ejemplo, se ejecuta el `PInvoke` método. También se guarda el ensamblado dinámico como PInvokeTest.dll. Puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el `MyType` clase y la `static` (`Shared` en Visual Basic) `PInvoke` contiene el método. Puede compilar un programa de Visual Basic o C# que utiliza el método estático `MyType.GetTickCount` método incluye una referencia al archivo DLL cuando ejecute csc.exe o vbc.exe; por ejemplo, `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Método no estático.  
  
 O bien  
  
 El tipo principal es una interfaz.  
  
 O bien  
  
 Método abstracto.  
  
 O bien  
  
 El método se definió anteriormente.  
  
 O bien  
  
 La longitud de <paramref name="name" />, <paramref name="dllName" />o <paramref name="entryName" /> es cero.  
  
 O bien  
  
 El tamaño de <paramref name="parameterTypeRequiredCustomModifiers" /> o <paramref name="parameterTypeOptionalCustomModifiers" /> no es igual al tamaño de <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineProperty">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega una nueva propiedad al tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">El nombre de la propiedad. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attributes">Atributos de la propiedad.</param>
        <param name="returnType">tipo de valor devuelto de la propiedad.</param>
        <param name="parameterTypes">Tipos de los parámetros de la propiedad.</param>
        <summary>Agrega una nueva propiedad al tipo, con el nombre y la signatura de propiedad especificados.</summary>
        <returns>La propiedad definida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente muestra cómo definir una propiedad dinámica y obtener un <xref:System.Reflection.Emit.PropertyBuilder> para la especificación. Tenga en cuenta que un `PropertyBuilder` también debe tener su correspondiente <xref:System.Reflection.Emit.MethodBuilder>, que hospedará la lógica de IL para la propiedad.  
  
 [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
 O bien  
  
 Cualquiera de los elementos de la matriz <paramref name="parameterTypes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">El nombre de la propiedad. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attributes">Atributos de la propiedad.</param>
        <param name="callingConvention">Convención de llamada de los descriptores de acceso de la propiedad.</param>
        <param name="returnType">tipo de valor devuelto de la propiedad.</param>
        <param name="parameterTypes">Tipos de los parámetros de la propiedad.</param>
        <summary>Agrega una nueva propiedad al tipo, con el nombre, los atributos, la convención de llamada y la firma de propiedad especificados.</summary>
        <returns>La propiedad definida.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
 O bien  
  
 Cualquiera de los elementos de la matriz <paramref name="parameterTypes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">El nombre de la propiedad. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attributes">Atributos de la propiedad.</param>
        <param name="returnType">tipo de valor devuelto de la propiedad.</param>
        <param name="returnTypeRequiredCustomModifiers">Matriz de tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad. Si el tipo de valor devuelto no tiene modificadores personalizados obligatorios, especifique <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad. Si el tipo de valor devuelto no tiene ningún modificador personalizado opcional, especifique <see langword="null" />.</param>
        <param name="parameterTypes">Tipos de los parámetros de la propiedad.</param>
        <param name="parameterTypeRequiredCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
        <param name="parameterTypeOptionalCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ningún parámetro tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
        <summary>Agrega una nueva propiedad al tipo, con el nombre, la signatura de propiedad y los modificadores personalizados especificados.</summary>
        <returns>La propiedad definida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se proporciona para los diseñadores de compiladores administrados.  
  
> [!NOTE]
>  Para obtener más información sobre los modificadores personalizados, consulte la documentación de ECMA Partition II metadatos. La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.</exception>
        <exception cref="T:System.ArgumentNullException">
          El valor de <paramref name="name" /> es <see langword="null" />.  
  
 O bien  
  
 Alguno de los elementos de la matriz de <paramref name="parameterTypes" /> es <see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">El nombre de la propiedad. <c>name</c> no puede contener valores null insertados.</param>
        <param name="attributes">Atributos de la propiedad.</param>
        <param name="callingConvention">Convención de llamada de los descriptores de acceso de la propiedad.</param>
        <param name="returnType">tipo de valor devuelto de la propiedad.</param>
        <param name="returnTypeRequiredCustomModifiers">Matriz de tipos que representan los modificadores personalizados necesarios, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad. Si el tipo de valor devuelto no tiene modificadores personalizados obligatorios, especifique <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Matriz de los tipos que representan los modificadores personalizados opcionales, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para el tipo devuelto de la propiedad. Si el tipo de valor devuelto no tiene ningún modificador personalizado opcional, especifique <see langword="null" />.</param>
        <param name="parameterTypes">Tipos de los parámetros de la propiedad.</param>
        <param name="parameterTypeRequiredCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados obligatorios para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ninguno de los parámetros tiene modificadores personalizados necesarios, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
        <param name="parameterTypeOptionalCustomModifiers">Matriz de matrices de tipos. Cada matriz de tipos representa los modificadores personalizados opcionales para el parámetro correspondiente, como <see cref="T:System.Runtime.CompilerServices.IsConst" />. Si un parámetro concreto no tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de tipos. Si ningún parámetro tiene modificadores personalizados opcionales, especifique <see langword="null" /> en lugar de una matriz de matrices.</param>
        <summary>Agrega una nueva propiedad al tipo, con el nombre, la convención de llamada, la firma de propiedad y los modificadores personalizados especificados.</summary>
        <returns>La propiedad definida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se proporciona para los diseñadores de compiladores administrados.  
  
> [!NOTE]
>  Para obtener más información sobre los modificadores personalizados, consulte la documentación de ECMA Partition II metadatos. La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.  
  
 Esta sobrecarga del método se introdujo en la [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o una versión posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.  
  
 O bien  
  
 Cualquiera de los elementos de la matriz <paramref name="parameterTypes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineTypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineTypeInitializer () As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineTypeInitializer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define el inicializador para este tipo.</summary>
        <returns>Devuelve un inicializador de tipo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El inicializador creado siempre es público.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo crear un constructor de inicialización mediante `DefineTypeInitializer`.  
  
 [!code-cpp[TypeBuilder_Properties1#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Properties1/CPP/typebuilder_properties.cpp#3)]
 [!code-csharp[TypeBuilder_Properties1#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Properties1/CS/typebuilder_properties.cs#3)]
 [!code-vb[TypeBuilder_Properties1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Properties1/VB/typebuilder_properties.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El tipo contenedor se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">Nombre utilizado para hacer referencia a los datos. <c>name</c> no puede contener valores null insertados.</param>
        <param name="size">Tamaño del campo de datos.</param>
        <param name="attributes">Atributos para el campo.</param>
        <summary>Define un campo de datos sin inicializar en la sección <see langword=".sdata" /> del archivo portable ejecutable (PE).</summary>
        <returns>Campo para hacer referencia a los datos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El campo que se cree con este método será `static`, incluso si no incluye `FieldAttributes.Static` en el `attributes` parámetro.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra el uso de `DefineUninitializedData` para crear un campo de datos sin inicializar en un tipo dinámico:  
  
 [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CPP/typebuilder_defineuninitializeddata.cpp#1)]
 [!code-csharp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CS/typebuilder_defineuninitializeddata.cs#1)]
 [!code-vb[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/VB/typebuilder_defineuninitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="name" /> es cero.  
  
 O bien  
  
 <paramref name="size" /> es menor o igual que cero, o mayor o igual que 0x003f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera la ruta de acceso completa de este tipo.</summary>
        <value>Es de solo lectura. Recupera la ruta de acceso completa de este tipo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El formato devuelto es "enclosingTypeFullName+nestedTypeName + en el caso" para los tipos anidados y "typeName" para tipos no anidados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</summary>
        <value>Combinación bit a bit de valores de <see cref="T:System.Reflection.GenericParameterAttributes" /> que describe la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Al emitir el código, un parámetro de tipo genérico se representa mediante un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto en lugar de un <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public override int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la posición del parámetro de tipo en la lista de parámetros de tipo del tipo genérico que declaró el parámetro.</summary>
        <value>Si el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual representa un parámetro de tipo genérico, la posición del parámetro de tipo en la lista de parámetros de tipo del tipo genérico que declaró el parámetro; de lo contrario, no se define.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Al emitir el código, un parámetro de tipo genérico se representa mediante un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto en lugar de un <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 Si la actual <xref:System.Reflection.Emit.TypeBuilder> no representa un parámetro de tipo genérico, el valor de esta propiedad es indefinido. Use la <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> propiedad para determinar si la actual <xref:System.Reflection.Emit.TypeBuilder> representa un parámetro de tipo genérico.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public override Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public override int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetArrayRank();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.ConstructorInfo GetConstructor(class System.Type type, class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::ConstructorInfo ^ GetConstructor(Type ^ type, System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="type">Tipo genérico construido cuyo constructor se devuelve.</param>
        <param name="constructor">Constructor de la definición de tipo genérico de <c>type</c>, que especifica qué constructor de <c>type</c> devolver.</param>
        <summary>Devuelve el constructor del tipo genérico construido especificado que corresponde al constructor especificado de la definición de tipo genérico.</summary>
        <returns>Un objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor de <paramref name="type" /> que corresponde a <paramref name="constructor" />, y que especifica un constructor perteneciente a la definición de tipo genérico de <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método proporciona una manera de obtener un <xref:System.Reflection.ConstructorInfo> objeto que representa un constructor de un tipo genérico construido cuya definición de tipo genérico se representa mediante un <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 Por ejemplo, suponga que tiene un <xref:System.Reflection.Emit.TypeBuilder> objeto que representa el tipo `G<T>` en sintaxis de C# (`G(Of T)` en Visual Basic, `generic <T> ref class G` en C++) y un <xref:System.Reflection.Emit.ConstructorBuilder> objeto que representa un constructor de `G<T>`. Suponga que `G<T>` tiene un método genérico con parámetros de tipo `U` que crea una instancia del tipo construido `G<U>`. Para emitir el código para crear una instancia del tipo construido, se necesita un <xref:System.Reflection.ConstructorInfo> objeto que representa el constructor de este tipo construido, es decir, que crea una instancia de `G<U>`. Para ello, llame primero a la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método en el <xref:System.Reflection.Emit.TypeBuilder> objeto, especificando la <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto que representa `U` como el argumento de tipo. A continuación, llame a la <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método con el valor devuelto de la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método como parámetro `type` y la <xref:System.Reflection.Emit.ConstructorBuilder> objeto que representa el constructor de `G<U>` como parámetro `constructor`. El valor devuelto es el <xref:System.Reflection.ConstructorInfo> objeto necesita para emitir la llamada de función. El ejemplo de código muestra este escenario.  
  
   
  
## Examples  
 El ejemplo de código siguiente contiene el código fuente de una clase genérica denominada `Sample` que tiene un parámetro de tipo denominado `T`. La clase tiene un campo denominado `Field`, del tipo `T`y un método genérico denominado `GM` con su propio parámetro de tipo, denominado `U`. Método `GM` crea una instancia de `Sample`, sustituyendo su propio parámetro de tipo `U` para el parámetro de tipo de `Sample`y almacena su parámetro de entrada de `Field`. Este código fuente se compila pero no se utiliza; puede ver con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) y compárelo con el código emitido por la clase `Example`.  
  
 El código de clase `Example` muestra el uso de la <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método para emitir código genérico. El `Main` método de clase `Example` crea un ensamblado dinámico que contiene una clase denominada `Sample` y usa el <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método hacerla genérica mediante la adición de un parámetro de tipo denominado `T`. Un constructor predeterminado y un campo denominado `Field`, del tipo `T`, se agregan a la clase `Sample`. Un método `GM` se agrega y se convierte en un método genérico mediante el uso de la <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método. El parámetro de tipo de `GM` se denomina `U`. Una vez definido el parámetro de tipo, la firma de `GM` se agrega mediante la <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método. No hay ningún tipo de valor devuelto y no requerido o modificadores personalizados, por lo que todos los parámetros de este método son `null` excepto `parameterTypes`; `parameterTypes` establece el tipo del parámetro del método única para `U`, parámetro de tipo genérico del método. El cuerpo del método crea una instancia del tipo construido `Sample<U>` (`Sample(Of U)` en Visual Basic), asigna el parámetro del método a `Field`y, a continuación, imprime el valor de `Field`. El <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método se utiliza para crear un <xref:System.Reflection.ConstructorInfo> que representa el constructor predeterminado del tipo genérico construido `Sample<U>` en el <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> instrucción que crea la instancia.  
  
 Se define un tipo ficticio para contener el método de punto de entrada `Main`. En el cuerpo de `Main`, el método estático `GM` método se invoca en el tipo genérico construido `Sample<int>` (`Sample(Of Integer)` en Visual Basic), con el tipo de <xref:System.String> sustituye por `U`.  
  
 Cuando se ejecuta el ejemplo de código, se guarda el ensamblado emitido como TypeBuilderGetFieldExample.exe. Se puede ejecutar TypeBuilderGetFieldExample.exe y puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para comparar el código emitido por el código para el `Sample` clase que se compila en el ejemplo de código propio.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no representa un tipo genérico.  
  
 O bien  
  
 <paramref name="type" /> no es del tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 O bien  
  
 El tipo declarativo de <paramref name="constructor" /> no es una definición de tipo genérico.  
  
 O bien  
  
 El tipo declarativo de <paramref name="constructor" /> no es la definición de tipo genérico de <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Debe tratarse de un marcador de bits de <see cref="T:System.Reflection.BindingFlags" />, como por ejemplo en <see langword="InvokeMethod" />, <see langword="NonPublic" />, entre otros.</param>
        <summary>Devuelve una matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representa a los constructores públicos y no públicos definidos para esta clase, tal y como se especifica.</summary>
        <returns>Devuelve una matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representa a los constructores especificados definidos para esta clase. Si no se ha definido ningún constructor, se devolverá una matriz vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método no se implementa en el caso de tipos incompletos.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve los atributos personalizados definidos para este tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Especifica si se debe buscar en la cadena de herencia de este miembro para encontrar los atributos.</param>
        <summary>Devuelve todos los atributos personalizados definidos para este tipo.</summary>
        <returns>Devuelve una matriz de objetos que representa todos los atributos personalizados de este tipo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Actualmente este método no es compatible para tipos incompletos. Recupere el tipo mediante el método <see cref="M:System.Type.GetType" /> y llame al método <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> en el objeto <see cref="T:System.Type" /> devuelto.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Tipo de atributo que se va a buscar. Solo se devuelven los atributos que son asignables a este tipo.</param>
        <param name="inherit">Especifica si se debe buscar en la cadena de herencia de este miembro para encontrar los atributos.</param>
        <summary>Devuelve todos los atributos personalizados del tipo actual que se pueden asignar a un tipo especificado.</summary>
        <returns>Una matriz de atributos personalizados definida en el tipo actual.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Actualmente este método no es compatible para tipos incompletos. Recupere el tipo mediante el método <see cref="M:System.Type.GetType" /> y llame al método <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> en el objeto <see cref="T:System.Type" /> devuelto.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El tipo debe ser un tipo proporcionado por el sistema en tiempo de ejecución subyacente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se llama a este método, siempre se produce <see cref="T:System.NotSupportedException" />.</summary>
        <returns>No se admite este método. No se devuelve ningún valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del evento que se va a buscar.</param>
        <param name="bindingAttr">Combinación bit a bit de valores de <see cref="T:System.Reflection.BindingFlags" /> que limita la búsqueda.</param>
        <summary>Devuelve el evento con el nombre especificado.</summary>
        <returns>Un objeto <see cref="T:System.Reflection.EventInfo" /> que representa el evento declarado o heredado por este tipo con el nombre especificado, o <see langword="null" /> si no hay ninguna coincidencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método no se implementa en el caso de tipos incompletos.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve los eventos definidos por el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve los eventos públicos declarados o heredados por este tipo.</summary>
        <returns>Devuelve una matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representa a los eventos públicos declarados o heredados por este tipo. Si no hay eventos públicos, se devuelve una matriz vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A> o <xref:System.Reflection.Assembly.GetType%2A> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método no se implementa en el caso de tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Combinación bit a bit de valores de <see cref="T:System.Reflection.BindingFlags" /> que limita la búsqueda.</param>
        <summary>Devuelve los eventos públicos y no públicos declarados por este tipo.</summary>
        <returns>Devuelve una matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representan los eventos declarados o heredados por este tipo que coinciden con los marcadores de enlace especificados. Si no hay eventos coincidentes, se devuelve una matriz vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método no se implementa en el caso de tipos incompletos.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un campo definido por el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del campo que se va a obtener.</param>
        <param name="bindingAttr">Debe tratarse de un marcador de bits de <see cref="T:System.Reflection.BindingFlags" />, como por ejemplo en <see langword="InvokeMethod" />, <see langword="NonPublic" />, entre otros.</param>
        <summary>Devuelve el campo especificado por el nombre dado.</summary>
        <returns>Devuelve el objeto <see cref="T:System.Reflection.FieldInfo" /> que representa al campo declarado o heredado por este tipo con el nombre especificado y el modificador público o no público. Si no existen coincidencias, se devolverá <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método no se implementa en el caso de tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetField(class System.Type type, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetField(Type ^ type, System::Reflection::FieldInfo ^ field);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="type">Tipo genérico construido cuyo campo se devuelve.</param>
        <param name="field">Campo de la definición de tipo genérico de <c>type</c>, que especifica qué campo de <c>type</c> se va a devolver.</param>
        <summary>Devuelve el campo del tipo genérico construido especificado que corresponde al campo especificado de la definición de tipo genérico.</summary>
        <returns>Un objeto <see cref="T:System.Reflection.FieldInfo" /> que representa el campo de <paramref name="type" /> que corresponde a <paramref name="field" />, y que especifica un campo perteneciente a la definición de tipo genérico de <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método proporciona una manera de obtener un <xref:System.Reflection.FieldInfo> objeto que representa un campo de un tipo genérico construido cuya definición de tipo genérico se representa mediante un <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 Por ejemplo, suponga que tiene un <xref:System.Reflection.Emit.TypeBuilder> objeto que representa el tipo `G<T>` en sintaxis de C# (`G(Of T)` en Visual Basic, `generic <T> ref class G` en C++) y un <xref:System.Reflection.Emit.FieldBuilder> objeto que representa un campo `public T F` en sintaxis de C# (`Public F As T` en Visual Basic, `public: T F` en C++) que se definen mediante `G<T>`. Suponga que `G<T>` tiene un método genérico con parámetros de tipo `U` que crea una instancia del tipo construido `G<U>` y campo llamadas `F` en esa instancia. Para emitir la llamada de función, se necesita un <xref:System.Reflection.FieldInfo> objeto que representa `F` en el tipo construido, es decir, que es de tipo `U` en lugar de tipo `T`. Para ello, llame primero a la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método en el <xref:System.Reflection.Emit.TypeBuilder> objeto, especificando la <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto que representa `U` como el argumento de tipo. A continuación, llame a la <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método con el valor devuelto de la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método como parámetro `type` y la <xref:System.Reflection.Emit.FieldBuilder> objeto que representa `F` como parámetro `field`. El valor devuelto es el <xref:System.Reflection.FieldInfo> objeto necesita para emitir la llamada de función. El ejemplo de código muestra este escenario.  
  
   
  
## Examples  
 El ejemplo de código siguiente contiene el código fuente de una clase genérica denominada Sample que tiene un parámetro de tipo denominado `T`. La clase tiene un campo denominado `Field`, del tipo `T`y un método genérico denominado `GM` con su propio parámetro de tipo, denominado `U`. Método `GM` crea una instancia de `Sample`, sustituyendo su propio parámetro de tipo `U` para el parámetro de tipo de `Sample`y almacena su parámetro de entrada de `Field`. Este código fuente se compila pero no se utiliza; puede ver con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) y compárelo con el código emitido por la clase `Example`.  
  
 El código de clase `Example` muestra el uso de la <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método para emitir código genérico. El `Main` método de clase `Example` crea un ensamblado dinámico que contiene una clase denominada `Sample`y utiliza el <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método hacerla genérica mediante la adición de un parámetro de tipo denominado `T`. Un constructor predeterminado y un campo denominado `Field`, del tipo `T`, se agregan a la clase `Sample`. Un método `GM` se agrega y se convierte en un método genérico mediante el uso de la <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método. El parámetro de tipo de `GM` se denomina `U`. Una vez definido el parámetro de tipo, la firma de `GM` se agrega mediante la <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método. No hay ningún tipo de valor devuelto y no requerido o modificadores personalizados, por lo que todos los parámetros de este método son `null` excepto `parameterTypes`; `parameterTypes` establece el tipo del parámetro del método única para `U`, parámetro de tipo genérico del método. El cuerpo del método crea una instancia del tipo construido `Sample<U>` (`Sample(Of U)` en Visual Basic), asigna el parámetro del método a `Field`y, a continuación, imprime el valor de `Field`. El <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método se utiliza para crear un <xref:System.Reflection.FieldInfo> que representa el campo de tipo genérico construido `Sample<U>` en el <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> y <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> instrucciones.  
  
 Se define un tipo ficticio para contener el método de punto de entrada `Main`. En el cuerpo de `Main`, el método estático `GM` método se invoca en el tipo genérico construido `Sample<int>` (`Sample(Of Integer)` en Visual Basic), con el tipo de <xref:System.String> sustituye por `U`.  
  
 Cuando se ejecuta el ejemplo de código, se guarda el ensamblado emitido como TypeBuilderGetFieldExample.exe. Se puede ejecutar TypeBuilderGetFieldExample.exe y puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para comparar el código emitido por el código para el `Sample` clase que se compila en el ejemplo de código propio.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> no representa un tipo genérico.  
  
 O bien  
  
 <paramref name="type" /> no es del tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 O bien  
  
 El tipo declarativo de <paramref name="field" /> no es una definición de tipo genérico.  
  
 O bien  
  
 El tipo declarativo de <paramref name="field" /> no es la definición de tipo genérico de <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Debe tratarse de una marca de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
        <summary>Devuelve los campos públicos y no públicos declarados por este tipo.</summary>
        <returns>Devuelve una matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representa a los campos públicos y no públicos declarados o heredados por este tipo. Si no hay campos, devuelve una matriz vacía, tal como se especifica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> método no devuelve campos en un orden determinado, como alfabético o el orden de declaración. El código no debe depender del orden en que se devuelven los campos, porque ese orden puede variar.  
  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método no se implementa en el caso de tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo de un tipo genérico o los parámetros de tipo de una definición de tipo genérico.</summary>
        <returns>Matriz de objetos <see cref="T:System.Type" />. Los elementos de la matriz representan los argumentos de tipo de un tipo genérico o los parámetros de tipo de una definición de tipo genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos de la matriz devuelta están en el orden en que aparecen en la lista de parámetros de tipo para la definición de tipo genérico.  
  
 A <xref:System.Reflection.Emit.TypeBuilder> objeto representa una definición de tipo genérico si el <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método se ha utilizado para darle parámetros de tipo genérico. Este método recupera el <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objetos que representan los parámetros de tipo genérico.  
  
 Para obtener más información sobre los tipos genéricos en la reflexión y una lista de las condiciones invariables de términos que se usan en la reflexión genérica, vea la <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericArguments" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetGenericTypeDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa una definición de tipo genérico a partir de la cual se puede obtener el tipo actual.</summary>
        <returns>Un objeto <see cref="T:System.Type" /> que representa una definición de tipo genérico a partir de la cual se puede obtener el tipo actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se llama a la <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> método en un <xref:System.Reflection.Emit.TypeBuilder> objeto para el que el <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> propiedad devuelve `true`, el <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> propiedad devuelve la instancia actual. Un <xref:System.Reflection.Emit.TypeBuilder> que representa un tipo genérico siempre es una definición de tipo genérico.  
  
 Si ha usado la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método para construir un tipo genérico a partir un <xref:System.Reflection.Emit.TypeBuilder> objeto que representa una definición de tipo genérico, con el <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> método en el tipo construido vuelve el <xref:System.Reflection.Emit.TypeBuilder> objeto que representa la definición de tipo genérico.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El tipo actual no es genérico. Es decir, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> devuelve <see langword="false" />.</exception>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la interfaz.</param>
        <param name="ignoreCase">Si es <see langword="true" />, la búsqueda no distingue entre mayúsculas y minúsculas. Si es <see langword="false" />, la búsqueda distingue entre mayúsculas y minúsculas.</param>
        <summary>Devuelve la interfaz implementada por esta clase (directa o indirectamente) con el nombre completo que coincide con el nombre de la interfaz dada.</summary>
        <returns>Devuelve un objeto <see cref="T:System.Type" /> que representa a la interfaz implementada. Devuelve null si no encuentra una interfaz que coincida con el nombre dado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método no se implementa en el caso de tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <see cref="T:System.Type" /> de la interfaz para el que se va a recuperar la asignación.</param>
        <summary>Devuelve una asignación de interfaz para la interfaz solicitada.</summary>
        <returns>Devuelve la asignación de interfaz solicitada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método no se implementa en el caso de tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz de todas las interfaces implementadas en este tipo y sus tipos base.</summary>
        <returns>Devuelve una matriz de objetos <see cref="T:System.Type" /> que representa a las interfaces implementadas. Si no se ha definido ninguna, se devolverá una matriz vacía.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del miembro.</param>
        <param name="type">Tipo del miembro que se va a devolver.</param>
        <param name="bindingAttr">Debe tratarse de un marcador de bits de <see cref="T:System.Reflection.BindingFlags" />, como en el caso de <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
        <summary>Devuelve todos los miembros públicos y no públicos declarados o heredados por este tipo, tal como se especifica.</summary>
        <returns>Si se utiliza <paramref name="nonPublic" />, devuelve una matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa a los miembros públicos y no públicos definidos en este tipo, en caso contrario, solo devuelve los miembros públicos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método no se implementa en el caso de tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Debe tratarse de una marca de bits de <see cref="T:System.Reflection.BindingFlags" />, como por ejemplo, <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
        <summary>Devuelve los miembros para los miembros públicos y no públicos declarados o heredados por este tipo.</summary>
        <returns>Devuelve una matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa a los miembros públicos y no públicos declarados o heredados por este tipo. Si no coinciden los miembros, devuelve una matriz vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método no se implementa en el caso de tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodInfo GetMethod(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodInfo ^ GetMethod(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">Tipo genérico construido cuyo método se devuelve.</param>
        <param name="method">Método de la definición de tipo genérico de <c>type</c>, que especifica qué método de <c>type</c> se va a devolver.</param>
        <summary>Devuelve el método del tipo genérico construido especificado que corresponde al método especificado de la definición de tipo genérico.</summary>
        <returns>Un objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método de <paramref name="type" /> que corresponde a <paramref name="method" />, y que especifica un método perteneciente a la definición de tipo genérico de <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método proporciona una manera de obtener un <xref:System.Reflection.MethodInfo> objeto que representa un método de un tipo genérico construido cuya definición de tipo genérico se representa mediante un <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 Por ejemplo, suponga que tiene un <xref:System.Reflection.Emit.TypeBuilder> objeto que representa el tipo `G<T>` en sintaxis de C# (`G(Of T)` en Visual Basic, `generic <T> ref class G` en C++) y un <xref:System.Reflection.Emit.MethodBuilder> objeto que representa un método `T M()` en sintaxis de C# (`Function M() As T` en Visual Basic, `T M()` en C++) que se definen mediante `G<T>`. Suponga que `G<T>` tiene un método genérico con parámetros de tipo `U` que crea una instancia del tipo construido `G<U>` y llama a método `M` en esa instancia. Para emitir la llamada de función, se necesita un <xref:System.Reflection.MethodInfo> objeto que representa `M` en el tipo construido, en otras palabras, que devuelve tipo `U` en lugar de tipo `T`. Para ello, llame primero a la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método en el <xref:System.Reflection.Emit.TypeBuilder> objeto, especificando la <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto que representa `U` como el argumento de tipo. A continuación, llame a la <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método con el valor devuelto de la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método como parámetro `type` y la <xref:System.Reflection.Emit.MethodBuilder> objeto que representa `T M()` como parámetro `method`. El valor devuelto es el <xref:System.Reflection.MethodInfo> objeto necesita para emitir la llamada de función. El ejemplo de código muestra un escenario similar al siguiente.  
  
   
  
## Examples  
 El ejemplo de código siguiente contiene el código fuente de una clase genérica denominada `Sample` que tiene un parámetro de tipo denominado `T`. La clase tiene un campo denominado `Field`, del tipo `T`y un método genérico denominado `GM` con su propio parámetro de tipo, denominado `U`. Método `GM` crea una instancia de `Sample`, sustituyendo su propio parámetro de tipo `U` para el parámetro de tipo de `Sample`y almacena su parámetro de entrada de `Field`. Este código fuente se compila pero no se utiliza; puede ver con el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) y compárelo con el código emitido por la clase `Example`.  
  
 El código de clase `Example` muestra el uso de la <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método para emitir código genérico. El `Main` método de clase `Example` crea un ensamblado dinámico que contiene una clase denominada `Sample` y usa el <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método hacerla genérica mediante la adición de un parámetro de tipo denominado `T`. Un constructor predeterminado y un campo denominado `Field`, del tipo `T`, se agregan a la clase `Sample`. Un método `GM` se agrega y se convierte en un método genérico mediante el uso de la <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método. El parámetro de tipo de `GM` se denomina `U`. Una vez definido el parámetro de tipo, la firma de `GM` se agrega mediante la <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método. No hay ningún tipo de valor devuelto y no requerido o modificadores personalizados, por lo que todos los parámetros de este método son `null` excepto `parameterTypes`; `parameterTypes` establece el tipo del parámetro del método única para `U`, parámetro de tipo genérico del método. El cuerpo del método crea una instancia del tipo construido `Sample<U>` (`Sample(Of U)` en Visual Basic), asigna el parámetro del método a `Field`y, a continuación, imprime el valor de `Field`. Se define un tipo ficticio para contener el método de punto de entrada `Main`. En el cuerpo de `Main`, el método estático `GM` método se invoca en el tipo genérico construido `Sample<int>` (`Sample(Of Integer)` en Visual Basic), con el tipo de <xref:System.String> sustituye por `U`. El <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método se utiliza para crear un <xref:System.Reflection.MethodInfo> para el método estático `GM` método del tipo genérico construido `Sample<U>`y el <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> , a continuación, se utiliza el método para crear un <xref:System.Reflection.MethodInfo> que pueden emitir en una llamada al método.  
  
 Cuando se ejecuta el ejemplo de código, se guarda el ensamblado emitido como TypeBuilderGetFieldExample.exe. Se puede ejecutar TypeBuilderGetFieldExample.exe y puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para comparar el código emitido por el código para el `Sample` clase que se compila en el ejemplo de código propio.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> es un método genérico que no es una definición de método genérico.  
  
 O bien  
  
 <paramref name="type" /> no representa un tipo genérico.  
  
 O bien  
  
 <paramref name="type" /> no es del tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 O bien  
  
 El tipo declarativo de <paramref name="method" /> no es una definición de tipo genérico.  
  
 O bien  
  
 El tipo declarativo de <paramref name="method" /> no es la definición de tipo genérico de <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Debe tratarse de un marcador de bits de <see cref="T:System.Reflection.BindingFlags" />, como por ejemplo en <see langword="InvokeMethod" />, <see langword="NonPublic" />, entre otros.</param>
        <summary>Devuelve los métodos públicos y no públicos declarados o heredados por este tipo, tal como se especifica.</summary>
        <returns>Si se utiliza <paramref name="nonPublic" />, devuelve una matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que representa los métodos públicos y no públicos definidos en este tipo, en caso contrario, solo devuelve los métodos públicos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método no se implementa en el caso de tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.String" /> que contiene el nombre del tipo anidado que se va a obtener.</param>
        <param name="bindingAttr">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.  
  
 O bien  
  
 Cero, para realizar una búsqueda de métodos públicos que distinga entre mayúsculas y minúsculas.</param>
        <summary>Devuelve los campos públicos y no públicos anidados, declarados por este tipo.</summary>
        <returns>Objeto <see cref="T:System.Type" /> que representa el tipo anidado que coincide con los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 Si este tipo es completo, por ejemplo, si `CreateType` se ha llamado en este tipo, pero hay tipos anidados que no están completos, a continuación, `GetNestedTypes` solo devolverá los tipos anidados para los que `CreateType` se ha llamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método no se implementa en el caso de tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Debe tratarse de un marcador de bits de <see cref="T:System.Reflection.BindingFlags" />, como en el caso de <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
        <summary>Devuelve los tipos públicos y no públicos anidados, declarados o heredados por este tipo.</summary>
        <returns>Matriz de objetos <see cref="T:System.Type" /> que representa a todos los tipos anidados en el objeto <see cref="T:System.Type" /> actual que coincidan con las restricciones de enlace especificadas.  
  
 Matriz vacía de tipo <see cref="T:System.Type" /> si no hay tipos anidados en el objeto <see cref="T:System.Type" /> actual o si ninguno de los tipos anidados coincide con las restricciones de enlace.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 Si este tipo es completo, por ejemplo, si `CreateType` se ha llamado en este tipo, pero hay tipos anidados que no están completos, a continuación, `GetNestedTypes` solo devolverá los tipos anidados para los que `CreateType` se ha llamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método no se implementa en el caso de tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Atributo de invocación. Debe tratarse de una marca de bits de <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" />, etc.</param>
        <summary>Devuelve todas las propiedades públicas y no públicas declaradas o heredadas por este tipo, tal como se especifica.</summary>
        <returns>Si se utiliza <paramref name="nonPublic" />, devuelve una matriz de objetos <see langword="PropertyInfo" /> que representa a las propiedades públicas y no públicas definidas en este tipo; en caso contrario, solo devuelve las propiedades públicas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método no se implementa en el caso de tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera el GUID de este tipo.</summary>
        <value>Es de solo lectura. Recupera el GUID de este tipo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Actualmente este método no es compatible para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del miembro al que se va a invocar. Puede ser un constructor, un método, una propiedad o un campo. Debe especificarse un atributo de invocación apropiado. Tenga en cuenta que es posible invocar al miembro predeterminado de una clase pasando una cadena vacía como el nombre del miembro.</param>
        <param name="invokeAttr">Atributo de invocación. Debe ser una marca de bits de <see langword="BindingFlags" />.</param>
        <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see langword="MemberInfo" /> mediante la reflexión. Si el enlazador es <see langword="null" /> se utilizará el enlazador predeterminado. Vea <see cref="T:System.Reflection.Binder" />.</param>
        <param name="target">Objeto donde debe invocarse al miembro especificado. Si el miembro es estático, se ignora este parámetro.</param>
        <param name="args">Lista de argumentos. Se trata de una matriz de objetos que contiene el número, orden y tipo de los parámetros del miembro que se va a invocar. Si no hay ningún parámetro, este debería ser null.</param>
        <param name="modifiers">Matriz de la misma longitud que <c>args</c> con elementos que representan los atributos asociados a los argumentos del miembro que se va a invocar. Parámetro con los atributos asociados a él en los metadatos. Los usan varios servicios de interoperabilidad. Consulte las especificaciones de metadatos para obtener más detalles.</param>
        <param name="culture">Instancia de <see langword="CultureInfo" /> por la que se rige la conversión de tipos. Si es null, se utiliza la clase <see langword="CultureInfo" /> para el subproceso actual. (Observe que esto es necesario, por ejemplo, para convertir una cadena que representa 1000 en un valor doble, ya que 1000 se representa de forma diferente en distintas referencias culturales).</param>
        <param name="namedParameters">Cada parámetro de la matriz <c>namedParameters</c> obtiene el valor del elemento correspondiente de la matriz <c>args</c>. Si la longitud de <c>args</c> es mayor que la longitud de <c>namedParameters</c>, los valores de argumento restantes se pasan en orden.</param>
        <summary>Invoca al miembro especificado. El método al que se va a invocar debe estar accesible y proporcionar la coincidencia más específica con la lista de argumentos especificada, teniendo en cuenta las restricciones del enlazador predeterminado y los atributos de invocación indicados.</summary>
        <returns>Devuelve el valor devuelto del miembro invocado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un método se invocará si el número de parámetros en la declaración del método es igual al número de argumentos en la lista de argumentos especificados, y el tipo de cada argumento se puede convertir por el enlazador al tipo del parámetro.  
  
 El enlazador encontrará todos los métodos de búsqueda de coincidencias. Estos métodos se encuentran en función del tipo de enlace solicitado (BindingFlags.InvokeMethod, BindingFlags.GetProperties etc.). El conjunto de métodos se filtra por el nombre, número de argumentos y un conjunto de modificadores de búsqueda definidos en el enlazador. Después de selecciona el método, se invocará. En ese momento se comprueba la accesibilidad. La búsqueda puede controlar qué conjunto de métodos que se buscan basándose en el atributo de accesibilidad asociado al método. El `IBinder.BindToMethod` método es responsable de seleccionar el método que se debe invocar. El enlazador predeterminado selecciona a la coincidencia más específica.  
  
> [!NOTE]
>  Se omiten las restricciones de acceso de código de plena confianza. Es decir, propiedades, métodos, campos y constructores privados son accesibles y se invocan mediante la reflexión siempre que el código es de plena confianza.  
  
 Actualmente este método no es compatible. Puede recuperar el tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Actualmente este método no es compatible para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAssignableFrom">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si se puede asignar un tipo especificado a este objeto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">Objeto que se va a probar.</param>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Reflection.TypeInfo" /> especificado puede asignarse a este objeto.</summary>
        <returns>
          <see langword="true" /> si <paramref name="typeInfo" /> se puede asignar este objeto; en caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Objeto que se va a probar.</param>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> especificado puede asignarse a este objeto.</summary>
        <returns>
          Es <see langword="true" /> si el parámetro <paramref name="c" /> y el tipo actual representan el mismo tipo, o si el tipo actual se encuentra en la jerarquía de herencia de <paramref name="c" />, o si el tipo actual es una interfaz compatible con <paramref name="c" />. Es <see langword="false" /> si ninguna de estas condiciones son válidas o si <paramref name="c" /> es <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este objeto representa un tipo genérico construido.</summary>
        <value>
          <see langword="true" /> si este objeto representa una definición de tipo genérico construido; de lo contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCreated">
      <MemberSignature Language="C#" Value="public bool IsCreated ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsCreated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCreated" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCreated () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsCreated();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si se ha creado el tipo dinámico actual.</summary>
        <returns>
          <see langword="true" /> si se ha llamado al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método se ha llamado, el tipo representado por la <xref:System.Reflection.Emit.TypeBuilder> objeto está completa. Las excepciones se producen en cualquier intento posterior de agregar a miembros o cambiar otras características del tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">Tipo de atributo que se va a buscar. Solo se devuelven los atributos que son asignables a este tipo.</param>
        <param name="inherit">Especifica si se debe buscar en la cadena de herencia de este miembro para encontrar los atributos.</param>
        <summary>Determina si un atributo personalizado se aplica al tipo actual.</summary>
        <returns>
          <see langword="true" /> si hay definidas una o más instancias de <paramref name="attributeType" />, o de un atributo derivado de <paramref name="attributeType" />, en este tipo; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no se admite para los parámetros de tipo genérico incompletos. Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Actualmente este método no es compatible para tipos incompletos. Recupere el tipo mediante el método <see cref="M:System.Type.GetType" /> y llame al método <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> en el objeto <see cref="T:System.Type" /> devuelto.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> no se ha definido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public override bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el tipo actual es un parámetro de tipo genérico.</summary>
        <value>
          Es <see langword="true" /> si el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual representa un parámetro de tipo genérico; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Al emitir el código, un parámetro de tipo genérico se representa mediante un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto en lugar de un <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public override bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el tipo actual es genérico.</summary>
        <value>
          <see langword="true" /> si el tipo representado por el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual es genérico; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Reflection.Emit.TypeBuilder> objeto representa una definición de tipo genérico si el <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método se ha utilizado para darle parámetros de tipo genérico. Una instancia de la <xref:System.Reflection.Emit.TypeBuilder> clase genérica siempre es una definición de tipo genérico.  
  
 Para obtener más información sobre los tipos genéricos en la reflexión y una lista de las condiciones invariables de términos que se usan en la reflexión genérica, vea la <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> actual representa una definición de tipo genérico, a partir de la cual se pueden construir otros tipos genéricos.</summary>
        <value>
          <see langword="true" /> si este objeto <see cref="T:System.Reflection.Emit.TypeBuilder" /> representa una definición de tipo genérico; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Reflection.Emit.TypeBuilder> objeto representa una definición de tipo genérico si el <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método se ha utilizado para darle parámetros de tipo genérico. Una instancia de la <xref:System.Reflection.Emit.TypeBuilder> clase genérica siempre es una definición de tipo genérico.  
  
 Un <xref:System.Reflection.Emit.TypeBuilder> puede usarse para crear definiciones de tipo genérico, pero no tipos genéricos construidos. Para obtener un tipo genérico construido, llame a la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método en un <xref:System.Reflection.Emit.TypeBuilder> que representa una definición de tipo genérico.  
  
 Para obtener más información sobre los tipos genéricos en la reflexión y una lista de las condiciones invariables de términos que se usan en la reflexión genérica, vea la <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el tipo actual es crítico para la seguridad o es crítico para la seguridad y disponible desde código transparente y, por tanto, puede realizar operaciones críticas.</summary>
        <value>
          <see langword="true" /> si el tipo actual es crítico para la seguridad o es crítico para la seguridad y disponible desde código transparente; <see langword="false" /> si es transparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, y <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> propiedades notifican el nivel de transparencia del tipo, según lo determinado por common language runtime (CLR). Las combinaciones de estas propiedades se muestran en la tabla siguiente:  
  
|Nivel de seguridad|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Crítico para la seguridad|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.  
  
 El tiempo de ejecución empieza a evaluar los niveles de transparencia en el ensamblado. Por ejemplo, si el ensamblado dinámico es crítico para la seguridad, se omiten las anotaciones en tipos y todos los tipos son críticos para la seguridad.  
  
 De forma predeterminada, un ensamblado dinámico hereda la transparencia del ensamblado que lo emite. Puede invalidar este comportamiento predeterminado mediante el uso de la <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, o <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> sobrecarga del método y especificando los atributos de seguridad. No puede elevar los niveles de seguridad haciendo esto; es decir, el código transparente no puede emitir código crítico para la seguridad o bien crítico para la seguridad. Atributos deben especificarse cuando se crea el ensamblado dinámico o no surtirán efecto hasta que se ha guardado en el disco y volver a cargar el ensamblado.  
  
> [!NOTE]
>  Herencia predeterminada se limita a la evaluación del runtime de transparencia. No hay atributos se aplican al ensamblado dinámico. Si desea agregar atributos de seguridad, debe aplicarlos usted mismo.  
  
 Para obtener más información acerca de la reflexión emitir y transparencia, consulte [problemas de seguridad en la emisión de reflexión](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Para obtener información acerca de las transparencias, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El tipo dinámico actual no se ha creado llamando al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el tipo actual es crítico para la seguridad y disponible desde código transparente; es decir, si puede realizar operaciones críticas y está disponible desde código transparente.</summary>
        <value>
          <see langword="true" /> si el tipo actual es crítico para la seguridad y disponible desde código transparente; <see langword="false" /> si es crítico para la seguridad o transparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, y <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> propiedades notifican el nivel de transparencia del tipo, según lo determinado por common language runtime (CLR). Las combinaciones de estas propiedades se muestran en la tabla siguiente:  
  
|Nivel de seguridad|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Crítico para la seguridad|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.  
  
 El tiempo de ejecución empieza a evaluar los niveles de transparencia en el ensamblado. Por ejemplo, si el ensamblado dinámico es crítico para la seguridad, se omiten las anotaciones en tipos y todos los tipos son críticos para la seguridad.  
  
 De forma predeterminada, un ensamblado dinámico hereda la transparencia del ensamblado que lo emite. Puede invalidar este comportamiento predeterminado mediante el uso de la <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, o <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> sobrecarga del método y especificando los atributos de seguridad. No puede elevar los niveles de seguridad haciendo esto; es decir, el código transparente no puede emitir código crítico para la seguridad o bien crítico para la seguridad. Atributos deben especificarse cuando se crea el ensamblado dinámico o no surtirán efecto hasta que se ha guardado en el disco y volver a cargar el ensamblado.  
  
> [!NOTE]
>  Herencia predeterminada se limita a la evaluación del runtime de transparencia. No hay atributos se aplican al ensamblado dinámico. Si desea agregar atributos de seguridad, debe aplicarlos usted mismo.  
  
 Para obtener más información acerca de la reflexión emitir y transparencia, consulte [problemas de seguridad en la emisión de reflexión](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Para obtener información acerca de las transparencias, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El tipo dinámico actual no se ha creado llamando al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el tipo actual es transparente y, por tanto, no puede realizar operaciones críticas.</summary>
        <value>
          Es <see langword="true" /> si el tipo es transparente para la seguridad; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, y <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> propiedades notifican el nivel de transparencia del tipo, según lo determinado por common language runtime (CLR). Las combinaciones de estas propiedades se muestran en la tabla siguiente:  
  
|Nivel de seguridad|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Crítico para la seguridad|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.  
  
 El tiempo de ejecución empieza a evaluar los niveles de transparencia en el ensamblado. Por ejemplo, si el ensamblado dinámico es crítico para la seguridad, se omiten las anotaciones en tipos y todos los tipos son críticos para la seguridad.  
  
 De forma predeterminada, un ensamblado dinámico hereda la transparencia del ensamblado que lo emite. Puede invalidar este comportamiento predeterminado mediante el uso de la <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, o <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> sobrecarga del método y especificando los atributos de seguridad. No puede elevar los niveles de seguridad haciendo esto; es decir, el código transparente no puede emitir código crítico para la seguridad o bien crítico para la seguridad. Atributos deben especificarse cuando se crea el ensamblado dinámico o no surtirán efecto hasta que se ha guardado en el disco y volver a cargar el ensamblado.  
  
> [!NOTE]
>  Herencia predeterminada se limita a la evaluación del runtime de transparencia. No hay atributos se aplican al ensamblado dinámico. Si desea agregar atributos de seguridad, debe aplicarlos usted mismo.  
  
 Para obtener más información acerca de la reflexión emitir y transparencia, consulte [problemas de seguridad en la emisión de reflexión](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Para obtener información acerca de las transparencias, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El tipo dinámico actual no se ha creado llamando al método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public override bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public override bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubclassOf(Type ^ c);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <see cref="T:System.Type" /> que se va a comprobar.</param>
        <summary>Determina si este tipo se deriva de un tipo especificado.</summary>
        <returns>Es de solo lectura. Devuelve <see langword="true" /> si este tipo es igual que el tipo <paramref name="c" /> o si es un subtipo del tipo <paramref name="c" />; en caso contrario, devuelve <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz del tipo actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual, con un límite inferior de cero.</summary>
        <returns>Un objeto <see cref="T:System.Type" /> que representa una matriz unidimensional cuyo tipo de elemento es el tipo actual, con un límite inferior de cero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> método proporciona una manera de generar un tipo de matriz con cualquier tipo de elemento posible, incluidos los tipos genéricos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un módulo dinámico, un tipo abstracto denominado `Sample`y un método abstracto denominado `TestMethod`. `TestMethod` toma una `ref` parámetro (`ByRef` en Visual Basic) de tipo `Sample`, un puntero al tipo `Sample`y una matriz de tipo `Sample`. Devuelve una matriz bidimensional de tipo `Sample`. El ejemplo de código guarda el módulo dinámico en el disco, por lo que puede examinar con la [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType(int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">Número de dimensiones de la matriz.</param>
        <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz del tipo actual, con el número de dimensiones especificado.</summary>
        <returns>Un objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> método proporciona una manera de generar un tipo de matriz con cualquier tipo de elemento posible, incluidos los tipos genéricos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un módulo dinámico, un tipo abstracto denominado `Sample`y un método abstracto denominado `TestMethod`. `TestMethod` toma una `ref` parámetro (`ByRef` en Visual Basic) de tipo `Sample`, un puntero al tipo `Sample`y una matriz de tipo `Sample`. Devuelve una matriz bidimensional de tipo `Sample`. El ejemplo de código guarda el módulo dinámico en el disco, por lo que puede examinar con la [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> no es una dimensión de matriz válida.</exception>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public override Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeByRefType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</summary>
        <returns>Objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> método proporciona una manera de generar `ref` tipos (`ByRef` en Visual Basic) para el parámetro se enumeran.  
  
> [!NOTE]
>  Utiliza la sintaxis de lenguaje intermedio (MSIL) de Microsoft, si la actual <xref:System.Reflection.Emit.TypeBuilder> representa `MyType`, entonces el tipo devuelto por este método se `MyType&`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un módulo dinámico, un tipo abstracto denominado `Sample`y un método abstracto denominado `TestMethod`. `TestMethod` toma una `ref` parámetro (`ByRef` en Visual Basic) de tipo `Sample`, un puntero al tipo `Sample`y una matriz de tipo `Sample`. Devuelve una matriz bidimensional de tipo `Sample`. El ejemplo de código guarda el módulo dinámico en el disco, por lo que puede examinar con la [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public override Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Matriz de tipos que se van a sustituir por los parámetros de tipo de la definición de tipo genérico actual.</param>
        <summary>Sustituye los elementos de una matriz de tipos por los parámetros de la definición de tipo genérico actual y devuelve el tipo construido resultante.</summary>
        <returns>Objeto <see cref="T:System.Type" /> que representa el tipo construido formado al sustituir los elementos de <paramref name="typeArguments" /> por los parámetros del tipo genérico actual. </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método cuando el código emitido requiere un tipo construido a partir de la definición de tipo genérico actual. No es necesario llamar a la <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método antes de llamar a la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método en un <xref:System.Reflection.Emit.TypeBuilder> que representa una definición de tipo genérico. Si la actual <xref:System.Reflection.Emit.TypeBuilder> no representa la definición de un tipo genérico, un <xref:System.InvalidOperationException> se produce.  
  
 El objeto devuelto por este método funciona como un marcador de posición para un tipo genérico construido en el código emitido. Es una instancia de una clase derivada de <xref:System.Type> que tiene capacidades limitadas. En concreto:  
  
-   Para obtener los métodos, campos y constructores para estos tipos genéricos construyen, use la <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, y <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> sobrecargas del método.  
  
-   Dos instancias que representan el mismo tipo construido no comparables a igual. Por ejemplo, en el código siguiente `t1.Equals(t2)` devuelve `false`:  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El tipo actual no representa la definición de un tipo genérico. Es decir, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> devuelve <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> es <see langword="null" />.  
  
 O bien  
  
 Cualquier elemento de <paramref name="typeArguments" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see cref="P:System.Type.Module" /> de cualquier elemento de <paramref name="typeArguments" /> es <see langword="null" />.  
  
 O bien  
  
 La propiedad <see cref="P:System.Reflection.Module.Assembly" /> del módulo de cualquier elemento de <paramref name="typeArguments" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public override Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakePointerType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto <see cref="T:System.Type" /> que representa el tipo de un puntero no administrado al tipo actual.</summary>
        <returns>Un objeto <see cref="T:System.Type" /> que representa el tipo de un puntero no administrado al tipo actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> método proporciona un medio para generar tipos de puntero para listas de parámetros.  
  
> [!NOTE]
>  Utiliza la sintaxis de lenguaje intermedio (MSIL) de Microsoft, si la actual <xref:System.Reflection.Emit.TypeBuilder> representa `MyType`, entonces el tipo devuelto por este método se `MyType*`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un módulo dinámico, un tipo abstracto denominado `Sample`y un método abstracto denominado `TestMethod`. `TestMethod` toma una `ref` parámetro (`ByRef` en Visual Basic) de tipo `Sample`, un puntero al tipo `Sample`y una matriz de tipo `Sample`. Devuelve una matriz bidimensional de tipo `Sample`. El ejemplo de código guarda el módulo dinámico en el disco, por lo que puede examinar con la [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera el módulo dinámico que contiene la definición de este tipo.</summary>
        <value>Es de solo lectura. Recupera el módulo dinámico que contiene la definición de este tipo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera el nombre de este tipo.</summary>
        <value>Es de solo lectura. Recupera el nombre <see cref="T:System.String" /> de este tipo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera el espacio de nombres en el que está definido este <see langword="TypeBuilder" />.</summary>
        <value>Es de solo lectura. Recupera el espacio de nombres en el que está definido este <see langword="TypeBuilder" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PackingSize">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PackingSize PackingSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.PackingSize PackingSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackingSize As PackingSize" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::PackingSize PackingSize { System::Reflection::Emit::PackingSize get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PackingSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera el tamaño de paquete de este tipo.</summary>
        <value>Es de solo lectura. Recupera el tamaño de paquete de este tipo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve el tipo utilizado para obtener este tipo.</summary>
        <value>Es de solo lectura. Tipo utilizado para obtener este tipo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece un atributo personalizado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">Instancia de una clase de ayuda utilizada para definir el atributo personalizado.</param>
        <summary>Establece un atributo personalizado utilizando un generador de atributos personalizados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este miembro ya no requiere <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> marca. (Consulte [problemas de seguridad en la reflexión emisión](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">Constructor para el atributo personalizado.</param>
        <param name="binaryAttribute">Objeto binario de bytes que representa los atributos.</param>
        <summary>Establece un atributo personalizado mediante un objeto binario de atributo especificado y personalizado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre cómo dar formato a `binaryAttribute`, consulte la documentación de Common Language Infrastructure (CLI), especialmente "partición II: definición y semántica de los metadatos". La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este miembro ya no requiere <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> marca. (Consulte [problemas de seguridad en la reflexión emisión](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> o <paramref name="binaryAttribute" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetParent">
      <MemberSignature Language="C#" Value="public void SetParent (Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParent(class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParent (parent As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParent(Type ^ parent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parent">Nuevo tipo base.</param>
        <summary>Establece el tipo base del tipo actualmente en construcción.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `parent` es `null`, <xref:System.Object> se utiliza como el tipo base.  
  
 En las versiones 1.0 y 1.1 de .NET Framework, se inicia ninguna excepción si `parent` es un tipo de interfaz, pero un <xref:System.TypeLoadException> se produce cuando el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> se llama al método.  
  
 El <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> método no comprueba la mayoría de los tipos de elemento primario no válido. Por ejemplo, no rechaza un tipo primario que no tiene ningún constructor predeterminado cuando el tipo actual tiene un constructor predeterminado, no rechaza los tipos sellados y no rechaza el <xref:System.Delegate> tipo. En todos estos casos, las excepciones se inician mediante el <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 O bien  
  
 <paramref name="parent" /> es <see langword="null" /> y la instancia actual representa una interfaz cuyos atributos no incluyen <see cref="F:System.Reflection.TypeAttributes.Abstract" />.  
  
 O bien  
  
 Para el tipo dinámico actual, la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> es <see langword="true" />, pero la propiedad <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> es <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parent" /> es una interfaz. Esta condición de excepción es nueva en la versión 2.0 de .NET Framework.</exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Size { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera el tamaño total de un tipo.</summary>
        <value>Es de solo lectura. Recupera el tamaño total de este tipo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _TypeBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_TypeBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="rgszNames">Matriz que se pasa con los nombres que se van a asignar.</param>
        <param name="cNames">Número de nombres que se van a asignar.</param>
        <param name="lcid">Contexto de configuración regional en el que se van a interpretar los nombres.</param>
        <param name="rgDispId">Matriz asignada por quien realiza la llamada que recibe los id. que corresponden a los nombres.</param>
        <summary>Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado. Para obtener más información sobre `IDispatch::GetIDsOfNames`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _TypeBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Información de tipos que se va a devolver.</param>
        <param name="lcid">Identificador de la configuración regional de la información de tipo.</param>
        <param name="ppTInfo">Recibe un puntero al objeto de información de tipo solicitado.</param>
        <summary>Recupera la información de tipo de un objeto, que se puede utilizar después para obtener la información de tipo de una interfaz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfo`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _TypeBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</param>
        <summary>Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfoCount`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _TypeBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_TypeBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica el miembro.</param>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="lcid">Contexto de la configuración regional en que se interpretan los argumentos.</param>
        <param name="wFlags">Marcas que describen el contexto de la llamada.</param>
        <param name="pDispParams">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</param>
        <param name="pVarResult">Puntero a la ubicación donde se va a almacenar el resultado.</param>
        <param name="pExcepInfo">Puntero a una estructura que contiene información de excepciones.</param>
        <param name="puArgErr">Índice del primer argumento que tiene un error.</param>
        <summary>Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no se debe llamar desde código administrado. Para obtener más información sobre `IDispatch::Invoke`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el nombre del tipo sin incluir el espacio de nombres.</summary>
        <returns>Es de solo lectura. Nombre del tipo sin incluir el espacio de nombres.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>No es compatible en módulos dinámicos.</summary>
        <value>Es de solo lectura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recupere el tipo mediante <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> y utilizar la reflexión en el tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">No es compatible en módulos dinámicos.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken TypeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.TypeToken TypeToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeToken As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::TypeToken TypeToken { System::Reflection::Emit::TypeToken get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve el símbolo (token) de tipo de este tipo.</summary>
        <value>Es de solo lectura. Devuelve el <see langword="TypeToken" /> de este tipo.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">El tipo se ha creado previamente mediante <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve el tipo de sistema subyacente para este <see langword="TypeBuilder" />.</summary>
        <value>Es de solo lectura. Devuelve el tipo de sistema subyacente.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Este tipo es una enumeración pero no hay ningún tipo de sistema subyacente.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnspecifiedTypeSize">
      <MemberSignature Language="C#" Value="public const int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 UnspecifiedTypeSize = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberSignature Language="VB.NET" Value="Public Const UnspecifiedTypeSize As Integer  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: int UnspecifiedTypeSize = 0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Indica que el tamaño total del tipo no está especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>